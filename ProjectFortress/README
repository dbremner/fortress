FORTRESS INTERPRETER v.0.1 ALPHA
--------------------------------
This software is an interpreter of a small core of the Fortress
Programming Language. At the moment the Fortress interpreter is only
partially feature-complete; there's a good deal of functionality
missing or only partially implemented.  One of the obvious
shortcomings is a rather small initial set of libraries.  This
document explains how to compile and run the interpreter, and
describes the language and libraries as it currently stands.

THE FORTRESS PROGRAMMING LANGUAGE

The Fortress Programming Language is a general-purpose, statically
typed, component-based programming language designed for producing
robust high-performance software with high programmability. In many
ways, Fortress is intended to be a "growable language" that can be
gracefully extended through its own library system. For more
information on Fortress:

The Fortress Language Specification, at:

  http://research.sun.com/projects/plrg/fortress.pdf

You can find supplementary materials on the Sun Microsystems
Programming Languages Research Group at:

  http://research.sun.com/projects/plrg/

A Fortress FAQ is available at:

  http://research.sun.com/projects/plrg/faq/index.html

but is being replaced by the wikified

  http://projectfortress.sun.com/Projects/Community/wiki/FortressQuestions

There is also a discussion@fortress mailing list, which you can join at:

  http://fortress.sunsource.net

but we are trying to move this, too.

BUILDING THE CODE

This software is intended to compile and run on
any platform that has working installations of all of the following:

* J2SDK 1.5 or later. See http://java.sun.com/javase/downloads/index.jsp
* Ant 1.6.5 or later. See http://ant.apache.org/bindownload.cgi
* JUnit 3.8.1 or later. See http://prdownloads.sourceforge.net/junit
* Bash version 2.5 or later, installed at /bin/bash.
  See http://www.gnu.org/software/bash/

To build this code, run the following command from directory
ProjectFortress:

ant clean compile

It is necessary to run the local bash script "./ant" because this
script passes command-line arguments to Ant that must be read before
Ant starts up a JVM.

RUNNING THE INTERPRETER

Set an environment variable FORTRESS_HOME to refer to the trunk of the
Fortress Subversion repository (i.e., the directory containing ProjectFortress).
Provided that the 'java' command is on your path, you can now run the
command "./fortress hello.fss".  If you put the ./fortress script
on your path, you should also be able to call fortress from outside the
interpreter directory (as you will normally want to do).
Typing "./fortress --help" will give usage information for the driver.

Or you can invoke the interpreter directly by replacing 'hello.fss'
with the name of your program in the following command:

java -cp "build:third_party/xtc/xtc.jar:third_party/FJ/concurrent.jar:third_party/plt/plt.jar" com.sun.fortress.interpreter.drivers.fs hello.fss

and get the usage of the driver by:

java -cp "build:third_party/xtc/xtc.jar:third_party/FJ/concurrent.jar:third_party/plt/plt.jar" com.sun.fortress.interpreter.drivers.fs --help

If all else fails, look at the ./fortress script to see if your system
has peculiarities (for example cygwin requires ; separators in the
classpath).

DEMO PROGRAMS

The directory demos/ contains some demonstration Fortress programs:

buffons.fss: Buffon's needle.  Estimates pi using a Monte Carlo
simulation.

fingerTree.fss: Finger trees.  This demo parses but does not currently
work.

lutx.fss: Naive dense LU decomposition.  Demonstrates how to define
new subclasses of Array2.

mm.fss, mm64.fss, mm64x.fss: Matrix multiplication by recursive
decomposition.  The library routine for matrix multiplication uses a
similar cache-oblivious multiplication routine.

sudoku.fss: Solve a simple sudoku by elimination.  Includes a
tree-based set implementation.

tree.fss: Tree-based wavelet functions, inspired by ORNL Madness
library.  This was used to prototype our matrix and vector
implementations, but that code has been moved to the libraries and
this demo doesn't quite work.

COMPONENTS

Fortress currently lacks a full-blown component system.  All the code
in your Fortress program should reside in one of two places: in api
and compponent file pairs in test_library, or in the (single) program
file you have written.

If you take a look at all the Fortress programs in tests/ and demos/
you'll see that they have the same overall structure:


component MyComponent
exports Executable

...  Your program here ...

run(args:String...):() = ...


end


Remember that the libraries you see here are preliminary and certain
to change; even the type hierarchy you see defined is different than
the one we actually want, due to missing features in the language.

LANGUAGE FEATURES THAT ARE IMPLEMENTED

* Object and trait declarations, including polymorphic traits.
  Polymorphic singletons are not yet accepted.  Constructor
  invocations must *always* provide the type arguments explicitly.

* Overloaded functions and ordinary methods.  Top-level overloaded
  functions can be polymorphic.  Nested functions and methods must be
  monomorphic.

* Polymorphic top-level functions and methods, so long as the methods
  are not overloaded.

* Checking and inference of argument types to functions, methods, and
  operators.  These checks use the dynamic types of the arguments.
  Return types are NOT checked.  Inference of type parameters is not
  complete yet; it is often necessary to provide type arguments
  explicitly.  It is *always* necessary to do so in a constructor call
  and in any situation where a type parameter occurs only in the result
  and not in the arguments to a function.  For example, you must always
  provide the array element type E and size n when invoking the
  factory array1[\E,n\]().

* Arrays of up to three dimensions.  Note that there isn't yet a
  single overarching Array type.  For more details on the array types
  and operations defined see below.  In particular, note that array
  comprehensions are not yet implemented; the array types provide
  functions to work around this lack.  Another caveat: due to a bug we
  haven't fully understood, some (but not all) uses of the compact
  notation T[n,m] for an array type cause the interpreter to fail.
  Desugaring the code by hand to e.g. Array2[\T,0,n,0,m\] works around
  this bug.

* Array aggregates except singleton arrays.

* Parallel tupling and argument evaluation.

* Parallel for loops over simple ranges such as 0#n.  Only values of
  type ZZ32Range can currently be used as for loop generators; true
  generators do not yet exist due to shortcomings in the type system
  and the absence of loop desugaring.

* Sequential for loops over simple ranges.  The seq() and sequential()
  functions (which are identical) take a ZZ32Range and return an
  equivalent sequential ZZ32Range.  Every use of the resulting range
  as a loop generator will cause the loop to run sequentially.

* While loops, typecase, if, etc.  Note that for parametric types
  typecase isn't nearly as useful as you might think, since it cannot
  bind type variables; we are working to address this shortcoming.

* The "atomic" construct uses code from the DSTM2 transactional memory
  library.  Nested transactions are flattened.  We use their obstruction
  free algorithm with a simple backoff contention manager.  Reductions
  are not yet implemented, so perform an explicit atomic update instead.

LANGUAGE FEATURES THAT ARE NOT IMPLEMENTED

* Numerals with radix specifiers (which implies that some numerals may be
  recognized as identifiers)

* Unicode names

* Dimensions and units

* Static arguments: nat (using minus), int, bool, dimension, and unit

* Modifiers

* Keyword arguments

* True type inference

* Any checking of return types at all

* Where clauses

* Coercion

* Constraint solving for nat parameters

* throw and catch.  Because of this lack we do not yet perform
  arithmetic range checks.

* Generators and reduction variables

* Comprehensions and BIG operators

* at and other data placement

* spawn

* also (multiple parallel *blocks*; use tuples of blocks instead.)

* Any of the types which classify operator properties

* Non-println I/O

* Any of the bits and storage types

* Non-ZZ64 floats

* Integers other than ZZ32 and ZZ64

* Use of ZZ64 for indexing

* Contracts and contract checking: requires, ensures, invariant
  clauses do not work.


SYNTAX CHANGES SINCE FORTRESS LANGUAGE SPECIFICATION v.1.0 ALPHA

* A file may contain a single component or API.  The enclosing component
  or API declaration may be omitted.

* At least one export statement is required for a component.

* Top-level variable declarations and field declarations should have
  initial-value expressions.

* A single declaration may declare multiple top-level variables, local
  variables, or fields depending on the context.  Immutable variables
  cannot be declared using the ":=" token.

* A default unit for a dimension must be an identifier.

* No more abstract declarations of dimensions, units, and type aliases

* Trait headers can have the excludes, comprises, and where clauses in
  any order.

* No more empty comprises clauses.  A comprises clause of a trait T may
  include "..." to hide some of T's subtraits.  A type listed in the
  comprises clause must be defined within the same component (or possibly
  an API imported by the component, if there is a cycle in the API import
  chain).

* More where-clause constraints and bool static arguments are added.

* Each contract clause (requires clause, ensures clause, and invariant
  clause) requires its subclauses or subexpressions to be separated by
  commas and enclosed by curly braces.

* Each modifier must not appear multiple times.

* method declarations occur syntactically after field declarations and
  getter and setter declarations.  Property declarations can be freely
  commingled with the field and method declarations.  A getter or setter
  modifier should be the last modifier of a method declaration.

* Local function declarations have the same syntax with top-level
  function declarations except that local function declarations must not
  have the modifiers "private" and "test".

* A second value parameter of a subscripted assignment operator method
  declaration must contain exactly one non-keyword value parameter.

* Left-hand-sides of assignment expressions are (possibly multiple of)
  array indexing, field accesses, the '_' token, or identifiers.

* Object expressions may include property declarations.

* Else clauses of case and typecase expressions have the "=>" token
  right after "else".

* A typecase expression uses "of" instead of "in" after its bindings.

* A parallel block expression syntax is enriched.

* The '_' token can be used in any place where a binding can occur.

* An index in left-hand sides of array comprehensions is either
  an identifier or an integer numeral.

* Matrix and vector types can be abbreviated using superscripts.

* Alternative mathematical notations for arrow types are not supported
  any more.

* DimRef, unitRef, NatRef, IntRef, and BoolRef are merged with
  StaticArg.


BUILT-IN TYPES

There are a bunch of types that are defined internally by the
Fortress interpreter.  With the exception of Any these cannot be
overridden.  Most built-in types do not have any methods.  The
built-in types are:

trait  Number        extends { Any }         excludes { String, Boolean }
trait  Integral      extends { Number }      excludes { String, Boolean, RR64, FloatLiteral }
object ZZ32          extends { Integral }    excludes { String, Boolean, RR64, FloatLiteral }
object ZZ32Range     extends { Any }
object ZZ64          extends { Integral }    excludes { String, Boolean, RR64, FloatLiteral }
object RR64          extends { Number }      excludes { String, Boolean }
object String        extends { Any }         excludes { IntLiteral, FloatLiteral, Boolean }
object Char          extends { Any }
object IntLiteral    extends { ZZ32, ZZ64, RR64 }
object FloatLiteral  extends { RR64 }
object Boolean       extends { Any }

Tuple and arrow types (that are always built-in)

object FlatStorageMaker[\T, n\]
  built-in flat indexed storage of size n containing objects of type
  T.  This type defines get and put methods, but only checks bounds at
  the java level.  It is not intended for programmer consumption, but
  is used to bootstrap support for arrays.

trait  Any           extends {}
  Note that everything is considered to extend the type Any.

Note also that there isn't (yet) a trait Object!  Eventually
user-written trait and object declarations will extend Object by
default; right now they instead extend Any by default.

The library defines primitive functions on the primitive Numbers:
+ -(unary and binary) *(juxtaposition) DOT = <= ^
MIN MAX |x| > < >= =/= are derived from these

For integral types:
DIV REM MOD GCD LCM CHOOSE BITAND BITOR BITXOR LSHIFT RSHIFT BITNOT
widen for ZZ32
narrow for ZZ64

For ZZ64:
> < >= =/= MIN MAX |\x/| |/x\| truncate
sqrt sin cos tanasin acos atan atan2 floor ceiling random |x|
Plus the constants pi and infinity.

For String:
= =/= < <= > >=
juxtaposition means string append, and can include non-string left or
right arguments.  This is presently the only way to convert numbers to
strings for output.

For Boolean (all derived):
AND OR NOT = =/=

For output:
print(Any)
println(Any)

THE LIBRARY

FortressLibrary.fss is loaded whenever any Fortress program is run.
It contains declarations for every function available to you except
for get and put on FlatStorageMaker.

Note that portions of the library code are commented out; these are
opened and closed by tear lines (***********  and **********).  Much
of this is code transcribed from the language specification for
prototyping and testing purposes.  We intend to make it work one day.


LIBRARY TYPES

Your best guide to library functionality is the library code itself
(which is less than 1000 lines including comments).  This section
provides an overview and describes the most non-trivial functionality.

trait Maybe[\T\] comprises { Nothing[\T\], Just[\T\] }
object Nothing[\T\]() extends { Maybe[\T\] }
object Just[\T\](x:T) extends { Maybe[\T\] }

Note that the type Nothing should actually be a singleton without a
type parameter; the absence of where clauses prevents us from writing
it monomorphically, and the absence of polymorphic singletons forces
us to construct a fresh one.

trait Exception comprises { UncheckedException, CheckedException }
trait UncheckedException extends Exception excludes { CheckedException }
trait CheckedException extends Exception excludes { UncheckedException }

These are stubs for a time when exceptions are implemented.

trait Rank[\ nat n \]

There are separate types Rank1, Rank2, and Rank3 which give
appropriate exclusions (since the absence of where clauses prevents us
from giving these exclusions directly).

trait Indexed1[\ nat n \] end
trait Indexed2[\ nat n \] end
trait Indexed3[\ nat n \] end

These indicate that an object has an i^th dimension of size n.

trait Indexed[\T extends Indexed[\T, E, I\], E, I\]
  opr[i:I] : E
  opr[i:I]:=(v:E) : ()
  assign(v:T):T = fill(fn (i:I):E => v[i])
  fill(f:I->E):T
  fill(v:E):T = fill(fn (i:I):E => v)
  copy():T
  mapReduce[\R\](f:(I,E)->R, j:(R,R)->R, z:R):R
  reduce(j:(E,E)->E, z:E):E = mapReduce[\E\](fn (i:I,e:E)=>e, j, z)
end

This defines most of the core array functionality; due to
implementation shortcomings it is not yet fully implemented for the
entire array type hierarchy, though the corresponding methods exist
for every array type.  We read Indexed[\T,E,I\] as "objects of type T
have elements of type E indexed by type I."  This contains indexing
operations.  It also contains functions which compensate for the
absence of array comprehensions and reductions:
    fill fills an array either using a function from index to value, or
        with a fixed value.
    A.reduce(j,z) is equivalent to BIG j [i <- A.indices] A[i], where j
        has zero z.  But note that j is a function, not an operator.
    A.mapReduce(f,j,z) is equivalent to BIG j [i <- A.indices] f(i,A[i])
        with the same caveats as above.

Note that these functions actually use generator-style iteration
internally, so it is possible to define new array layouts and
experiment with generators by using these functions rather than
looping.

trait Array1[\T, nat b0, nat s0\]
    extends { Indexed1 [\s0\], Rank1, Indexed[\Array1[\T,b0,s0\],T,ZZ32\] }
    excludes { Number, String }

1-D arrays.  Note the use of nat types for base b0 and size s0.
Note also that indices are ZZ32 rather than ZZ64; this is because
we're running inside java, which uses 32-bit array indices.  Internal
methods (which you shouldn't use) include get, put, and offset.  The
most interesting methods beyond those in Indexed are:

  subarray[\nat b, nat s, nat o\]():Array1[\T, b, s\]

This returns a structure-sharing subarray with base b and size s
starting from offset o in the current array.  Structure sharing means
updates to one array will be reflected in the other.  To avoid the
structure sharing just call the copy() method.

  replica[\U\]():Array1[\U,b0,s0\]

This returns a "replica" of the array with a different element type.
By "replica" we intend "an array similar in structure to this one, but
with a different element type and fresh storage."

Note that Array1 is a trait; its subclasses are unimportant (unless
you want to define your own, in which case they are instructive) and
they're subject to change anyway.

To create an Array1 you must either write a 1-D aggregate in your
program:

z : ZZ32[3] = [1 2 3]

Or you must replicate an existing array:

v : RR64[3] = z.replica[\RR64\]()

Or you must call a factory function:

w : ZZ64[1000] = array1[\ZZ64,1000\]()
x : ZZ64[1000] = array1[\ZZ64,1000\](17)
y : ZZ64[1000] = array1[\ZZ64,1000\](fn i => 2 i + 1)

The special factory function vector is restricted to numeric argument
types:

x' : ZZ64[1000] = vector[\ZZ64,1000\](17)

At the moment, any Array1 whose element type extends Number is
considered to be a valid vector (this will eventually be accomplished
by coercion, and vectors will be a distinct type).  The pmul
operation is elementwise multiplication; DOT is dot product, as is
juxtaposition; DOT, CROSS, or juxtaposition with a scalar is scalar
multiplication.  ||v|| returns the 2-norm (pythagorean length) of a
vector.

trait Array2[\T, nat b0, nat s0, nat b1, nat s1\]
    extends { Indexed1 [\ s0 \], Indexed2 [\ s1 \] , Rank2 (* ,
              Indexed[\Array2[\T,b0,s0,b1,s1\],T, (ZZ32,ZZ32)\] *) }
    excludes { Number, String }

This trait is structured much like Array1, and also provides:
  replica[\U\]():Array2[\U,b0,s0,b1,s1\]
  t():Array2[\T,b1,s1,b0,s0\]

The latter operation is transposition, and should properly be opr ()^T
when functional methods exist.  Subarray operations aren't defined yet
for two-dimensional arrays.

The factories are also similar to the 1-D case:

array2[\T, nat s0, nat s1\]():Array2[\T,0,s0,0,s1\]
array2[\T, nat s0, nat s1\](v:T):Array2[\T,0,s0,0,s1\]
array2[\T, nat s0, nat s1\](f:(ZZ32,ZZ32)->T):Array2[\T,0,s0,0,s1\]

We consider any Array2 whose element type extends Number to be a
matrix (again this will eventually use coercion).  Matrix arithmetic
defines much the same operators as vector arithmetic; all
multiplication operators are treated the same way.  When both
arguments are matrices, this is matrix multiplication.  When one
argument is a vector, it's matrix/vector or vector/matrix
multiplication.  When one argument is a scalar, it's scalar
multiplication.

Finally Array3 is similar to Array1 and Array2.  It does not yet offer
factories with arguments, nor subarrays, and we do not treat numeric
3-D arrays specially.


OTHER FUNCTIONS

A number of simple functions from the spec are provided:

cast[\T\](x:Any):T
instanceOf[\T\](x:Any):Boolean
ignore(x:Any):() = ()
identity[\T\](x:T):T = x
tuple[\T\](x:T):T = x


SOME POSSIBLY USEFUL UTILITY FUNCTIONS AND CLASSES

These classes aren't strictly intended for external use, but may be
handy as guides to how to write recursively-decomposed computations or
otherwise get things done in the current version of Fortress:

partition(x:ZZ32):(ZZ32,ZZ32)
  canonically partition positive number n into two pieces (a,b) such
  that 0 < a <= b, n = a+b.

trait ReductionBase[\T\]
trait Reduction1[\T, nat s\] extends ReductionBase[\T\]
trait Reduction2[\T, nat s0, nat s1\] extends ReductionBase[\T\]
trait Reduction3[\R,nat s0,nat s1,nat s2\] extends ReductionBase[\R\]

Reductions over 1-, 2-, and 3-D 0-based index spaces.  Used for
defining most of the array methods.

DEFINING NEW PRIMITIVE FUNCTIONS

It is relatively easy to add new primitive functions to Fortress.  To
do this, you simply invoke the builtinPrimitive function with the name
of a loadable Java class which extends glue.NativeApp.  Useful
subclasses are NativeFn1 and NativeFn2, and any of the classes in
glue.prim (particularly the classes in glue.prim.Util).  Here's a
sample native binding, which defines the floor operator which returns
an integer:

opr |\a:RR64/|:ZZ64 = builtinPrimitive("glue.prim.Float$IFloor")

You should *not* mention the type parameter to builtinPrimitive when
invoking it; doing so will confuse the interpreter.  Note also that
the interpreter requires that you declare appropriate argument and
return types for your native functions as shown above.  If you give an
incorrect type declaration on the Fortress side, you'll get
non-user-friendly error messages when the Java code is run.


////////////////////////////////////////////////////////////////////////////////

FORTRESS ABSTRACT SYNTAX TREE (astgen/Fortress.ast)
---------------------------------------------------
* Where each concrete AST node is evaluated or not yet implemented (NYI)
 - Component                    : BuildEnvironments
 - Api                          : BuildEnvironments
 - ImportStar                   : Driver (injectExplicitImports)
 - ImportNames                  : Driver (injectExplicitImports)
 - ImportApi                    : Driver (injectExplicitImports)
 - AliasedSimpleName            : Driver (injectExplicitImports)
 - AliasedAPIName               : Driver (injectExplicitImports)
 - Export                       : NYI
 - AbsTraitDecl                 : BuildEnvironments
 - TraitDecl                    : BuildEnvironments
 - AbsObjectDecl                : BuildEnvironments
 - ObjectDecl                   : BuildEnvironments
 - AbsVarDecl                   : BuildEnvironments
 - VarDecl                      : BuildEnvironments
 - LValueBind                   : BuildLetEnvironments (forLocalVarDecl)
 - UnpastingBind        	: NYI
 - UnpastingSplit       	: NYI
 - AbsFnDecl                    : BuildEnvironments
 - FnDef                        : BuildEnvironments
 - NormalParam                  : EvalType (paramsToParameters)
 - VarargsParam                 : EvalType (paramsToParameters)
 - DimUnitDecl          	: NYI
 - TestDecl             	: NYI
 - PropertyDecl         	: NYI
 - AbsExternalSyntax    	: NYI
 - ExternalSyntax       	: NYI
 - AsExpr                       : Evaluator
 - AsIfExpr                     : Evaluator
 - Assignment                   : Evaluator
 - Block                        : Evaluator
 - CaseExpr                     : Evaluator
 - Do                           : Evaluator
 - For                          : Desugarer
 - If                           : Evaluator
 - Label                        : Evaluator
 - ObjectExpr                   : rewritten to _RewriteObjectExpr
 - _RewriteObjectExpr           : internal -- Evaluator
 - Try                          : Evaluator
 - TupleExpr                    : Evaluator
 - Typecase                     : Evaluator
 - While                        : Evaluator
 - Accumulator                  : Desugarer
 - ArrayComprehension           : NYI
 - AtomicExpr                   : Evaluator
 - Exit                         : Evaluator
 - Spawn                        : Desugarer
 - Throw                        : Evaluator
 - TryAtomicExpr                : Evaluator
 - FnExpr                       : Evaluator
 - LetFn                        : BuildLetEnvironments
 - LocalVarDecl                 : BuildLetEnvironments
 - GeneratedExpr                : Desugarer
 - SubscriptExpr                : Evaluator
 - FloatLiteralExpr             : Evaluator
 - IntLiteralExpr               : Evaluator
 - CharLiteralExpr              : Evaluator
 - StringLiteralExpr            : Evaluator
 - VoidLiteralExpr              : Evaluator
 - VarRef                       : Evaluator
 - FieldRef                     : Evaluator
 - FieldRefForSure              : internal
 - _RewriteFieldRef             : internal
 - FnRef                        : Evaluator
 - _RewriteFnRef                : internal
 - OpRef                        : Evaluator (forOprExpr)
 - LooseJuxt                    : Evaluator
 - TightJuxt                    : Evaluator
 - OprExpr                      : Evaluator
 - CoercionInvocation           : NYI
 - MethodInvocation             : Evaluator
 - MathPrimary                  : Evaluator
 - ChainExpr                    : Evaluator
 - ArrayElement                 : Evaluator
 - ArrayElements                : Evaluator
 - ExponentType                 : internal
 - BaseDim                      : NYI
 - DimRef                       : NYI
 - ProductDim                   : NYI
 - QuotientDim                  : NYI
 - ExponentDim                  : NYI
 - OpDim                        : NYI
 - ArrowType                    : EvalType
 - _RewriteGenericArrowType     : internal
 - BottomType                   : internal
 - ArrayType                    : EvalType
 - IdType                       : EvalType
 - InferenceVarType             : internal
 - MatrixType                   : EvalType
 - InstantiatedType             : EvalType
 - TupleType                    : EvalType
 - VoidType                     : EvalType
 - IntersectionType             : internal
 - UnionType                    : internal
 - AndType                      : internal
 - OrType                       : internal
 - TaggedDimType                : NYI
 - TaggedUnitType               : NYI
 - IdArg                        : NYI
 - TypeArg                      : EvalType
 - IntArg                       : EvalType
 - BoolArg                      : EvalType
 - OprArg                       : EvalType
 - DimArg                       : NYI
 - UnitArg                      : NYI
 - _RewriteImplicitType         : internal
 - _RewriteIntersectionType     : internal
 - _RewriteUnionType            : internal
 - _RewriteFixedPointType       : internal
 - NumberConstraint             : EvalType (forIntArg)
 - IntRef                       : EvalType (forIntArg)
 - SumConstraint                : EvalType (forIntArg)
 - MinusConstraint              : EvalType (forIntArg)
 - ProductConstraint            : EvalType (forIntArg)
 - ExponentConstraint           : NYI
 - BoolConstant                 : EvalType
 - BoolRef                      : NYI
 - NotConstraint                : NYI
 - OrConstraint                 : NYI
 - AndConstraint                : NYI
 - ImpliesConstraint            : NYI
 - BEConstraint                 : NYI
 - WhereClause                  : NYI
 - WhereType                    : NYI
 - WhereNat                     : NYI
 - WhereInt                     : NYI
 - WhereBool                    : NYI
 - WhereUnit                    : NYI
 - WhereExtends                 : NYI
 - TypeAlias                    : NYI
 - WhereCoerces                 : NYI
 - WhereWidens                  : NYI
 - WhereWidensCoerces           : NYI
 - WhereEquals                  : NYI
 - UnitConstraint               : NYI
 - LEConstraint                 : NYI
 - LTConstraint                 : NYI
 - GEConstraint                 : NYI
 - GTConstraint                 : NYI
 - IEConstraint                 : NYI
 - BoolConstraintExpr           : NYI
 - Contract                     : NYI
 - EnsuresClause                : NYI
 - ModifierAbstract     	: NYI
 - ModifierAtomic       	: NYI
 - ModifierGetter       	: NYI
 - ModifierHidden       	: NYI
 - ModifierIO           	: NYI
 - ModifierOverride     	: NYI
 - ModifierPrivate      	: NYI
 - ModifierSettable     	: NYI
 - ModifierSetter       	: NYI
 - ModifierTest         	: NYI
 - ModifierTransient    	: NYI
 - ModifierValue        	: NYI
 - ModifierVar          	: NYI
 - ModifierWidens       	: NYI
 - ModifierWrapped      	: NYI
 - OperatorParam                : EvalType (bindGenericParameters)
 - BoolParam                    : EvalType (bindGenericParameters)
 - DimensionParam               : NYI
 - IntParam                     : EvalType (bindGenericParameters)
 - NatParam                     : EvalType (bindGenericParameters)
 - SimpleTypeParam              : EvalType (bindGenericParameters)
 - UnitParam                    : NYI
 - APIName                      : Evaluator
 - QualifiedIdName              : Evaluator
 - QualifiedOpName      	: internal
 - Id                           : Evaluator
 - Op                           : Evaluator
 - Enclosing                    : Evaluator
 - AnonymousFnName      	: internal
 - ConstructorFnName            : internal
 - ArrayComprehensionClause     : NYI
 - Binding                      : NYI (keyword parameters)
 - CaseClause                   : Evaluator (forCaseExpr)
 - Catch                        : Evaluator (forTry)
 - CatchClause                  : Evaluator (forTry)
 - DoFront                      : Evaluator (forDo)
 - IfClause                     : Evaluator (forIf)
 - TypecaseClause               : Evaluator (forTypecase)
 - ExtentRange                  : NYI (unpasting)
 - GeneratorClause              : Evaluator
 - VarargsExpr                  : NYI
 - VarargsType                  : EvalType
 - KeywordType                  : NYI
 - TraitTypeWhere               : NYI
 - Indices                      : EvalType (forArrayType)
 - ParenthesisDelimitedMI       : Evaluator (forMathPrimary)
 - NonParenthesisDelimitedMI    : Evaluator (forMathPrimary)
 - ExponentiationMI             : Evaluator (forMathPrimary)
 - SubscriptingMI               : Evaluator (forMathPrimary)
 - InFixity                     : OprUtil
 - PreFixity                    : OprUtil
 - PostFixity                   : OprUtil
 - NoFixity                     : OprUtil
 - MultiFixity                  : OprUtil
 - EnclosingFixity              : OprUtil
 - BigFixity                    : OprUtil


* Differences between the Concrete Syntax Grammar (CSG) in the specification
  and the Abstract Syntax Tree (AST) in Fortress.ast
 1) CSG defines productions for "NONTERMINALs" and "NONTERMINALList". For
    example:

Imports  ::= Import+
Name     ::= Name | { NameList }
NameList ::= Name(, Name)*

    AST does not define such productions but use "List<NONTERMINAL>" instead.
    For example, "List<Name>" is used instead of "NameList".

 2) CSG provides productions for component and API declarations that do not
    include their "component DottedId/end" and "api DottedId/end" reserved
    words:

File ::= CompilationUnit
       | Imports? Exports Decls?
       | Imports? AbsDecls
       | Imports AbsDecls?

    AST does not provide such productions: They are all translated to
    CompilationUnit.

 3) CSG distinguishes occurrences of "Id", "opr Op", and "opr EncloserPair".
    For example:

AliasedName ::= Id (as DottedId)?
              | opr Op (as Op)?
              | opr EncloserPair (as EncloserPair)?
EncloserPair ::= LeftEncloser RightEncloser

    AST does not distinguish them but uses FnName as follows:

AliasedName(FnName fnName, Option<FnName> alias = new None<FnName>());

 4) CSG classifies declarations that can occur in trait, abstract trait, object,
    and abstract object declarations in detail.  For example:

GoInATrait        ::= Coercions? GoFrontInATrait GoBackInATrait?
                    | Coercions? GoBackInATrait
GoesFrontInATrait ::= AbsFldDecl
                    | GetterSetterDecl
                    | PropertyDecl
GoesBackInATrait  ::= MdDecl
                    | PropertyDecl

    AST does not classify them but abstracts them as lists of Decls or lists of
    AbsDecls as follows:

TraitDecl(List<? extends Decl> decls) implements GenericDecl;

 5) CSG distinguishes kinds of modifiers for each declaration can have.  For
    example:

AbsTraitMod ::= value | test

    AST does not distinguish them but abstracts them as lists of Modifiers
    as follows:

TraitObjectAbsDeclOrDecl(List<Modifier> mods ...)

 6) CSG has productions for most of clauses.  For example:

Extends ::= extends TraitTypes

    AST does not have such productions.  For example:

TraitObjectAbsDeclOrDecl(..., Option<List<TraitType>> extendsClause ...)

 7) CSG distinguishes parameters of objects, methods, and functions.  For
    example:

ObjectValParam ::= ( ObjectParams? )
ObjectParams ::= (ObjectParam ,)* (ObjectVarargs, )? ObjectKeyword(, ObjectKeyword)*
               | (ObjectParam ,)* ObjectVarargs
               | ObjectParam (, ObjectParam)*
ObjectVarargs ::= transient Varargs
ObjectKeyword ::= ObjectParam = Expr
ObjectParam ::= ParamFldMods? Param
              | transient Param

    AST does not distinguish them but abstracts them as follows:

abstract Param(List<Modifier> mods = Collections.<Modifier>emptyList(),
               Id id);
    NormalParam(Option<TypeRef> type = None.<TypeRef>make(),
                Option<Expr> defaultExpr = None.<Expr>make());
    VarargsParam(VarargsType varargsType);

 8) CSG distinguishes various forms of left-hand sides of variable and field
    declarations.  For example:

VarDecl ::= VarMods? VarWTypes InitVal
          | VarMods? IdOrIdTuple = Expr
          | VarMods? IdOrIdTuple : TypeRef ... InitVal
          | VarMods? IdOrIdTuple : SimpleTupleType InitVal

    AST does not distinguish them but abstracts them as follows:

abstract VarAbsDeclOrDecl(List<LValueBind> lhs) implements VarFieldAbsDeclOrDecl;
LValueBind(Id id, Option<TypeRef> type = None.<TypeRef>make(),
           List<Modifier> mods = Collections.<Modifier>emptyList(),
           boolean mutable) implements LHS;

 9) CSG distinguishes functional declarations in APIs and components (AbsFnDecl
    and FnDecl, respectively) but it does not distinguish functional declarations
    with and without body expressions.  AST does not distinguishes functional
    declarations in APIs and functional declarations without body expressions
    in components (both AbsFnDecl) but it distinguishes functional declarations
    without body expressions in components (AbsFnDecl) and functional
    declarations with body expressions (FnDef) in components.  These differences
    are purely due to the different interests between the parser which cares
    about syntactic entities and the later phases of the compiler which care
    about semantic entities.

10) CSG distinguishes function, method, getter, setter, and coercion declarations
    but AST does not distinguish them.  Similarly, CSG distinguishes top-level
    variable and field declarations but AST does not.

11) A parenthesized expression in CSG:

Parenthesized ::= ( Expr )

    is represented as an Expr whose 'parenthesized" is set.

12) CSG distinguishes big operators but AST abstracts them as Op.

13) CSG syntactically restricts kinds of expressions that can appear after the
    atomic and tryatomic reserved words.  AST abstracts them as Expr.

14) Even though a function expression does not have a name, static parameters,
    nor a where clause in CSG, AST includes them in FnExpr for the interpreter's
    benefit.

15) For the interpreter to manipulate scopes within block expressions, the
    following syntax in CSG:

BlockElem ::= LocalVarFnDecl
            | Expr(, GeneratorList)?
LocalVarFnDecl ::= LocalFnDecl+
                 | LocalVarDecl

    is represented as follows:

LetExpr(List<Expr> body);
    GeneratedExpr(Expr expr, List<Generator> gens);
    LetFn(List<FnDef> fns);
    LocalVarDecl(List<LValue> lhs, Option<Expr> rhs = None.<Expr>make());

    in AST.

16) Unpasting syntax is slightly different.  The following syntax in CSG:

Unpasting ::= [ UnpastingElems ]
UnpastingElems ::= UnpastingElem RectSeparator UnpastingElems
                 | UnpastingElem
UnpastingElem ::= Id ([ UnpastingDim ])?
                | Unpasting
UnpastingDim ::= ExtentRange (BY ExtentRange)+

    is represented in AST as follows:

abstract Unpasting();
    UnpastingBind(Id id, List<ExtentRange> dim);
    UnpastingSplit(List<Unpasting> elems, int dim);

17) In CSG, only Id or IntLiteral can appear in left-hand sides of array
    comprehension clauses:

ArrayComprehensionLeft ::= IdOrInt |-> Expr
                         | ( IdOrInt, IdOrIntList ) |-> Expr
IdOrInt ::= Id
          | IntLiteral
ArrayComprehensionClause ::= ArrayComprehensionLeft | GeneratorList

    AST abstracts them as:

ArrayComprehensionClause(List<Expr> bind, Expr init, List<Generator> gens);

18) Array expression syntax is slightly different.  The following syntax in CSG:

Aggregate ::= [ RectElements ]
RectElements ::= Expr MultiDimCons*
MultiDimCons ::= RectSeparator Expr
RectSeparator ::= ;+
                | Whitespace

    is represented in AST as follows:

abstract ArrayExpr();
    ArrayElement(Expr element);
    ArrayElements(int dimension, List<ArrayExpr> elements);

19) While CSG treats parenthesized expressions and tuple expressions as
    functional arguments differently from other expressions as follows:

BaseExpr ::= NoKeyTuple
           | Parenthesized

    AST does not distinguish them.

20) Some expressions using operators cannot be parsed correctly without type
    information.  Therefore, the following syntax in CSG:

OpExpr ::= EncloserOp OpExpr? EncloserOp?
         | OpExpr EncloserOp OpExpr?
         | Primary
EncloserOp ::= Encloser
             | Op
Primary ::= LeftEncloser ExprList? RightEncloser
          | Primary . Id ([\StaticArgList\])? Parenthesized
          | Primary . Id ([\StaticArgList\])? ()
          | Primary ^ BaseExpr
          | Primary ExponentOp
          | Primary Parenthesized
          | Primary ()
          | Primary Primary

    is abstracted in AST as follows:

abstract OpExpr();
    OprExpr(OprName op,
            List<Expr> args = Collections.<Expr>emptyList());
    abstract Primary();
        Apply(Expr fn, Expr args);
        ChainExpr(Expr first, List<Pair<Op, Expr>> links);
        LooseJuxt(List<Expr> exprs);
        TightJuxt(List<Expr> exprs);
        FnRef(Expr expr,
              List<StaticArg> staticArgs = Collections.<StaticArg>emptyList());

21) Matrix types in CSG:

TypeRef ::= TypeRef ^ StaticArg
          | TypeRef ^ ( ExtentRange (BY ExtentRange)* )

    is represented as follows in AST:

MatrixType(TypeRef element, List<ExtentRange> dimensions);

22) Array sizes in CSG:

ArraySize ::= ExtentRange(, ExtentRange)*

    is represented as follows in AST:

abstract Indices();
    FixedDim(List<ExtentRange> extents);

23) CSG distinguishes prefix and postfix operators of dimensions and units:

DUPreOp ::= square | cubic | inverse
DUPostOp ::= squared | cubed

    AST does not distinguish them:

abstract DimUnitOp();
    SquareDimUnit();
    CubicDimUnit();
    InverseDimUnit();

24) AST has the following internal nodes that do not have corresponding syntax
    in CSG:

AnonymousFnName();
ConstructorFnName(GenericWithParams def);

25) CSG does not distinguish between different kinds of operators.  AST
    classifies operators as follows:

abstract OprName();
    Enclosing(Op open, Op close);
    Opr(Op op);
    PostFix(Op op);
    SubscriptOp();

26) CSG distinguishes contracts used in coercion declarations and the other
    functional declarations and object declarations.  AST abstracts them
    as Contract.

27) While CSG treats parenthesized types differently from other types as follows:

NonArrowType ::= ( TypeRef? )

    AST does not have a separate node for parenthesized types but maintains
    a field describing parenthesizedness.

28) While CSG has NonArrowType for the types of domain and range of an arrow
    type, AST abstracts them as TypeRef.


* Criteria for the Differences in CSG and AST
 1) It should be possible to reverse-engineer the source code from AST.
 2) Convenience for visitors is more preferrable to instanceof testing.
 3) Subclasses for variants are more preferrable to a class with a field.
 4) Do not propogate the subtype structure of a field to the enclosing method.
 5) Only leaves should be concrete classes.
 6) Common fields should be hoisted where possible and where it makes sense.


* Frequently Asked Questions and Answers for Fortress.ast
 1) Why does it distinguish between List<TypeRef> and Option<List<TypeRef>>?
   - Each of extends and excludes clauses and static parameter lists has type
     List<...> because an empty clause or an empty list is a parse error.
   - A parameter list of a functional has type List<Param> because a functional
     always has a possibly empty parameter list.
   - Each of comprises, throws, require, ensures, and invariants clauses has
     type Option<List<...>> because we want to distinguish between:
trait T end
     and
trait T comprises {...} end
     for IDE supports.
   - A parameter list of

 2) What are the purposes of the interfaces?

 3) What does the FnName hierarchy mean?
    FnName (abstract)      : name representing a functional
        DottedId           : qualified name
        AnonymousFnName    : internal name for anonymous function expression
        ConstructorFnName  : internal name for anonymous constructor expression
        OprName (abstract) : name representing an operator
            Enclosing      : a pair of enclosing operators
            PostFix        : a postfix operator
            SubscriptOp    : subscripting or subscripted assignment operator
            Opr            : all the other operator

 4) What is the root of the node hierarchy, UIDObject?
   - It provides a unique identification for each node.
   - It should not include things that are applicable only to nodes.
   - It should include things that are shared by nodes and the other parts
     of the interpreter such as the "at" method.


* Nodes That May Be Added Later
 1) Separate nodes for top-level functions, local functions, dotted methods,
    functional methods, operators, coercions, getters, and setters.


////////////////////////////////////////////////////////////////////////////////

FORTRESS LIBRARIES (test_library/)
---------------------------------
For testing of imports and exports, there needs to be a place to put
non-executable Fortress files that could not be run on their own.
This directory is that place.

This will probably change once the linker becomes more sophisticated.


////////////////////////////////////////////////////////////////////////////////

FORTRESS PARSER (src/com/sun/fortress/parser/)
----------------------------------------------
* Not Yet Parsed
 - operator symbols

* Rats! files: Fortress syntax
 - Fortress.rats
   Top-level module for the Fortress syntax.
   Instantiates every other Rats! modules.

 - Compilation.rats
   Files, compilation units, components, APIs, import and export statements.

 - Declaration.rats
   Top-level declarations.
   NYI: Dimension and unit declarations.

 - OtherDeclaration.rats
   Dimension, unit, type alias, test, property, and syntax expander
   declarations.
   NYI: Dimension and unit declarations.

 - TraitObject.rats
   Trait and object declarations.

 - Function.rats
   Function declarations.

 - Variable.rats
   Top-level variable declarations.
   Shared by local variable and field declarations.

 - Parameter.rats
   Parameter syntax for top-level and local function declarations.
   Shared by method and object declarations.

 - Method.rats
   Method declarations.

 - MethodParam.rats
   Parameter syntax for methods.
   Modifies the Parameter module.

 - Field.rats
   Field declarations.
   Modifies the Variable module.

 - AbsField.rats
   Abstract field declarations.
   Modifies the Variable module.

 - Header.rats
   Headers such as extends, excludes, comprises, where, and contract clauses.
   NYI: Where-clause constraints - nat, int, bool, and unit constraints.
        Unit static parameters.

 - Type.rats
   Types.
   NYI: Dimension and unit types.
        Static arguments - nat (minus), bool, dimension, unit, and opr.

 - Expression.rats
   Top-level module for the expression syntax.
   NYI: Unit expressions.

 - DelimitedExpr.rats
   Expressions beginning and ending with keywords.

 - LocalDecl.rats
   Local declarations within block expressions.

 - NoNewlineExpr.rats
   Body expressions of function, method, variable, field, dimension, unit,
   test, property, and syntax expander definitions.

 - NoSpaceExpr.rats
   Expressions within array expressions.

 - Literal.rats
   Literals.

 - Symbol.rats
   Symbols and operators.

 - Identifier.rats
   Identifiers allowing Unicode characters in the basic
   multilingual plane (i.e., with code points between U+0000 and U+FFFF).
   Supplementary characters (i.e., with code points between U+10000 and
   U+10FFFF) are not yet supported.

 - Keyword.rats
   Keywords.

 - Spacing.rats
   Whitespaces and comments.

 - Unicode.rats
   Generated by unicode.id.codes.pl.

* Operator precedence stuff
  precedence/


////////////////////////////////////////////////////////////////////////////////

FORTRESS COMPILER (src/com/sun/fortress/compiler/)
--------------------------------------------------
* Static Checker
 - StaticChecker is the main entry point.
 - It calls Parser, Disambiguator, IndexBuilder, and maybe some others to
   process ASTs (all in the compiler package).
 - Disambiguator calls some things in the compiler.disambiguator package.
 - compiler.index contains the intermediate data representations -- syntax
   wrapped in indices, which map things like names to functions.
 - compiler.IndexBuilder creates these indices.
 - The disambiguator pass resolves names and converts them to qualified names.
 - The typechecker pass performs analysis that requires a complete type
   environment (TraitIndexes, etc.)
 - typechecker.TypeChecker is a visitor; it creates a TypeAnalyzer object for
   each type variable scope it enters, and uses that object to make subtyping
   checks.
 - The TypeAnalyzer.subtype method produces a ConstraintFormula, which
   describes the constraints on inference variables. There are trivial formulas
   representing true and false.
 - The type checker combines all these formulas that it encounters in a certain
   scope, and then solves them to produce a substitution from inference variables
   to types, which it then performs on the syntax in that scope.
 - The formulas catch errors early -- if a certain formula is not satisfiable,
   then it will be false, and that can be checked.

* To Do
 - Immediate concerns:
  = Eliminate a nonterminating recursion in ConstraintFormula.and().
  = Generalize the equality check in the SubtypeHistory to handle types that are
    equal modulo inference variable renaming.
 - Missing features:
  = Implement TraitIndex's type parameter/hidden variable/where constraint
    accessors; fix the corresponding subtyping implementation.
  = Implement relationships defined by in-scope where constraints.
  = Implement disjunctive constraint formulas.
  = Add mu-types; determine how to handle them in subtyping, etc.
  = Implement constraint formula solving (eliminating inference variables from
    the variables' bounds).
  = Implement exclusion and negative subtyping.  Does this require that we
    support negative assertions in constraint formulas?
  = Implement equivalence and inequivalence of non-type static arguments.
  = Implement subset checking -- extending subtyping with comprises clauses,
    used to check domain coverage in overloadings, type cases, etc.
  = Implement coercion checking.
  = Implement method lookup.
  = Extend inference?  (Is it good enough at this point to behave as it has been
    specified?)
 - Optimizations:
  = Implement memoization; figure out how to generalize results for different
    sizes/contents of the SubtypeHistory parameter.
  = Find obvious opportunities for simplification, and (informally) prove that
    they're valid.  (If s and t are both trait types, for example, there's no
    point in pursuing an intersection supertype involving s.)
  = Replace binary intersections and unions with sets (eliminating the need for
    associative and commutative rules).
  = Determine if it will be necessary for the memoization cache to "forget"
    results, in order to limit memory usage; determine if it would be useful to
    separate cached results that are globally true from those that are only true
    in a certain type variable's scope.
  = Use a better metric than recursion depth to decide when a certain path
    should be abandoned (number of introduced inference variables, perhaps?).


////////////////////////////////////////////////////////////////////////////////

FORTRESS PREPARSER (src/com/sun/fortress/parser/preparser/)
-----------------------------------------------------------

This directory contains the Rats! files for the Fortress Preparser.
The preparser is able to recognize the name and imports of a component.
Every other aspect of Fortress syntax is ignored.

Rats! files: PreFortress syntax
 - PreFortress.rats
   Top-level module for the Fortress preparser syntax.
   Instantiates every other Rats! modules.

 - PreCompilation.rats
   Files, compilation units, components, and import statements.

 - PreSymbol.rats
   Symbols and operators relevant to the preparser.
