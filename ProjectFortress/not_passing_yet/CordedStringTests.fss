(*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component CordedStringTests
  import CordedString.{...}
  import Set.{...}
  import List.{...}
  export Executable
  
  test testDepth(): () = do
    words = ⟨"Hello ", "world, ", "it's ", "a ", "bright ", "new ", "day."⟩
    var result: String = EmptyString
    for w ← seq(words) do result := CatString(result, w) end
    assert(result, "Hello world, it's a bright new day.")
    result.verify()
(*    result.showStructure()  *)
    assert(result.depth, 7)
  end  
  
  test indexing(): () = do
    words = ⟨"The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog."⟩
    var testString: String = EmptyString
    for w ← seq(words) do testString := CatString(testString, w) end
    referenceString = "Thequickbrownfoxjumpedoverthelazydog."
    assert(testString, referenceString)
    for i ← ⟨ 0, 5, 7, 8, 9, 36, 23, 35 ⟩ do 
        assert(testString[i], referenceString[i]) 
    end
    for i ← ⟨ -1, -5, 37, 38, 109 ⟩ do
        shouldRaise⟦IndexOutOfBounds⟧ (fn() => testString[i])
    end
  end
  
  test subString(): () = do
    words = ⟨"The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog."⟩
    var testString: String = EmptyString
    for w ← seq(words) do testString := CatString(testString, w) end
    referenceString = "Thequickbrownfoxjumpedoverthelazydog."
    assert(testString, referenceString)
    for i ← ⟨ 0, 5, 7, 8, 9, 36, 23, 35 ⟩, 
            j ← ⟨ 0, 5, 7, 8, 9, 36, 23, 35 ⟩ do 
        assert(testString[i:j], referenceString[i:j]) 
    end

  end

  test testNonEmptyConcat(): () =  do
    stuff = "Hello "
    more = "World"
    hw = CatString(stuff, more)
    assert(|hw|, |stuff| + |more|)
    assert(hw, "Hello World")
    assert(hw, CatString("Hell", "o World"))
    assert(hw[2:7], "llo Wo")
    assert(hw[0:3], "Hell")
    assert(hw[5:2], "")
  end
  
  test testEmptyConcat(): () = do   
    e = EmptyString
    assert(|e|, 0)
    assert(e.isEmpty)
    stuff = "Hello "
    more = "World"
    h = CatString(stuff, e)
    assert(|h|, |stuff|)
    assert(stuff || e, stuff)
  end 

  test testCharConcat(): () =  do
    var result: String = EmptyString
    hw = "Hello World"
    for c <- seq(hw) do
        result := result || c
    end
    assert(result, hw)
  end
  
  test testParallelGenerator(): () = do
    chars = "abcdefghijklmnopqrstuvwxyz"
    var result: Set⟦Char⟧ = set⟦Char⟧()
    for c ← chars atomic do result := result.add(c) end
    assert(|result|, |chars|)
    for c ← result do assert(c ∈ chars) end
  end  
  
  test testSequentialGenerator(): () = do
    chars = "abcdefghijklmnopqrstuvwxyz"
    var result: List⟦Char⟧ = emptyList⟦Char⟧(26)
    for c ← seq(chars) do result := result.addRight(c) end
    assert(|result|, |chars|)
    for i ← result.bounds do assert(result[i] , chars[i]) end
  end  

  run(args:String...):() = do
    println "Tests complete"
  end

end
