(*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component CordedStringTests
  import CordedString.{...}
  import JavaString.{...}
  import Set.{...}
  import List.{...}
  export Executable
  
  test testDepth(): () = do
    words = ⟨"Hello ", "world, ", "it's ", "a ", "bright ", "new ", "day."⟩
    var result: String = EmptyString
    for w ← seq(words) do result := CatString(result, w) end
    assert(result, "Hello world, it's a bright new day.")
    result.verify()
(*    result.showStructure()  *)
    assert(result.depth, 7)
  end  
  
  test indexing(): () = do
    words = ⟨"The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog."⟩
    var testString: String = EmptyString
    for w ← seq(words) do testString := CatString(testString, w) end
    referenceString = "Thequickbrownfoxjumpedoverthelazydog."
    assert(testString, referenceString)
    for i ← ⟨ 0, 5, 7, 8, 9, 36, 23, 35 ⟩ do 
        assert(testString[i], referenceString[i]) 
    end
    for i ← ⟨ -1, -5, 37, 38, 109 ⟩ do
        shouldRaise⟦IndexOutOfBounds⟧ (fn() => testString[i])
    end
  end
 
  test subString(): () = do
    words = ⟨"The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog."⟩
    var testString: String = EmptyString
    for w ← seq(words) do testString := CatString(testString, w) end
    referenceString = "Thequickbrownfoxjumpedoverthelazydog."
    assert(testString, referenceString)
    for i ← ⟨ 0, 5, 7, 8, 9, 36, 23, 35 ⟩, 
            j ← ⟨ 0, 5, 7, 8, 9, 36, 23, 35 ⟩ do 
        assert(testString[i:j], referenceString[i:j]) 
    end
  end
  
  test subStringSimplification():() = do
    testString = catStringFrom("The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog.")
    testString.verify()
    sub1 = testString[34:36]
    typecase sub1 of
        JavaString => assert(true)
        String => do sub1.showStructure()
                            assert(false, "sub1=" sub1 " is not a JavaString") end
     end
  end
  
  (* test *) validateSubdivision(subject: String, division: Maybe⟦Generator⟦(ZZ32, String)⟧⟧): () = do
    var len: ZZ32 = 0
    var accum: String = ""
    if gen ← division then 
      for (start, str) ← seq(gen) do
         assert(start, len, str)
         len := len + |str|
         accum := accum || str
      end
      assert(len, |subject|)
      assert(accum, subject)
    end
  end
    
  test testSubdivide():() = do
    subject = CatString("abcd", "efgh")
    substr1 = subject[2:6]
    var len: ZZ32 = 0
    var accum: String = ""
    for (start, str) ← seq(substr1.subdivide()) do
         assert(start, len, str)
         len := len + |str|
         accum := accum || str
    end
    assert(len, |substr1|)
    accum.verify()
    accum.showStructure()
    assert(accum, substr1)  
    
    substr2 = subject[4:6]
    assert(substr2.subdivide(), Nothing⟦Generator⟦(ZZ32,String)⟧⟧)
    
    substr3 = subject[0:5]
    for p ← seq(substr1.subdivide()) do
        println ("found tuple" || p)    (* This should (did?) work prefix string too *)
    end
    
  end 
  
(*
  test comparison():() = do
    smaller = catStringFrom("The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog.")
    bigger = catStringFrom("The", "quick", "brown", "jumped", "fox", "over", "the", "lazy", "doggie.")
    smaller.verify
    bigger.verify
    smaller.showStructure
    bigger.showStructure
    assert(smaller < bigger)
    assert(smaller[10:] < bigger[10:])
    a = smaller[30:36] 
    b = bigger[30:36]
    a.verify
    b.verify
    a.showStructure
    b.showStructure
    assert(smaller[30:36] = bigger[30:36], smaller[30:36] " is not = to " bigger[30:36])
  end
 *)
  object CatStringReduction extends MonoidReduction[\String\]
    getter toString() = "CatStringReduction"
    empty(): String = EmptyString
    join(a:String, b:String):String = CatString(a, b)
  end
  
  test catStringFrom(args: String...): String =
    seq(args).generate⟦String⟧(CatStringReduction, fn(x) => x)
  
 
  test testNonEmptyConcat(): () =  do
    stuff = "Hello "
    more = "World"
    hw = CatString(stuff, more)
    assert(|hw|, |stuff| + |more|)
    assert(hw, "Hello World")
    assert(hw, CatString("Hell", "o World"))
  end
  
  test testEmptyConcat(): () = do   
    e = EmptyString
    assert(|e|, 0)
    assert(e.isEmpty)
    stuff = "Hello "
    more = "World"
    h = CatString(stuff, e)
    assert(|h|, |stuff|)
    assert(stuff || e, stuff)
  end 

  test testCharConcat(): () =  do
    var result: String = EmptyString
    hw = "Hello World"
    for c <- seq(hw) do
        result := result || c
    end
    assert(result, hw)
  end
  
  test testParallelGenerator(): () = do
    chars = "abcdefghijklmnopqrstuvwxyz"
    var result: Set⟦Char⟧ = set⟦Char⟧()
    for c ← chars atomic do result := result.add(c) end
    assert(|result|, |chars|)
    for c ← result do assert(c ∈ chars) end
  end  
  
  test testSequentialGenerator(): () = do
    chars = "abcdefghijklmnopqrstuvwxyz"
    var result: List⟦Char⟧ = emptyList⟦Char⟧(26)
    for c ← seq(chars) do result := result.addRight(c) end
    assert(|result|, |chars|)
    for i ← result.bounds do assert(result[i] , chars[i]) end
  end  
  
  run(args:String...):() = do
    println "Tests complete"
  end

end
