(*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component CordedStringTests
  import CordedString.{...}
  import JavaString.{...}
  import Set.{...}
  import List.{...}
  export Executable
  
  testDepth(): () = do
    words = ⟨"Hello ", "world, ", "it's ", "a ", "bright ", "new ", "day."⟩
    var result: String = EmptyString
    for w ← seq(words) do result := CatString(result, w) end
    assert(result, "Hello world, it's a bright new day.")
    result.verify()
    assert(result.depth, 7)
  end  
  
  testindexing(): () = do
    words = ⟨"The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog."⟩
    var testString: String = EmptyString
    for w ← seq(words) do testString := CatString(testString, w) end
    referenceString = "Thequickbrownfoxjumpedoverthelazydog."
    assert(testString, referenceString)
    for i ← ⟨ 0, 5, 7, 8, 9, 36, 23, 35 ⟩ do 
        assert(testString[i], referenceString[i]) 
    end
    for i ← ⟨ -1, -5, 37, 38, 109 ⟩ do
        shouldRaise⟦IndexOutOfBounds[\ZZ32\]⟧ (fn() => testString[i])
    end
  end
 

  testSubString(): () = do
    words = ⟨"The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog."⟩
    var testString: String = EmptyString
    for w ← seq(words) do testString := CatString(testString, w) end
    referenceString = "Thequickbrownfoxjumpedoverthelazydog."
    assert(testString, referenceString)
    for i ← ⟨ 0, 5, 7, 8, 9, 36, 23, 35 ⟩, 
            j ← ⟨ 0, 5, 7, 8, 9, 36, 23, 35 ⟩ do 
        assert(testString[i:j], referenceString[i:j]) 
    end
  end
  
  testSubStringSimplification():() = do
    testString = catStringFrom("The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog.")
    testString.verify()
    sub1 = testString[34:36]
    typecase sub1 of
        JavaString => assert(true)
        String => do sub1.showStructure()
                            assert(false, "sub1=" sub1 " is not a JavaString") end
    end
  end
 
   
  validateSubdivision(subject: String, division): () = do
    var len: ZZ32 = 0
    var accum: String = ""
    for (start, str) ← division do
         assert(start, len, str)
         len := len + |str|
         accum := accum || str
    end
      assert(len, |subject|)
      assert(accum, subject)
  end
  
  testIlk() = do
    hello = "Hello"
    assert(hello.ilkName, "JavaString")
    hw = CatString(hello, " World")
    assert(hw.ilkName, "CatString")
  end
  
  testJavaStringification() = do
    e = EmptyString
    assert(e.asJavaString, "", "EmptyString.javaString")
    c = CatString("abcd", "efgh")
    assert(c.asJavaString, "abcdefgh", "CatString.javaString")
    s = c[2:5]
    assert(s.asJavaString, "cdef", "SubString'.javaString")
    ss = s[1:2]
    assert(ss.asJavaString, "de", "Substring of SubString'.javaString")
    lss = s[0:1]
    assert(lss.asJavaString, "cd", "left Substring of SubString'.javaString")
  end  
  

  test testSubdivide():() = do
    subject = CatString("abcd", "efgh")
    substr1 = subject[2:6]
    validateSubdivision(substr1, seq(substr1.subdivide()))
    
    substr2 = subject[4:6]
    assert(substr2.subdivide().isEmpty, "subject[4:6].subdivide is not empty!")

    substr3 = subject[0:5]
    validateSubdivision(substr3, seq(substr3.subdivide()))
    
    
    subC = (CatString("@ab", "cdefg"))[2#4]
    print "subC =";  subC.showStructure
    validateSubdivision(subC, seq(subC.subdivide()))
  end 

  
  testComparison():() = do
    smaller = catStringFrom("The", "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog.")
    bigger = catStringFrom("The", "quick", "brown", "jumped", "fox", "over", "the", "lazy", "doggie.")
    smallerFlat = smaller.asJavaString
    biggerFlat = bigger.asJavaString
    smaller.verify
    bigger.verify
    assert(smaller < bigger)
    assert(smallerFlat < bigger)
    assert(smallerFlat < biggerFlat)
    assert(bigger > smaller)
    assert(smaller[10:] < bigger[10:])
    assert(bigger[12:] > smaller[12:])
    assert(biggerFlat[12:] > smaller[12:])
    a = smaller[30:36] 
    b = bigger[30:36]
    a.verify
    b.verify
    assert(smaller[30#6], bigger[30:35], smaller[30:36] " is not = to " bigger[30:36])
    assert(smallerFlat[30#6], bigger[30:35], smallerFlat[30:36] " is not = to " bigger[30:36])
  end
 
  object CatStringReduction extends MonoidReduction[\String\]
    getter toString() = "CatStringReduction"
    empty(): String = EmptyString
    join(a:String, b:String):String = CatString(a, b)
  end
  
  catStringFrom(args: String...): String =
    seq(args).generate⟦String⟧(CatStringReduction, fn(x) => x)
    
   
  testNonEmptyConcat(): () =  do
    print "starting testNonEmptyConcat: "
    stuff = "Hello "
    more = "World"
    hw = CatString(stuff, more)
    assert(|hw|, |stuff| + |more|)
    assert(hw, "Hello World")
    assert(hw, CatString("Hell", "o World"))
    println "testNonEmptyConcat done"
  end
  
  testEmptyConcat(): () = do
    e = EmptyString
    assert(|e|, 0)
    assert(e.isEmpty)
    stuff = "Hello "
    more = "World"
    h = CatString(stuff, e)
    assert(|h|, |stuff|)
    assert(stuff || e, stuff)
  end 

  test testCharConcat(): () =  do
    var result: String = EmptyString
    hw = "Hello World"
    for c <- seq(hw) do
        result := result || c
    end
    assert(result, hw)
  end 
  
  testParallelGenerator(): () = do
    chars = "abcdefghijklmnopqrstuvwxyz"
    var result: Set⟦Char⟧ = set⟦Char⟧()
    for c ← chars atomic do result := result.add(c) end
    assert(|result|, |chars|)
    for c ← result do assert(c ∈ chars) end
  end  
  
  testSequentialGenerator(): () = do
    chars = "abcdefghijklmnopqrstuvwxyz"
    var result: List⟦Char⟧ = emptyList⟦Char⟧(26)
    for c ← seq(chars) do result := result.addRight(c) end
    assert(|result|, |chars|)
    for i ← result.bounds do assert(result[i] , chars[i]) end
  end  
  
  run(args:String...):() = do
    testDepth()
    testindexing()
    testSubString()
    testSubStringSimplification()
    testIlk()
    testJavaStringification()
    testSubdivide()
    testComparison()
    testNonEmptyConcat()
    testEmptyConcat()
    testCharConcat()
    testParallelGenerator()
    testSequentialGenerator()
  end

end CordedStringTests

