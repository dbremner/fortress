(*******************************************************************************
    Copyright 2012, Oracle and/or its affiliates.
    All rights reserved.


    Use is subject to license terms.

    This distribution may include materials developed by third parties.

 ******************************************************************************)

component Util

  import Maybe.{...}

  export Util

  trait Reduction[\L\]
    empty(): L
    join(a: L, b: L): L
  end

  trait ActualReduction[\R,L\] extends Reduction[\L\]
    lift(r: R): L
    unlift(l:L): R
  end
  
  trait MonoidReduction[\R\] extends ActualReduction[\R,R\]
    lift(r:R): R = r
    unlift(r:R): R = r
  end

  object MIMapReduceReduction[\R\](j:(R,R)->R, z:R) extends MonoidReduction[\R\]
    getter asString():String="MIMapReduceReduction from embiggen"
    empty(): R = z
    join(a:R, b:R): R = (j)(a,b)
  end

  embiggen[\T\](j:(T,T)->T, z:T) : Comprehension[\T,T,T,T\] =
      Comprehension[\T,T,T,T\](fn (x) => x, MIMapReduceReduction[\T\](j,z), fn (x) => x)

  trait AssociativeReduction[\R\] extends ActualReduction[\R,Maybe[\R\]\]
    empty(): Nothing[\R\] = Nothing[\R\]
    join(a: Maybe[\R\], b: Maybe[\R\]): Maybe[\R\] =
        if av <- a then
            if bv <- b then
                Just(simpleJoin(av,bv))
            else
                a
            end
        else
            b
        end
    simpleJoin(a:R, b:R): R
    lift(r:R): Maybe[\R\] = Just(r)
    unlift(r:Maybe[\R\]): R =
        if res <- r then
            res
        else
            throw EmptyReduction
        end
  end

  trait ReductionWithZeroes[\R,L\] extends ActualReduction[\R,L\]
    isLeftZero(l:L): Boolean = isZero(l)
    isRightZero(l:L): Boolean = isZero(l)
    isZero(l:L): Boolean = false
  end
  
  trait Generator[\E\]
    generate[\R\](r: Reduction[\R\], body: E -> R): R 
  end  

  trait SequentialGenerator[\E\] extends { Generator[\E\] }
    getter asString(): String = "seq"
    seq(self): SequentialGenerator[\E\] = self
  end SequentialGenerator

  __generate[\E,R\](g:Generator[\E\], r: Reduction[\R\], b:E->R): R =
      g.generate[\R\](r,b)

  trait BigOperator[\I,O,R,L\]
    getter reduction(): ActualReduction[\R,L\]
    getter body(): I->R
    getter unwrap(): R->O
  end

  __bigOperator[\I,O,R,L\](o:BigOperator[\I,O,R,L\],desugaredClauses:(Reduction[\L\],I->L)->L): O = do
    r: ActualReduction[\R,L\] = o.reduction
    (*)body(i: I): L = r.lift((o.body)(i))
    (o.unwrap)(r.unlift(desugaredClauses(r,fn i => r.lift((o.body)(i)))))
  end

  __bigOperatorSugar[\I,O,R,L\](o:BigOperator[\I,O,R,L\],g:Generator[\I\]): O =
      __bigOperator[\I,O,R,L\](o, fn (r,u) => __generate[\I,L\](g, r, u))

  object BigReduction[\R,L\](reduction:ActualReduction[\R,L\]) extends BigOperator[\R,R,R,L\]
    getter body(): R->R = fn x => x
    getter unwrap() : R -> R = fn x => x
  end

  object Comprehension[\I,O,R,L\](unwrap: R -> O, reduction: ActualReduction[\R,L\], body:I->R) 
     extends BigOperator[\I,O,R,L\]
  end

end