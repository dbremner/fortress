component BigOpTests

  import List.{...}
  import Maybe.{...}
  import Util.{...}
  export Executable
  
  opr ::(l: List[\ZZ32\], x: ZZ32): List[\ZZ32\] = l.addRight(x)

  pl(l: List[\ZZ32\]): () =  
    if (hd,tl) <- l.extractLeft()
      then do print(" " || hd) ; pl(tl) end
      else println("")
    end

(*

  object Cat[\T\] extends MonoidReduction[\List[\T\]\]
      getter asString(): String = "List red"
      getter id(): List[\T\] = <| |>
      join(x: List[\T\], y: List[\T\]) = x || y  
  end
  
  opr BIG ||[\T\]() : BigReduction[\List[\T\],List[\T\]\] =
  BigReduction[\List[\T\],List[\T\]\](Cat[\T\])

*)
  
  run() = 
    do z1: ZZ32 = 1
       z2: ZZ32 = 2
       z3: ZZ32 = 3 
       l1 = <|[\ZZ32\] |> :: z1 :: z2 :: z3 :: z1 :: z2 :: z3
       pl(l1)
       l2 = <|[\ZZ32\] x + y | x <- l1, y <- l1 |>
       pl(l2) 
       l3 = <|[\ZZ32\] a + b | (a,b) <- l1.cross(l1) |>
       pl(l3)
       println("PASS")
    end

end