component BigOpTests

  import List.{...}
  import Maybe.{...}
  import Util.{...}
  export Executable
  
  opr ::(l: List[\ZZ32\], x: ZZ32): List[\ZZ32\] = l.addRight(x)

  pl(l: List[\ZZ32\]): () =  
    if (hd,tl) <- l.extractLeft()
      then do print(" " || hd) ; pl(tl) end
      else println("")
    end

  pl(l: List[\List[\ZZ32\]\]): () =
    if (hd,tl) <- l.extractLeft()
      then do pl(hd) ; pl(tl) end
      else println("")
    end    

  object Cat[\T\] extends MonoidReduction[\List[\T\]\]
      getter asString(): String = "List red"
      getter id(): List[\T\] = <| |>
      join(x: List[\T\], y: List[\T\]) = x || y  
  end
  
  opr BIG ||[\T\]() : BigReduction[\List[\T\],List[\T\]\] =
  BigReduction[\List[\T\],List[\T\]\](Cat[\T\])
  
  p(x: ZZ32, y: ZZ32): Boolean = x =/= y
  
  f(x: ZZ32) : List[\ZZ32\] = <| x, x |>

  fst(x: ZZ32, y: ZZ32): ZZ32 = x
  snd(x: ZZ32, y: ZZ32): ZZ32 = y

  run() = 
    do z1: ZZ32 = 1
       z2: ZZ32 = 2
       z3: ZZ32 = 3 
       l1 = <|[\ZZ32\] |> :: z1 :: z2 :: z3 :: z1 :: z2 :: z3
       pl(l1)
       l2 = <|[\ZZ32\] x + y | x <- l1, y <- l1 |>
       pl(l2)
       l3 = <|[\ZZ32\] a + b | (a,b) <- l1.cross(l1) |>
       pl(l3)       
       l4 = <|[\ZZ32\] x + x | x <- l1.filter(fn y => y =/= 2) |>
       pl(l4)
       l5 = <|[\List[\ZZ32\]\] <| x, y |> | x <- l1, y <- l1 |>   
       pl(l5)
       l6 = BIG ||[\ZZ32\] [l <- l5] l
       pl(l6) 
       l7 = <|[\ZZ32\] y | x <- l1, y <- f(x) |> 
       pl(l7) 
       l8 = <|[\ZZ32\] y | y <- l1.nest(f) |>  
       pl(l8)
       l9 = <|[\ZZ32\] x + y + z | x <- l1 , y <- l1, z <- l1 |>
       pl(l9)   
       l10 = <|[\ZZ32\] x + y + z | (x,y) <- l1.cross(l1) , z <- l1 |>
       pl(l10)
       l11 = <|[\ZZ32\] fst(a) + snd(a) + b | (a,b) <- (l1.cross(l1)).cross(l1) |>
       pl(l11)
       (*)l9 = <|[\ZZ32\] x + y | x <- l1, y <- l1, p(x,y) |>
       (*)pl(l9)    

       println("PASS")
    end

end