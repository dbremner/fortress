(*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component SkipList
export SkipList

(*****************************************************************************
   An implementation of Skip Lists, based on Pugh, William (June 1990).
   "Skip lists: a probabilistic alternative to balanced trees". Communications
   of the ACM 33: 668-676. The expected time for searching, inserting, or deleting
   a key-element pair is O(log n). Skip Lists are represented here in a tree
   structure, based on Xavier Messeguer (1997). "Skip Trees, an Alternative Data
   Structure to Skip Lists in a Concurrent Approach". ITA 31(3): 251-269.

   A skip tree is a variant of a B-tree.  It shares the B-tree property that
   every path from the root to a leaf has the same length.  Every node contains
   some number of keys (n) and exactly n + 1 children nodes. Skip trees do not
   share the B-tree property of a minimum or a maximum number of keys per node.
   All leaves live in level 0 of the tree, and values are stored only in the leaf
   nodes.

***************************************************************************)

(* A SkipList type consists of a root node and pInverse = 1/p, where the fraction
   p is used in the negative binomial distribution to select random levels for insertion.
*)
object SkipList[\Key,Val,nat pInverse\](root:Node[\Key,Val\])

  p:RR64 = 1.0 / pInverse

  toString():String = root.toString()

  search(k:Key):Maybe[\Val\] = root.search(k)

  add(k:Key, v:Val):SkipList[\Key,Val,pInverse\] = do
    level:ZZ32 = randomLevel()
    SkipList[\Key,Val,pInverse\](root.add(k,v,level))
  end

  remove(k:Key):SkipList[\Key,Val,pInverse\] = do
    SkipList[\Key,Val,pInverse\](root.remove(k))
  end

  randomLevel():ZZ32 = do
    level':ZZ32 := 1
    while random(1.0) < p do
      level' += 1
    end
    level'
  end

end

(* Construct an empty skip list *)
NewList[\Key,Val,nat pInverse\]():SkipList[\Key,Val,pInverse\] =
  SkipList[\Key,Val,pInverse\](EmptyNode[\Key,Val\]())


(* A Node is the basic type for the Skip List data structure.
   There are four types of Nodes:
    i)   Empty Nodes - represents an empty tree.
    ii)  Leaf Nodes - stores a (key,val) pair. Lives at the bottom of the tree.
    iii) Internal Nodes - stores N keys and N+1 children for N > 0.
    iv)  White Nodes - stores exactly zero keys and one child.
*)
trait Node[\Key,Val\] comprises {EmptyNode[\Key,Val\], LeafNode[\Key,Val\],
  InternalNode[\Key,Val\], WhiteNode[\Key,Val\]}

  getHeight():ZZ32

  isLeaf():Boolean
  isTreeEmpty():Boolean
  isNodeEmpty():Boolean

  search(k:Key):Maybe[\Val\]

  toString():String
  (* toGraphViz():String   wait until hashCode() is implemented*)

  (* the add method can grow the tree if level > root height *)
  add(k:Key, v:Val, level:ZZ32):Node[\Key,Val\]

  (* the add_helper method is only invoked if level <= root height *)
  add_helper(k:Key, v:Val, level:ZZ32):Node[\Key,Val\]

  remove(k:Key):Node[\Key,Val\]

  (* splits the new child in half and sucks the split key up to this level *)
  split(index:ZZ32, heir:Node[\Key,Val\]):InternalNode[\Key,Val\]

  (* breaks the keys of this node into two new nodes *)
  break():(Node[\Key,Val\],Node[\Key,Val\],Key)

end


generate_tail[\Key,Val\](node:Node[\Key,Val\], length:ZZ32):Node[\Key,Val\] =
if length > 0 then
  generate_tail[\Key,Val\](WhiteNode[\Key,Val\](node,node.getHeight() + 1), length - 1)
else
  node
end


(* A white node stores exactly zero keys and contains one child. White nodes are
   used as placeholders to keep the height of all branches identical. A white node
   has a height > 0 *)
object WhiteNode[\Key,Val\](child:Node[\Key,Val\], height:ZZ32) extends Node[\Key,Val\]

  getHeight():ZZ32 = height

  isLeaf():Boolean = false
  isTreeEmpty():Boolean = false
  isNodeEmpty():Boolean = true

  search(k:Key):Maybe[\Val\] = child.search(k)

  toString():String = "{ [], [" child.toString() "] }"

  add(k:Key, v:Val, level:ZZ32):Node[\Key,Val\] = do
    tail:Node[\Key,Val\] = generate_tail[\Key,Val\](self, level - getHeight())
    tail.add_helper(k,v,level)
  end

  add_helper(k:Key, v:Val, level:ZZ32):Node[\Key,Val\] =
  if height = 1 then
    height1_add(k,v)
  else
    heightn_add(k,v,level)
  end

  remove(k:Key):Node[\Key,Val\] = do
    if height = 1 then
      height1_remove(k)
    else
      heightn_remove(k)
    end
  end

  (* splits the new child in half and sucks the split key up to this level *)
  split(index:ZZ32, heir:Node[\Key,Val\]):InternalNode[\Key,Val\] = do
    keys:Array[\Key,ZZ32\] = array[\Key\](1)
    children:Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](2)
    (left,right,key') = heir.break()
    keys[0] := key'
    children[0] := left
    children[1] := right
    InternalNode[\Key,Val\](keys,children,height)
  end

  break():(Node[\Key,Val\],Node[\Key,Val\],Key) = fail("Cannot break a white node")

  (* perform the add operation when the height is one *)
  height1_add(k:Key, v:Val):Node[\Key,Val\] = do
    other:LeafNode[\Key,Val\] = LeafNode[\Key,Val\]((k,v))
    k':Key = child.key
    keys:Array[\Key,ZZ32\] = array[\Key\](1)
    children:Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](2)
    (smaller,larger,lkey) = if k > k' then (child,other,k) else (other,child,k') end
    keys[0] := lkey
    children[0] := smaller
    children[1] := larger
    InternalNode[\Key,Val\](keys,children,height)
  end

  (* perform the add operation when the height is greater than one *)
  heightn_add(k:Key, v:Val, level:ZZ32):Node[\Key,Val\] = do
    child':Node[\Key,Val\] = child.add_helper(k,v,level)
    if level < height then
      WhiteNode[\Key,Val\](child', height)
    else
      split(0, child')
    end
  end

  (* perform the remove operation when the height is one *)
  height1_remove(k:Key):Node[\Key,Val\] = do
    if child.getKey() = k then
      EmptyNode[\Key,Val\]()
    else
      self
    end
  end

  (* perform the remove operation when the height is greater than one *)
  heightn_remove(k:Key):Node[\Key,Val\] = do
    child':Node[\Key,Val\] = child.remove(k)
    if instanceOf[\EmptyNode[\Key,Val\]\](child') then
      child'
    else
      WhiteNode[\Key,Val\](child', height)
    end
  end

end

(* An internal node stores N keys and N + 1 children where N > 0.
   An internal nodes has a height > 0. *)
object InternalNode[\Key,Val\](keys:Array[\Key,ZZ32\],
  children:Array[\Node[\Key,Val\],ZZ32\], height:ZZ32) extends Node[\Key,Val\]

  getHeight():ZZ32 = height

  isLeaf():Boolean = false
  isTreeEmpty():Boolean = false
  isNodeEmpty():Boolean = false

  find_index(k:Key):ZZ32 = do
    index:ZZ32 := 0
    (* FIXME: replace with AND: *)
    (* OR BETTER YET: replace with a reduction *)
    flag:Boolean := false
    if index < keys.size() then flag := k >= keys[index] end
    while (flag) do
      index += 1
      flag := false
      if index < keys.size() then flag := k >= keys[index] end
    end
    index
  end

  search(k:Key):Maybe[\Val\] = do
    index:ZZ32 = find_index(k)
    children[index].search(k)
  end

  toString():String = "{" keys.toString() ", " children.toString() "}"

  add(k:Key, v:Val, level:ZZ32):Node[\Key,Val\] = do
    tail:Node[\Key,Val\] = generate_tail[\Key,Val\](self, level - getHeight())
    tail.add_helper(k,v,level)
  end

  add_helper(k:Key, v:Val, level:ZZ32):Node[\Key,Val\] = do
    index:ZZ32 = find_index(k)
    if height = 1 then
      height1_add(k,v,index)
    else
      heightn_add(k,v,index,level)
    end
  end

  remove(k:Key):Node[\Key,Val\] = do
    index:ZZ32 = find_index(k)
    if height = 1 then
      height1_remove(k,index)
    else
      heightn_remove(k,index)
    end
  end

  (* splits the new child in half and sucks the split key up to this level *)
  split(index:ZZ32, heir:Node[\Key,Val\]):InternalNode[\Key,Val\] = do
    keysplit:ZZ32 = keys.size() - index
    keys':Array[\Key,ZZ32\] = array[\Key\](keys.size() + 1)
    children':Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](children.size() + 1)
    (left,right,key') = heir.break()
    keys'[0 # index] := keys[0 # index]
    children'[0 # index] := children[0 # index]
    keys'[index] := key'
    children'[index] := left
    children'[index + 1] := right
    keys'[(index + 1) # keysplit] := keys[index # keysplit]
    children'[(index + 2) # keysplit] := children[(index + 1) # keysplit]
    InternalNode[\Key,Val\](keys',children',height)
  end

  break():(Node[\Key,Val\],Node[\Key,Val\],Key) =
  if keys.size() = 1 then
    onekey_break()
  elif keys.size() = 2 then
    twokeys_break()
  else
    nkeys_break()
  end

  (* perform the add operation when the height is one *)
  height1_add(k:Key, v:Val, index:ZZ32):Node[\Key,Val\] = do
    keys':Array[\Key,ZZ32\] = array[\Key\](keys.size() + 1)
    children':Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](children.size() + 1)
    newnode:Node[\Key,Val\] = LeafNode[\Key,Val\]((k,v))
    keysplit:ZZ32 = keys.size() - index
    (smaller,larger) = if k > children[index].getKey() then (children[index], newnode) else (newnode, children[index]) end
    children'[index] := smaller
    children'[index + 1] := larger
    children'[0 # index] := children[0 # index]
    children'[(index + 2) # keysplit] := children[(index + 1) # keysplit]    
    keys'[index] := larger.getKey()
    keys'[0 # index] := keys[0 # index]
    keys'[(index + 1) # keysplit] := keys[index # keysplit]
    InternalNode[\Key,Val\](keys',children',height)
  end

  (* perform the add operation when the height is greater than one *)
  heightn_add(k:Key, v:Val, index:ZZ32, level:ZZ32):Node[\Key,Val\] = do
    child':Node[\Key,Val\] = children[index].add_helper(k,v,level)
    if level < height then
      children':Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](children.size())
      children'[0 # (children.size())] := children[0 # (children.size())]
      children'[index] := child'
      InternalNode[\Key,Val\](keys,children',height)
    else
      split(index, child')
    end
  end

  (* perform the remove operation when the height is one *)
  height1_remove(k:Key, index:ZZ32):Node[\Key,Val\] = do
    if children[index].getKey() = k then
      height1_remove_helper(index)
    else
      self
    end
  end

  height1_remove_helper(index:ZZ32):Node[\Key,Val\] = do
    if keys.size() = 1 then
      WhiteNode[\Key,Val\](children[(index + 1) MOD 2], height)
    else
      index_remove(index)
    end
  end

  (* perform the remove operation when the height is greater than one *)
  heightn_remove(k:Key, index:ZZ32):Node[\Key,Val\] = do
    child':Node[\Key,Val\] = children[index].remove(k)
    if keys.size() = 1 then
      heightn_remove_1key(index,child')
    else
      heightn_remove_nkeys(index,child')
    end
  end

  (* perform the remove operation when height > 1 and keys = 1 *)
  heightn_remove_1key(index:ZZ32, child':Node[\Key,Val\]):Node[\Key,Val\] = do
    other:ZZ32 = (index + 1) MOD 2
    if instanceOf[\EmptyNode[\Key,Val\]\](child') then
      WhiteNode[\Key,Val\](children[other], height)
    else
      keys':Array[\Key,ZZ32\] = array[\Key\](1)
      children':Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](2)
      keys'[0] := keys[0]
      children'[index] := child'
      children'[other] := children[other]
      InternalNode[\Key,Val\](keys', children', height)
    end
  end

  (* perform the remove operation when height > 1 and keys > 1 *)
  heightn_remove_nkeys(index:ZZ32, child':Node[\Key,Val\]):Node[\Key,Val\] = do
    if instanceOf[\EmptyNode[\Key,Val\]\](child') then
      index_remove(index)
    else
      keys':Array[\Key,ZZ32\] = array[\Key\](keys.size())
      children':Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](children.size())
      keys'[0 # keys.size()] := keys[0 # keys.size()]
      children'[0 # children.size()] := children[0 # children.size()]
      children'[index] := child'
      InternalNode[\Key,Val\](keys', children', height)
    end
  end

  (* return a new internal node that has children[index] and keys[index - 1] missing *)
  index_remove(index:ZZ32):Node[\Key,Val\] = do
    keys':Array[\Key,ZZ32\] = array[\Key\](keys.size() - 1)
    children':Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](children.size() - 1)
    replace:ZZ32 = MAX(0, index - 1)
    keys'[0 # replace] := keys[0 # replace]
    keys'[replace # (keys'.size() - replace)] := keys[(replace + 1) # (keys'.size() - replace)]
    children'[0 # index] := children[0 # index]
    children'[index # (children'.size() - index)] := children[(index + 1) # (children'.size() - index)]
    InternalNode[\Key,Val\](keys', children', height)
  end

  (* perform the break operation when we have exactly one key *)
  onekey_break():(Node[\Key,Val\],Node[\Key,Val\],Key) = do
    smaller:Node[\Key,Val\] = children[0]
    larger:Node[\Key,Val\] = children[1]
    key':Key = keys[0]
    left:Node[\Key,Val\] = generate_tail[\Key,Val\](smaller, 1)
    right:Node[\Key,Val\] = generate_tail[\Key,Val\](larger, 1)
    (left, right, key')
  end

  (* perform the break operation when we have exactly two keys *)
  twokeys_break():(Node[\Key,Val\],Node[\Key,Val\],Key) = do
    smaller:Node[\Key,Val\] = children[0]
    rkeys:Array[\Key,ZZ32\] = array[\Key\](1)
    rchildren:Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](2)
    key':Key = keys[0]
    rkeys[0] := keys[1]
    rchildren[0#2] := children[1#2]
    left:Node[\Key,Val\] = generate_tail[\Key,Val\](smaller, 1)
    right:Node[\Key,Val\] = InternalNode[\Key,Val\](rkeys,rchildren,height)
    (left, right, key')
  end

  (* perform the break operation when we have three or more keys *)
  nkeys_break():(Node[\Key,Val\],Node[\Key,Val\],Key) = do
    half:ZZ32 = keys.size() DIV 2
    rsize:ZZ32 = keys.size() - half - 1
    lsize:ZZ32 = keys.size() - rsize - 1
    key':Key = keys[half]
    lkeys:Array[\Key,ZZ32\] = array[\Key\](lsize)
    lchildren:Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](lsize + 1)
    rkeys:Array[\Key,ZZ32\] = array[\Key\](rsize)
    rchildren:Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](rsize + 1)
    lkeys[0 # lsize] := keys[0 # lsize]
    lchildren[0 # (lsize + 1)] := children[0 # (lsize + 1)]
    rkeys[0 # rsize] := keys[(half + 1) # rsize]
    rchildren[0 # (rsize + 1)] := children[(half + 1) # (rsize + 1)]
    left:Node[\Key,Val\] = InternalNode[\Key,Val\](lkeys,lchildren,height)
    right:Node[\Key,Val\] = InternalNode[\Key,Val\](rkeys,rchildren,height)
    (left, right, key')
  end

end

(* The empty node represents an empty tree. It is neither a leaf node nor
   an internal node, and the empty node does not have a height. *)
object EmptyNode[\Key,Val\]() extends Node[\Key,Val\]

  getHeight():ZZ32 = fail("Cannot get height of an empty tree")

  isLeaf():Boolean = fail("Empty node is neither a leaf nor an internal node")
  isTreeEmpty():Boolean = true
  isNodeEmpty():Boolean = fail("Empty node cannot check for emptiness on keys")

  search(k:Key):Maybe[\Val\] = Nothing[\Val\]()

  toString():String = "{}"

  remove(k:Key):Node[\Key,Val\] = self

  add(k:Key, v:Val, level:ZZ32):Node[\Key,Val\] = do
    add_helper(k,v,level)
  end

  add_helper(k:Key, v:Val, level:ZZ32):Node[\Key,Val\] = do
    leaf:LeafNode[\Key,Val\] = LeafNode[\Key,Val\]((k, v))
    parent:WhiteNode[\Key,Val\] = WhiteNode[\Key,Val\](leaf,1)
    parent
  end

  split(index:ZZ32, heir:Node[\Key,Val\]):InternalNode[\Key,Val\] = fail("Cannot split an empty node.")
  break():(Node[\Key,Val\],Node[\Key,Val\],Key) = fail("Cannot break an empty node.")


end

(* Leaf nodes are the only nodes that store values.  All leaf
   nodes live at the bottom of the tree, and they all have height 0. *)
object LeafNode[\Key,Val\](pair: (Key, Val)) extends Node[\Key,Val\]

  (key, val) = pair
  getPair():(Key, Val) = pair
  getKey():Key = key
  getVal():Val = val
  getHeight():ZZ32 = 0

  isLeaf():Boolean = true
  isTreeEmpty():Boolean = false
  isNodeEmpty():Boolean = false

  search(k:Key):Maybe[\Val\] = if k = key then Just[\Val\](val) else Nothing[\Val\]() end

  add(k:Key, v:Val, level:ZZ32):Node[\Key,Val\] = fail("Cannot add a new node into a leaf node.")
  add_helper(k:Key, v:Val, level:ZZ32):Node[\Key,Val\] = fail("Cannot add a new node into a leaf node.")
  remove(k:Key):Node[\Key,Val\] = fail("Cannot remove a key from a leaf node.")

  split(index:ZZ32, heir:Node[\Key,Val\]):InternalNode[\Key,Val\] = fail("Cannot split a leaf node.")
  break():(Node[\Key,Val\],Node[\Key,Val\],Key) = fail("Cannot break a leaf node.")

  toString():String = "<<" key ">>"

end


end
