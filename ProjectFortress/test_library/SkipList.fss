(*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component SkipList
export SkipList

(*****************************************************************************
   An implementation of Skip Lists, based on Pugh, William (June 1990).
   "Skip lists: a probabilistic alternative to balanced trees". Communications
   of the ACM 33: 668-676. The Search(), Insert(), and Delete() operations
   are based off "A Skip List Cookbook" by William Pugh. University of Maryland,
   Deptartment of Computer Science, Technical Report CS-TR-2286.1. The expected
   time for searching, inserting, or deleting a key-element pair is O(log n).

   This collection is a mutable container type. The simplest synchronization
   scheme has been implemented: all the methods on the skip lists have been
   declared atomic. For a more sophisticated implementation look at
   "A Provably Correct Scalable Concurrent Skip List" by Maurice Herlihy,
   Yossi Lev, Victor Luchangco, and Nir Shavit. On Principles Of Distributed
   Systems Conference (OPODIS) 2006.

   From http://en.wikipedia.org/wiki/Skip_list
   "A skip list is a probabilistic data structure. Underlying the skip list is
   an augmentation of an ordered linked list with additional forward links,
   added in a randomized way with a geometric/negative binomial distribution,
   so that a search in the list may quickly skip parts of the list."

   "A skip list is built in layers. The bottom layer is an ordinary ordered
   linked list. Each higher layer acts as an "express lane" for the lists below,
   where an element in layer i appears in layer i+1 with some fixed probability p.
   On average, each element appears in 1/(1-p) lists."

***************************************************************************)

(* A Node is the basic type for the Skip List data structure. Nodes instances
  contain a (key, value) pair that stores data along with an array of forward
  pointers. Each node has a level which corresponds to the highest forward pointer
  of a node (level = forward.size - 1). The ith foward pointer points to the next
  node of level i or higher.
*)
trait Node[\Key,Val\] comprises {HeadNode[\Key,Val\],FullNode[\Key,Val\],NilNode[\Key,Val\]}

  getPair():(Key, Val)
  getKey():Key
  getVal():Val

  (* return the level of this Node. level = forward.size - 1 *)
  getLevel():ZZ32

  (* The generate method for (Key,Val)->R reductions. *)
  generate[\R\](r: Reduction[\R\], body: (Key,Val)->R): R

  (* The generate method for ZZ32->R reductions.
     FIXME: My attempt to overload the generate() method
     throw some errors in the interpreter *)
  generate2[\R\](r: Reduction[\R\], body: ZZ32->R): R

  (* returns a (key, value) String representation of this node
     and all downstream nodes *)
  toString():String

  (* returns a pictoral representation of the ith level
     of forward pointers of this node and all downstream nodes *)
  toStringLine(line:ZZ32):String

  (* use these methods in place of < and = operations on the node
     key to avoid giving the nil node a dummy key of positive infinity. *)
  isLessCompare(searchKey:Key):Boolean
  isEqualCompare(searchKey:Key):Boolean
end

(* The HeadNode is the head of the skip list data structure. The head node
   does not contain a (key,value) pair. The forward array is always of size
   maxLevel, where maxLevel is a static parameter of the SkipNode type.
*)
object HeadNode[\Key,Val\](settable forward:Array[\Node[\Key,Val\],ZZ32\]) extends Node[\Key,Val\]
  getPair():(Key, Val) = fail("Head node: cannot get (key,value) pair")
  getKey():Key = fail("Head node: cannot get key")
  getVal():Val = fail("Head node: cannot get value")
  getLevel():ZZ32 = fail("Head node: cannot get level")
  generate[\R\](r: Reduction[\R\], body: (Key,Val)->R): R = forward[0].generate[\R\](r,body)
  generate2[\R\](r: Reduction[\R\], body: ZZ32->R): R = forward[0].generate[\R\](r,body)
  toString():String = forward[0].toString()
  toStringLine(line:ZZ32):String = forward[0].toStringLine(line)
  printStringLines(level:ZZ32):() = do
    for j <- seq(0:level) do
      i = level - j
      println toStringLine(i)
    end
  end
  isLessCompare(searchKey:Key):Boolean = fail("Head node: cannot perform less-than comparison")
  isEqualCompare(searchKey:Key):Boolean = fail("Head node: cannot perform equals comparison")
end

(* The NilNode is the tail of the skip list data structure. The nil node
   does not contain a (key,value) pair. The nil node does not contain
   a forward array.
*)
object NilNode[\Key,Val\]() extends Node[\Key,Val\]
  getPair():(Key, Val) = fail("Nil node: cannot get (key,value) pair")
  getKey():Key = fail("Nil node: cannot get key")
  getVal():Val = fail("Nil node: cannot get value")
  getLevel():ZZ32 = fail("Nil node: cannot get level")
  generate[\R\](r: Reduction[\R\], body: (Key,Val)->R): R = r.empty()
  generate2[\R\](r: Reduction[\R\], body: ZZ32->R): R = r.empty()
  toString():String = "{}"
  toStringLine(line:ZZ32):String = ""
  isLessCompare(searchKey:Key):Boolean = false
  isEqualCompare(searchKey:Key):Boolean = false
end

(* SkipNodes comprise the bulk of the skip list data structure. They
   consist of a (key, value) pair and a forward array that points
   to downstream Nodes.
*)
object SkipNode[\Key,Val\](pair:(Key,Val),settable forward:Array[\Node[\Key,Val\],ZZ32\])
  extends Node[\Key,Val\]
  (key, val) = pair
  getPair():(Key, Val) = pair
  getKey():Key = key
  getVal():Val = val
  getLevel():ZZ32 = forward.size() - 1
  generate[\R\](r: Reduction[\R\], body: (Key,Val)->R): R =
    r.join(body(key,val),forward[0].generate[\R\](r,body))
  generate2[\R\](r: Reduction[\R\], body: ZZ32->R): R =
    r.join(body(forward.size()),forward[0].generate2[\R\](r,body))
  toString():String = "{" key "|->" val forward[0].generate[\String\](StringReduction,
    fn (k:Key, v:Val):String=> ", " k "|->" v) "}"
  toStringLine(line:ZZ32):String = if line < forward.size() then
    "| " forward[0].generate2[\String\](StringReduction,
    fn (i:ZZ32):String=> if line < i then "| " else "  " end)
  else
    "  " forward[0].generate2[\String\](StringReduction,
    fn (i:ZZ32):String=> if line < i then "| " else "  " end)
  end
  isLessCompare(searchKey:Key):Boolean = key < searchKey
  isEqualCompare(searchKey:Key):Boolean = key = searchKey
end

(* A SkipList type consists of a HeadNode and an integer to keep track of the
   current level of the skip list. The level of a skip list is the level of its
   highest node (excluding the header). MaxLevel is a constant that caps the
   level of the list. pInverse = 1/p, where the fraction p of the nodes with
   level i pointers also have level i+1 pointers. MaxLevel and pInverse should
   be selected such that MaxLevel = log_1/p (N), where N is an upper bound on
   the number of elements in the skip list.  If pInverse = 2 and MaxLevel = 32,
   then N = 2 ^ 32.
*)
object SkipList[\Key,Val,nat maxLevel,nat pInverse\](settable header:HeadNode[\Key,Val\],settable level:ZZ32)

  p:RR64 = 1.0 / pInverse
  atomic toString():String = header.toString()
  atomic printStringLines():() = header.printStringLines(level)

  atomic search(searchKey:Key):Maybe[\Val\] = do
    x:Node[\Key,Val\] := header
    for j <- seq(0:level) do
      i = level - j
      while x.forward[i].isLessCompare(searchKey) do
        x := x.forward[i]
      end
    end
    x := x.forward[0]
    if x.isEqualCompare(searchKey) then
      Just[\Val\](x.getVal())
    else
      Nothing[\Val\]()
    end
  end

  atomic insert(searchKey:Key,newValue:Val):() = do
    update:Array1[\Node[\Key,Val\],0,maxLevel\] := array1[\Node[\Key,Val\], maxLevel\]()
    x:Node[\Key,Val\] := header
    for j <- seq(0:level) do
      i = level - j
      while x.forward[i].isLessCompare(searchKey) do
        x := x.forward[i]
      end
      update[i] := x
    end
    newLevel:ZZ32 = randomLevel()
    if newLevel > level then
      for i <- (level + 1):newLevel do
        update[i] := header
      end
      level := newLevel
    end
    x := SkipNode[\Key,Val\]((searchKey,newValue),array[\Node[\Key,Val\]\](newLevel + 1))
    for i <- 0:newLevel do
      x.forward[i] := update[i].forward[i]
      update[i].forward[i] := x
    end
  end

  atomic delete(searchKey:Key):() = do
    update:Array1[\Node[\Key,Val\],0,maxLevel\] := array1[\Node[\Key,Val\], maxLevel\]()
    x:Node[\Key,Val\] := header
    for j <- seq(0:level) do
      i = level - j
      while x.forward[i].isLessCompare(searchKey) do
        x := x.forward[i]
      end
      update[i] := x
    end
    x := x.forward[0]
    if x.isEqualCompare(searchKey) then
      for i <- 0:level do
        (* FIXME: This should actually be (update[i].forward[i] = x)
          but equality has not yet been implemented *)
        if update[i].forward[i].isEqualCompare(searchKey) then
          update[i].forward[i] := x.forward[i]
        end
      end
      while level > 0 AND instanceOf[\NilNode[\Key,Val\]\](header.forward[level]) do
        level -= 1
      end
    end
  end

  randomLevel():ZZ32 = do
    level':ZZ32 := 0
    while random(1.0) < p do
      level' += 1
    end
    if level' >= maxLevel then
      maxLevel - 1
    else
      level'
    end
  end
end

(* The EmptyList() function creates an empty skip list with given
   maxLevel and pInverse values.
*)
EmptyList[\Key,Val,nat maxLevel,nat pInverse\]():SkipList[\Key,Val,maxLevel,pInverse\] = do
  tail:NilNode[\Key,Val\] = NilNode[\Key,Val\]()
  head:HeadNode[\Key,Val\] = HeadNode[\Key,Val\](array1[\Node[\Key,Val\],maxLevel\]().fill(tail))
  empty:SkipList[\Key,Val,maxLevel,pInverse\] = SkipList[\Key,Val,maxLevel,pInverse\](head,0)
  empty
end

end
