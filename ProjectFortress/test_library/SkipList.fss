(*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component SkipList
export SkipList

(*****************************************************************************
   An implementation of Skip Lists, based on Pugh, William (June 1990).
   "Skip lists: a probabilistic alternative to balanced trees". Communications
   of the ACM 33: 668-676. The expected time for searching, inserting, or deleting
   a key-element pair is O(log n). Skip Lists are represented here in a tree
   structure, based on Xavier Messeguer (1997). "Skip Trees, an Alternative Data
   Structure to Skip Lists in a Concurrent Approach". ITA 31(3): 251-269.

   A skip tree is a variant of a B-tree.  It shares the B-tree property that
   every path from the root to a leaf has the same length.  Every node contains
   some number of keys (n) and exactly n + 1 children nodes. Skip trees do not
   share the B-tree property of a minimum or a maximum number of keys per node.
   All leaves live in level 0 of the tree, and values are stored only in the leaf
   nodes.

***************************************************************************)

trait SkipList[\Key,Val,nat pInverse\] comprises {EmptyList[\Key,Val,pInverse\],
  FullList[\Key,Val,pInverse\]}

  toString():String
  (* toGraphViz():String   wait until hashCode() is implemented*)
  search(k:Key):Maybe[\Val\]
  add(k:Key, v:Val):SkipList[\Key,Val,pInverse\]

end

(* A Node is the basic type for the Skip List data structure.
   There are four types of Nodes:
    i) Empty Nodes - represents an empty tree.
    ii) Leaf Nodes - stores a (key,val) pair. Lives at the bottom of the tree.
    iii) Internal Nodes - stores N keys and N+1 children for N > 0.
    iv) White Nodes - stores exactly zero keys and one child.
*)
trait Node[\Key,Val\] comprises {EmptyNode[\Key,Val\], LeafNode[\Key,Val\],
  InternalNode[\Key,Val\], WhiteNode[\Key,Val\]}

  getHeight():ZZ32

  isLeaf():Boolean
  isTreeEmpty():Boolean
  isNodeEmpty():Boolean

  search(k:Key):Maybe[\Val\]

  toString():String
  (* toGraphViz():String   wait until hashCode() is implemented*)

  add(k:Key, v:Val, level:ZZ32):Node[\Key,Val\]

  (* splits the new child in half and sucks the split key up to this level *)
  split(index:ZZ32, heir:Node[\Key,Val\]):InternalNode[\Key,Val\]

  (* breaks the keys of this node into two new nodes *)
  break():(Node[\Key,Val\],Node[\Key,Val\],Key)

end


generate_tail[\Key,Val\](node:Node[\Key,Val\], length:ZZ32):Node[\Key,Val\] =
if length > 0 then
  generate_tail[\Key,Val\](WhiteNode[\Key,Val\](node,node.getHeight() + 1), length - 1)
else
  node
end


(* A white node stores exactly zero keys and contains one child. White nodes are
   used as placeholders to keep the height of all branches identical. A white node
   has a height > 0 *)
object WhiteNode[\Key,Val\](child:Node[\Key,Val\], height:ZZ32) extends Node[\Key,Val\]

  getHeight():ZZ32 = height

  isLeaf():Boolean = false
  isTreeEmpty():Boolean = false
  isNodeEmpty():Boolean = true

  search(k:Key):Maybe[\Val\] = child.search(k)

  toString():String = "{ [], [" child.toString() "] }"

  add(k:Key, v:Val, level:ZZ32):Node[\Key,Val\] =
  if height = 1 then
    height1_add(k,v)
  else
    heightn_add(k,v,level)
  end

  (* splits the new child in half and sucks the split key up to this level *)
  split(index:ZZ32, heir:Node[\Key,Val\]):InternalNode[\Key,Val\] = do
    keys:Array[\Key,ZZ32\] = array[\Key\](1)
    children:Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](2)
    (left,right,key') = heir.break()
    keys[0] := key'
    children[0] := left
    children[1] := right
    InternalNode[\Key,Val\](keys,children,height)
  end

  break():(Node[\Key,Val\],Node[\Key,Val\],Key) = fail("Cannot break a white node")

  (* perform the add operation when the height is one *)
  height1_add(k:Key, v:Val):Node[\Key,Val\] = do
    other:LeafNode[\Key,Val\] = LeafNode[\Key,Val\]((k,v))
    k':Key = child.key
    keys:Array[\Key,ZZ32\] = array[\Key\](1)
    children:Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](2)
    (smaller,larger,lkey) = if k > k' then (child,other,k) else (other,child,k') end
    keys[0] := lkey
    children[0] := smaller
    children[1] := larger
    InternalNode[\Key,Val\](keys,children,height)
  end

  (* perform the add operation when the height is greater than one *)
  heightn_add(k:Key, v:Val, level:ZZ32):Node[\Key,Val\] = do
    child':Node[\Key,Val\] = child.add(k,v,level)
    if level < height then
      WhiteNode[\Key,Val\](child', height)
    else
      split(0, child')
    end
  end


end

(* An internal node stores N keys and N + 1 children where N > 0.
   An internal nodes has a height > 0. *)
object InternalNode[\Key,Val\](keys:Array[\Key,ZZ32\],
  children:Array[\Node[\Key,Val\],ZZ32\], height:ZZ32) extends Node[\Key,Val\]

  getHeight():ZZ32 = height

  isLeaf():Boolean = false
  isTreeEmpty():Boolean = false
  isNodeEmpty():Boolean = false

  search(k:Key):Maybe[\Val\] = do
    index:ZZ32 := 0
    while (index < keys.size() AND: k > keys[index]) do
      index += 1
    end
    children[index].search(k)
  end

  toString():String = "{" keys.toString() ", " children.toString() "}"

  add(k:Key, v:Val, level:ZZ32):Node[\Key,Val\] = do
    index:ZZ32 := 0
    (* FIXME: replace with AND: *)
    flag:Boolean := false
    if index < keys.size() then flag := k > keys[index] end
    while (flag) do
      index += 1
      flag := false
      if index < keys.size() then flag := k > keys[index] end
    end
    if height = 1 then
      height1_add(k,v,index)
    else
      heightn_add(k,v,index,level)
    end
  end

  (* splits the new child in half and sucks the split key up to this level *)
  split(index:ZZ32, heir:Node[\Key,Val\]):InternalNode[\Key,Val\] = do
    keysplit:ZZ32 = keys.size() - index
    keys':Array[\Key,ZZ32\] = array[\Key\](keys.size() + 1)
    children':Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](children.size() + 1)
    (left,right,key') = heir.break()
    keys'[0 # index] := keys[0 # index]
    children'[0 # index] := children[0 # index]
    keys'[index] := key'
    children'[index] := left
    children'[index + 1] := right
    keys'[(index + 1) # keysplit] := keys[index # keysplit]
    children'[(index + 2) # keysplit] := children[(index + 1) # keysplit]
    InternalNode[\Key,Val\](keys',children',height)
  end

  break():(Node[\Key,Val\],Node[\Key,Val\],Key) =
  if keys.size() = 1 then
    onekey_break()
  elif keys.size() = 2 then
    twokeys_break()
  else
    nkeys_break()
  end

  (* perform the add operation when the height is one *)
  height1_add(k:Key, v:Val, index:ZZ32):Node[\Key,Val\] = do
    keys':Array[\Key,ZZ32\] = array[\Key\](keys.size() + 1)
    children':Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](children.size() + 1)
    keysplit:ZZ32 = keys.size() - index
    keys'[0 # index] := keys[0 # index]
    children'[0 : index] := children[0 : index]
    children'[index + 1] := LeafNode[\Key,Val\]((k,v))
    keys'[index] := k
    keys'[(index + 1) # keysplit] := keys[index # keysplit]
    children'[(index + 2) # keysplit] := children[(index + 1) # keysplit]
    InternalNode[\Key,Val\](keys',children',height)
  end

  (* perform the add operation when the height is greater than one *)
  heightn_add(k:Key, v:Val, index:ZZ32, level:ZZ32):Node[\Key,Val\] = do
    child':Node[\Key,Val\] = children[index].add(k,v,level)
    if level < height then
      children':Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](children.size())
      children'[0 # (children.size())] := children[0 # (children.size())]
      children'[index] := child'
      InternalNode[\Key,Val\](keys,children',height)
    else
      split(index, child')
    end
  end

  (* perform the break operation when we have exactly one key *)
  onekey_break():(Node[\Key,Val\],Node[\Key,Val\],Key) = do
    smaller:Node[\Key,Val\] = children[0]
    larger:Node[\Key,Val\] = children[1]
    key':Key = keys[0]
    left:Node[\Key,Val\] = generate_tail[\Key,Val\](smaller, 1)
    right:Node[\Key,Val\] = generate_tail[\Key,Val\](larger, 1)
    (left, right, key')
  end

  (* perform the break operation when we have exactly two keys *)
  twokeys_break():(Node[\Key,Val\],Node[\Key,Val\],Key) = do
    smaller:Node[\Key,Val\] = children[0]
    rkeys:Array[\Key,ZZ32\] = array[\Key\](1)
    rchildren:Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](2)
    key':Key = keys[0]
    rkeys[0] := keys[1]
    rchildren[0#2] := children[1#2]
    left:Node[\Key,Val\] = generate_tail[\Key,Val\](smaller, 1)
    right:Node[\Key,Val\] = InternalNode[\Key,Val\](rkeys,rchildren,height)
    (left, right, key')
  end

  (* perform the break operation when we have three or more key *)
  nkeys_break():(Node[\Key,Val\],Node[\Key,Val\],Key) = do
    half:ZZ32 = keys.size() DIV 2
    rsize:ZZ32 = keys.size() - half - 1
    lsize:ZZ32 = keys.size() - rsize - 1
    key':Key = keys[half]
    lkeys:Array[\Key,ZZ32\] = array[\Key\](lsize)
    lchildren:Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](lsize + 1)
    rkeys:Array[\Key,ZZ32\] = array[\Key\](rsize)
    rchildren:Array[\Node[\Key,Val\],ZZ32\] = array[\Node[\Key,Val\]\](rsize + 1)
    lkeys[0 # lsize] := keys[0 # lsize]
    lchildren[0 # (lsize + 1)] := children[0 # (lsize + 1)]
    rkeys[0 # rsize] := keys[(half + 1) # rsize]
    rchildren[0 # (rsize + 1)] := children[(half + 1) # (rsize + 1)]
    left:Node[\Key,Val\] = InternalNode[\Key,Val\](lkeys,lchildren,height)
    right:Node[\Key,Val\] = InternalNode[\Key,Val\](rkeys,rchildren,height)
    (left, right, key')
  end

end

(* The empty node represents an empty tree. It is neither a leaf node nor
   an internal node, and the empty node does not have a height. *)
object EmptyNode[\Key,Val\]() extends Node[\Key,Val\]

  getHeight():ZZ32 = fail("Empty node does not have a height")

  isLeaf():Boolean = fail("Empty node is neither a leaf nor an internal node")
  isTreeEmpty():Boolean = true
  isNodeEmpty():Boolean = fail("Empty node cannot check for emptiness on keys")

  search(k:Key):Maybe[\Val\] = Nothing[\Val\]()

  toString():String = "{}"

  add(k:Key, v:Val, level:ZZ32):Node[\Key,Val\] = do
    leaf:LeafNode[\Key,Val\] = LeafNode[\Key,Val\]((k, v))
    parent:WhiteNode[\Key,Val\] = WhiteNode[\Key,Val\](leaf,1)
    parent
  end

  split(index:ZZ32, heir:Node[\Key,Val\]):InternalNode[\Key,Val\] = fail("Cannot split an empty node.")
  break():(Node[\Key,Val\],Node[\Key,Val\],Key) = fail("Cannot break an empty node.")


end

(* Leaf nodes are the only nodes that store values.  All leaf
   nodes live at the bottom of the tree, and they all have height 0. *)
object LeafNode[\Key,Val\](pair: (Key, Val)) extends Node[\Key,Val\]

  (key, val) = pair
  getPair():(Key, Val) = pair
  getKey():Key = key
  getVal():Val = val
  getHeight():ZZ32 = 0

  isLeaf():Boolean = true
  isTreeEmpty():Boolean = false
  isNodeEmpty():Boolean = false

  search(k:Key):Maybe[\Val\] = if k = key then Just[\Val\](val) else Nothing[\Val\]() end

  add(k:Key, v:Val, level:ZZ32):Node[\Key,Val\] = fail("Cannot add a new node into a leaf node.")

  split(index:ZZ32, heir:Node[\Key,Val\]):InternalNode[\Key,Val\] = fail("Cannot split a leaf node.")
  break():(Node[\Key,Val\],Node[\Key,Val\],Key) = fail("Cannot break a leaf node.")

  toString():String = "<<" key ">>"

end


object EmptyList[\Key,Val,nat pInverse\](root:EmptyNode[\Key,Val\]) extends SkipList[\Key,Val,pInverse\]

  toString():String = root.toString()

  search(k:Key):Maybe[\Val\] = root.search(k)

  add(k:Key, v:Val):SkipList[\Key,Val,pInverse\] = do
    FullList[\Key,Val,pInverse\](root.add(k,v,1))
  end

end

(* A SkipList type consists of a root node and pInverse = 1/p, where the fraction
   p is used in the negative binomial distribution to select random levels for insertion.
*)
object FullList[\Key,Val,nat pInverse\](root:Node[\Key,Val\]) extends SkipList[\Key,Val,pInverse\]

  p:RR64 = 1.0 / pInverse

  toString():String = root.toString()

  search(k:Key):Maybe[\Val\] = root.search(k)

  add(k:Key, v:Val):SkipList[\Key,Val,pInverse\] = do
    level:ZZ32 = randomLevel()
    tail:Node[\Key,Val\] = generate_tail[\Key,Val\](root, level - root.getHeight())
    FullList[\Key,Val,pInverse\](tail.add(k,v,level))
  end

  randomLevel():ZZ32 = do
    level':ZZ32 := 1
    while random(1.0) < p do
      level' += 1
    end
    level'
  end

end

NewList[\Key,Val,nat pInverse\]():SkipList[\Key,Val,pInverse\] =
  EmptyList[\Key,Val,pInverse\](EmptyNode[\Key,Val\]())

end
