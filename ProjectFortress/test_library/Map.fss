(*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component Map
export Map

weight:ZZ32 = 4

trait Map[\Key,Val\] extends ZeroIndexed[\(Key,Val)\]
    comprises {NodeMap[\Key,Val\], EmptyMap[\Key,Val\]}
  getter indexValuePairs(): ZeroIndexed[\(ZZ32,(Key,Val))\] =
      IndexValueMapGenerator[\Key,Val\](self)
  ivgen[\R\](i0: ZZ32, r: Reduction[\R\], body: (ZZ32,(Key,Val))->R): R
  seqgen[\R\](r: Reduction[\R\], body: (Key,Val)->R): R
  seq(self): SequentialGenerator[\(Key,Val)\] = SeqMapGenerator[\Key,Val\](self)
  getPair():(Key, Val)
  getKey():Key
  getVal():Val
  getLeftChild():Map[\Key,Val\]
  getRightChild():Map[\Key,Val\]
  printTree():()
  toString():String
  member(x:Key): Maybe[\Val\]
  minimum():(Key,Val)
  deleteMinimum():Map[\Key,Val\] = do
    (_, res) = self.removeMinimum()
    res
  end
  removeMinimum():((Key,Val), Map[\Key,Val\])
  add(k:Key, v:Val):Map[\Key,Val\]
  update(k:Key, v:Val):Map[\Key,Val\]
  delete(k:Key):Map[\Key,Val\]
  updateWith(f:Maybe[\Val\]->Maybe[\Val\], k:Key): Map[\Key,Val\]
  union(other: Map[\Key,Val\]): Map[\Key,Val\]
  union(f:(Key,Val,Val)->Val, other: Map[\Key,Val\]): Map[\Key,Val\]
  splitAt(k:Key):(Map[\Key,Val\],Maybe[\Val\],Map[\Key,Val\])
  belowEq(i:ZZ32): Map[\Key,Val\]
  aboveEq(i:ZZ32): Map[\Key,Val\]

  balancedDelete(r:Map[\Key,Val\]):Map[\Key,Val\]
  balancedAdd(x:(Key,Val), left:Map[\Key,Val\], right:Map[\Key,Val\]):NodeMap[\Key,Val\]
  concat3(k:Key, v:Val, t2:Map[\Key,Val\]): Map[\Key,Val\]
end

singleton[\Key,Val\](m:Mapping[\Key,Val\]): Map[\Key,Val\] = do
    kv = (m.key(),m.val())
    e = EmptyMap[\Key,Val\]()
    NodeMap[\Key,Val\](kv,e,e)
  end

mapping[\Key,Val\](g: Generator[\Mapping[\Key,Val\]\]): Map[\Key,Val\] =
    g.generate[\Map[\Key,Val\]\](MapUnion[\Key,Val\](), singleton[\Key,Val\])


value object IndexValueMapGenerator[\Key,Value\](s: Map[\Key,Value\])
      extends ZeroIndexed[\(ZZ32,(Key,Value))\]
   getter size(): ZZ32 = s.size()
   getter indices(): ZZ32 = s.indices()
   getter isEmpty(): Boolean = s.isEmpty()
   generate[\R\](r: Reduction[\R\], body: (ZZ32,(Key,Value))->R): R =
      s.ivgen[\R\](0,r,body)
   opr[ x: ZZ32 ]: (ZZ32,(Key,Value)) = (x,s[x])
   opr[ r: Range[\ZZ32\] ]: ZeroIndexed[\(ZZ32,(Key,Value))\] =
       s[r].indexValuePairs()
   indexOf(i:ZZ32,v:(Key,Value)): Boolean = if s[i]=v then i else -1 end
end

object SeqMapGenerator[\Key,Val\](o:Map[\Key,Val\])
    extends SequentialGenerator[\(Key,Val)\]
  generate[\R\](r: Reduction[\R\], body: (Key,Val)->R): R = o.seqgen[\R\](r,body)
end

object MapUnion[\Key,Val\]() extends Reduction[\Map[\Key,Val\]\]
    e = EmptyMap[\Key,Val\]()
    empty():Map[\Key,Val\] = e
    join(a:Map[\Key,Val\], b:Map[\Key,Val\]): Map[\Key,Val\] =
        a.union(b)
end

object EmptyMap[\Key,Val\]() extends Map[\Key,Val\]
  getter size():ZZ32 = 0
  getter isEmpty():Boolean = true
  generate[\R\](r: Reduction[\R\], body: (Key,Val)->R): R = r.empty()
  ivgen[\R\](i0: ZZ32, r: Reduction[\R\], body: (ZZ32,(Key,Val))->R): R =
      r.empty()
  seqgen[\R\](r: Reduction[\R\], body: (Key,Val)->R): R = r.empty()
  getPair():(Key, Val) = getPair()
  getKey():Key = getKey()
  getVal():Val = getVal()
  getLeftChild():Map[\Key,Val\] = self
  getRightChild():Map[\Key,Val\] = self
  printTree():() = print "EmptyMap"
  toString():String = "{}"
  member(x:Key): Maybe[\Val\] = Nothing[\Val\]()
  opr[i:ZZ32]: (Key,Val) = do
      fail("Map: index " i " out of range")
    end
  opr[ r: Range[\ZZ32\] ]: Map[\Key,Val\] = do
      r' = (bounds())[r]
      self
    end
  minimum(): (Key,Val) = fail("Empty map: no minimum key.")
  removeMinimum():((Key,Val), Map[\Key,Val\]) =
    fail("Empty map: cannot remove minimum")
  maximum(): (Key,Val) = fail("Empty map: no maximum key.")
  removeMaximum():((Key,Val), Map[\Key,Val\]) =
    fail("Empty map: cannot remove maximum")
  add(k:Key, v:Val):Map[\Key,Val\] = NodeMap[\Key,Val\]((k,v), self, self)
  update(k:Key, v:Val):Map[\Key,Val\] = add(k, v)
  delete(k:Key):Map[\Key,Val\] = self
  updateWith(f:Maybe[\Val\]->Maybe[\Val\], k:Key): Map[\Key,Val\] =
      f(Nothing[\Val\]()).maybe[\Map[\Key,Val\]\](
        fn (): EmptyMap[\Key,Val\] => self,
        fn (v:Val): Map[\Key,Val\] => add(k,v))
  union(other: Map[\Key,Val\]): Map[\Key,Val\] = other
  union(f:(Key,Val,Val)->Val, other: Map[\Key,Val\]): Map[\Key,Val\] =
      other
  splitAt(k:Key):(Map[\Key,Val\],Maybe[\Val\],Map[\Key,Val\]) =
      (self,Nothing[\Val\](),self)
  belowEq(i:ZZ32): Map[\Key,Val\] = self
  aboveEq(i:ZZ32): Map[\Key,Val\] = self

  balancedDelete(r:Map[\Key,Val\]):Map[\Key,Val\] = r
  balancedAdd(x:(Key,Val), left:Map[\Key,Val\], right:Map[\Key,Val\]):
      NodeMap[\Key,Val\] = NodeMap[\Key,Val\](x,self,self)
  concat3(k:Key, v:Val, t2:Map[\Key,Val\]): Map[\Key,Val\] = t2.add(k,v)
end

object NodeMap[\Key,Val\](pair:(Key,Val), left:Map[\Key,Val\],
                          right:Map[\Key,Val\]) extends Map[\Key,Val\]
  sz:ZZ32 = 1 + left.size() + right.size()
  (key, val) = pair
  getter size():ZZ32 = sz
  getter isEmpty():Boolean = false

  generate[\R\](r: Reduction[\R\], body: (Key,Val)->R): R =
    r.join(r.join(left.generate[\R\](r,body),body(key,val)),
           right.generate[\R\](r,body))
  ivgen[\R\](i0: ZZ32, r: Reduction[\R\], body: (ZZ32,(Key,Val))->R): R = do
      mi = i0 + left.size()
      r.join(r.join(left.ivgen[\R\](i0,r,body),body(mi,(key,val))),
             right.ivgen[\R\](mi+1,r,body))
    end
  seqgen[\R\](r: Reduction[\R\], body: (Key,Val)->R): R = do
      ll = left.generate[\R\](r,body)
      mm = body(key,val)
      lm = r.join(ll,mm)
      rr = right.generate[\R\](r,body)
      r.join(lm,rr)
    end

  getPair():(Key, Val) = pair
  getKey():Key = key
  getVal():Val = val
  getLeftChild():Map[\Key,Val\] = left
  getRightChild():Map[\Key,Val\] = right

  printTree():() = do
    print("((")
    print(key)
    print(",")
    print(val)
    print(") ")
    left.printTree()
    right.printTree()
    println(")")
  end

  toString():String = do
    (two, delmin) = removeMinimum()
    (km, vm) = two
    ("{" km "|->" vm
         (BIG STRING[(k,v)<-delmin] ", " k "|->" v) "}")
  end

  opr[i:ZZ32]: (Key,Val) = do
      mi = l.size()
      typecase _ = i CMP mi of
          LessThan => l[i]
          EqualTo => (key,val)
          GreaterThan => r[i-mi-1]
      end
    end

  opr[r:Range[\ZZ32\]]: Map[\Key,Val\] = do
    r' = (bounds())[r]
    lo = r'.lower()
    szr = r'.extent()
    mi = l.size()
    typecase _ = lo CMP mi of
        LessThan =>
            hi = lo+szr-1
            typecase _ = hi CMP mi of
                LessThan => l[r']
                EqualTo => l.aboveEq(lo).add(key,val)
                GreaterThan => l.aboveEq(lo).concat3(key,val,right.belowEq(hi-1))
            end
        EqualTo => right.belowEq(szr-1)
        GreaterThan => r[(lo-mi)#szr]
    end
  end

  member(x:Key): Maybe[\Val\] =
    if   x = key then Just[\Val\](val)
    elif x < key then left.member(x)
    else right.member(x)
    end

  minimum() =
    if left.isEmpty() then (key,val)
    else left.minimum()
    end
  removeMinimum() =
    if left.isEmpty() then (pair,right)
    else
      (min, delmin) = left.removeMinimum()
      (min, balancedAdd(pair,delmin,right))
    end
  maximum() =
    if right.isEmpty() then (key,val)
    else right.maximum()
    end
  removeMaximum() =
    if right.isEmpty() then (pair,left)
    else
      (min, delmin) = right.removeMaximum()
      (min, balancedAdd(pair,delmin,left))
    end

  add(k:Key, v:Val):Map[\Key,Val\] =
    if   k = key then self
    elif k < key then balancedAdd(pair,left.add(k,v),right)
    else balancedAdd(pair,left,right.add(k,v))
    end

  update(k:Key, v:Val):Map[\Key,Val\] =
    if   k = key then NodeMap[\Key,Val\]((k,v), left, right)
    elif k < key then NodeMap[\Key,Val\](pair, left.update(k,v), right)
    else NodeMap[\Key,Val\](pair, left, right.update(k,v))
    end

  delete(k:Key):Map[\Key,Val\] =
    if   k < key then balancedAdd(pair,left.delete(k),right)
    elif key < k then balancedAdd(pair,left,right.delete(k))
    else              left.balancedDelete(right)
    end

  updateWith(f:Maybe[\Val\]->Maybe[\Val\], k:Key): Map[\Key,Val\] =
    if   k < key then balancedAdd(pair, left.updateWith(f,k), right)
    elif key < k then balancedAdd(pair, left, right.updateWith(f,k))
    else f(val).maybe[\Map[\Key,Val\]\](
                fn (): Map[\Key,Val\] => left.balancedDelete(right),
                fn (v': Val): Map[\Key,Val\] =>
                    NodeMap[\Key,Val\]((k,v'), left, right))
    end

  union(other: Map[\Key,Val\]): Map[\Key,Val\] = do
      (new, _, newr) = t2.splitAt(val)
      left.union(f,newl).concat3(key,val,right.union(newr))
    end
  union(f:(Key,Val,Val)->Val, other: Map[\Key,Val\]): Map[\Key,Val\] = do
      (new, mv, newr) = t2.splitAt(val)
      val' = mv.maybe[\Val\](fn ():Val => val, fn (v:Val):Val => f(key,val,v))
      left.union(f,newl).concat3(key,val',right.union(newr))
    end
  splitAt(k:Key):(Map[\Key,Val\],Maybe[\Val\],Map[\Key,Val\]) =
    if   k < key then
         (ll, v, rl) = left.splitAt(k)
         (ll, v, rl.concat3(key,val,right))
    elif k > key then
         (lr, v, rr) = right.splitAt(k)
         (left.concat3(key,val,lr), v, rr)
    else (left, Just[\Val\](val), right)
    end
  belowEq(i:ZZ32): Map[\Key,Val\] = do
      mi = left.size()
      typecase _ = i CMP mi of
          LessThan => left.belowEq(i)
          EqualTo => left.add(key,val)
          GreaterThan => left.concat3(key,val,right.belowEq(i-mi-1))
      end
    end
  aboveEq(i:ZZ32): Map[\Key,Val\] = do
      mi = left.size()
      typecase _ = i CMP mi of
          LessThan    => left.aboveEq(i).concat3(key,val,r)
          EqualTo     => right.add(key,val)
          GreaterThan => right.aboveEq(i-mi-1)
      end
    end

  concat3(k:Key, v:Val, t2:Map[\Key,Val\]): Map[\Key,Val\] = add(k,v)
  concat3(k:Key, v:Val, t2:NodeMap[\Key,Val\]): Map[\Key,Val\] = do
      sz2 = t2.size()
      if   weight sz < sz2 then
           balancedAdd((t2.key,t2.val),concat3(k,v,t2.left),t2.right)
      elif weight sz2 < sz then
           balancedAdd((key,val),left,right.concat3(k,v,t2))
      else NodeMap[\Key,Val\](k,v,self,t2)
      end
    end

  balancedDelete(r:NodeMap[\Key,Val\]):Map[\Key,Val\] = do
    (min_elt, del_min) = right.removeMinimum()
    balancedAdd(min_elt, self, del_min)
  end
  balancedDelete(r:Map[\Key,Val\]):Map[\Key,Val\] = self

  balancedAdd(x:(Key,Val), left:Map[\Key,Val\], right:Map[\Key,Val\]):NodeMap[\Key,Val\] = do
    ln = left.size()
    rn = right.size()
    if ln + rn < weight then NodeMap[\Key,Val\](x, left, right)
    elif rn > weight ln then
      r = right.getRightChild()
      rl = r.getLeftChild()
      rr = r.getRightChild()
      rln = rl.size()
      rrn = rr.size()
      if rln < rrn
      then single_L(x, left, right)
      else double_L(x, left, right)
      end
    elif ln > weight rn then
      l = left.getLeftChild()
      ll = l.getLeftChild()
      lr = l.getRightChild()
      lln = ll.size()
      lrn = lr.size()
      if lrn < lln
      then single_R(x, left, right)
      else double_R(x, left, right)
      end
    else NodeMap[\Key,Val\](x, left, right) end
  end

  single_L(x:(Key,Val), left:Map[\Key,Val\], right:Map[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](right.getPair(),
                       NodeMap[\Key,Val\](x, left, right.getLeftChild()),
                       right.getRightChild())

  single_R(x:(Key,Val), left:Map[\Key,Val\], right:Map[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](left.getPair(),
                       left.getLeftChild(),
                       NodeMap[\Key,Val\](x,left.getRightChild(),right))

  double_L(x:(Key,Val), left:Map[\Key,Val\], right:Map[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](right.getLeftChild().getPair(),
                       NodeMap[\Key,Val\](x, left,
                                          right.getLeftChild().getLeftChild()),
                       NodeMap[\Key,Val\](right.getPair(),
                                          right.getLeftChild().getRightChild(),
                                          right.getRightChild()))

  double_R(x:(Key,Val), left:Map[\Key,Val\], right:Map[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](left.getRightChild().getPair(),
                       NodeMap[\Key,Val\](left.getPair(),
                                          left.getLeftChild(),
                                          left.getRightChild().getLeftChild()),
                       NodeMap[\Key,Val\](x,left.getRightChild().getRightChild(),
                                          right))
end

end
