(*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component Map
export Map

weight:ZZ32 = 4

trait TreeMap[\Key,Val\] extends Generator[\(Key,Val)\]
    comprises {NodeMap[\Key,Val\], EmptyMap[\Key,Val\]}
  seqgen[\R\](r: Reduction[\R\], body: (Key,Val)->R): R
  seq(self): SequentialGenerator[\(Key,Val)\] = SeqMapGenerator[\Key,Val\](self)
  getPair():(Key, Val)
  getKey():Key
  getVal():Val
  getLeftChild():TreeMap[\Key,Val\]
  getRightChild():TreeMap[\Key,Val\]
  printTree():()
  toString():String
  member(x:Key): Maybe[\Val\]
  minimum():(Key,Val)
  deleteMinimum():TreeMap[\Key,Val\] = do
    (_, res) = self.removeMinimum()
    res
  end
  removeMinimum():((Key,Val), TreeMap[\Key,Val\])
  add(k:Key, v:Val):TreeMap[\Key,Val\]
  update(k:Key, v:Val):TreeMap[\Key,Val\]
  delete(k:Key):TreeMap[\Key,Val\]
  updateWith(f:Maybe[\Val\]->Maybe[\Val\], k:Key): TreeMap[\Key,Val\]
  union(other: TreeMap[\Key,Val\]): TreeMap[\Key,Val\]
  union(f:(Key,Val,Val)->Val, other: TreeMap[\Key,Val\]): TreeMap[\Key,Val\]
  splitAt(k:Key):(TreeMap[\Key,Val\],Maybe[\Val\],TreeMap[\Key,Val\])

  balancedDelete(r:TreeMap[\Key,Val\]):TreeMap[\Key,Val\]
  balancedAdd(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\]
  concat3(k:Key, v:Val, t2:TreeMap[\Key,Val\]): TreeMap[\Key,Val\]
end

singleton[\Key,Val\](k:Key, v:Val): TreeMap[\Key,Val\] = do
    kv = (k,v)
    e = EmptyMap[\Key,Val\]()
    NodeMap[\Key,Val\](kv,e,e)
  end

mapping[\Key,Val\](g: Generator[\(Key,Val)\]): TreeMap[\Key,Val\] =
    g.generate[\TreeMap[\Key,Val\]\](MapUnion[\Key,Val\](), singleton[\Key,Val\])

opr [\Key,Val\]{ pairs:(Key,Val)... }: TreeMap[\Key,Val\] =
    mapping[\Key,Val\](pairs)

object SeqMapGenerator[\Key,Val\](o:TreeMap[\Key,Val\])
    extends SequentialGenerator[\(Key,Val)\]
  generate[\R\](r: Reduction[\R\], body: (Key,Val)->R): R = o.seqgen[\R\](r,body)
end

object MapUnion[\Key,Val\]() extends Reduction[\TreeMap[\Key,Val\]\]
    e = EmptyMap[\Key,Val\]()
    empty():TreeMap[\Key,Val\] = e
    join(a:TreeMap[\Key,Val\], b:TreeMap[\Key,Val\]): TreeMap[\Key,Val\] =
        a.union(b)
end

object EmptyMap[\Key,Val\]() extends TreeMap[\Key,Val\]
  getter size():ZZ32 = 0
  getter isEmpty():Boolean = true
  generate[\R\](r: Reduction[\R\], body: (Key,Val)->R): R = r.empty()
  seqgen[\R\](r: Reduction[\R\], body: (Key,Val)->R): R = r.empty()
  getPair():(Key, Val) = getPair()
  getKey():Key = getKey()
  getVal():Val = getVal()
  getLeftChild():TreeMap[\Key,Val\] = self
  getRightChild():TreeMap[\Key,Val\] = self
  printTree():() = print "EmptyMap"
  toString():String = "{}"
  member(x:Key): Maybe[\Val\] = Nothing[\Val\]()
  minimum(): (Key,Val) = fail("Empty map: no minimum key.")
  removeMinimum():((Key,Val), TreeMap[\Key,Val\]) =
    fail("Empty map: cannot remove minimum")
  maximum(): (Key,Val) = fail("Empty map: no maximum key.")
  removeMaximum():((Key,Val), TreeMap[\Key,Val\]) =
    fail("Empty map: cannot remove maximum")
  add(k:Key, v:Val):TreeMap[\Key,Val\] = NodeMap[\Key,Val\]((k,v), self, self)
  update(k:Key, v:Val):TreeMap[\Key,Val\] = add(k, v)
  delete(k:Key):TreeMap[\Key,Val\] = self
  updateWith(f:Maybe[\Val\]->Maybe[\Val\], k:Key): TreeMap[\Key,Val\] =
      f(Nothing[\Val\]()).maybe[\TreeMap[\Key,Val\]\](
        fn (): EmptyMap[\Key,Val\] => self,
        fn (v:Val): TreeMap[\Key,Val\] => add(k,v))
  union(other: TreeMap[\Key,Val\]): TreeMap[\Key,Val\] = other
  union(f:(Key,Val,Val)->Val, other: TreeMap[\Key,Val\]): TreeMap[\Key,Val\] =
      other
  splitAt(k:Key):(TreeMap[\Key,Val\],Maybe[\Val\],TreeMap[\Key,Val\]) =
      (self,Nothing[\Val\](),self)

  balancedDelete(r:TreeMap[\Key,Val\]):TreeMap[\Key,Val\] = r
  balancedAdd(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):
      NodeMap[\Key,Val\] = NodeMap[\Key,Val\](x,self,self)
  concat3(k:Key, v:Val, t2:TreeMap[\Key,Val\]): TreeMap[\Key,Val\] = t2.add(k,v)
end

object NodeMap[\Key,Val\](pair:(Key,Val), left:TreeMap[\Key,Val\],
                          right:TreeMap[\Key,Val\]) extends TreeMap[\Key,Val\]
  sz:ZZ32 = 1 + left.size() + right.size()
  (key, val) = pair
  getter size():ZZ32 = sz
  getter isEmpty():Boolean = false

  generate[\R\](r: Reduction[\R\], body: (Key,Val)->R): R =
    r.join(r.join(left.generate[\R\](r,body),body(key,val)),
           right.generate[\R\](r,body))
  seqgen[\R\](r: Reduction[\R\], body: (Key,Val)->R): R = do
      ll = left.generate[\R\](r,body)
      mm = body(key,val)
      lm = r.join(ll,mm)
      rr = right.generate[\R\](r,body)
      r.join(lm,rr)
    end

  getPair():(Key, Val) = pair
  getKey():Key = key
  getVal():Val = val
  getLeftChild():TreeMap[\Key,Val\] = left
  getRightChild():TreeMap[\Key,Val\] = right

  printTree():() = do
    print("((")
    print(key)
    print(",")
    print(val)
    print(") ")
    left.printTree()
    right.printTree()
    println(")")
  end

  toString():String = do
    (two, delmin) = removeMinimum()
    (km, vm) = two
    ("{" km "|->" vm
         (BIG STRING[(k,v)<-delmin] ", " k "|->" v) "}")
  end

  member(x:Key): Maybe[\Val\] =
    if   x = key then Just[\Val\](val)
    elif x < key then left.member(x)
    else right.member(x)
    end

  minimum() =
    if left.isEmpty() then (key,val)
    else left.minimum()
    end
  removeMinimum() =
    if left.isEmpty() then (pair,right)
    else
      (min, delmin) = left.removeMinimum()
      (min, balancedAdd(pair,delmin,right))
    end
  maximum() =
    if right.isEmpty() then (key,val)
    else right.maximum()
    end
  removeMaximum() =
    if right.isEmpty() then (pair,left)
    else
      (min, delmin) = right.removeMaximum()
      (min, balancedAdd(pair,delmin,left))
    end

  add(k:Key, v:Val):TreeMap[\Key,Val\] =
    if   k = key then self
    elif k < key then balancedAdd(pair,left.add(k,v),right)
    else balancedAdd(pair,left,right.add(k,v))
    end

  update(k:Key, v:Val):TreeMap[\Key,Val\] =
    if   k = key then NodeMap[\Key,Val\]((k,v), left, right)
    elif k < key then NodeMap[\Key,Val\](pair, left.update(k,v), right)
    else NodeMap[\Key,Val\](pair, left, right.update(k,v))
    end

  delete(k:Key):TreeMap[\Key,Val\] =
    if   k < key then balancedAdd(pair,left.delete(k),right)
    elif key < k then balancedAdd(pair,left,right.delete(k))
    else              left.balancedDelete(right)
    end

  updateWith(f:Maybe[\Val\]->Maybe[\Val\], k:Key): TreeMap[\Key,Val\] =
    if   k < key then balancedAdd(pair, left.updateWith(f,k), right)
    elif key < k then balancedAdd(pair, left, right.updateWith(f,k))
    else f(val).maybe[\TreeMap[\Key,Val\]\](
                fn (): TreeMap[\Key,Val\] => left.balancedDelete(right),
                fn (v': Val): TreeMap[\Key,Val\] =>
                    NodeMap[\Key,Val\]((k,v'), left, right))
    end

  union(other: TreeMap[\Key,Val\]): TreeMap[\Key,Val\] = do
      (new, _, newr) = t2.splitAt(val)
      left.union(f,newl).concat3(key,val,right.union(newr))
    end
  union(f:(Key,Val,Val)->Val, other: TreeMap[\Key,Val\]): TreeMap[\Key,Val\] = do
      (new, mv, newr) = t2.splitAt(val)
      val' = mv.maybe[\Val\](fn ():Val => val, fn (v:Val):Val => f(key,val,v))
      left.union(f,newl).concat3(key,val',right.union(newr))
    end
  splitAt(k:Key):(TreeMap[\Key,Val\],Maybe[\Val\],TreeMap[\Key,Val\]) =
    if   k < key then
         (ll, v, rl) = left.splitAt(k)
         (ll, v, rl.concat3(key,val,right))
    elif k > key then
         (lr, v, rr) = right.splitAt(k)
         (left.concat3(key,val,lr), v, rr)
    else (left, Just[\Val\](val), right)
    end

  concat3(k:Key, v:Val, t2:TreeMap[\Key,Val\]): TreeMap[\Key,Val\] = add(k,v)
  concat3(k:Key, v:Val, t2:NodeMap[\Key,Val\]): TreeMap[\Key,Val\] = do
      sz2 = t2.size()
      if   weight sz < sz2 then
           balancedAdd((t2.key,t2.val),concat3(k,v,t2.left),t2.right)
      elif weight sz2 < sz then
           balancedAdd((key,val),left,right.concat3(k,v,t2))
      else NodeMap[\Key,Val\](k,v,self,t2)
      end
    end

  balancedDelete(r:NodeMap[\Key,Val\]):TreeMap[\Key,Val\] = do
    (min_elt, del_min) = r.removeMinimum()
    balancedAdd(min_elt, self, del_min)
  end
  balancedDelete(r:TreeMap[\Key,Val\]):TreeMap[\Key,Val\] = self

  balancedAdd(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\] = do
    ln = left.size()
    rn = right.size()
    if ln + rn < weight then NodeMap[\Key,Val\](x, left, right)
    elif rn > weight ln then
      r = right.getRightChild()
      rl = r.getLeftChild()
      rr = r.getRightChild()
      rln = rl.size()
      rrn = rr.size()
      if rln < rrn
      then single_L(x, left, right)
      else double_L(x, left, right)
      end
    elif ln > weight rn then
      l = left.getLeftChild()
      ll = l.getLeftChild()
      lr = l.getRightChild()
      lln = ll.size()
      lrn = lr.size()
      if lrn < lln
      then single_R(x, left, right)
      else double_R(x, left, right)
      end
    else NodeMap[\Key,Val\](x, left, right) end
  end

  single_L(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](right.getPair(),
                       NodeMap[\Key,Val\](x, left, right.getLeftChild()),
                       right.getRightChild())

  single_R(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](left.getPair(),
                       left.getLeftChild(),
                       NodeMap[\Key,Val\](x,left.getRightChild(),right))

  double_L(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](right.getLeftChild().getPair(),
                       NodeMap[\Key,Val\](x, left,
                                          right.getLeftChild().getLeftChild()),
                       NodeMap[\Key,Val\](right.getPair(),
                                          right.getLeftChild().getRightChild(),
                                          right.getRightChild()))

  double_R(x:(Key,Val), left:TreeMap[\Key,Val\], right:TreeMap[\Key,Val\]):NodeMap[\Key,Val\] =
    NodeMap[\Key,Val\](left.getRightChild().getPair(),
                       NodeMap[\Key,Val\](left.getPair(),
                                          left.getLeftChild(),
                                          left.getRightChild().getLeftChild()),
                       NodeMap[\Key,Val\](x,left.getRightChild().getRightChild(),
                                          right))
end

end
