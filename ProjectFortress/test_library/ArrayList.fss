(*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component ArrayList
import * from OneShotFlag
export ArrayList

(** Array Lists, immutable style (not the mutable Java ArrayList style).

    An ArrayList is an immutable segment of a mutable array.  The rest
    of the mutable array may contain elements of purelists in which
    this list is contained, or may be free for future use.  Every
    PureList includes a pointer to a flag canExtend; if this flag is
    true we are permitted to add additional elements to the PureList
    in place by writing into the mutable array.  At most one instance
    sharing the same backing array will obtain permission to extend
    the array in this way; we atomically check and update the flag to
    guarantee this.  Having obtained permission to extend the list,
    that permission may be extended to future attempts to extend.

    Eventually the backing array fills and we must allocate a new
    backing array to accept new elements.  At the moment we're not
    particularly careful to avoid stealing permission to extend for
    overflowing append operations.

    Note that because of this implementation, an ArrayList can be
    efficiently extended on the right (addRight) and appended to
    (append), but cannot be efficiently extended on the left
    (addLeft).

    Note also that the implementation hasn't yet been carefully
    checked for amortization, so it is quite likely there are a number
    of asymptotic infelicities in the implementation.

    Finally, note that this is an efficient *amortized* structure.  An
    individual operation may be quite slow due to copying work.

    Baking these off vs PureLists, they look very good in practice.
 **)

(* Tests can be found in
   tests/ArrayListQuick.fss
   demos/ArrayListLong.fss
*)

scale(x : ZZ32): ZZ32 = 2 x

expansion(curr: ZZ32, new: ZZ32) =
  if new > curr then
      (* Common case? *)
      (1 + scale curr) MAX new
  elif scale new <= curr then
      new
  else
      curr
  end

(** Generic list trait.
    We return a Generator for non-List-specific operations for which
    reuse of the Generator won't increase asymptotic complexity, but
    return a List in cases (such as map and filter) where it will.
*)
trait List[\E\] extends { ZeroIndexed[\E\] }
        excludes { Number, HasRank }
  getter left():Maybe[\E\] = extractLeft().map[\E\](fn (v:E,_):E => v)
  getter right():Maybe[\E\] = extractRight().map[\E\](fn (_,v:E):E => v)
  getter extractLeft(): Maybe[\(E,List[\E\])\]
  getter extractRight(): Maybe[\(List[\E\],E)\]
  append(f:List[\E\]): List[\E\]
  addLeft(e:E):List[\E\]
  addRight(e:E):List[\E\]
  take(n:ZZ32): List[\E\]
  drop(n:ZZ32): List[\E\]
  opr [n:ZZ32]: E
  opr [n:Range[\ZZ32\]]: List[\E\] =
      drop(n.lower()).take(n.extent())
  split(n:ZZ32): (List[\E\], List[\E\])
  split(): (List[\E\], List[\E\])
  reverse(): List[\E\] = generate[\List[\E\]\](RevConcat[\E\](),singleton[\E\])
  zip[\F\](other: List[\F\]): Generator[\(E,F)\] =
      ZipGenerator[\E,F\](self,other)
  filter(p: E -> Boolean): List[\E\] =
      concatMap[\E\](fn (x:ZZ32):List[\E\] => if p(x) then singleton[\E\](x)
                                              else emptyList[\E\]() end)
  opr =(self, other: List[\E\]): Boolean = do
      if self.size() = other.size() then
          self.zip[\E\](other).generate[\Boolean\](AndReduction,
                                                   fn(a,b) => a=b)
      else println("Sizes don't match"); false end
    end
  toString():String =
    "<|" extractLeft().maybe[\String\](
             fn () => " ",
             fn (h,t) => h t.generate[\String\](StringReduction,
                                                   fn (e:E) => ", " e)) "|>"
  concatMap[\G\](f: E->List[\G\]): List[\G\] =
      generate[\List[\G\]\](Concat[\G\](),f)
  map[\G\](f: E->G): List[\G\] =
      concatMap[\G\](fn (e:E):List[\G\] => singleton[\G\](f(e)))
  ivmap[\G\](f: (ZZ32,E)->G): List[\G\] =
      indexValuePairs().generate[\List[\G\]\](Concat[\G\](),
                fn (t:(ZZ32,E)):List[\G\] => singleton[\G\](f(t)))
end

(** Vararg factory for lists; provides aggregate list constants **)
opr [\E\]<| xs: E... |>: List[\E\] = list(xs)

(** Convert generator into list; can be used to desugar list
    comprehensions *)
list[\E\](g:Generator[\E\]):List[\E\] =
    g.generate[\List[\E\]\](Concat[\E\](), singleton[\E\])
list[\E\](g:Indexed[\E,ZZ32\]):List[\E\] = do
    sz = g.size()
    a = primitiveImmutableArray[\E\](sz)
    for (i,v) <- g[#].indexValuePairs() do
        a.init(i,v)
    end
    alr(a,0,sz,noShot)
  end
list[\E, nat n\](f: PrimImmutableArray[\E,n\]): Alr[\E,n\] =
    Alr[\E,n\]( f, 0, n, noShot )

(** Flatten a list of lists *)
concat[\E\](x:List[\List[\E\]\]):List[\E\] = x.concatMap[\E\](identity[\E\])

(** A reduction object for concatenating lists. *)
object Concat[\E\]() extends Reduction[\ List[\E\] \]
  empty(): List[\E\] = emptyList[\E\]()
  join(a:List[\E\], b:List[\E\]): List[\E\] = a.append(b)
end

(** The same for reverse concatenation *)
object RevConcat[\E\]() extends Reduction[\ List[\E\] \]
  empty(): List[\E\] = emptyList[\E\]()
  join(a:List[\E\], b:List[\E\]): List[\E\] = b.append(a)
end

(** A reduction object for concatenating specifically ArrayLists. *)
object PLConcat[\E\]() extends Reduction[\ ArrayList[\E\] \]
  empty(): ArrayList[\E\] = D0[\E\]()
  join(a:ArrayList[\E\], b:ArrayList[\E\]): ArrayList[\E\] = a.append(b)
end

trait ArrayList[\E\] extends { List[\E\], DelegatedIndexed[\E,ZZ32\] }
    append0(f: List[\E\]): ArrayList[\E\]
    get(i:ZZ32): E
end

value object Alr[\E,nat maxUn\]( underlying : PrimImmutableArray[\E,maxUn\],
                                 firstUsed:ZZ32, firstUnused:ZZ32,
                                 canExtend : OneShot)
      extends ArrayList[\E\]
  getter size(): ZZ32 = firstUnused - firstUsed
  getter isEmpty(): Boolean = firstUnused <= firstUsed
  getter left():Maybe[\E\] =
      if isEmpty() then Nothing[\E\]()
      else Just[\E\](underlying.get(firstUsed)) end
  getter right():Maybe[\E\] =
      if isEmpty() then Nothing[\E\]()
      else Just[\E\](underlying.get(firstUnused-1)) end
  getter extractLeft(): Maybe[\(E,ArrayList[\E\])\] =
      if isEmpty() then Nothing[\(E,ArrayList[\E\])\]()
      else Just[\(E,ArrayList[\E\])\](underlying.get(firstUsed),
                     Alr[\E, maxUn\](underlying, firstUsed+1,
                                     firstUnused, canExtend))
      end
  getter extractRight(): Maybe[\(ArrayList[\E\],E)\] =
      if isEmpty() then Nothing[\(ArrayList[\E\],E)\]()
      else Just[\(ArrayList[\E\],E)\](
                     Alr[\E, maxUn\](underlying, firstUsed,
                                     firstUnused-1, noShot),
                     underlying.get(firstUnused-1))
      end
  getter indices(): Generator[\ZZ32\] = 0#size()
  getter indexValuePairs(): Generator[\(ZZ32,E)\] =
      indices().map[\(ZZ32,E)\](fn (i:ZZ32):(ZZ32,E) => (i,get(i)))
  getter generator(): Generator[\E\] =
      (firstUsed#size()).map[\E\](fn (i:ZZ32):E => underlying.get(i))

  get(i:ZZ32): E = underlying.get(firstUsed+i)

  (* Internal: fill blindly from f; assume enough space *)
  appendFrom(f:List[\E\]): ArrayList[\E\] = do
      for (i,v) <- f.indexValuePairs() do
          underlying.init(firstUnused + i, v)
      end
      self
    end
  appendFrom(f:ArrayList[\E\]): ArrayList[\E\] = do
      for i <- 0#f.size() do
          underlying.init(firstUnused + i, f.get(i))
      end
      self
    end
  appendClosed(f:List[\E\]): ArrayList[\E\] = do
      appendFrom(f)
      Alr[\E,maxUn\]( underlying, firstUsed, firstUnused+f.size(), noShot )
    end

  append(f:List[\E\]): ArrayList[\E\] =
      if size() <= 0 then
          f
      else
          newUnused = f.size() + firstUnused
          if newUnused <= maxUn AND: canExtend.tryOnce() then
              append0(f)
          else
              increaseTo(newUnused-firstUsed).append0(f)
          end
      end
  append0(f:List[\E\]): ArrayList[\E\] = do
      assert(NOT canExtend.canTry(), "append0 of extensible list!")
      appendFrom(f)
      Alr[\E,maxUn\]( underlying, firstUsed, firstUnused+f.size(), oneShot())
    end
  (* addLeft is O(n) *)
  addLeft(e:E):ArrayList[\E\] = do
      rfl = reflect(expansion(maxUn, size()+1))
      mkEmptyLike(self,rfl).addRight(e).append(self)
    end
  addRight(e:E):ArrayList[\E\] = do
      newSize = size() + 1
      if newSize <= maxUn AND: canExtend.tryOnce() then
          addRight0(e)
      else increaseTo(newSize).addRight0(e)
      end
    end
  addRight0(e:E): ArrayList[\E\] = do
      assert(NOT canExtend.canTry(), "addRight0 of extensible list!")
      underlying.init(firstUnused,e)
      Alr[\E,maxUn\]( underlying, firstUsed, firstUnused+1, oneShot())
    end
  take(n:ZZ32): ArrayList[\E\] =
      if n <= 0 then
          emptyList[\E\]()
      elif n < size() then
          Alr[\E,maxUn\](underlying,firstUsed,firstUsed+n,noShot)
      else
          self
      end
  drop(n:ZZ32): ArrayList[\E\] =
      if n <= 0 then
          self
      elif n < size() then
          Alr[\E,maxUn\](underlying, firstUsed+n, firstUnused, canExtend)
      else
          emptyList[\E\]()
      end
  opr [n:ZZ32]: E =
      if n < 0 then
          fail("ArrayList[" n "] index negative")
      elif n >= size() then
          fail("ArrayList[" n "] of size " size() " index too large")
      else
          get(n)
      end
  split(n:ZZ32): (ArrayList[\E\], ArrayList[\E\]) =
      if n <= 0 then
          (emptyList[\E\](), self)
      elif n < size() then
          (Alr[\E,maxUn\](underlying,firstUsed,firstUsed+n,noShot),
           Alr[\E,maxUn\](underlying, firstUsed+n, firstUnused, canExtend))
      else
          (self, emptyList[\E\]())
      end
  split(): (ArrayList[\E\], ArrayList[\E\]) =
      if size() <= 1 then
          (self, emptyList[\E\]())
      else
          split(partitionL(size()))
      end

  reverse(): ArrayList[\E\] =
      makeClosedList(reflect(size()),
                     fn (i:ZZ32):E => underlying.get(firstUnused-1-i))
  concatMap[\G\](f: E->List[\G\]): List[\G\] = do
      mf = map[\List[\G\]\](f)
      mLen = primitiveArray[\ZZ32\](mf.size())
      (* This is a prefix computation, replace it when we get real
         prefixes. *)
      sz : ZZ32 := 0
      for i <- mLen.indices() do
          mLen.init(i,sz)
          sz += mf.get(i).size()
      end
      r = makeListForConcat(reflect(sz),f)
      rUnder = r.underlying
      rFirstUsed = r.firstUsed
      for (i,posn) <- mLen.indexValuePairs() do
          ofs = rFirstUsed + posn
          for (j,v) <- mf.get(i).indexValuePairs() do
              rUnder.init(ofs+j,v)
          end
      end
      r
    end
  map[\G\](f: E->G): ArrayList[\G\] =
      makeClosedList(reflect(size()),
                     fn (i:ZZ32):G => f(get(i)))
  ivmap[\G\](f: (ZZ32,E)->G): ArrayList[\G\] =
      makeClosedList(reflect(size()),
                     fn (i:ZZ32):G => f(i,get(i)))

  increaseTo(newSize: ZZ32):ArrayList[\E\] = do
      rfl = reflect(expansion(maxUn, newSize))
      mkEmptyLike(self,rfl).appendClosed(self)
    end
end

alr[\E, nat sz\]( underlying : PrimImmutableArray[\E,sz\],
                  firstUsed:ZZ32, firstUnused:ZZ32,
                  canExtend : OneShot): Alr[\E,sz\] =
    Alr[\E,sz\](underlying, firstUsed, firstUnused, canExtend)

mkEmptyLike[\E, nat maxUn\](_:ArrayList[\E\], _:N[\maxUn\]): Alr[\E,maxUn\] =
    Alr[\E, maxUn\](PrimImmutableArray[\E,maxUn\](),0,0,noShot)

makeClosedList[\E, nat sz\](_:N[\sz\], f: ZZ32 -> E): Alr[\E,sz\] =
    Alr[\E,sz\](PrimImmutableArray[\E,sz\]().fill(f),0,sz,noShot)

(* makeListForConcat doesn't fill its array with anything. *)
makeListForConcat[\A, E, nat sz\](_:N[\sz\], f: A->List[\E\]): Alr[\E,sz\] =
    Alr[\E,sz\](PrimImmutableArray[\E,sz\](),0,sz,noShot)

(* The ZipGenerator works by first chopping the lists so that they are
the same size, then successively splitting them.  The first argument
is used as a template to guide the splitting process; the second
argument is then split to match. *)
value object ZipGenerator[\A,B\](transient x0: ArrayList[\A\],
                                 transient y0: ArrayList[\B\])
        extends { Generator[\(A,B)\] }
    sz = (x0.size() MIN y0.size())
    getter size() = sz
    seq(self): SequentialGenerator[\(A,B)\] = SeqZipGenerator(sz,x0,y0)
    generate[\R\](r: Reduction[\R\], body: (A,B)->R): R =
        (0#sz).generate[\R\](r,fn(i:ZZ32):R=>body(x0.get(i),y0.get(i)))
end

value object SeqZipGenerator[\A,B\](sz:ZZ32, xs:ArrayList[\A\], ys:ArrayList[\B\])
        extends { SequentialGenerator[\E\] }
    getter size() = sz
    generate[\R\](r: Reduction[\R\], body: E->R): R =
        sequential(0#sz).generate[\R\](r,fn(i:ZZ32):R=>body(xs.get(i),ys.get(i)))
end

emptyList[\E\](): List[\E\] =
    Alr[\E,0\](PrimImmutableArray[\E,0\](),0,0,noShot)

emptyList[\E\](n:ZZ32): List[\E\] =
    if n<=0 then emptyList[\E\]() else
        alr(primitiveImmutableArray[\E\](n),0,0,oneShot())
    end

singleton[\E\](e:E): List[\E\] = do
    u = PrimImmutableArray[\E,1\]()
    u.init(0,e)
    Alr[\E,1\](u,0,1,noShot)
  end

end
