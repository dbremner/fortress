(*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component Set
import CovariantCollection.{...}
export Set

weight:ZZ32 = 4

trait Set[\E\] extends ZeroIndexed[\E\] comprises {NodeSet[\E\], EmptySet[\E\]}
   getter indexValuePairs():ZeroIndexed[\(ZZ32,E)\] =
       IndexValueSetGenerator[\E\](self)
   seqgen[\R\](r: Reduction[\R\], body: E->R): R
   ivgen[\R\](i0:ZZ32, r: Reduction[\R\], body: (ZZ32,E)->R): R
   seq(self): SequentialGenerator[\E\] = SeqSetGenerator[\E\](self)
   getVal():E
   getLeftChild():Set[\E\]
   getRightChild():Set[\E\]
   printTree():()
   toString():String
   opr IN(x:E, self):Boolean
   indexOf(x:E): ZZ32 = self.indexOfI(0,x)
   indexOfI(i:ZZ32, x:E): ZZ32
   minimum():E
   maximum():E
   deleteMinimum():Set[\E\] = do
     (_, res) = removeMinimum()
     res
   end
   deleteMaximum():Set[\E\] = do
     (_, res) = removeMaximum()
     res
   end
   removeMinimum():(E, Set[\E\])
   removeMaximum():(E, Set[\E\])
   add(z:E):Set[\E\]
   delete(z:E):Set[\E\]
   balancedDelete(r:Set[\E\]):Set[\E\]

   opr UNION(self,t2:Set[\E\]):Set[\E\]
   opr INTERSECTION(self,t2:Set[\E\]):Set[\E\]
   opr DIFFERENCE(self,t2:Set[\E\]):Set[\E\]
   concat(t2:Set[\E\]):Set[\E\]
   (** Split at index x, meaning left result has size = x or
       left result has size < x and right result is empty. **)
   splitIndex(x:ZZ32):(Set[\E\],Set[\E\])
   splitAt(x:E):(Set[\E\],Boolean,Set[\E\])
   concat3(v:E, t2:Set[\E\])
end

singleton[\E\](x:E): Set[\E\] = do
   e = EmptySet[\E\]()
   NodeSet[\E\](x,e,e)
end

set[\E\](): Set[\E\] = EmptySet[\E\]()
set[\E\](g: Generator[\E\]): Set[\E\] =
    g.generate[\Set[\E\]\](Union[\E\](), singleton[\E\])

opr [\E\]{ es: E... }: Set[\E\] =
    es.generate[\Set[\E\]\](Union[\E\](),
                                fn (e:E): Set[\E\] => singleton[\E\](e))
opr BIG [\T,U\]{ g: ( Reduction[\SomeCovariantCollection\],
                      T -> SomeCovariantCollection) ->
                    SomeCovariantCollection } : Set[\U\] =
    set(g(CVReduction,fn x => CVUnit(x)))

object Union[\E\]() extends Reduction[\Set[\E\]\]
   e = EmptySet[\E\]()
   empty():Set[\E\] = e
   join(a:Set[\E\], b:Set[\E\]): Set[\E\] = a UNION b
end

value object SeqSetGenerator[\E\](s: Set[\E\])
      extends SequentialGenerator[\E\]
   getter size(): ZZ32 = s.size()
   getter isEmpty(): Boolean = s.isEmpty()
   generate[\R\](r: Reduction[\R\], body: E->R): R =
      s.seqgen[\R\](r,body)
end

value object IndexValueSetGenerator[\E\](s: Set[\E\])
      extends ZeroIndexed[\(ZZ32,E)\]
   getter size(): ZZ32 = s.size()
   getter indices(): ZZ32 = s.indices()
   getter isEmpty(): Boolean = s.isEmpty()
   generate[\R\](r: Reduction[\R\], body: (ZZ32,E)->R): R =
      s.ivgen[\R\](0,r,body)
   opr[ x: ZZ32 ]: (ZZ32,E) = (x,s[x])
   opr[ r: Range[\ZZ32\] ]: ZeroIndexed[\(ZZ32,E)\] = s[r].indexValuePairs()
   indexOf(i:ZZ32,v:E): Boolean = if s[i]=v then i else -1 end
end

object EmptySet[\E\]() extends Set[\E\]
   getter size():ZZ32 = 0
   getter bounds():Range[\ZZ32\] = 0#0
   getter isEmpty():Boolean = true
   opr[i:ZZ32]:E = fail("Empty set: cannot use subscript operator.")
   opr[r:Range[\ZZ32\]] : Set[\E\] = do
      r' = (bounds())[r]
      self
   end
   indexOfI(_:ZZ32, e:E):Boolean = -1
   generate[\R\](r: Reduction[\R\], body: E->R): R = r.empty()
   ivgen[\R\](i0: ZZ32, r: Reduction[\R\], body: (ZZ32,E)->R): R = r.empty()
   seqgen[\R\](r: Reduction[\R\], body: E->R): R = r.empty()
   getVal():E = fail("Empty set: cannot getVal()")
   getLeftChild():Set[\E\] = self
   getRightChild():Set[\E\] = self
   printTree():() = print " EmptySet"
   toString():String = "{}"
   opr IN(x:E, self):Boolean = false
   minimum():E = fail("Empty set: no minimum element.")
   removeMinimum():(E, Set[\E\]) = fail("Empty set: cannot remove minimum.")
   maximum():E = fail("Empty set: no maximum element.")
   removeMaximum():(E, Set[\E\]) = fail("Empty set: cannot remove maximum.")
   add(z:E):Set[\E\] = NodeSet[\E\](z,self,self)
   delete(z:E):Set[\E\] = self
   balancedAdd(val:E,  left:Set[\E\], right:Set[\E\]):NodeSet[\E\] = NodeSet[\E\](val,self,self)
   balancedDelete(r:Set[\E\]):Set[\E\] = r
   opr UNION(self, t2:Set[\E\]):Set[\E\] = t2
   opr INTERSECTION(self,t2:Set[\E\]):Set[\E\] = self
   opr DIFFERENCE(self,t2:Set[\E\]):Set[\E\] = self
   concat(t2:Set[\E\]):Set[\E\] = t2
   splitAt(x:E):(Set[\E\],Boolean,Set[\E\]) = (self, false, self)
   splitIndex(x:ZZ32):(Set[\E\],Set[\E\]) = (self,self)
   concat3(v:E, t2:Set[\E\]) = t2.add(v)
end

object NodeSet[\E\](val:E,  left:Set[\E\], right:Set[\E\]) extends Set[\E\]
   sz:ZZ32 = 1 + left.size() + right.size()
   getter size():ZZ32 = sz
   getter isEmpty():Boolean = false
   subscript(i:ZZ32):E = if i < left.size() then left.subscript(i)
      elif i = left.size() then val
      else right.subscript(i - left.size() - 1) end
   opr[i:ZZ32]:E = if 0 <= i < sz then subscript(i)
                   else fail(self "[" i "] is out of bounds.") end
   opr[r:Range[\ZZ32\]] : Set[\E\] = do
      r' = (bounds())[r]
      (lside,rside) = splitIndex( r'.lower() )
      (lside',rside') = rside.splitIndex( r'.size())
      lside'
   end
   indexOfI(i:ZZ32, e:E): ZZ32 =
       typecase _ = e CMP val of
           LessThan => left.indexOfI(i,e)
           EqualTo => i+left.size()
           GreaterThan => right.indexOfI(i+left.size()+1,e)
       end
   generate[\R\](r: Reduction[\R\], body: E->R): R =
      r.join(r.join(left.generate[\R\](r,body),body(val)),
             right.generate[\R\](r,body))
   ivgen[\R\](i0:ZZ32, r: Reduction[\R\], body: (ZZ32,E)->R): R = do
       mi = left.size()+i0
       r.join(r.join(left.ivgen[\R\](i0,r,body),body(mi,val)),
              right.ivgen[\R\](mi+1,r,body))
     end
   seqgen[\R\](r: Reduction[\R\], body: E->R): R = do
      lg = left.generate[\R\](r,body)
      vg = body(val)
      mg = r.join(lg,vg)
      rg = right.generate[\R\](r,body)
      r.join(mg,rg)
   end
   getVal():E = val
   getLeftChild():Set[\E\] = left
   getRightChild():Set[\E\] = right

   printTree():() = do
      print("(")
      print(val)
      print(" ")
      left.printTree()
      right.printTree()
      println(")")
   end

   toString():String = do
      (h,t) = removeMinimum()
      "{" h t.generate[\String\](StringReduction,
                                  fn (e:E)=>"," e) "}"
   end

   opr IN(z:E, self):Boolean =
       typecase _ = z CMP val of
           LessThan => z IN left
           EqualTo => true
           GreaterThan => z IN right
       end

   add(z:()): Set[\E\] = self
   add(z:E):Set[\E\] =
      if   (z = val) then self
      elif (z < val) then balancedAdd(val,left.add(z),right)
      else balancedAdd(val,left,right.add(z))
      end

   delete(x:E):Set[\E\] =
       if   x < val then balancedAdd(val,left.delete(x),right)
       elif val < x then balancedAdd(val,left,right.delete(x))
       else              left.balancedDelete(right)
       end

   balancedDelete(r:NodeSet[\E\]):Set[\E\] = do
     (min_elt, del_min) = r.removeMinimum()
     balancedAdd(min_elt, self, del_min)
   end
   balancedDelete(r:Set[\E\]):Set[\E\] = self

   minimum():E = do
      if left.isEmpty() then val else left.minimum() end
   end

   maximum():E = do
      if right.isEmpty() then val else right.maximum() end
   end

   removeMinimum() =
     if left.isEmpty() then (val,right)
     else
       (min, delmin) = left.removeMinimum()
       (min, balancedAdd(val,delmin,right))
     end

   removeMaximum() =
     if right.isEmpty() then (val,left)
     else
       (max, delmax) = right.removeMaximum()
       (max, balancedAdd(val,left,delmax))
     end

   (* TODO: union, intersection, and difference should use hedge
      algorithms, which avoid splitting and the allocation it entails
      but require a pile of code instead. *)
   opr UNION(self, t2:NodeSet[\E\]):Set[\E\] = do
      (newl, _, newr) = t2.splitAt(val)
      (left UNION newl).concat3(val, right UNION newr)
   end
   opr UNION(self, t2:Set[\E\]):Set[\E\] = self

   opr INTERSECTION(self,t2:NodeSet[\E\]):Set[\E\] = do
      (newl, m, newr) = t2.splitAt(val)
      (li, ri) = (left INTERSECTION newl, right INTERSECTION newr)
      if m then li.concat3(val,ri) else li.concat(ri)
      end
   end
   opr INTERSECTION(self,t2:Set[\E\]):Set[\E\] = t2

   opr DIFFERENCE(self,t2:NodeSet[\E\]):Set[\E\] = do
      (newl, m, newr) = t2.splitAt(val)
      (li,ri) = (left DIFFERENCE newl, right DIFFERENCE newr)
      if m then li.concat(ri) else li.concat3(val,ri) end
   end
   opr DIFFERENCE(self,t2:Set[\E\]):Set[\E\] = self

   concat(t2:NodeSet[\E\]):Set[\E\] = do
      (min, delmin) = t2.removeMinimum()
      concat3(min, delmin)
   end
   concat(t2:Set[\E\]):Set[\E\] = self

   splitIndex(x:ZZ32):(Set[\E\],Set[\E\]) =
      if x < left.size() then
        (ll,rl) = left.splitIndex(x)
        (ll,rl.concat3(val,right))
      elif left.size() < x then
        (lr,rr) = right.splitIndex(x - left.size() - 1)
        (left.concat3(val,lr),rr)
      else
        (left,right.add(val))
      end

   splitAt(x:E):(Set[\E\],Boolean,Set[\E\]) =
      if x < val then
        (ll,m,rl) = left.splitAt(x)
        (ll,m,rl.concat3(val,right))
      elif val < x then
        (lr,m,rr) = right.splitAt(x)
        (left.concat3(val,lr),m,rr)
      else (left,true,right)
      end

   concat3(v:E, t2:NodeSet[\E\]) = do
      v1 = val
      n1 = sz
      l1 = left
      r1 = right
      v2 = t2.getVal()
      n2 = t2.size()
      l2 = t2.getLeftChild()
      r2 = t2.getRightChild()
      if   weight n1 < n2 then balancedAdd(v2,concat3(v,l2),r2)
      elif weight n2 < n1 then balancedAdd(v1,l1,r1.concat3(v,t2))
      else NodeSet[\E\](v,self,t2) end
   end
   concat3(v:E, t2:Set[\E\]) = add(v)

   balancedAdd(val:E,  left:Set[\E\], right:Set[\E\]):NodeSet[\E\] = do
      ln = left.size()
      rn = right.size()
      if ln + rn < weight then NodeSet[\E\](val, left, right)
      elif rn > weight ln then do
         rl = right.getRightChild().getLeftChild()
         rr = right.getRightChild().getRightChild()
         rln = rl.size()
         rrn = rr.size()
         if rln < rrn then single_L(val, left, right) else double_L(val, left, right) end
         end
      elif ln > weight rn then do
         ll = left.getLeftChild().getLeftChild()
         lr = left.getLeftChild().getRightChild()
         lln = ll.size()
         lrn = lr.size()
         if (lrn < lln) then single_R(val, left, right) else double_R(val,left,right) end
         end
      else NodeSet[\E\](val,left,right) end
   end

   single_L(val:E,  left:Set[\E\], right:Set[\E\]):NodeSet[\E\] = do
      a = val
      x = left
      b = right.getVal()
      y = right.getLeftChild()
      z = right.getRightChild()
      NodeSet[\E\](b, NodeSet[\E\](a, x, y), z)
   end

   single_R(val:E,  left:Set[\E\], right:Set[\E\]):NodeSet[\E\] = do
      b = val
      a = left.getVal()
      x = left.getLeftChild()
      y = left.getRightChild()
      z = right
      NodeSet[\E\](a,x,NodeSet[\E\](b,y,z))
   end

   double_L(val:E,  left:Set[\E\], right:Set[\E\]):NodeSet[\E\] = do
      a = val
      x = left
      c = right.getVal()
      b = right.getLeftChild().getVal()
      y1 = right.getLeftChild().getLeftChild()
      y2 = right.getLeftChild().getRightChild()
      z = right.getRightChild()
      println("double_L " a " " b)
      NodeSet[\E\](b, NodeSet[\E\](a,x,y1),NodeSet[\E\](c,y2,z))
   end

   double_R(val:E,  left:Set[\E\], right:Set[\E\]):NodeSet[\E\] = do
      c = val
      a = left.getVal()
      x = left.getLeftChild()
      b = left.getRightChild().getVal()
      y1 = left.getRightChild().getLeftChild()
      y2 = left.getRightChild().getRightChild()
      z = right
      (* println("double_R " a " " b " " c) *)
      NodeSet[\E\](b, NodeSet[\E\](a, x,y1), NodeSet[\E\](c,y2,z))
   end
end

end
