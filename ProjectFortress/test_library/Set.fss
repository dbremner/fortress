(*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component Set
export Set

weight:ZZ32 = 4

trait TreeSet[\E\] extends Indexed[\E,ZZ32\] comprises {NodeSet[\E\], EmptySet[\E\]}
   seqgen[\R\](r: Reduction[\R\], body: E->R): R
   seq(self): SequentialGenerator[\E\] = SeqSetGenerator[\E\](self)
   getVal():E
   getLeftChild():TreeSet[\E\]
   getRightChild():TreeSet[\E\]
   printTree():()
   toString():String
   member(x:E):Boolean
   minimum():E
   maximum():E
   deleteMinimum():TreeSet[\E\] = do
     (_, res) = removeMinimum()
     res
   end
   deleteMaximum():TreeSet[\E\] = do
     (_, res) = removeMaximum()
     res
   end
   removeMinimum():(E, TreeSet[\E\])
   removeMaximum():(E, TreeSet[\E\])
   add(z:E):TreeSet[\E\]
   delete(z:E):TreeSet[\E\]
   balancedDelete(r:TreeSet[\E\]):TreeSet[\E\]

   union(t2:TreeSet[\E\]):TreeSet[\E\]
   intersection(t2:TreeSet[\E\]):TreeSet[\E\]
   difference(t2:TreeSet[\E\]):TreeSet[\E\]
   concat(t2:TreeSet[\E\]):TreeSet[\E\]
   (** Split at index x, meaning left result has size = x or
       left result has size < x and right result is empty. **)
   splitIndex(x:ZZ32):(TreeSet[\E\],TreeSet[\E\])
   splitAt(x:E):(TreeSet[\E\],Boolean,TreeSet[\E\])
   concat3(v:E, t2:TreeSet[\E\])
end

singleton[\E\](x:E): TreeSet[\E\] = do
   e = EmptySet[\E\]()
   NodeSet[\E\](x,e,e)
end

set[\E\](): TreeSet[\E\] = EmptySet[\E\]()
set[\E\](g: Generator[\E\]): TreeSet[\E\] =
    g.generate[\TreeSet[\E\]\](Union[\E\](), singleton[\E\])

opr [\E\]{ es: E... }: TreeSet[\E\] =
    es.generate[\TreeSet[\E\]\](Union[\E\](),
                                fn (e:E): TreeSet[\E\] => singleton[\E\](e))

object Union[\E\]() extends Reduction[\TreeSet[\E\]\]
   e = EmptySet[\E\]()
   empty():TreeSet[\E\] = e
   join(a:TreeSet[\E\], b:TreeSet[\E\]): TreeSet[\E\] = a.union(b)
end

value object SeqSetGenerator[\E\](s: TreeSet[\E\])
      extends SequentialGenerator[\E\]
   getter size(): ZZ32 = s.size()
   getter isEmpty(): Boolean = s.isEmpty()
   generate[\R\](r: Reduction[\R\], body: E->R): R =
      s.seqgen[\R\](r,body)
end

object EmptySet[\E\]() extends TreeSet[\E\]
   getter size():ZZ32 = 0
   getter bounds():Range[\ZZ32\] = 0#0
   getter isEmpty():Boolean = true
   opr[i:ZZ32]:E = fail("Empty set: cannot use subscript operator.")
   opr[r:Range[\ZZ32\]] : Indexed[\E,ZZ32\] = do
      r' = bounds()[r]
      self
   end
   generate[\R\](r: Reduction[\R\], body: E->R): R = r.empty()
   seqgen[\R\](r: Reduction[\R\], body: E->R): R = r.empty()
   getVal():E = fail("Empty set: cannot getVal()")
   getLeftChild():TreeSet[\E\] = self
   getRightChild():TreeSet[\E\] = self
   printTree():() = print " EmptySet"
   toString():String = "{}"
   member(x:E):Boolean = false
   minimum():E = fail("Empty set: no minimum element.")
   removeMinimum():(E, TreeSet[\E\]) = fail("Empty set: cannot remove minimum.")
   maximum():E = fail("Empty set: no maximum element.")
   removeMaximum():(E, TreeSet[\E\]) = fail("Empty set: cannot remove maximum.")
   add(z:E):TreeSet[\E\] = NodeSet[\E\](z,self,self)
   delete(z:E):TreeSet[\E\] = self
   balancedAdd(val:E,  left:TreeSet[\E\], right:TreeSet[\E\]):NodeSet[\E\] = NodeSet[\E\](val,self,self)
   balancedDelete(r:TreeSet[\E\]):TreeSet[\E\] = r
   union(t2:TreeSet[\E\]):TreeSet[\E\] = t2
   intersection(t2:TreeSet[\E\]):TreeSet[\E\] = self
   difference(t2:TreeSet[\E\]):TreeSet[\E\] = self
   concat(t2:TreeSet[\E\]):TreeSet[\E\] = t2
   splitAt(x:E):(TreeSet[\E\],Boolean,TreeSet[\E\]) = (self, false, self)
   splitIndex(x:ZZ32):(TreeSet[\E\],TreeSet[\E\]) = (self,self)
   concat3(v:E, t2:TreeSet[\E\]) = t2.add(v)
end

object NodeSet[\E\](val:E,  left:TreeSet[\E\], right:TreeSet[\E\]) extends TreeSet[\E\]
   sz:ZZ32 = 1 + left.size() + right.size()
   getter size():ZZ32 = sz
   getter isEmpty():Boolean = false
   getter bounds():Range[\ZZ32\] = 0 # sz
   subscript(i:ZZ32):E = if i < left.size() then left.subscript(i)
      elif i = left.size() then val
      else right.subscript(i - left.size() - 1) end
   opr[i:ZZ32]:E = if 0 <= i < sz then subscript(i)
                   else fail(self "[" i "] is out of bounds.") end
   opr[r:Range[\ZZ32\]] : Indexed[\E,ZZ32\] = do
      r' = bounds()[r]
      (lside,rside) = splitIndex( r'.lower() )
      (lside',rside') = rside.splitIndex( r'.size())
      lside'
   end
   generate[\R\](r: Reduction[\R\], body: E->R): R =
      r.join(r.join(left.generate[\R\](r,body),body(val)),
             right.generate[\R\](r,body))
   seqgen[\R\](r: Reduction[\R\], body: E->R): R = do
      lg = left.generate[\R\](r,body)
      vg = body(val)
      mg = r.join(lg,vg)
      rg = right.generate[\R\](r,body)
      r.join(mg,rg)
   end
   getVal():E = val
   getLeftChild():TreeSet[\E\] = left
   getRightChild():TreeSet[\E\] = right

   printTree():() = do
      print("(")
      print(val)
      print(" ")
      left.printTree()
      right.printTree()
      println(")")
   end

   toString():String = do
      (h,t) = removeMinimum()
      "{" h t.generate[\String\](StringReduction,
                                  fn (e:E)=>"," e) "}"
   end

   member(z:E):Boolean = do
      if (z = val) then true
      elif (z < val) then left.member(z)
      else right.member(z)
      end
   end

   add(z:()): TreeSet[\E\] = self
   add(z:E):TreeSet[\E\] =
      if   (z = val) then self
      elif (z < val) then balancedAdd(val,left.add(z),right)
      else balancedAdd(val,left,right.add(z))
      end

   delete(x:E):TreeSet[\E\] =
       if   x < val then balancedAdd(val,left.delete(x),right)
       elif val < x then balancedAdd(val,left,right.delete(x))
       else              left.balancedDelete(right)
       end

   balancedDelete(r:NodeSet[\E\]):TreeSet[\E\] = do
     (min_elt, del_min) = r.removeMinimum()
     balancedAdd(min_elt, self, del_min)
   end
   balancedDelete(r:TreeSet[\E\]):TreeSet[\E\] = self

   minimum():E = do
      if left.isEmpty() then val else left.minimum() end
   end

   maximum():E = do
      if right.isEmpty() then val else right.maximum() end
   end

   removeMinimum() =
     if left.isEmpty() then (val,right)
     else
       (min, delmin) = left.removeMinimum()
       (min, balancedAdd(val,delmin,right))
     end

   removeMaximum() =
     if right.isEmpty() then (val,left)
     else
       (max, delmax) = right.removeMaximum()
       (max, balancedAdd(val,left,delmax))
     end

   (* TODO: union, intersection, and difference should use hedge
      algorithms, which avoid splitting and the allocation it entails
      but require a pile of code instead. *)
   union(t2:NodeSet[\E\]):TreeSet[\E\] = do
      (newl, _, newr) = t2.splitAt(val)
      left.union(newl).concat3(val, right.union(newr))
   end
   union(t2:TreeSet[\E\]):TreeSet[\E\] = self

   intersection(t2:NodeSet[\E\]):TreeSet[\E\] = do
      (newl, m, newr) = t2.splitAt(val)
      (li, ri) = (left.intersection(newl), right.intersection(newr))
      if m then li.concat3(val,ri) else li.concat(ri)
      end
   end
   intersection(t2:TreeSet[\E\]):TreeSet[\E\] = t2

   difference(t2:NodeSet[\E\]):TreeSet[\E\] = do
      (newl, m, newr) = t2.splitAt(val)
      (li,ri) = (left.difference(newl), right.difference(newr))
      if m then li.concat(ri) else li.concat3(val,ri) end
   end
   difference(t2:TreeSet[\E\]):TreeSet[\E\] = self

   concat(t2:NodeSet[\E\]):TreeSet[\E\] = do
      (min, delmin) = t2.removeMinimum()
      concat3(min, delmin)
   end
   concat(t2:TreeSet[\E\]):TreeSet[\E\] = self

   splitIndex(x:ZZ32):(TreeSet[\E\],TreeSet[\E\]) =
      if x < left.size() then
        (ll,rl) = left.splitIndex(x)
        (ll,rl.concat3(val,right))
      elif left.size() < x then
        (lr,rr) = right.splitIndex(x - left.size() - 1)
        (left.concat3(val,lr),rr)
      else
        (left,right.add(val))
      end

   splitAt(x:E):(TreeSet[\E\],Boolean,TreeSet[\E\]) =
      if x < val then
        (ll,m,rl) = left.splitAt(x)
        (ll,m,rl.concat3(val,right))
      elif val < x then
        (lr,m,rr) = right.splitAt(x)
        (left.concat3(val,lr),m,rr)
      else (left,true,right)
      end

   concat3(v:E, t2:NodeSet[\E\]) = do
      v1 = val
      n1 = sz
      l1 = left
      r1 = right
      v2 = t2.getVal()
      n2 = t2.size()
      l2 = t2.getLeftChild()
      r2 = t2.getRightChild()
      if   weight n1 < n2 then balancedAdd(v2,concat3(v,l2),r2)
      elif weight n2 < n1 then balancedAdd(v1,l1,r1.concat3(v,t2))
      else NodeSet[\E\](v,self,t2) end
   end
   concat3(v:E, t2:TreeSet[\E\]) = add(v)

   balancedAdd(val:E,  left:TreeSet[\E\], right:TreeSet[\E\]):NodeSet[\E\] = do
      ln = left.size()
      rn = right.size()
      if ln + rn < weight then NodeSet[\E\](val, left, right)
      elif rn > weight ln then do
         rl = right.getRightChild().getLeftChild()
         rr = right.getRightChild().getRightChild()
         rln = rl.size()
         rrn = rr.size()
         if rln < rrn then single_L(val, left, right) else double_L(val, left, right) end
         end
      elif ln > weight rn then do
         ll = left.getLeftChild().getLeftChild()
         lr = left.getLeftChild().getRightChild()
         lln = ll.size()
         lrn = lr.size()
         if (lrn < lln) then single_R(val, left, right) else double_R(val,left,right) end
         end
      else NodeSet[\E\](val,left,right) end
   end

   single_L(val:E,  left:TreeSet[\E\], right:TreeSet[\E\]):NodeSet[\E\] = do
      a = val
      x = left
      b = right.getVal()
      y = right.getLeftChild()
      z = right.getRightChild()
      NodeSet[\E\](b, NodeSet[\E\](a, x, y), z)
   end

   single_R(val:E,  left:TreeSet[\E\], right:TreeSet[\E\]):NodeSet[\E\] = do
      b = val
      a = left.getVal()
      x = left.getLeftChild()
      y = left.getRightChild()
      z = right
      NodeSet[\E\](a,x,NodeSet[\E\](b,y,z))
   end

   double_L(val:E,  left:TreeSet[\E\], right:TreeSet[\E\]):NodeSet[\E\] = do
      a = val
      x = left
      c = right.getVal()
      b = right.getLeftChild().getVal()
      y1 = right.getLeftChild().getLeftChild()
      y2 = right.getLeftChild().getRightChild()
      z = right.getRightChild()
      println("double_L " a " " b)
      NodeSet[\E\](b, NodeSet[\E\](a,x,y1),NodeSet[\E\](c,y2,z))
   end

   double_R(val:E,  left:TreeSet[\E\], right:TreeSet[\E\]):NodeSet[\E\] = do
      c = val
      a = left.getVal()
      x = left.getLeftChild()
      b = left.getRightChild().getVal()
      y1 = left.getRightChild().getLeftChild()
      y2 = left.getRightChild().getRightChild()
      z = right
      (* println("double_R " a " " b " " c) *)
      NodeSet[\E\](b, NodeSet[\E\](a, x,y1), NodeSet[\E\](c,y2,z))
   end
end

end
