(*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component Set
import CovariantCollection.{...}
export Set

weight:ZZ32 = 4

trait Set[\E\]
      extends { ZeroIndexed[\E\], Equality[\Set[\E\]\] }
      comprises {NodeSet[\E\], EmptySet[\E\]}
   getter indexValuePairs():ZeroIndexed[\(ZZ32,E)\] =
       IndexValueSetGenerator[\E\](self)
   seqgen[\R\](r: Reduction[\R\], body: E->R): R
   ivgen[\R\](i0:ZZ32, r: Reduction[\R\], body: (ZZ32,E)->R): R
   seq(self): SequentialGenerator[\E\] = SeqSetGenerator[\E\](self)
   getVal():E
   getLeftChild():Set[\E\]
   getRightChild():Set[\E\]
   showTree():String
   toString():String
   opr IN(x:E, self):Boolean
   indexOf(x:E): ZZ32 = self.indexOfI(0,x)
   indexOfI(i:ZZ32, x:E): ZZ32
   minimum():E
   maximum():E
   deleteMinimum():Set[\E\] = do
     (_, res) = removeMinimum()
     res
   end
   deleteMaximum():Set[\E\] = do
     (_, res) = removeMaximum()
     res
   end
   removeMinimum():(E, Set[\E\])
   removeMaximum():(E, Set[\E\])
   add(z:E):Set[\E\]
   delete(z:E):Set[\E\]
   balancedDelete(r:Set[\E\]):Set[\E\]
   opr | self | : ZZ32
   opr UNION(self,t2:Set[\E\]):Set[\E\]
   opr INTERSECTION(self,t2:Set[\E\]):Set[\E\]
   opr DIFFERENCE(self,t2:Set[\E\]):Set[\E\]
   concat(t2:Set[\E\]):Set[\E\]
   (** Split at index x, meaning left result has size = x or
       left result has size < x and right result is empty. **)
   splitIndex(x:ZZ32):(Set[\E\],Set[\E\])
   splitAt(x:E):(Set[\E\],Boolean,Set[\E\])
   concat3(v:E, t2:Set[\E\])
   opr SUBSET(self, other:Set[\E\]): Boolean = (self SETCMP other) = LessThan
   opr SUBSETEQ(self, other:Set[\E\]): Boolean
   opr SUPSET(self, other:Set[\E\]): Boolean = other SUBSET self
   opr SUPSETEQ(self, other:Set[\E\]): Boolean = other SUBSETEQ self
   opr =(self, other:Set[\E\]): Boolean
   opr SETCMP(self, other:Set[\E\]): Comparison
end

singleton[\E\](x:E): Set[\E\] = do
   e = EmptySet[\E\]
   NodeSet[\E\](x,e,e)
end

set[\E\](): Set[\E\] = EmptySet[\E\]
set[\E\](g: Generator[\E\]): Set[\E\] =
    g.generate[\Set[\E\]\](Union[\E\], singleton[\E\])

opr {[\E\] es: E... }: Set[\E\] =
    es.generate[\Set[\E\]\](Union[\E\],
                                fn (e:E): Set[\E\] => singleton[\E\](e))
opr BIG {[\T,U\] g: ( Reduction[\SomeCovariantCollection\],
                      T -> SomeCovariantCollection) ->
                    SomeCovariantCollection } : Set[\U\] =
    set(g(CVReduction,fn x => CVUnit(x)))

opr BIG UNION[\R\](g:(Reduction[\Set[\R\]\], Set[\R\]->Set[\R\])->Set[\R\]):
                    Set[\R\] = g(Union[\R\], identity[\R\])

object Union[\E\] extends Reduction[\Set[\E\]\]
   e = EmptySet[\E\]
   empty():Set[\E\] = e
   join(a:Set[\E\], b:Set[\E\]): Set[\E\] = a UNION b
end

opr BIG INTERSECTION[\R\](g:(Reduction[\Maybe[\Set[\R\]\]\],
                             Set[\R\]->Maybe[\Set[\R\]\]) ->
                            Maybe[\Set[\R\]\]): Set[\R\] =
    Intersection[\R\].unwrap(g(Intersection[\R\],
                               fn (s:Set[\R\]):Just[\Set[\R\]\] =>
                                   Just[\Set[\R\]\](s)))

object Intersection[\E\] extends Reduction[\Maybe[\Set[\E\]\]\]
    ee = Nothing[\Set[\E\]\]()
    empty():Maybe[\Set[\E\]\] = ee
    join(a:Maybe[\Set[\E\]\], b:Maybe[\Set[\E\]\]): Maybe[\Set[\E\]\] =
        if NOT a.isJust() then b
        elif NOT b.isJust() then a
        else Just[\Set[\E\]\](a.unJust() INTERSECTION b.unJust)
        end
    unwrap(w:Maybe[\Set[\E\]\]): Set[\E\] =
        if w.isJust() then w.unJust()
        else fail("BIG INTERSECTION: empty generator.")
        end
end

value object SeqSetGenerator[\E\](s: Set[\E\])
      extends SequentialGenerator[\E\]
   getter size(): ZZ32 = |s|
   getter isEmpty(): Boolean = s.isEmpty()
   generate[\R\](r: Reduction[\R\], body: E->R): R =
      s.seqgen[\R\](r,body)
end

value object IndexValueSetGenerator[\E\](s: Set[\E\])
      extends ZeroIndexed[\(ZZ32,E)\]
   getter size(): ZZ32 = |s|
   getter indices(): ZZ32 = s.indices()
   getter isEmpty(): Boolean = s.isEmpty()
   generate[\R\](r: Reduction[\R\], body: (ZZ32,E)->R): R =
      s.ivgen[\R\](0,r,body)
   opr[ x: ZZ32 ]: (ZZ32,E) = (x,s[x])
   opr[ r: Range[\ZZ32\] ]: ZeroIndexed[\(ZZ32,E)\] = s[r].indexValuePairs()
   indexOf(i:ZZ32,v:E): Boolean = if s[i]=v then i else -1 end
end

object EmptySet[\E\] extends Set[\E\]
   getter size():ZZ32 = 0
   getter bounds():Range[\ZZ32\] = 0#0
   getter isEmpty():Boolean = true
   opr[i:ZZ32]:E = fail("Empty set: cannot use subscript operator.")
   opr[r:Range[\ZZ32\]] : Set[\E\] = do
      rr = (bounds())[r]
      self
   end
   indexOfI(_:ZZ32, e:E):Boolean = -1
   generate[\R\](r: Reduction[\R\], body: E->R): R = r.empty()
   ivgen[\R\](i0: ZZ32, r: Reduction[\R\], body: (ZZ32,E)->R): R = r.empty()
   seqgen[\R\](r: Reduction[\R\], body: E->R): R = r.empty()
   getVal():E = fail("Empty set: cannot getVal()")
   getLeftChild():Set[\E\] = self
   getRightChild():Set[\E\] = self
   showTree():String = "Îµ"
   toString():String = "{}"
   opr IN(x:E, self):Boolean = false
   minimum():E = fail("Empty set: no minimum element.")
   removeMinimum():(E, Set[\E\]) = fail("Empty set: cannot remove minimum.")
   maximum():E = fail("Empty set: no maximum element.")
   removeMaximum():(E, Set[\E\]) = fail("Empty set: cannot remove maximum.")
   add(z:E):Set[\E\] = NodeSet[\E\](z,self,self)
   delete(z:E):Set[\E\] = self
   balancedAdd(val:E,  left:Set[\E\], right:Set[\E\]):NodeSet[\E\] = NodeSet[\E\](val,self,self)
   balancedDelete(r:Set[\E\]):Set[\E\] = r
   opr | self |: ZZ32 = 0
   opr UNION(self, t2:Set[\E\]):Set[\E\] = t2
   opr INTERSECTION(self,t2:Set[\E\]):Set[\E\] = self
   opr DIFFERENCE(self,t2:Set[\E\]):Set[\E\] = self
   concat(t2:Set[\E\]):Set[\E\] = t2
   splitAt(x:E):(Set[\E\],Boolean,Set[\E\]) = (self, false, self)
   splitIndex(x:ZZ32):(Set[\E\],Set[\E\]) = (self,self)
   concat3(v:E, t2:Set[\E\]) = t2.add(v)
   opr =(self, other:Set[\E\]): Boolean = other.isEmpty()
   opr SUBSETEQ(self, other:Set[\E\]): Boolean = true
   override opr SUBSET(self, other:Set[\E\]): Boolean = NOT (other.isEmpty())
   opr SETCMP(self, other:Set[\E\]): Comparison =
      if other.isEmpty() then EqualTo else LessThan end
end

object NodeSet[\E\](val:E,  left:Set[\E\], right:Set[\E\]) extends Set[\E\]
   sz:ZZ32 = 1 + |left| + |right|
   getter size():ZZ32 = sz
   getter isEmpty():Boolean = false
   subscript(i:ZZ32):E = if i < |left| then left.subscript(i)
      elif i = |left| then val
      else right.subscript(i - |left| - 1) end
   opr[i:ZZ32]:E = if 0 <= i < sz then subscript(i)
                   else fail(self "[" i "] is out of bounds.") end
   opr[r:Range[\ZZ32\]] : Set[\E\] = do
      r' = (bounds())[r]
      (lside,rside) = splitIndex( r'.lower() )
      (lside',rside') = rside.splitIndex( r'.size() )
      lside'
   end
   indexOfI(i:ZZ32, e:E): ZZ32 =
       typecase _ = e CMP val of
           LessThan => left.indexOfI(i,e)
           EqualTo => i+|left|
           GreaterThan => right.indexOfI(i + |left| + 1,e)
       end
   generate[\R\](r: Reduction[\R\], body: E->R): R =
      r.join(r.join(left.generate[\R\](r,body),body(val)),
             right.generate[\R\](r,body))
   ivgen[\R\](i0:ZZ32, r: Reduction[\R\], body: (ZZ32,E)->R): R = do
       mi = |left| + i0
       r.join(r.join(left.ivgen[\R\](i0,r,body),body(mi,val)),
              right.ivgen[\R\](mi+1,r,body))
     end
   seqgen[\R\](r: Reduction[\R\], body: E->R): R = do
      lg = left.generate[\R\](r,body)
      vg = body(val)
      mg = r.join(lg,vg)
      rg = right.generate[\R\](r,body)
      r.join(mg,rg)
   end
   getVal():E = val
   getLeftChild():Set[\E\] = left
   getRightChild():Set[\E\] = right

   showTree():String =
      "(" left.showTree() " " val " " right.showTree() ")"

   toString():String = do
      (h,t) = removeMinimum()
      "{" h t.generate[\String\](StringReduction,
                                  fn (e:E)=>"," e) "}"
   end

   opr IN(z:E, self):Boolean =
       typecase _ = z CMP val of
           LessThan => z IN left
           EqualTo => true
           GreaterThan => z IN right
       end

   add(z:()): Set[\E\] = self
   add(z:E):Set[\E\] =
      if   (z = val) then self
      elif (z < val) then balancedAdd(val,left.add(z),right)
      else balancedAdd(val,left,right.add(z))
      end

   delete(x:E):Set[\E\] =
       if   x < val then balancedAdd(val,left.delete(x),right)
       elif val < x then balancedAdd(val,left,right.delete(x))
       else              left.balancedDelete(right)
       end

   balancedDelete(r:NodeSet[\E\]):Set[\E\] = do
     (min_elt, del_min) = r.removeMinimum()
     balancedAdd(min_elt, self, del_min)
   end
   balancedDelete(r:Set[\E\]):Set[\E\] = self

   minimum():E = do
      if left.isEmpty() then val else left.minimum() end
   end

   maximum():E = do
      if right.isEmpty() then val else right.maximum() end
   end

   removeMinimum() =
     if left.isEmpty() then (val,right)
     else
       (min, delmin) = left.removeMinimum()
       (min, balancedAdd(val,delmin,right))
     end

   removeMaximum() =
     if right.isEmpty() then (val,left)
     else
       (max, delmax) = right.removeMaximum()
       (max, balancedAdd(val,left,delmax))
     end

   opr | self | : ZZ32 = sz

   (* TODO: union, intersection, and difference should use hedge
      algorithms, which avoid splitting and the allocation it entails
      but require a pile of code instead. *)
   opr UNION(self, t2:NodeSet[\E\]):Set[\E\] = do
      (newl, _, newr) = t2.splitAt(val)
      r = (left UNION newl).concat3(val, right UNION newr)
      (* println(self "âª" t2 " = " r) *)
      r
   end
   opr UNION(self, t2:Set[\E\]):Set[\E\] = self

   opr INTERSECTION(self,t2:NodeSet[\E\]):Set[\E\] = do
      (newl, m, newr) = t2.splitAt(val)
      (li, ri) = (left INTERSECTION newl, right INTERSECTION newr)
      if m then li.concat3(val,ri) else li.concat(ri)
      end
   end
   opr INTERSECTION(self,t2:Set[\E\]):Set[\E\] = t2

   opr DIFFERENCE(self,t2:NodeSet[\E\]):Set[\E\] = do
      (newl, m, newr) = t2.splitAt(val)
      (li,ri) = (left DIFFERENCE newl, right DIFFERENCE newr)
      if m then li.concat(ri) else li.concat3(val,ri) end
   end
   opr DIFFERENCE(self,t2:Set[\E\]):Set[\E\] = self

   opr =(self, other:Set[\E\]): Boolean =
      if self SEQV other then true
      elif other.isEmpty() then false
      else
         (l,m,r) = other.splitAt(val)
         m AND: left=l AND: right=r
      end
   opr SUBSETEQ(self, other:Set[\E\]): Boolean =
      if self SEQV other then true
      elif other.isEmpty() then false
      else
         (l,m,r) = other.splitAt(val)
         m AND: left SUBSETEQ l AND right SUBSETEQ r
      end
   opr SETCMP(self, other:Set[\E\]): Comparison =
      if self SEQV other then EqualTo
      elif other.isEmpty() then GreaterThan
      else
          (l,m,r) = other.splitAt(val)
          typecase _ = left SETCMP l of
              Unordered => Unordered
              LessThan =>
                  if m AND: right SUBSETEQ r then
                       LessThan
                  else Unordered end
              EqualTo =>
                  if m then right SETCMP r
                  elif r SUBSETEQ right then
                      GreaterThan
                  else Unordered end
              GreaterThan =>
                  if r SUBSETEQ right then
                       GreaterThan
                  else Unordered end
          end
      end

   concat(t2:NodeSet[\E\]):Set[\E\] = do
      (min, delmin) = t2.removeMinimum()
      concat3(min, delmin)
   end
   concat(t2:Set[\E\]):Set[\E\] = self

   splitIndex(x:ZZ32):(Set[\E\],Set[\E\]) =
      if x < |left| then
        (ll,rl) = left.splitIndex(x)
        (ll,rl.concat3(val,right))
      elif |left| < x then
        (lr,rr) = right.splitIndex(x - |left| - 1)
        (left.concat3(val,lr),rr)
      else
        (left,right.add(val))
      end

   splitAt(x:E):(Set[\E\],Boolean,Set[\E\]) =
      if x < val then
        (ll,m,rl) = left.splitAt(x)
        (ll,m,rl.concat3(val,right))
      elif val < x then
        (lr,m,rr) = right.splitAt(x)
        (left.concat3(val,lr),m,rr)
      else (left,true,right)
      end

   concat3(v:E, t2:NodeSet[\E\]) = do
      v1 = val
      n1 = sz
      l1 = left
      r1 = right
      v2 = t2.getVal()
      n2 = |t2|
      l2 = t2.getLeftChild()
      r2 = t2.getRightChild()
      if   weight n1 < n2 then balancedAdd(v2,concat3(v,l2),r2)
      elif weight n2 < n1 then balancedAdd(v1,l1,r1.concat3(v,t2))
      else NodeSet[\E\](v,self,t2) end
   end
   concat3(v:E, t2:Set[\E\]) = add(v)

   balancedAdd(val:E,  left:Set[\E\], right:Set[\E\]):NodeSet[\E\] = do
      ln = |left|
      rn = |right|
      if ln + rn < weight then NodeSet[\E\](val, left, right)
      elif rn > weight ln then do
         rl = right.getLeftChild()
         rr = right.getRightChild()
         rln = |rl|
         rrn = |rr|
         if rln < rrn then single_L(val, left, right) else double_L(val, left, right) end
         end
      elif ln > weight rn then do
         ll = left.getLeftChild()
         lr = left.getRightChild()
         lln = |ll|
         lrn = |lr|
         if (lrn < lln) then single_R(val, left, right) else double_R(val,left,right) end
         end
      else NodeSet[\E\](val,left,right) end
   end

   single_L(val:E,  left:Set[\E\], right:Set[\E\]):NodeSet[\E\] = do
      a = val
      x = left
      b = right.getVal()
      y = right.getLeftChild()
      z = right.getRightChild()
      NodeSet[\E\](b, NodeSet[\E\](a, x, y), z)
   end

   single_R(val:E,  left:Set[\E\], right:Set[\E\]):NodeSet[\E\] = do
      b = val
      a = left.getVal()
      x = left.getLeftChild()
      y = left.getRightChild()
      z = right
      NodeSet[\E\](a,x,NodeSet[\E\](b,y,z))
   end

   double_L(val:E,  left:Set[\E\], right:Set[\E\]):NodeSet[\E\] = do
      a = val
      x = left
      c = right.getVal()
      b = right.getLeftChild().getVal()
      y1 = right.getLeftChild().getLeftChild()
      y2 = right.getLeftChild().getRightChild()
      z = right.getRightChild()
      (* println("double_L " a " " b) *)
      NodeSet[\E\](b, NodeSet[\E\](a,x,y1),NodeSet[\E\](c,y2,z))
   end

   double_R(val:E,  left:Set[\E\], right:Set[\E\]):NodeSet[\E\] = do
      c = val
      a = left.getVal()
      x = left.getLeftChild()
      b = left.getRightChild().getVal()
      y1 = left.getRightChild().getLeftChild()
      y2 = left.getRightChild().getRightChild()
      z = right
      (* println("double_R " a " " b " " c) *)
      NodeSet[\E\](b, NodeSet[\E\](a, x,y1), NodeSet[\E\](c,y2,z))
   end
end

end
