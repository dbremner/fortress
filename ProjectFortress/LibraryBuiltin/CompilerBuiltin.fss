(*******************************************************************************
    Copyright 2008,2011, Oracle and/or its affiliates.
    All rights reserved.


    Use is subject to license terms.

    This distribution may include materials developed by third parties.

 ******************************************************************************)

component CompilerBuiltin
import java com.sun.fortress.nativeHelpers.{simplePrintln.nativePrint => jPrint,
                                            simplePrintln.nativePrintln => jPrintln,
                                            simplePrintln.nativeErrorPrint => jErrorPrint,
                                            simplePrintln.nativeErrorPrintln => jErrorPrintln}
import java com.sun.fortress.nativeHelpers.{simpleConcatenate.nativeConcatenate => jConcatenate,
                                            simpleConcatenate.nativeStrlen => jStrlen}
import java com.sun.fortress.nativeHelpers.{simpleBoolean.booleanAnd => jBooleanAnd,
                                            simpleBoolean.booleanOr => jBooleanOr,
                                            simpleBoolean.booleanXor => jBooleanXor,
                                            simpleBoolean.booleanEqv => jBooleanEqv,
                                            simpleBoolean.booleanNot => jBooleanNot}
import java com.sun.fortress.nativeHelpers.{simpleIntArith.intToString => jIntToString,
                                            simpleIntArith.intAdd => jIntAdd,
                                            simpleIntArith.intSub => jIntSub,
                                            simpleIntArith.intMul => jIntMul,
                                            simpleIntArith.intDiv => jIntDiv,
                                            simpleIntArith.intLT => jIntLT,
                                            simpleIntArith.intLE => jIntLE,
                                            simpleIntArith.intGT => jIntGT,
                                            simpleIntArith.intGE => jIntGE,
                                            simpleIntArith.intEQ => jIntEQ,
                                            simpleIntArith.intNeg => jIntNeg,
                                            simpleIntArith.parseInt => jParseInt,
                                            simpleIntArith.intAbs => jIntAbs,
                                            simpleIntArith.longToInt => jLongToInt}
import java com.sun.fortress.nativeHelpers.{simpleLongArith.longToString => jLongToString,
                                            simpleLongArith.longAdd => jLongAdd,
                                            simpleLongArith.longSub => jLongSub,
                                            simpleLongArith.longMul => jLongMul,
                                            simpleLongArith.longDiv => jLongDiv,
                                            simpleLongArith.longLT => jLongLT,
                                            simpleLongArith.longLE => jLongLE,
                                            simpleLongArith.longGT => jLongGT,
                                            simpleLongArith.longGE => jLongGE,
                                            simpleLongArith.longEQ => jLongEQ,
                                            simpleLongArith.longNeg => jLongNeg,
                                            simpleLongArith.parseLong => jParseLong,
                                            simpleLongArith.longAbs => jLongAbs,
                                            simpleLongArith.intToLong => jIntToLong}
import java com.sun.fortress.nativeHelpers.{simpleDoubleArith.floatToDouble => jFloatToDouble,
                                            simpleDoubleArith.doubleToString => jDoubleToString,
                                            simpleDoubleArith.doubleAdd => jDoubleAdd,
                                            simpleDoubleArith.doubleSub => jDoubleSub,
                                            simpleDoubleArith.doubleMul => jDoubleMul,
                                            simpleDoubleArith.doubleDiv => jDoubleDiv,
                                            simpleDoubleArith.doubleLT => jDoubleLT,
                                            simpleDoubleArith.doubleLE => jDoubleLE,
                                            simpleDoubleArith.doubleGT => jDoubleGT,
                                            simpleDoubleArith.doubleGE => jDoubleGE,
                                            simpleDoubleArith.doubleEQ => jDoubleEQ,
                                            simpleDoubleArith.doubleNeg => jDoubleNeg,
                                            simpleDoubleArith.parseDouble => jParseDouble,
                                            simpleDoubleArith.doubleAbs => jDoubleAbs,
                                            simpleDoubleArith.doublePow => jDoublePow,
                                            simpleDoubleArith.doubleNanoTime => jNanoTime}
import java com.sun.fortress.nativeHelpers.{simpleChar.charToString => jCharToString,
                                            simpleChar.charToExprString => jCharToExprString,
                                            simpleChar.charCodePointWithSpecialCompilerHackForCharacterArgumentType => jCodePoint,
                                            simpleChar.charMakeCharacterWithSpecialCompilerHackForCharacterResultType => jMakeCharacter,
                                            simpleChar.charLT => jCharLT,
                                            simpleChar.charLE => jCharLE,
                                            simpleChar.charGT => jCharGT,
                                            simpleChar.charGE => jCharGE,
                                            simpleChar.charEQ => jCharEQ,
                                            simpleChar.charNE => jCharNE,
                                            simpleChar.charLessNotSim => jCharLessNotSim,
                                            simpleChar.charLessSim => jCharLessSim,
                                            simpleChar.charGreaterNotSim => jCharGreaterNotSim,
                                            simpleChar.charGreaterSim => jCharGreaterSim,
                                            simpleChar.charSimEq => jCharSimEq,
                                            simpleChar.charNotSimEq => jCharNotSimEq,
                                            simpleChar.charGetDirectionality => jCharGetDirectionality,
                                            simpleChar.charGetNumericValue => jCharGetNumericValue,
                                            simpleChar.charGetType => jCharGetType,
                                            simpleChar.charIsDefined => jCharIsDefined,
                                            simpleChar.charIsDigit => jCharIsDigit,
                                            simpleChar.charIsFortressIdentifierPart => jCharIsFortressIdentifierPart,
                                            simpleChar.charIsFortressIdentifierStart => jCharIsFortressIdentifierStart,
                                            simpleChar.charIsHighSurrogate => jCharIsHighSurrogate,
                                            simpleChar.charIsIdentifierIgnorable => jCharIsIdentifierIgnorable,
                                            simpleChar.charIsISOControl => jCharIsISOControl,
                                            simpleChar.charIsJavaIdentifierPart => jCharIsJavaIdentifierPart,
                                            simpleChar.charIsJavaIdentifierStart => jCharIsJavaIdentifierStart,
                                            simpleChar.charIsLetter => jCharIsLetter,
                                            simpleChar.charIsLetterOrDigit => jCharIsLetterOrDigit,
                                            simpleChar.charIsLowerCase => jCharIsLowerCase,
                                            simpleChar.charIsLowSurrogate => jCharIsLowSurrogate,
                                            simpleChar.charIsMirrored => jCharIsMirrored,
                                            simpleChar.charIsSpaceChar => jCharIsSpaceChar,
                                            simpleChar.charIsSupplementaryCodePoint => jCharIsSupplementaryCodePoint,
                                            simpleChar.charIsSurrogatePair => jCharIsSurrogatePair,
                                            simpleChar.charIsTitleCase => jCharIsTitleCase,
                                            simpleChar.charIsUnicodeIdentifierPart => jCharIsUnicodeIdentifierPart,
                                            simpleChar.charIsUnicodeIdentifierStart => jCharIsUnicodeIdentifierStart,
                                            simpleChar.charIsUpperCase => jCharIsUpperCase,
                                            simpleChar.charIsValidCodePoint => jCharIsValidCodePoint,
                                            simpleChar.charIsWhitespace => jCharIsWhitespace,
                                            simpleChar.charJavaDigit => jCharJavaDigit,
                                            simpleChar.charToLowerCase => jCharToLowerCase,
                                            simpleChar.charToTitleCase => jCharToTitleCase,
                                            simpleChar.charToUpperCase => jCharToUpperCase}
import java com.sun.fortress.nativeHelpers.{LocalRandom.localRandomDouble => jRandomDouble,
                                            LocalRandom.localRandomInt => jRandomInt }
import java com.sun.fortress.nativeHelpers.{stringOps.compareTo => jCompareTo,
                                            stringOps.substring => jSubstring,
                                            stringOps.charAt => jCharAt,
                                            stringOps.asString => jAsString}
import java com.sun.fortress.nativeHelpers.{fileOps.jbrOpen => jJavaBufferedReaderOpen,
                                            fileOps.jbrAsString => jJavaBufferedReaderAsString,
                                            fileOps.jbrRead => jJavaBufferedReaderRead,
                                            fileOps.jbrReadLine => jJavaBufferedReaderReadLine,
                                            fileOps.jbrReadk => jJavaBufferedReaderReadk,
                                            fileOps.jbrEof => jJavaBufferedReaderEof,
                                            fileOps.jbrReady => jJavaBufferedReaderReady,
                                            fileOps.jbrClose => jJavaBufferedReaderClose,
                                            fileOps.jbrWhenUnconsumed => jJavaBufferedReaderWhenUnconsumed,
                                            fileOps.jbrConsume => jJavaBufferedReaderConsume,
                                            fileOps.jbwOpen => jJavaBufferedWriterOpen,
                                            fileOps.jbwAsString => jJavaBufferedWriterAsString,
                                            fileOps.jbwWriteChar => jJavaBufferedWriterWriteChar,
                                            fileOps.jbwWriteString => jJavaBufferedWriterWriteString,
                                            fileOps.jbwNewLine => jJavaBufferedWriterNewLine,
                                            fileOps.jbwFlush => jJavaBufferedWriterFlush,
                                            fileOps.jbwClose => jJavaBufferedWriterClose }


import AnyType.{Any}
import CompilerAlgebra.{ Equality }
export CompilerBuiltin

nanoTime(): RR64 = jNanoTime()

trait Object extends Any
   getter asString(): String = jAsString(self)
   getter asExprString(): String = "[no expression for "  self.asString "]"
   getter asDebugString(): String = self.asString
(*)     getter asDebugString(): String  = do  (* for debugging; may contain more information *)
(*)         ilk = self.ilkName
(*)         firstChar = ilk[0]
(*)         article = if firstChar = 'a' OR: firstChar = 'e' OR: firstChar = 'i' OR: firstChar = 'o' then "an " else "a " end
(*)         article ilk ": " self.asString
(*)         self.asString
(*) end
end Object

trait String
    getter isEmpty(): Boolean = (jStrlen(self) = 0)
    getter asString(): String = self
    opr |self| : ZZ32 = jStrlen(self)
    opr <(self, b: String) = (jCompareTo(self, b) < 0)
    opr =(self, b: String) = (jCompareTo(self, b) = 0)
    opr ||(self, b:String): String =  jConcatenate(self, b)
    opr juxtaposition(self, b:String): String = jConcatenate(self, b)
    opr [i:ZZ32] : ZZ32 = jCharAt(self, i)
    substring(lo:ZZ32, hi:ZZ32):String = jSubstring(self, lo, hi)
end

object FlatString extends String
end FlatString

println(s:String):() = jPrintln(s)
println(c:Character):() = jPrintln(c.asString)
(*) println(x:Object): () = jPrintln(x.asString)
(*) println():() = jPrintln("")
(*) println(x:Any):() = jPrintln("<any>")

println(x:ZZ32):() = jPrintln(x.asString)
println(x:ZZ64):() = jPrintln(x.asString)
(*) println(x:RR32):() = jPrintln(x.asString)
println(x:RR64):() = jPrintln(x.asString)
(*) println(x: (Any, Any)):() = jPrintln(str(x))
(*) println(x: (Any, Any, Any)):() = jPrintln(str(x))
(*) println(x: (Any, Any, Any, Any)):() = jPrintln(str(x))
(*) println[\A,B,C,D,E\](x: (A,B,C,D,E)):() = jPrintln(str(x))
(*) println[\A,B,C,D,E,F\](x: (A,B,C,D,E,F)):() = jPrintln(str(x))
(*) println[\A,B,C,D,E,F,G\](x: (A,B,C,D,E,F,G)):() = jPrintln(str(x))

errorPrintln(s:String):() = jErrorPrintln(s)
errorPrintln(c:Character):() = jErrorPrintln(c.asString)
(*) errorPrintln(x:Object): () = jErrorPrintln(x.asString)
(*) errorPrintln():() = jErrorPrintln("")
(*) errorPrintln(x:Any):() = jErrorPrintln("<big tuple>")

errorPrintln(x:ZZ32):() = jErrorPrintln(x.asString)
errorPrintln(x:ZZ64):() = jErrorPrintln(x.asString)
(*) errorPrintln(x:RR32):() = jErrorPrintln(x.asString)
errorPrintln(x:RR64):() = jErrorPrintln(x.asString)
(*) errorPrintln[\A,B\](x: (A,B)):() = jErrorPrintln(str(x))
(*) errorPrintln[\A,B,C\](x: (A,B,C)):() = jErrorPrintln(str(x))
(*) errorPrintln[\A,B,C,D\](x: (A,B,C,D)):() = jErrorPrintln(str(x))
(*) errorPrintln[\A,B,C,D,E\](x: (A,B,C,D,E)):() = jErrorPrintln(str(x))
(*) errorPrintln[\A,B,C,D,E,F\](x: (A,B,C,D,E,F)):() = jErrorPrintln(str(x))
(*) errorPrintln[\A,B,C,D,E,F,G\](x: (A,B,C,D,E,F,G)):() = jErrorPrintln(str(x))

(*) Utility routine for converting tuples to strings
(*) private str(x:Any):String = "<big tuple>"
(*) private str(x: Object):String = x.asString
(*) private str():String = "()"
(*) private str(x: (Any, Any)):String = do (a,b) = x; "(" str(a) ", " str(b) ")" end
(*) private str(x: (Any, Any, Any)):String = do (a,b,c) = x; "(" str(a) ", " str(b) ", " str(c) ")" end
(*) private str(x: (Any, Any, Any, Any)):String = do (a,b,c,d) = x; "(" str(a) ", " str(b) ", " str(c) ", " str(d) ")" end
(*) private str[\A,B,C,D,E\](x: (A,B,C,D,E)):String = do (a,b,c,d,e) = x; "(" str(a) ", " str(b) ", " str(c) ", " str(d) ", " str(e) ")" end
(*) private str[\A,B,C,D,E,F\](x: (A,B,C,D,E,F)):String = do (a,b,c,d,e,f) = x; "(" str(a) ", " str(b) ", " str(c) ", " str(d) ", " str(e) ", " str(f) ")" end
(*) private str[\A,B,C,D,E,F,G\](x: (A,B,C,D,E,F,G)):String = do (a,b,c,d,e,f,g) = x; "(" str(a) ", " str(b) ", " str(c) ", " str(d) ", " str(e) ", " str(f) ", " str(g) ")" end

strToInt(s:String):ZZ32 = jParseInt(s)

trait Number excludes { String }
end

trait ZZ64 extends Number excludes { RR64 }
    coerce(x: IntLiteral) = x.asZZ64
    coerce(x: ZZ32) = jIntToLong(x)
    getter asZZ32(): ZZ32 = jLongToInt(self)
    getter asString(): String = jLongToString(self)
    opr |self| : ZZ64 = jLongAbs(self)
    opr -(self): ZZ64 = jLongNeg(self)
    opr +(self, other:ZZ64): ZZ64 = jLongAdd(self,other)
    opr -(self, other:ZZ64): ZZ64 = jLongSub(self,other)
    opr <(self, other:ZZ64): Boolean = jLongLT(self,other)
    opr <=(self, other:ZZ64): Boolean = jLongLE(self,other)
    opr >(self, other:ZZ64): Boolean = jLongGT(self,other)
    opr >=(self, other:ZZ64): Boolean = jLongGE(self,other)
    opr =(self, other:ZZ64): Boolean = jLongEQ(self,other)
    opr juxtaposition(self, other:ZZ64): ZZ64 = jLongMul(self,other)
    opr DOT(self, other:ZZ64): ZZ64 = jLongMul(self,other)
    opr DIV(self, other:ZZ64): ZZ64 = jLongDiv(self,other)
end

trait ZZ32 extends Number excludes { ZZ64, RR32, RR64 }
    coerce(x: IntLiteral) = x.asZZ32
    getter asZZ32(): ZZ32 = self
    getter asString(): String = jIntToString(self)
    opr |self| : ZZ32 = jIntAbs(self)
    opr -(self): ZZ32 = jIntNeg(self)
    opr +(self, other:ZZ32): ZZ32 = jIntAdd(self,other)
    opr -(self, other:ZZ32): ZZ32 = jIntSub(self,other)
    opr <(self, other:ZZ32): Boolean = jIntLT(self,other)
    opr <=(self, other:ZZ32): Boolean = jIntLE(self,other)
    opr >(self, other:ZZ32): Boolean = jIntGT(self,other)
    opr >=(self, other:ZZ32): Boolean = jIntGE(self,other)
    opr =(self, other:ZZ32): Boolean = jIntEQ(self,other)
    opr juxtaposition(self, other:ZZ32): ZZ32 = jIntMul(self,other)
    opr DOT(self, other:ZZ32): ZZ32 = jIntMul(self,other)
    opr DIV(self, other:ZZ32): ZZ32 = jIntDiv(self,other)
end

trait IntLiteral excludes {ZZ32, ZZ64}
    getter asZZ32(): ZZ32
    getter asZZ64(): ZZ64
(*
    getter asNN32(): NN32
    getter asZZ(): ZZ
    getter asRR32(): RR32
*)
    getter asRR64(): RR64
end

trait RR64 extends Number excludes ZZ64
    coerce(x: FloatLiteral) = x.asRR64
    coerce(x: RR32) = jFloatToDouble(x)
    getter asString(): String = jDoubleToString(self)
    opr |self| : RR64 = jDoubleAbs(self)
    opr -(self): RR64 = jDoubleNeg(self)
    opr +(self, other:RR64): RR64 = jDoubleAdd(self,other)
    opr -(self, other:RR64): RR64 = jDoubleSub(self,other)
    opr <(self, other:RR64): Boolean = jDoubleLT(self,other)
    opr <=(self, other:RR64): Boolean = jDoubleLE(self,other)
    opr >(self, other:RR64): Boolean = jDoubleGT(self,other)
    opr >=(self, other:RR64): Boolean = jDoubleGE(self,other)
    opr =(self, other:RR64): Boolean = jDoubleEQ(self,other)
    opr juxtaposition(self, other:RR64): RR64 = jDoubleMul(self,other)
    opr DOT(self, other:RR64): RR64 = jDoubleMul(self,other)
    opr /(self, other:RR64): RR64 = jDoubleDiv(self,other)
    opr ^(self, other:RR64): RR64 = jDoublePow(self,other)
    opr ^(self, other:ZZ32): RR64 =
        if other > 2 then
            mid = other DIV 2
            if (mid + mid) = other then
                (self self)^mid
            else
                self (self self)^mid
            end
        elif other = 2 then self self
        elif other = 1 then self
        elif other = 0 then 1.0
        elif other = -other then
          (* Screw case of most negative `ZZ32` value *)
          1.0 / (self^(-(other DIV 2)))^2

        else (* other < 0 then *) 1.0 / (self^(-other))
        end
end

trait RR32 extends Number excludes { ZZ64, ZZ32, RR64 }
    coerce(x: FloatLiteral) = x.asRR32
end

trait FloatLiteral excludes {RR32, RR64}
    getter asRR32(): RR32
    getter asRR64(): RR64
end

trait Boolean      extends { Equality[\Boolean\] }
    excludes { String, Number }
  getter holds(): Boolean = self
  getter get(): () = ()
  getter asString(): String = self.asExprString
  getter asExprString(): String = if self then "true" else "false" end
  getter size(): ZZ32 = |self|
  opr |self| : ZZ32 = if self then 1 else 0 end
(*)   cond[\R\](t:()->R, e:()->R) : R = if self then t() else e() end
(*)   generate[\R\](r:Reduction[\R\],b:()->R): R =
(*)       if self then b() else r.empty() end
(*)   map[\G\](f: ()->G): Maybe[\G\] =
(*)       if self then Just[\G\](f()) else Nothing[\G\] end
(*)   cross[\G\](g: Generator[\G\]): Generator[\((),G)\] =
(*)       if self
(*)       then g.map[\((),G)\](fn (e:G):((),G) => ((),e))
(*)       else Nothing[\((),G)\] end

(*)   mapReduce[\R\](b: ()->R, _:(R,R)->R, z:R): R =
(*)       if self then b() else z end
(*)   loop(f:()->()): () = if self then f() end

  opr NOT(self):Boolean = jBooleanNot(self)
  opr AND(self, other:Boolean):Boolean = jBooleanAnd(self, other)
  opr AND(self, other:()->Boolean):Boolean = if self then other() else self end
  opr OR(self, other:Boolean):Boolean = jBooleanOr(self, other)
  opr OR(self, other:()->Boolean):Boolean = if self then self else other() end
  opr XOR(self, other:Boolean):Boolean = jBooleanXor(self, other)
  opr OPLUS(self, other:Boolean):Boolean = jBooleanXor(self, other)
  opr NEQV(self, other:Boolean):Boolean = jBooleanXor(self, other)
  opr EQV(self, other:Boolean):Boolean = jBooleanEqv(self, other)
  opr <->(self, other:Boolean):Boolean = jBooleanEqv(self, other)
  opr ->(self, other:Boolean):Boolean = (NOT self) OR other
  opr NAND(self, other:Boolean):Boolean = NOT (self AND other)
  opr NOR(self, other:Boolean):Boolean = NOT (self OR other)

  opr =(self, other:Boolean): Boolean = jBooleanEqv(self, other)
(*)   opr <(self, other:Boolean): Boolean = (NOT self) AND other
(*)   opr CMP(self, other:Boolean): TotalComparison =
(*)       if self then
(*)           if other then EqualTo else GreaterThan end
(*)       else
(*)           if other then LessThan else EqualTo end
(*)       end
end

true: Boolean = (0=0)
false: Boolean = (0=1)

makeCharacter(n: ZZ32): Character = jMakeCharacter(n)

trait Character excludes { String, Number, Boolean }
    getter asString() : String = jCharToString(jCodePoint(self))
    getter asExprString() : String = jCharToExprString(jCodePoint(self))
    getter codePoint(): ZZ32 = jCodePoint(self)

    opr <(self, other:Character): Boolean = jCharLT(jCodePoint(self), jCodePoint(other))
    opr <=(self, other:Character): Boolean = jCharLE(jCodePoint(self), jCodePoint(other))
    opr >(self, other:Character): Boolean = jCharGT(jCodePoint(self), jCodePoint(other))
    opr >=(self, other:Character): Boolean = jCharGE(jCodePoint(self), jCodePoint(other))
    opr =(self, other:Character): Boolean = jCharEQ(jCodePoint(self), jCodePoint(other))
    opr =/=(self, other:Character): Boolean = jCharNE(jCodePoint(self), jCodePoint(other))

    opr LNSIM(self, other:Character): Boolean = jCharLessNotSim(jCodePoint(self), jCodePoint(other))
    opr LESSSIM(self, other:Character): Boolean = jCharLessSim(jCodePoint(self), jCodePoint(other))
    opr GNSIM(self, other:Character): Boolean = jCharGreaterNotSim(jCodePoint(self), jCodePoint(other))
    opr GTRSIM(self, other:Character): Boolean = jCharGreaterSim(jCodePoint(self), jCodePoint(other))
    opr SIMEQ(self, other:Character): Boolean = jCharSimEq(jCodePoint(self), jCodePoint(other))
    opr NSIMEQ(self, other:Character): Boolean = jCharNotSimEq(jCodePoint(self), jCodePoint(other))

    getDirectionality(self): ZZ32 = jCharGetDirectionality(jCodePoint(self))
    getNumericValue(self): ZZ32 = jCharGetNumericValue(jCodePoint(self))
    getType(self): ZZ32 = jCharGetType(jCodePoint(self))
    isDefined(self): Boolean = jCharIsDefined(jCodePoint(self))
    isDigit(self): Boolean = jCharIsDigit(jCodePoint(self))
    isFortressIdentifierPart(self): Boolean = jCharIsFortressIdentifierPart(jCodePoint(self))
    isFortressIdentifierStart(self): Boolean = jCharIsFortressIdentifierStart(jCodePoint(self))
    isHighSurrogate(self): Boolean = jCharIsHighSurrogate(jCodePoint(self))
    isIdentifierIgnorable(self): Boolean = jCharIsIdentifierIgnorable(jCodePoint(self))
    isISOControl(self): Boolean = jCharIsISOControl(jCodePoint(self))
    isJavaIdentifierPart(self): Boolean = jCharIsJavaIdentifierPart(jCodePoint(self))
    isJavaIdentifierStart(self): Boolean = jCharIsJavaIdentifierStart(jCodePoint(self))
    isLetter(self): Boolean = jCharIsLetter(jCodePoint(self))
    isLetterOrDigit(self): Boolean = jCharIsLetterOrDigit(jCodePoint(self))
    isLowerCase(self): Boolean = jCharIsLowerCase(jCodePoint(self))
    isLowSurrogate(self): Boolean = jCharIsLowSurrogate(jCodePoint(self))
    isMirrored(self): Boolean = jCharIsMirrored(jCodePoint(self))
    isSpaceChar(self): Boolean = jCharIsSpaceChar(jCodePoint(self))
    isSupplementaryCodePoint(self): Boolean = jCharIsSupplementaryCodePoint(jCodePoint(self))
    isSurrogatePair(self, low: Character): Boolean = jCharIsSurrogatePair(jCodePoint(self), jCodePoint(low))
    isTitleCase(self): Boolean = jCharIsTitleCase(jCodePoint(self))
    isUnicodeIdentifierPart(self): Boolean = jCharIsUnicodeIdentifierPart(jCodePoint(self))
    isUnicodeIdentifierStart(self): Boolean = jCharIsUnicodeIdentifierStart(jCodePoint(self))
    isUpperCase(self): Boolean = jCharIsUpperCase(jCodePoint(self))
    isValidCodePoint(self): Boolean = jCharIsValidCodePoint(jCodePoint(self))
    isWhitespace(self): Boolean = jCharIsWhitespace(jCodePoint(self))
    javaDigit(self, radix: ZZ32): ZZ32 = jCharJavaDigit(jCodePoint(self), radix)
    toLowerCase(self): Character = jMakeCharacter(jCharToLowerCase(jCodePoint(self)))
    toTitleCase(self): Character = jMakeCharacter(jCharToTitleCase(jCodePoint(self)))
    toUpperCase(self): Character = jMakeCharacter(jCharToUpperCase(jCodePoint(self)))
end

trait JavaBufferedReader excludes { String, Number, Boolean, Character }
  getter asString(): String = jJavaBufferedReaderAsString(self)
  read(): Character throws IOException = jMakeCharacter(jJavaBufferedReaderRead(self))
  readLine(): String throws IOException = jJavaBufferedReaderReadLine(self)
  readk(k: ZZ32): String throws IOException = jJavaBufferedReaderReadk(self, k)
  eof(): Boolean = jJavaBufferedReaderEof(self)
  ready(): Boolean throws IOException = jJavaBufferedReaderReady(self)
  close(): () throws IOException = jJavaBufferedReaderClose(self)
  whenUnconsumed(): () throws IOException = jJavaBufferedReaderWhenUnconsumed(self)
  consume(): () = jJavaBufferedReaderConsume(self)
end

makeJavaBufferedReader(s: String): JavaBufferedReader throws FileNotFoundException = jJavaBufferedReaderOpen(s)

trait   JavaBufferedWriter excludes { String, Number, Boolean, Character, JavaBufferedReader }
  getter asString(): String = jJavaBufferedWriterAsString(self)
  write(c: Character): () throws IOException = jJavaBufferedWriterWriteChar(self, jCodePoint(c))
  write(s: String): () throws IOException = jJavaBufferedWriterWriteString(self, s)
  newLine(): () throws IOException = jJavaBufferedWriterNewLine(self)
  flush(): () throws IOException = jJavaBufferedWriterFlush(self)
  close(): () throws IOException = jJavaBufferedWriterClose(self)
end

makeJavaBufferedWriter(s: String): JavaBufferedWriter throws FileNotFoundException = jJavaBufferedWriterOpen(s)


(************************************************************
* Comparison values
************************************************************)


(*
  The four values of type `Comparison` are `LessThan`, `EqualTo`, `GreaterThan`, and `Unordered`;
  they are used as the results of comparison operators such as `CMP` and `SQCMP`.

  The comparison operators `<` and `<=` and `>=` and `>` treat these four values themselves as
  being totally ordered in the order just given.

  The combining operator `LEXICO` combines two comparison values in a manner that is convenient
  for computing lexicographic order between two tuples:
    `((a, b, c) CMP (d, e, f)) = ((a CMP d) LEXICO (b CMP e) LEXICO (c CMP f))`

  The combining operator `SQCAP` combines two comparison values in a manner that is convenient
  for computing product order between two tuples:
    `((a, b, c) SQCMP (d, e, f)) = ((a CMP d) SQCAP (b CMP e) SQCAP (c CMP f))`

  The unary operator `CONVERSE` converts a comparison result to the result that would have
  occurred with the operands switched:
    `CONVERSE (a CMP b) = (b CMP a)`
 *)

trait Comparison
(*)        extends { StandardPartialOrder[\Comparison\] }
(*)          extends { SnerdEquality[\Comparison\] }
        extends { Equality[\Comparison\] }
        comprises { Unordered, TotalComparison }
        excludes { String, Number, Boolean, Character, JavaBufferedReader, JavaBufferedWriter }
    getter asExprString(): String = self.asString
    (*) Default opr = is suitable for Comparison
    (** Lexicographic ordering.  An associative operator.
        Leftmost non-equal comparison dictates result. *)
    opr LEXICO(self, other:Comparison): Comparison =
        if self=EqualTo then other else self end
    opr LEXICO(self, other:()->Comparison): Comparison =
        if self=EqualTo then other() else self end
    (** Symmetric comparison (product ordering).  A commutative
        and associative operator. *)
    opr SQCAP(self, other:Comparison): Comparison = Unordered
    opr SQCAP(self, other:()->Comparison): Comparison = self SQCAP other()
    opr CONVERSE(self): Comparison = Unordered
    (*) This stuff ought to be provided by Equality[\Comparison\].
    opr =(self, other:Comparison): Boolean = (self === other)
    (*) This stuff ought to be provided by StandardPartialOrder[\Comparison\].
    opr CMP(self, other:Comparison): Comparison =
        if self < other then LessThan
        elif other < self then GreaterThan
        elif self = other then EqualTo
        else Unordered
        end
    opr <(self, other:Comparison): Boolean
    opr >(self, other:Comparison): Boolean = (other < self)
    opr <=(self, other:Comparison): Boolean = (self = other OR: self < other)
    opr >=(self, other:Comparison): Boolean = (other <= self)
end

(** Unordered is the outcome of a CMP b when a and b are partially
    ordered and no ordering relationship exists between them. **)
object Unordered extends Comparison
    getter asString(): String = "Unordered"
    opr <(self, other:Comparison): Boolean = false
    opr SQCAP(self, other:()->Comparison): Comparison = Unordered
    opr CONVERSE(self): Comparison = Unordered
end

trait TotalComparison
(*)     extends { Comparison, StandardTotalOrder[\TotalComparison\] }
        extends { Comparison }
        comprises { LessThan, EqualTo, GreaterThan }
    (* We're both a partial order (including Unordered) and a total
       order (TotalComparison alone).  Avoid ambiguity between the
       default definitions of CMP and >=. *)
    opr CMP(self, other:Unordered): Comparison = Unordered
    opr CMP(self, other:TotalComparison): TotalComparison =
        if self < other then LessThan
        elif other < self then GreaterThan
        else EqualTo
        end
    opr <(self, other:Unordered): Boolean = false
    opr >=(self, other:Unordered): Boolean = false
    opr >=(self, other:Comparison): Boolean = NOT (other < self)
    opr LEXICO(self, other:TotalComparison): TotalComparison =
        if self=EqualTo then other else self end
    opr LEXICO(self, other:()->TotalComparison): TotalComparison =
        if self=EqualTo then other() else self end
    opr CONVERSE(self): TotalComparison = EqualTo
end

object LessThan extends TotalComparison
    getter asString(): String = "LessThan"
    opr CMP(self, other:LessThan): TotalComparison = EqualTo
    opr CMP(self, other:TotalComparison): TotalComparison = GreaterThan
    opr <(self, other:LessThan): Boolean = false
    opr <(self, other:TotalComparison): Boolean = true
    opr SQCAP(self, other:LessThan): LessThan = LessThan
    opr SQCAP(self, other:EqualTo): LessThan = LessThan
    opr CONVERSE(self): GreaterThan = GreaterThan
end

object EqualTo extends TotalComparison
    getter asString(): String = "EqualTo"
    opr CMP(self, other:TotalComparison): TotalComparison = CONVERSE other
    opr <(self, other:GreaterThan): Boolean = true
    opr <(self, other:TotalComparison): Boolean = false
    opr SQCAP(self, other: Comparison): Comparison = other
    opr CONVERSE(self): EqualTo = EqualTo
end

object GreaterThan extends TotalComparison
    getter asString(): String = "GreaterThan"
    opr CMP(self, other:GreaterThan): TotalComparison = EqualTo
    opr CMP(self, other:TotalComparison): TotalComparison = LessThan
    opr <(self, other:TotalComparison): Boolean = false
    opr SQCAP(self, other:GreaterThan): GreaterThan = GreaterThan
    opr SQCAP(self, other:EqualTo): GreaterThan = GreaterThan
    opr CONVERSE(self): LessThan = LessThan
end


(************************************************************
* Exception hierarchy
************************************************************)

trait Exception comprises { UncheckedException, CheckedException }
end

trait UncheckedException extends Exception excludes CheckedException
end

trait CheckedException extends Exception excludes UncheckedException
end

trait IOException extends CheckedException
end

object IOFailure(s: String) extends IOException
    getter asString(): String = "[I/O failure: " s "]"
end

object FileNotFoundException(s: String) extends IOException
    getter asString(): String = "[File not found: " s "]"
end


(************************************************************
* Random numbers
************************************************************)

random(i:RR64): RR64 = jRandomDouble(i)
randomZZ32(x:ZZ32): ZZ32 = jRandomInt(0,x)

end
