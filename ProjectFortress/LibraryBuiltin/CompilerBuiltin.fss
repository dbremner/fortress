(*******************************************************************************
    Copyright 2008,2011, Oracle and/or its affiliates.
    All rights reserved.


    Use is subject to license terms.

    This distribution may include materials developed by third parties.

 ******************************************************************************)

component CompilerBuiltin
import java com.sun.fortress.nativeHelpers.{simplePrintln.nativePrint => jPrint,
                                            simplePrintln.nativePrintln => jPrintln,
                                            simplePrintln.nativeErrorPrint => jErrorPrint,
                                            simplePrintln.nativeErrorPrintln => jErrorPrintln}
import java com.sun.fortress.nativeHelpers.{simpleConcatenate.nativeConcatenate => jConcatenate,
                                            simpleConcatenate.nativeStrlen => jStrlen}
import java com.sun.fortress.nativeHelpers.{simpleBoolean.booleanAnd => jBooleanAnd,
                                            simpleBoolean.booleanOr => jBooleanOr,
                                            simpleBoolean.booleanXor => jBooleanXor,
                                            simpleBoolean.booleanEqv => jBooleanEqv,
                                            simpleBoolean.booleanNot => jBooleanNot}
import java com.sun.fortress.nativeHelpers.{simpleIntArith.intToString => jIntToString,
                                            simpleIntArith.parseInt => jParseInt,
                                            simpleIntArith.intAdd => jIntAdd,
                                            simpleIntArith.intSub => jIntSub,
                                            simpleIntArith.intMul => jIntMul,
                                            simpleIntArith.intDiv => jIntDiv,
                                            simpleIntArith.intNeg => jIntNeg,
                                            simpleIntArith.intAbs => jIntAbs,
                                            simpleIntArith.longToInt => jLongToInt,
                                            simpleIntArith.intOverflowingAdd => jIntOverflowingAdd,
                                            simpleIntArith.intOverflowingSub => jIntOverflowingSub,
                                            simpleIntArith.intOverflowingMul => jIntOverflowingMul,
                                            simpleIntArith.intOverflowingDiv => jIntOverflowingDiv,
                                            simpleIntArith.intOverflowingNeg => jIntOverflowingNeg,
                                            simpleIntArith.intOverflowingAbs => jIntOverflowingAbs,
                                            simpleIntArith.longOverflowingToInt => jLongOverflowingToInt,
                                            simpleIntArith.intOverflowingChoose => jIntOverflowingChoose,
                                            simpleIntArith.intWrappingAdd => jIntWrappingAdd,
                                            simpleIntArith.intWrappingSub => jIntWrappingSub,
                                            simpleIntArith.intWrappingMul => jIntWrappingMul,
                                            simpleIntArith.intWrappingDiv => jIntWrappingDiv,
                                            simpleIntArith.intWrappingNeg => jIntWrappingNeg,
                                            simpleIntArith.intWrappingAbs => jIntWrappingAbs,
                                            simpleIntArith.longWrappingToInt => jLongWrappingToInt,
                                            simpleIntArith.intSaturatingAdd => jIntSaturatingAdd,
                                            simpleIntArith.intSaturatingSub => jIntSaturatingSub,
                                            simpleIntArith.intSaturatingMul => jIntSaturatingMul,
                                            simpleIntArith.intSaturatingDiv => jIntSaturatingDiv,
                                            simpleIntArith.intSaturatingNeg => jIntSaturatingNeg,
                                            simpleIntArith.intSaturatingAbs => jIntSaturatingAbs,
                                            simpleIntArith.longSaturatingToInt => jLongSaturatingToInt,
                                            simpleIntArith.intLT => jIntLT,
                                            simpleIntArith.intLE => jIntLE,
                                            simpleIntArith.intGT => jIntGT,
                                            simpleIntArith.intGE => jIntGE,
                                            simpleIntArith.intEQ => jIntEQ,
                                            simpleIntArith.intBitNot => jIntBitNot,
                                            simpleIntArith.intBitAnd => jIntBitAnd,
                                            simpleIntArith.intBitOr => jIntBitOr,
                                            simpleIntArith.intBitXor => jIntBitXor,
                                            simpleIntArith.intExp => jIntExp,
                                            simpleIntArith.intToDouble => jIntToDouble}
import java com.sun.fortress.nativeHelpers.{simpleUnsignedIntArith.makeNN32FromZZ32WithSpecialCompilerHackForNN32ResultType => jMakeNN32FromZZ32,
                                            simpleUnsignedIntArith.makeZZ32FromNN32WithSpecialCompilerHackForNN32ArgumentType => jMakeZZ32FromNN32,
                                            simpleUnsignedIntArith.unsignedIntToString => jUnsignedIntToString,
                                            simpleUnsignedIntArith.parseUnsignedInt => jParseUnsignedInt,
                                            simpleUnsignedIntArith.unsignedIntOverflowingAdd => jUnsignedIntOverflowingAdd,
                                            simpleUnsignedIntArith.unsignedIntOverflowingSub => jUnsignedIntOverflowingSub,
                                            simpleUnsignedIntArith.unsignedIntOverflowingMul => jUnsignedIntOverflowingMul,
                                            simpleUnsignedIntArith.unsignedIntOverflowingDiv => jUnsignedIntOverflowingDiv,
                                            simpleUnsignedIntArith.unsignedIntOverflowingNeg => jUnsignedIntOverflowingNeg,
                                            simpleUnsignedIntArith.unsignedIntOverflowingAbs => jUnsignedIntOverflowingAbs,
                                            simpleUnsignedIntArith.longOverflowingToUnsignedInt => jLongOverflowingToUnsignedInt,
                                            simpleUnsignedIntArith.unsignedIntOverflowingChoose => jUnsignedIntOverflowingChoose,
                                            simpleUnsignedIntArith.unsignedIntWrappingAdd => jUnsignedIntWrappingAdd,
                                            simpleUnsignedIntArith.unsignedIntWrappingSub => jUnsignedIntWrappingSub,
                                            simpleUnsignedIntArith.unsignedIntWrappingMul => jUnsignedIntWrappingMul,
                                            simpleUnsignedIntArith.unsignedIntWrappingDiv => jUnsignedIntWrappingDiv,
                                            simpleUnsignedIntArith.unsignedIntWrappingNeg => jUnsignedIntWrappingNeg,
                                            simpleUnsignedIntArith.unsignedIntWrappingAbs => jUnsignedIntWrappingAbs,
                                            simpleUnsignedIntArith.longWrappingToUnsignedInt => jLongWrappingToUnsignedInt,
                                            simpleUnsignedIntArith.unsignedIntSaturatingAdd => jUnsignedIntSaturatingAdd,
                                            simpleUnsignedIntArith.unsignedIntSaturatingSub => jUnsignedIntSaturatingSub,
                                            simpleUnsignedIntArith.unsignedIntSaturatingMul => jUnsignedIntSaturatingMul,
                                            simpleUnsignedIntArith.unsignedIntSaturatingDiv => jUnsignedIntSaturatingDiv,
                                            simpleUnsignedIntArith.unsignedIntSaturatingNeg => jUnsignedIntSaturatingNeg,
                                            simpleUnsignedIntArith.unsignedIntSaturatingAbs => jUnsignedIntSaturatingAbs,
                                            simpleUnsignedIntArith.longSaturatingToUnsignedInt => jLongSaturatingToUnsignedInt,
                                            simpleUnsignedIntArith.unsignedIntLT => jUnsignedIntLT,
                                            simpleUnsignedIntArith.unsignedIntLE => jUnsignedIntLE,
                                            simpleUnsignedIntArith.unsignedIntGT => jUnsignedIntGT,
                                            simpleUnsignedIntArith.unsignedIntGE => jUnsignedIntGE,
                                            simpleUnsignedIntArith.unsignedIntEQ => jUnsignedIntEQ,
                                            simpleUnsignedIntArith.unsignedIntBitNot => jUnsignedIntBitNot,
                                            simpleUnsignedIntArith.unsignedIntBitAnd => jUnsignedIntBitAnd,
                                            simpleUnsignedIntArith.unsignedIntBitOr => jUnsignedIntBitOr,
                                            simpleUnsignedIntArith.unsignedIntBitXor => jUnsignedIntBitXor,
                                            simpleUnsignedIntArith.unsignedIntExp => jUnsignedIntExp,
                                            simpleUnsignedIntArith.unsignedIntToDouble => jUnsignedIntToDouble}
import java com.sun.fortress.nativeHelpers.{simpleLongArith.longToString => jLongToString,
                                            simpleLongArith.parseLong => jParseLong,
                                            simpleLongArith.longAdd => jLongAdd,
                                            simpleLongArith.longSub => jLongSub,
                                            simpleLongArith.longMul => jLongMul,
                                            simpleLongArith.longDiv => jLongDiv,
                                            simpleLongArith.longNeg => jLongNeg,
                                            simpleLongArith.longAbs => jLongAbs,
                                            simpleLongArith.longOverflowingAdd => jLongOverflowingAdd,
                                            simpleLongArith.longOverflowingSub => jLongOverflowingSub,
                                            simpleLongArith.longOverflowingMul => jLongOverflowingMul,
                                            simpleLongArith.longOverflowingDiv => jLongOverflowingDiv,
                                            simpleLongArith.longOverflowingNeg => jLongOverflowingNeg,
                                            simpleLongArith.longOverflowingAbs => jLongOverflowingAbs,
                                            simpleLongArith.longOverflowingChoose => jLongOverflowingChoose,
                                            simpleLongArith.longWrappingAdd => jLongWrappingAdd,
                                            simpleLongArith.longWrappingSub => jLongWrappingSub,
                                            simpleLongArith.longWrappingMul => jLongWrappingMul,
                                            simpleLongArith.longWrappingDiv => jLongWrappingDiv,
                                            simpleLongArith.longWrappingNeg => jLongWrappingNeg,
                                            simpleLongArith.longWrappingAbs => jLongWrappingAbs,
                                            simpleLongArith.longSaturatingAdd => jLongSaturatingAdd,
                                            simpleLongArith.longSaturatingSub => jLongSaturatingSub,
                                            simpleLongArith.longSaturatingMul => jLongSaturatingMul,
                                            simpleLongArith.longSaturatingDiv => jLongSaturatingDiv,
                                            simpleLongArith.longSaturatingNeg => jLongSaturatingNeg,
                                            simpleLongArith.longSaturatingAbs => jLongSaturatingAbs,
                                            simpleLongArith.longLT => jLongLT,
                                            simpleLongArith.longLE => jLongLE,
                                            simpleLongArith.longGT => jLongGT,
                                            simpleLongArith.longGE => jLongGE,
                                            simpleLongArith.longEQ => jLongEQ,
                                            simpleLongArith.intToLong => jIntToLong,
                                            simpleLongArith.longBitNot => jLongBitNot,
                                            simpleLongArith.longBitAnd => jLongBitAnd,
                                            simpleLongArith.longBitOr => jLongBitOr,
                                            simpleLongArith.longBitXor => jLongBitXor}
import java com.sun.fortress.nativeHelpers.{simpleDoubleArith.floatToDouble => jFloatToDouble,
                                            simpleDoubleArith.doubleToString => jDoubleToString,
                                            simpleDoubleArith.doubleAdd => jDoubleAdd,
                                            simpleDoubleArith.doubleSub => jDoubleSub,
                                            simpleDoubleArith.doubleMul => jDoubleMul,
                                            simpleDoubleArith.doubleDiv => jDoubleDiv,
                                            simpleDoubleArith.doubleLT => jDoubleLT,
                                            simpleDoubleArith.doubleLE => jDoubleLE,
                                            simpleDoubleArith.doubleGT => jDoubleGT,
                                            simpleDoubleArith.doubleGE => jDoubleGE,
                                            simpleDoubleArith.doubleEQ => jDoubleEQ,
                                            simpleDoubleArith.doubleNeg => jDoubleNeg,
                                            simpleDoubleArith.parseDouble => jParseDouble,
                                            simpleDoubleArith.doubleAbs => jDoubleAbs,
                                            simpleDoubleArith.doublePow => jDoublePow,
                                            simpleDoubleArith.doubleNanoTime => jNanoTime}
import java com.sun.fortress.nativeHelpers.{simpleChar.charToString => jCharToString,
                                            simpleChar.charToExprString => jCharToExprString,
                                            simpleChar.charCodePointWithSpecialCompilerHackForCharacterArgumentType => jCodePoint,
                                            simpleChar.charMakeCharacterWithSpecialCompilerHackForCharacterResultType => jMakeCharacter,
                                            simpleChar.charLT => jCharLT,
                                            simpleChar.charLE => jCharLE,
                                            simpleChar.charGT => jCharGT,
                                            simpleChar.charGE => jCharGE,
                                            simpleChar.charEQ => jCharEQ,
                                            simpleChar.charNE => jCharNE,
                                            simpleChar.charLessNotSim => jCharLessNotSim,
                                            simpleChar.charLessSim => jCharLessSim,
                                            simpleChar.charGreaterNotSim => jCharGreaterNotSim,
                                            simpleChar.charGreaterSim => jCharGreaterSim,
                                            simpleChar.charSimEq => jCharSimEq,
                                            simpleChar.charNotSimEq => jCharNotSimEq,
                                            simpleChar.charGetDirectionality => jCharGetDirectionality,
                                            simpleChar.charGetNumericValue => jCharGetNumericValue,
                                            simpleChar.charGetType => jCharGetType,
                                            simpleChar.charIsDefined => jCharIsDefined,
                                            simpleChar.charIsDigit => jCharIsDigit,
                                            simpleChar.charIsFortressIdentifierPart => jCharIsFortressIdentifierPart,
                                            simpleChar.charIsFortressIdentifierStart => jCharIsFortressIdentifierStart,
                                            simpleChar.charIsHighSurrogate => jCharIsHighSurrogate,
                                            simpleChar.charIsIdentifierIgnorable => jCharIsIdentifierIgnorable,
                                            simpleChar.charIsISOControl => jCharIsISOControl,
                                            simpleChar.charIsJavaIdentifierPart => jCharIsJavaIdentifierPart,
                                            simpleChar.charIsJavaIdentifierStart => jCharIsJavaIdentifierStart,
                                            simpleChar.charIsLetter => jCharIsLetter,
                                            simpleChar.charIsLetterOrDigit => jCharIsLetterOrDigit,
                                            simpleChar.charIsLowerCase => jCharIsLowerCase,
                                            simpleChar.charIsLowSurrogate => jCharIsLowSurrogate,
                                            simpleChar.charIsMirrored => jCharIsMirrored,
                                            simpleChar.charIsSpaceChar => jCharIsSpaceChar,
                                            simpleChar.charIsSupplementaryCodePoint => jCharIsSupplementaryCodePoint,
                                            simpleChar.charIsSurrogatePair => jCharIsSurrogatePair,
                                            simpleChar.charIsTitleCase => jCharIsTitleCase,
                                            simpleChar.charIsUnicodeIdentifierPart => jCharIsUnicodeIdentifierPart,
                                            simpleChar.charIsUnicodeIdentifierStart => jCharIsUnicodeIdentifierStart,
                                            simpleChar.charIsUpperCase => jCharIsUpperCase,
                                            simpleChar.charIsValidCodePoint => jCharIsValidCodePoint,
                                            simpleChar.charIsWhitespace => jCharIsWhitespace,
                                            simpleChar.charJavaDigit => jCharJavaDigit,
                                            simpleChar.charToLowerCase => jCharToLowerCase,
                                            simpleChar.charToTitleCase => jCharToTitleCase,
                                            simpleChar.charToUpperCase => jCharToUpperCase}
import java com.sun.fortress.nativeHelpers.{LocalRandom.localRandomDouble => jRandomDouble,
                                            LocalRandom.localRandomInt => jRandomInt }
import java com.sun.fortress.nativeHelpers.{stringOps.compareTo => jCompareTo,
                                            stringOps.substring => jSubstring,
                                            stringOps.charAt => jCharAt,
                                            stringOps.asString => jAsString}
import java com.sun.fortress.nativeHelpers.{fileOps.jbrOpen => jJavaBufferedReaderOpen,
                                            fileOps.jbrAsString => jJavaBufferedReaderAsString,
                                            fileOps.jbrRead => jJavaBufferedReaderRead,
                                            fileOps.jbrReadLine => jJavaBufferedReaderReadLine,
                                            fileOps.jbrReadk => jJavaBufferedReaderReadk,
                                            fileOps.jbrEof => jJavaBufferedReaderEof,
                                            fileOps.jbrReady => jJavaBufferedReaderReady,
                                            fileOps.jbrClose => jJavaBufferedReaderClose,
                                            fileOps.jbrWhenUnconsumed => jJavaBufferedReaderWhenUnconsumed,
                                            fileOps.jbrConsume => jJavaBufferedReaderConsume,
                                            fileOps.jbwOpen => jJavaBufferedWriterOpen,
                                            fileOps.jbwAsString => jJavaBufferedWriterAsString,
                                            fileOps.jbwWriteChar => jJavaBufferedWriterWriteChar,
                                            fileOps.jbwWriteString => jJavaBufferedWriterWriteString,
                                            fileOps.jbwNewLine => jJavaBufferedWriterNewLine,
                                            fileOps.jbwFlush => jJavaBufferedWriterFlush,
                                            fileOps.jbwClose => jJavaBufferedWriterClose }
import java com.sun.fortress.nativeHelpers.{simpleIntVector.getIndexedValue => jIntVectorGet,
                                            simpleIntVector.putIndexedValue => jIntVectorPut,
                                            simpleIntVector.getSize => jIntVectorGetSize,
                                            simpleIntVector.make => jIntVectorMake,
                                            simpleIntVector.asString => jIntVectorAsString,
                                            simpleIntVector.getRows => jIntVectorGetRows,
                                            simpleIntVector.getCols => jIntVectorGetCols }
import java com.sun.fortress.nativeHelpers.{simpleStringVector.getIndexedValue => jStringVectorGet,
                                            simpleStringVector.putIndexedValue => jStringVectorPut,
                                            simpleStringVector.getSize => jStringVectorGetSize,
                                            simpleStringVector.make => jStringVectorMake }

import AnyType.{Any}
import CompilerAlgebra.{ Equality }
export CompilerBuiltin

nanoTime(): RR64 = jNanoTime()

trait Object extends Any
   getter asString(): String = jAsString(self)
   getter asExprString(): String = "[no expression for "  self.asString "]"
   getter asDebugString(): String = self.asString
(*)     getter asDebugString(): String  = do  (* for debugging; may contain more information *)
(*)         ilk = self.ilkName
(*)         firstChar = ilk[0]
(*)         article = if firstChar = 'a' OR: firstChar = 'e' OR: firstChar = 'i' OR: firstChar = 'o' OR:
(*)           (firstChar = 'h' AND: |ilk| >= 4 AND: ilk[0:3] = "hono") OR:
(*)           (firstChar = 'u' AND:
(*)              (do ilkNameLength = |ilk|
(*)                ilkNameLength >= 3 AND:
(*)                  (do (secondChar, thirdChar) = (ilk[1], ilk[2])
(*)                    (secondChar = 'b' AND thirdChar = 'i') OR:
(*)                    (secondChar = 'n' AND thirdChar = 'i' AND:
(*)                      (ilkNameLength = 3 OR:
(*)                    (case ilk[3] of
(*)                            'd' => ilkNameLength < 6 OR: (ilk[4:5] =/= "en" AND: ilk[4:5] =/= "io")
(*)                            'm' => ilkNameLength < 5 OR: (ilk[4] =/= 'a' AND: ilk[4] =/= 'p')
(*)                            'n' => ilkNameLength >= 5 AND: (ilk[4] = 'u')
(*)                            'r' => ilkNameLength < 6 OR: ilk[4:5] =/= "on"
(*)                        else => true))) OR:
(*)                    (secondChar = 'r' AND
(*)                  (thirdChar = 'a' OR: thirdChar = 'e' OR: thirdChar = 'i' OR: thirdChar = 'o' OR:
(*)                    (thirdChar = 'u' AND: (ilkNameLength = 3 OR: ilk[3] =/= 'g')))) OR:
(*)                    (secondChar = 't' AND
(*)                  (thirdChar = 'a' OR: thirdChar = 'e' OR: thirdChar = 'i' OR: thirdChar = 'o'))
(*)                    (secondChar = 'v' AND
(*)                  (thirdChar = 'a' OR: thirdChar = 'e' OR: thirdChar = 'i' OR: thirdChar = 'u')))))
(*)             then "an " else "a " end
(*)         article ilk ": " self.asString
(*)         self.asString
(*) end
end Object

trait String
    getter isEmpty(): Boolean
    getter asString(): String
    getter asJavaString(): JavaString
    opr |self| : ZZ32
    opr <(self, b: String): Boolean = false    (*) Needs to be replaced by generic definition once big operators work
    opr =(self, b: String): Boolean = false    (*) Needs to be replaced by generic definition once big operators work
    opr ||(self, b:Object): String
    opr juxtaposition(self, b:Object): String
    opr [i:ZZ32] : Character
    substring(lo:ZZ32, hi:ZZ32): String
    opr ^(self, n: ZZ32): String
end

trait JavaString extends String
    getter isEmpty(): Boolean = (jStrlen(self) = 0)
    getter asString(): String = self
    getter asJavaString(): JavaString = self
    opr |self| : ZZ32 = jStrlen(self)
    opr <(self, b: JavaString): Boolean = (jCompareTo(self, b) < 0)
    opr =(self, b: JavaString): Boolean = (jCompareTo(self, b) = 0)
    opr ||(self, b:Object): JavaString =  jConcatenate(self, b.asString.asJavaString)
    opr juxtaposition(self, b:Object): JavaString = jConcatenate(self, b.asString.asJavaString)
    opr [i:ZZ32] : Character = jMakeCharacter(jCharAt(self, i))
    substring(lo:ZZ32, hi:ZZ32): JavaString = jSubstring(self, lo, hi)
    opr ^(self, n: ZZ32): JavaString =
      if n <= 1 then
        if n=1 then self elif n=0 then ("").asJavaString else throw NegativeLength end
      else
        x = (self || self)^(n DIV 2)
        if odd n then x || self else x end
      end
end

print(x:Object):() = jPrint(x.asString.asJavaString)
(*) print(s:String):() = jPrint(s.asJavaString)
(*) print(s:JavaString):() = jPrint(s)
(*) print(c:Character):() = jPrint(c.asString)
(*) print(x:ZZ32):() = jPrint(x.asString)
(*) print(x:ZZ64):() = jPrint(x.asString)
(*) print(x:RR64):() = jPrint(x.asString)

println(x:Object):() = jPrintln(x.asString.asJavaString)
(*) println(s:String):() = jPrintln(s.asJavaString)
(*) println(s:JavaString):() = jPrintln(s)
(*) println(c:Character):() = jPrintln(c.asString)
(*) println():() = jPrintln("")
(*) println(x:Any):() = jPrintln("<any>")

(*) println(x:ZZ32):() = jPrintln(x.asString)
(*) println(x:ZZ64):() = jPrintln(x.asString)
(*) println(x:RR32):() = jPrintln(x.asString)
(*) println(x:RR64):() = jPrintln(x.asString)
println(a: Any, b: Any): () = jPrintln(("(" str(a) ", " str(b) ")").asJavaString)
println(a: Any, b: Any, c: Any): () = jPrintln(("(" str(a) ", " str(b) ", " str(c) ")").asJavaString)
println(a: Any, b: Any, c: Any, d: Any): () = jPrintln(("(" str(a) ", " str(b) ", " str(c) ", " str(d) ")").asJavaString)
(*) println[\A,B,C,D,E\](x: (A,B,C,D,E)):() = jPrintln(str(x))
(*) println[\A,B,C,D,E,F\](x: (A,B,C,D,E,F)):() = jPrintln(str(x))
(*) println[\A,B,C,D,E,F,G\](x: (A,B,C,D,E,F,G)):() = jPrintln(str(x))

errorPrintln(x:Object):() = jErrorPrintln(x.asString.asJavaString)
(*) errorPrintln(s:String):() = jErrorPrintln(s.asJavaString)
(*) errorPrintln(s:JavaString):() = jErrorPrintln(s)
(*) errorPrintln(c:Character):() = jErrorPrintln(c.asString)
(*) errorPrintln(x:Object): () = jErrorPrintln(x.asString)
(*) errorPrintln():() = jErrorPrintln("")
(*) errorPrintln(x:Any):() = jErrorPrintln("<big tuple>")

(*) errorPrintln(x:ZZ32):() = jErrorPrintln(x.asString)
(*) errorPrintln(x:ZZ64):() = jErrorPrintln(x.asString)
(*) errorPrintln(x:RR32):() = jErrorPrintln(x.asString)
(*) errorPrintln(x:RR64):() = jErrorPrintln(x.asString)
(*) errorPrintln[\A,B\](x: (A,B)):() = jErrorPrintln(str(x))
(*) errorPrintln[\A,B,C\](x: (A,B,C)):() = jErrorPrintln(str(x))
(*) errorPrintln[\A,B,C,D\](x: (A,B,C,D)):() = jErrorPrintln(str(x))
(*) errorPrintln[\A,B,C,D,E\](x: (A,B,C,D,E)):() = jErrorPrintln(str(x))
(*) errorPrintln[\A,B,C,D,E,F\](x: (A,B,C,D,E,F)):() = jErrorPrintln(str(x))
(*) errorPrintln[\A,B,C,D,E,F,G\](x: (A,B,C,D,E,F,G)):() = jErrorPrintln(str(x))

(*) Utility routine for converting tuples to strings
private str(x: Any): JavaString = ("<big tuple>").asJavaString
private str(x: Object): JavaString = x.asString.asJavaString
private str(): JavaString = ("()").asJavaString
private str(a: Any, b: Any): JavaString = ("(" str(a) ", " str(b) ")").asJavaString
private str(a: Any, b: Any, c: Any): JavaString = ("(" str(a) ", " str(b) ", " str(c) ")").asJavaString
private str(a: Any, b: Any, c: Any, d: Any): JavaString = ("(" str(a) ", " str(b) ", " str(c) ", " str(d) ")").asJavaString
(*) private str[\A,B,C,D,E\](x: (A,B,C,D,E)): JavaString = do (a,b,c,d,e) = x; "(" str(a) ", " str(b) ", " str(c) ", " str(d) ", " str(e) ")" end
(*) private str[\A,B,C,D,E,F\](x: (A,B,C,D,E,F)): JavaString = do (a,b,c,d,e,f) = x; "(" str(a) ", " str(b) ", " str(c) ", " str(d) ", " str(e) ", " str(f) ")" end
(*) private str[\A,B,C,D,E,F,G\](x: (A,B,C,D,E,F,G)): JavaString = do (a,b,c,d,e,f,g) = x; "(" str(a) ", " str(b) ", " str(c) ", " str(d) ", " str(e) ", " str(f) ", " str(g) ")" end

strToInt(s:String):ZZ32 = jParseInt(s.asJavaString)

trait Number excludes { String }
end

value object Infinity extends Number end
value object NegativeInfinity extends Number end
value object IndefiniteNumber extends Number end

trait ZZ64 extends { Number, Equality[\ZZ64\] } excludes { RR64 }
    coerce(x: IntLiteral) = x.asZZ64
    coerce(x: ZZ32) = jIntToLong(x)
    getter asZZ32(): ZZ32 = jLongOverflowingToInt(self)
    getter asString(): String = jLongToString(self)
    opr |self| : ZZ64 = jLongOverflowingAbs(self)
    opr -(self): ZZ64 = jLongOverflowingNeg(self)
    opr BOXMINUS(self): ZZ64 = jLongWrappingNeg(self)
    opr DOTMINUS(self): ZZ64 = jLongSaturatingNeg(self)
    opr +(self, other:ZZ64): ZZ64 = jLongOverflowingAdd(self,other)
    opr BOXPLUS(self, other:ZZ64): ZZ64 = jLongWrappingAdd(self,other)
    opr DOTPLUS(self, other:ZZ64): ZZ64 = jLongSaturatingAdd(self,other)
    opr -(self, other:ZZ64): ZZ64 = jLongOverflowingSub(self,other)
    opr BOXMINUS(self, other:ZZ64): ZZ64 = jLongWrappingSub(self,other)
    opr DOTMINUS(self, other:ZZ64): ZZ64 = jLongSaturatingSub(self,other)
    opr DOT(self, other:ZZ64): ZZ64 = jLongOverflowingMul(self,other)
    opr BOXDOT(self, other:ZZ64): ZZ64 = jLongWrappingMul(self,other)
    opr CROSS(self, other:ZZ64): ZZ64 = jLongOverflowingMul(self,other)
    opr BOXCROSS(self, other:ZZ64): ZZ64 = jLongWrappingMul(self,other)
    opr DOTCROSS(self, other:ZZ64): ZZ64 = jLongSaturatingMul(self,other)
    opr DIV(self, other:ZZ64): ZZ64 = jLongOverflowingDiv(self,other)
    opr <(self, other:ZZ64): Boolean = jLongLT(self,other)
    opr <=(self, other:ZZ64): Boolean = jLongLE(self,other)
    opr >(self, other:ZZ64): Boolean = jLongGT(self,other)
    opr >=(self, other:ZZ64): Boolean = jLongGE(self,other)
    opr =(self, other:ZZ64): Boolean = jLongEQ(self,other)
    opr =/=(self, other:ZZ64): Boolean = NOT (self = other)
    opr juxtaposition(self, other:ZZ64): ZZ64 = jLongOverflowingMul(self,other)
    opr BITNOT(self): ZZ64 = jLongBitNot(self)
    opr BITAND(self, other:ZZ64): ZZ64 = jLongBitAnd(self,other)
    opr BITOR(self, other:ZZ64): ZZ64 = jLongBitOr(self,other)
    opr BITXOR(self, other:ZZ64): ZZ64 = jLongBitXor(self,other)
    opr MIN(self, other:ZZ64): ZZ64 = if self <= other then self else other end
    opr MAX(self, other:ZZ64): ZZ64 = if self >= other then self else other end
    opr MINMAX(self, other:ZZ64): (ZZ64, ZZ64) = if self <= other then (self, other) else (other, self) end
    opr CHOOSE(self, other:ZZ64): ZZ64 = jLongOverflowingChoose(self,other)
    even(self): Boolean = ((self BITAND 1) = 0)
    odd(self): Boolean = NOT (even self)
end

trait ZZ32 extends { Number, Equality[\ZZ32\] } excludes { ZZ64, RR32, RR64 }
    coerce(x: IntLiteral) = x.asZZ32
    getter asZZ32(): ZZ32 = self
    getter asString(): String = jIntToString(self)
    opr |self| : ZZ32 = jIntOverflowingAbs(self)
    opr -(self): ZZ32 = jIntOverflowingNeg(self)
    opr BOXMINUS(self): ZZ32 = jIntWrappingNeg(self)
    opr DOTMINUS(self): ZZ32 = jIntSaturatingNeg(self)
    opr +(self, other:ZZ32): ZZ32 = jIntOverflowingAdd(self,other)
    opr BOXPLUS(self, other:ZZ32): ZZ32 = jIntWrappingAdd(self,other)
    opr DOTPLUS(self, other:ZZ32): ZZ32 = jIntSaturatingAdd(self,other)
    opr -(self, other:ZZ32): ZZ32 = jIntOverflowingSub(self,other)
    opr BOXMINUS(self, other:ZZ32): ZZ32 = jIntWrappingSub(self,other)
    opr DOTMINUS(self, other:ZZ32): ZZ32 = jIntSaturatingSub(self,other)
    opr DOT(self, other:ZZ32): ZZ32 = jIntOverflowingMul(self,other)
    opr BOXDOT(self, other:ZZ32): ZZ32 = jIntWrappingMul(self,other)
    opr CROSS(self, other:ZZ32): ZZ32 = jIntOverflowingMul(self,other)
    opr BOXCROSS(self, other:ZZ32): ZZ32 = jIntWrappingMul(self,other)
    opr DOTCROSS(self, other:ZZ32): ZZ32 = jIntSaturatingMul(self,other)
    opr DIV(self, other:ZZ32): ZZ32 = jIntOverflowingDiv(self,other)
    opr <(self, other:ZZ32): Boolean = jIntLT(self,other)
    opr <=(self, other:ZZ32): Boolean = jIntLE(self,other)
    opr >(self, other:ZZ32): Boolean = jIntGT(self,other)
    opr >=(self, other:ZZ32): Boolean = jIntGE(self,other)
    opr =(self, other:ZZ32): Boolean = jIntEQ(self,other)
    opr =/=(self, other:ZZ32): Boolean = NOT (self = other)
    opr juxtaposition(self, other:ZZ32): ZZ32 = jIntOverflowingMul(self,other)
    opr BITNOT(self): ZZ32 = jIntBitNot(self)
    opr BITAND(self, other:ZZ32): ZZ32 = jIntBitAnd(self,other)
    opr BITOR(self, other:ZZ32): ZZ32 = jIntBitOr(self,other)
    opr BITXOR(self, other:ZZ32): ZZ32 = jIntBitXor(self,other)
    opr MIN(self, other:ZZ32): ZZ32 = if self <= other then self else other end
    opr MAX(self, other:ZZ32): ZZ32 = if self >= other then self else other end
    opr MINMAX(self, other:ZZ32): (ZZ32, ZZ32) = if self <= other then (self, other) else (other, self) end
    opr CHOOSE(self, other:ZZ32): ZZ32 = jIntOverflowingChoose(self,other)
    even(self): Boolean = ((self BITAND 1) = 0)
    odd(self): Boolean = NOT (even self)
    opr ^(self, other:ZZ32):ZZ32 = jIntExp(self, other)
    asRR64(): RR64 = jIntToDouble(self)
end

trait NN32 extends { Number, Equality[\NN32\] } excludes { ZZ32, ZZ64, RR32, RR64 }
    coerce(x: IntLiteral) = x.asNN32
    getter asNN32(): NN32 = self
    getter asString(): String = jUnsignedIntToString(jMakeZZ32FromNN32(self))
    opr |self| : NN32 = self
    opr -(self): NN32 = 
         if (self = 0) 
         then 0
         else throw IntegerOverflow
         end
    opr BOXMINUS(self): NN32 = jMakeNN32FromZZ32(jUnsignedIntWrappingNeg(jMakeZZ32FromNN32(self)))
    opr DOTMINUS(self): NN32 = jMakeNN32FromZZ32(jUnsignedIntSaturatingNeg(jMakeZZ32FromNN32(self)))
    opr +(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntOverflowingAdd(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    opr BOXPLUS(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntWrappingAdd(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    opr DOTPLUS(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntSaturatingAdd(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    opr -(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntOverflowingSub(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    opr BOXMINUS(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntWrappingSub(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    opr DOTMINUS(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntSaturatingSub(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    opr DOT(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntOverflowingMul(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    opr BOXDOT(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntWrappingMul(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    opr CROSS(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntOverflowingMul(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    opr BOXCROSS(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntWrappingMul(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    opr DOTCROSS(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntSaturatingMul(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    opr DIV(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntOverflowingDiv(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    opr <(self, other:NN32): Boolean = jUnsignedIntLT(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other))
    opr <=(self, other:NN32): Boolean = jUnsignedIntLE(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other))
    opr >(self, other:NN32): Boolean = jUnsignedIntGT(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other))
    opr >=(self, other:NN32): Boolean = jUnsignedIntGE(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other))
    opr =(self, other:NN32): Boolean = jIntEQ(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other))
    opr =/=(self, other:NN32): Boolean = NOT (jMakeZZ32FromNN32(self) = jMakeZZ32FromNN32(other))
    opr juxtaposition(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntOverflowingMul(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    opr BITNOT(self): NN32 = jMakeNN32FromZZ32(jUnsignedIntBitNot(jMakeZZ32FromNN32(self)))
    opr BITAND(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntBitAnd(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    opr BITOR(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntBitOr(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    opr BITXOR(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntBitXor(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    opr MIN(self, other:NN32): NN32 = if self <= other then self else other end
    opr MAX(self, other:NN32): NN32 = if self >= other then self else other end
    opr MINMAX(self, other:NN32): (NN32, NN32) = if self <= other then (self, other) else (other, self) end
    opr CHOOSE(self, other:NN32): NN32 = jMakeNN32FromZZ32(jUnsignedIntOverflowingChoose(jMakeZZ32FromNN32(self),jMakeZZ32FromNN32(other)))
    even(self): Boolean = ((self BITAND 1) = 0)
    odd(self): Boolean = NOT (even self)
    opr ^(self, other:NN32):NN32 = jMakeNN32FromZZ32(jUnsignedIntExp(jMakeZZ32FromNN32(self), jMakeZZ32FromNN32(other)))
    asRR64(): RR64 = jUnsignedIntToDouble(jMakeZZ32FromNN32(self))
end

trait IntLiteral excludes {ZZ32, ZZ64, NN32, RR64, RR32, Character, Boolean, String}
    getter asString(): String = self.asZZ32.asString
    getter asZZ32(): ZZ32
    getter asZZ64(): ZZ64
    getter asNN32(): NN32
(*
    getter asZZ(): ZZ
    getter asRR32(): RR32
*)
    getter asRR64(): RR64

    opr |self| : IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr -(self): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr BOXMINUS(self): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr DOTMINUS(self): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr +(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr BOXPLUS(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr DOTPLUS(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr -(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr BOXMINUS(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr DOTMINUS(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr DOT(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr BOXDOT(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr CROSS(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr BOXCROSS(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr DOTCROSS(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr DIV(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr <(self, other:IntLiteral): Boolean = throw CompilerFailureDetectedAtRunTime
    opr <=(self, other:IntLiteral): Boolean = throw CompilerFailureDetectedAtRunTime
    opr >(self, other:IntLiteral): Boolean = throw CompilerFailureDetectedAtRunTime
    opr >=(self, other:IntLiteral): Boolean = throw CompilerFailureDetectedAtRunTime
    opr =(self, other:IntLiteral): Boolean = throw CompilerFailureDetectedAtRunTime
    opr =/=(self, other:IntLiteral): Boolean = throw CompilerFailureDetectedAtRunTime
    opr juxtaposition(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr BITNOT(self): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr BITAND(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr BITOR(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr BITXOR(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr MIN(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr MAX(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    opr MINMAX(self, other:IntLiteral): (IntLiteral, IntLiteral) = throw CompilerFailureDetectedAtRunTime
    opr CHOOSE(self, other:IntLiteral): IntLiteral = throw CompilerFailureDetectedAtRunTime
    even(self): Boolean = throw CompilerFailureDetectedAtRunTime
    odd(self): Boolean = throw CompilerFailureDetectedAtRunTime
end

trait RR64 extends { Number, Equality[\RR64\] } excludes ZZ64
    coerce(x: FloatLiteral) = x.asRR64
    coerce(x: RR32) = jFloatToDouble(x)
    getter asString(): String = jDoubleToString(self)
    getter isNaN(): Boolean = NOT (self = self)
    opr |self| : RR64 = jDoubleAbs(self)
    opr -(self): RR64 = jDoubleNeg(self)
    opr +(self, other:RR64): RR64 = jDoubleAdd(self,other)
    opr -(self, other:RR64): RR64 = jDoubleSub(self,other)
    opr <(self, other:RR64): Boolean = jDoubleLT(self,other)
    opr <=(self, other:RR64): Boolean = jDoubleLE(self,other)
    opr >(self, other:RR64): Boolean = jDoubleGT(self,other)
    opr >=(self, other:RR64): Boolean = jDoubleGE(self,other)
    opr =(self, other:RR64): Boolean = jDoubleEQ(self,other)
    opr juxtaposition(self, other:RR64): RR64 = jDoubleMul(self,other)
    opr DOT(self, other:RR64): RR64 = jDoubleMul(self,other)
    opr /(self, other:RR64): RR64 = jDoubleDiv(self,other)
    opr MIN(self, other:RR64): RR64 = if self <= other then self elif other <= self then other elif self.isNaN then self else other end
    opr MAX(self, other:RR64): RR64 = if self >= other then self elif other >= self then other elif self.isNaN then self else other end
    opr MINNUM(self, other:RR64): RR64 = if self <= other then self elif other <= self then other elif self.isNaN then other else self end
    opr MAXNUM(self, other:RR64): RR64 = if self >= other then self elif other >= self then other elif self.isNaN then other else self end
    opr MINNUMMAX(self, other:RR64): (RR64, RR64) = if self <= other then (self, other) elif other <= self then (other, self) elif other.isNaN then (self, other) else (other, self) end
    opr MINMAXNUM(self, other:RR64): (RR64, RR64) = if self <= other then (self, other) elif other <= self then (other, self) elif self.isNaN then (self, other) else (other, self) end
    opr ^(self, other:RR64): RR64 = jDoublePow(self,other)
    opr ^(self, other:ZZ32): RR64 =
        if other > 2 then
            mid = other DIV 2
            if (mid + mid) = other then
                (self self)^mid
            else
                self (self self)^mid
            end
        elif other = 2 then self self
        elif other = 1 then self
        elif other = 0 then 1.0
        elif other = -other then
          (* Screw case of most negative `ZZ32` value *)
          1.0 / (self^(-(other DIV 2)))^2

        else (* other < 0 then *) 1.0 / (self^(-other))
        end
end

trait RR32 extends { Number, Equality[\RR32\] } excludes { ZZ64, ZZ32, RR64 }
    coerce(x: FloatLiteral) = x.asRR32
end

trait FloatLiteral excludes {RR32, RR64}
    getter asRR32(): RR32
    getter asRR64(): RR64
end

trait Boolean extends { Equality[\Boolean\] }
    excludes { String, Number }
  getter holds(): Boolean = self
  getter get(): () = ()
  getter asString(): String = self.asExprString
  getter asExprString(): String = if self then "true" else "false" end
  getter size(): ZZ32 = |self|
  opr |self| : ZZ32 = if self then 1 else 0 end
(*)   cond[\R\](t:()->R, e:()->R) : R = if self then t() else e() end
(*)   generate[\R\](r:Reduction[\R\],b:()->R): R =
(*)       if self then b() else r.empty() end
(*)   map[\G\](f: ()->G): Maybe[\G\] =
(*)       if self then Just[\G\](f()) else Nothing[\G\] end
(*)   cross[\G\](g: Generator[\G\]): Generator[\((),G)\] =
(*)       if self
(*)       then g.map[\((),G)\](fn (e:G):((),G) => ((),e))
(*)       else Nothing[\((),G)\] end

(*)   mapReduce[\R\](b: ()->R, _:(R,R)->R, z:R): R =
(*)       if self then b() else z end
(*)   loop(f:()->()): () = if self then f() end

  opr NOT(self):Boolean = jBooleanNot(self)
  opr AND(self, other:Boolean):Boolean = jBooleanAnd(self, other)
  opr AND(self, other:()->Boolean):Boolean = if self then other() else self end
  opr OR(self, other:Boolean):Boolean = jBooleanOr(self, other)
  opr OR(self, other:()->Boolean):Boolean = if self then self else other() end
  opr XOR(self, other:Boolean):Boolean = jBooleanXor(self, other)
  opr OPLUS(self, other:Boolean):Boolean = jBooleanXor(self, other)
  opr NEQV(self, other:Boolean):Boolean = jBooleanXor(self, other)
  opr EQV(self, other:Boolean):Boolean = jBooleanEqv(self, other)
  opr <->(self, other:Boolean):Boolean = jBooleanEqv(self, other)
  opr ->(self, other:Boolean):Boolean = (NOT self) OR other
  opr NAND(self, other:Boolean):Boolean = NOT (self AND other)
  opr NOR(self, other:Boolean):Boolean = NOT (self OR other)

  opr =(self, other:Boolean): Boolean = jBooleanEqv(self, other)
(*)   opr <(self, other:Boolean): Boolean = (NOT self) AND other
(*)   opr CMP(self, other:Boolean): TotalComparison =
(*)       if self then
(*)           if other then EqualTo else GreaterThan end
(*)       else
(*)           if other then LessThan else EqualTo end
(*)       end
end

(*)true: Boolean = do x: ZZ32 = 0; (x=x) end
(*)false: Boolean = do x: ZZ32 = 0; (x=/=x) end

makeCharacter(n: ZZ32): Character =
    if characterMinCodePoint <= n <= characterMaxCodePoint
    then jMakeCharacter(n)
    else throw IntegerOverflow   (*) Really should be IndexOutOfRange
    end

trait Character extends Equality[\Character\]  excludes { String, Number, Boolean }
    getter asString() : String = jCharToString(jCodePoint(self))
    getter asExprString() : String = jCharToExprString(jCodePoint(self))
    getter codePoint(): ZZ32 = jCodePoint(self)

    opr <(self, other:Character): Boolean = jCharLT(jCodePoint(self), jCodePoint(other))
    opr <=(self, other:Character): Boolean = jCharLE(jCodePoint(self), jCodePoint(other))
    opr >(self, other:Character): Boolean = jCharGT(jCodePoint(self), jCodePoint(other))
    opr >=(self, other:Character): Boolean = jCharGE(jCodePoint(self), jCodePoint(other))
    opr =(self, other:Character): Boolean = jCharEQ(jCodePoint(self), jCodePoint(other))
    opr =/=(self, other:Character): Boolean = jCharNE(jCodePoint(self), jCodePoint(other))

    opr LNSIM(self, other:Character): Boolean = jCharLessNotSim(jCodePoint(self), jCodePoint(other))
    opr LESSSIM(self, other:Character): Boolean = jCharLessSim(jCodePoint(self), jCodePoint(other))
    opr GNSIM(self, other:Character): Boolean = jCharGreaterNotSim(jCodePoint(self), jCodePoint(other))
    opr GTRSIM(self, other:Character): Boolean = jCharGreaterSim(jCodePoint(self), jCodePoint(other))
    opr SIMEQ(self, other:Character): Boolean = jCharSimEq(jCodePoint(self), jCodePoint(other))
    opr NSIMEQ(self, other:Character): Boolean = jCharNotSimEq(jCodePoint(self), jCodePoint(other))

    getDirectionality(self): ZZ32 = jCharGetDirectionality(jCodePoint(self))
    getNumericValue(self): ZZ32 = jCharGetNumericValue(jCodePoint(self))
    getType(self): ZZ32 = jCharGetType(jCodePoint(self))
    isDefined(self): Boolean = jCharIsDefined(jCodePoint(self))
    isDigit(self): Boolean = jCharIsDigit(jCodePoint(self))
    isFortressIdentifierPart(self): Boolean = jCharIsFortressIdentifierPart(jCodePoint(self))
    isFortressIdentifierStart(self): Boolean = jCharIsFortressIdentifierStart(jCodePoint(self))
    isHighSurrogate(self): Boolean = jCharIsHighSurrogate(jCodePoint(self))
    isIdentifierIgnorable(self): Boolean = jCharIsIdentifierIgnorable(jCodePoint(self))
    isISOControl(self): Boolean = jCharIsISOControl(jCodePoint(self))
    isJavaIdentifierPart(self): Boolean = jCharIsJavaIdentifierPart(jCodePoint(self))
    isJavaIdentifierStart(self): Boolean = jCharIsJavaIdentifierStart(jCodePoint(self))
    isLetter(self): Boolean = jCharIsLetter(jCodePoint(self))
    isLetterOrDigit(self): Boolean = jCharIsLetterOrDigit(jCodePoint(self))
    isLowerCase(self): Boolean = jCharIsLowerCase(jCodePoint(self))
    isLowSurrogate(self): Boolean = jCharIsLowSurrogate(jCodePoint(self))
    isMirrored(self): Boolean = jCharIsMirrored(jCodePoint(self))
    isSpaceChar(self): Boolean = jCharIsSpaceChar(jCodePoint(self))
    isSupplementaryCodePoint(self): Boolean = jCharIsSupplementaryCodePoint(jCodePoint(self))
    isSurrogatePair(self, low: Character): Boolean = jCharIsSurrogatePair(jCodePoint(self), jCodePoint(low))
    isTitleCase(self): Boolean = jCharIsTitleCase(jCodePoint(self))
    isUnicodeIdentifierPart(self): Boolean = jCharIsUnicodeIdentifierPart(jCodePoint(self))
    isUnicodeIdentifierStart(self): Boolean = jCharIsUnicodeIdentifierStart(jCodePoint(self))
    isUpperCase(self): Boolean = jCharIsUpperCase(jCodePoint(self))
    isValidCodePoint(self): Boolean = jCharIsValidCodePoint(jCodePoint(self))
    isWhitespace(self): Boolean = jCharIsWhitespace(jCodePoint(self))
    javaDigit(self, radix: ZZ32): ZZ32 = jCharJavaDigit(jCodePoint(self), radix)
    toLowerCase(self): Character = jMakeCharacter(jCharToLowerCase(jCodePoint(self)))
    toTitleCase(self): Character = jMakeCharacter(jCharToTitleCase(jCodePoint(self)))
    toUpperCase(self): Character = jMakeCharacter(jCharToUpperCase(jCodePoint(self)))
end

trait ZZ32Vector excludes { String, Number, Boolean, Character }
   getter asString(): String = jIntVectorAsString(self)
   getter shape(): (ZZ32, ZZ32) = (jIntVectorGetRows(self), jIntVectorGetCols(self))
   getter nrows(): ZZ32 = jIntVectorGetRows(self)
   getter ncols(): ZZ32 = jIntVectorGetCols(self)
   getter copy(): ZZ32Vector = makeZZ32Vector(self.nrows).fill(fn (i) => self[i])    (*) Handles only 1D case
   getValue(i:ZZ32): ZZ32 = jIntVectorGet(self, i)
   getValue(i:ZZ32, j:ZZ32): ZZ32 = jIntVectorGet(self, i, j)
   putValue(i:ZZ32, v:ZZ32): () = jIntVectorPut(self, i, v)
   putValue(i:ZZ32, j:ZZ32, v:ZZ32): () = jIntVectorPut(self, i, j, v)
   opr[i:ZZ32]: ZZ32 = getValue(i)
   opr[i:ZZ32, j:ZZ32]: ZZ32 = getValue(i,j)
   opr[i:ZZ32] := (v: ZZ32): () = putValue(i,v)
   opr[i:ZZ32, j:ZZ32] := (v: ZZ32): () = putValue(i,j,v)
   opr |self| : ZZ32 = jIntVectorGetSize(self)
   fill(v: ZZ32): ZZ32Vector = do
     for i <- 0 # |self| do
       self[i] := v
     end
     self
   end
   fill(f: ZZ32 -> ZZ32): ZZ32Vector = do
     for i <- 0 # |self| do
       self[i] := f(i)
     end
     self
   end
   fill2(f: (ZZ32, ZZ32) -> ZZ32): ZZ32Vector = do
     for i <- 0 # self.nrows, j <- 0 # self.ncols do
       self[i,j] := f(i,j)
     end
     self
   end
end

__makeZZ32Vector(l1: ZZ32, d1: ZZ32, l2: ZZ32, d2: ZZ32): ZZ32Vector = jIntVectorMake(l1, d1, l2, d2)

makeStringVector(i:ZZ32): StringVector = jStringVectorMake(i)

trait StringVector 
   getValue(i:ZZ32): String = jStringVectorGet(self, i)
   putValue(i:ZZ32, v:String): () = jStringVectorPut(self, i, v.asJavaString)
   opr[i:ZZ32]: String = getValue(i)
   opr |self| : ZZ32 = jStringVectorGetSize(self)
end

trait JavaBufferedReader excludes { String, Number, Boolean, Character }
  getter asString(): String = jJavaBufferedReaderAsString(self)
  read(): Character throws IOException = jMakeCharacter(jJavaBufferedReaderRead(self))
  readLine(): String throws IOException = jJavaBufferedReaderReadLine(self)
  readk(k: ZZ32): String throws IOException = jJavaBufferedReaderReadk(self, k)
  eof(): Boolean = jJavaBufferedReaderEof(self)
  ready(): Boolean throws IOException = jJavaBufferedReaderReady(self)
  close(): () throws IOException = jJavaBufferedReaderClose(self)
  whenUnconsumed(): () throws IOException = jJavaBufferedReaderWhenUnconsumed(self)
  consume(): () = jJavaBufferedReaderConsume(self)
end

makeJavaBufferedReader(s: String): JavaBufferedReader throws FileNotFoundException = jJavaBufferedReaderOpen(s.asJavaString)

trait JavaBufferedWriter excludes { String, Number, Boolean, Character, JavaBufferedReader }
  getter asString(): String = jJavaBufferedWriterAsString(self)
  write(c: Character): () throws IOException = jJavaBufferedWriterWriteChar(self, jCodePoint(c))
  write(s: String): () throws IOException = jJavaBufferedWriterWriteString(self, s.asJavaString)
  newLine(): () throws IOException = jJavaBufferedWriterNewLine(self)
  flush(): () throws IOException = jJavaBufferedWriterFlush(self)
  close(): () throws IOException = jJavaBufferedWriterClose(self)
end

makeJavaBufferedWriter(s: String): JavaBufferedWriter throws FileNotFoundException = jJavaBufferedWriterOpen(s.asJavaString)


(************************************************************
* Comparison values
************************************************************)

(*) Material not present for now.  See CompilerBuiltinComparison.txt


(************************************************************
* Exception hierarchy
************************************************************)

trait Exception comprises { UncheckedException, CheckedException }
end

trait UncheckedException extends Exception excludes CheckedException
end

object NegativeLength extends UncheckedException
    getter asString(): String = "Negative length"
end

object DivisionByZero extends UncheckedException
    getter asString(): String = "Division by zero"
end

object IntegerOverflow extends UncheckedException
    getter asString(): String = "Integer overflow"
end

trait CheckedException extends Exception excludes UncheckedException
end

trait IOException extends CheckedException
end

object CompilerFailureDetectedAtRunTime extends UncheckedException
    getter asString(): String = "Compiler failure detected at runtime"
end

object IOFailure(s: String) extends IOException
    getter asString(): String = "[I/O failure: " s "]"
end

object FileNotFoundException(s: String) extends IOException
    getter asString(): String = "[File not found: " s "]"
end


(************************************************************
* Random numbers
************************************************************)

random(i:RR64): RR64 = jRandomDouble(i)
randomZZ32(x:ZZ32): ZZ32 = jRandomInt(0,x)


(************************************************************
* Character properties
************************************************************)

characterMinCodePoint: ZZ32 = 0
characterMaxCodePoint: ZZ32 = 1114111

end
