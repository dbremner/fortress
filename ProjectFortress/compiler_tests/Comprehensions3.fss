(*******************************************************************************
    Copyright 2009 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

export Executable

(* Mock up of the kind of code we expect after desugaring of
comprehensions, in order to see whether we can typecheck it.

In this case we worry things might start breaking with the advent of
coercion; will type inference get confused by SUM?
*)

(** Is excludes Boolean actually necessary here, or is that a bug in
    exclusion checking? *)
trait Generator[\T\] excludes Boolean
    generate[\R\](r: Reduction[\R\], body: T->R): R
    filter(f: T -> Boolean): Generator[\T\]
end

trait Reduction[\R\]
    empty(): R
    join(a: R, b:R): R
end

object SumReduction extends Reduction[\ZZ32\]
    empty(): ZZ32 = 0
    join(a:ZZ32, b:ZZ32): ZZ32 = a + b
end

__bigOperator[\R\](o:Reduction[\R\],
                desugaredClauses:(Reduction[\R\], R->R)->R): R =
    desugaredClauses(o, fn (x:R):R => x)

__generate[\T,R\](g: Generator[\T\], r: Reduction[\R\], f:T->R): R =
    g.generate[\R\](r,f)
__generate[\R\](p: Boolean, r: Reduction[\R\], f:()->R): R =
    if p then f() else r.empty() end

(* TODO: fix return type of filter when that works *)
object FilteredRange(lo: ZZ32, hi:ZZ32, p: ZZ32 -> Boolean) extends Generator[\ZZ32\]
    (* Interestingly, deleting the explicit type parameter [\R\] to gen here works *)
    generate[\R\](r: Reduction[\R\], body: ZZ32->R): R = gen[\R\](lo,hi,p,r,body)
    filter(q: ZZ32 -> Boolean): Generator[\ZZ32\] =
        FilteredRange(lo, hi, fn n => p(n) AND: q(n))
end

gen[\R\](lo:ZZ32, hi:ZZ32, p: ZZ32->Boolean, r:Reduction[\R\], body: ZZ32->R): R =
    if lo < hi then
        mid = (lo+hi) DIV 2
        r.join(gen(lo, mid, p, r, body), gen(mid+1,hi,p,r,body))
    elif lo=hi AND: p(lo) then
        body(lo)
    else
        r.empty()
    end

opr :(lo:ZZ32, hi:ZZ32): FilteredRange = FilteredRange(lo, hi, fn (n) => 0=0)

opr SUM(): SumReduction = SumReduction

opr AND(a:Boolean, b:()->Boolean): Boolean = if a then b() else a end

length[\T\](g: Generator[\T\]): ZZ32 = SUM[_ <- g] 1

run(): () = do
    printlnZZ32(length(1:100))
  end
