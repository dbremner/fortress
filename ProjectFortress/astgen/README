CHECK: value trait / value object / value type

* Not yet implemented features
 - lexical structure
  = ASCII conversion
  = digit-group separator
 - coercions
 - operators
  = conditional operators
  = BIG operators
 - keyword parameters
 - dimensions and units
 - where clauses
 - conditional extensions
 - syntax expanders
 - component system
 - static checking
  = acyclic type hierarchy

* Constraints that should be checked by the static checker
 1) Functions
  - A throws clause does not include naked type variables.
  - Every element in a throws clause is a subtype of CheckedException.
 2) Label Expressions
  - It is a static error if the identifier after \KWD{end} of a labeled block
    is not the name of the block.
  - It is a static error if the target is not in scope
    in the label namespace at the \KWD{exit} expression.
    That is, the target must be the name of a statically enclosing \KWD{label}
    expression, and the \KWD{exit} expression must not be within a \KWD{spawn}
    expression that is contained in the \KWD{label} expression.
    If no target is specified, the target is implicitly the name
    of the smallest statically enclosing \KWD{label} expression;
    it is a static error if there is no such expression.
 3) Case Expressions
  - It is a static error if the specified operator is not defined for these types
    or if the operator's return type is not \TYP{Boolean}.
 4) Operator Declarations
  - An infix/multifix operator declaration must not have any keyword parameters,
    and must be capable of accepting at least two arguments.  It is permissible
    to use a varargs parameter.
  - An operator declaration for superscripting (^) should have exactly two value
    parameters.
  - A prefix operator declaration must have one value parameter, which must not
    be a keyword parameter or varargs parameter.
  - A postfix operator declaration must have one value parameter, which must not
    be a keyword parameter or varargs parameter
  - A nofix operator declaration must have no parameters.
  - If a result type appears in a subscripted assignment operator method
    declaration, it must be ().


* Differences between the Concrete Syntax Grammar (CSG) in the specification
  and the Abstract Syntax Tree (AST) in Fortress.ast
 1) CSG defines productions for "NONTERMINALs" and "NONTERMINALList". For
    example:

Imports  ::= Import+
Name     ::= Name | { NameList }
NameList ::= Name(, Name)*

    AST does not define such productions but use "List<NONTERMINAL>" instead.
    For example, "List<Name>" is used instead of "NameList".

 2) CSG provides productions for component and API declarations that do not
    include their "component DottedId/end" and "api DottedId/end" reserved
    words:

File ::= CompilationUnit
       | Imports? Exports Decls?
       | Imports? AbsDecls
       | Imports AbsDecls?

    AST does not provide such productions: They are all translated to
    CompilationUnit.

 3) CSG distinguishes occurrences of "Id", "opr Op", and "opr EncloserPair".
    For example:

AliasedName ::= Id (as DottedId)?
              | opr Op (as Op)?
              | opr EncloserPair (as EncloserPair)?
EncloserPair ::= LeftEncloser RightEncloser

    AST does not distinguish them but uses FnName as follows:

AliasedName(FnName fnName, Option<FnName> alias = new None<FnName>());

 4) CSG classifies declarations that can occur in trait, abstract trait, object,
    and abstract object declarations in detail.  For example:

GoInATrait        ::= Coercions? GoFrontInATrait GoBackInATrait?
                    | Coercions? GoBackInATrait
GoesFrontInATrait ::= AbsFldDecl
                    | GetterSetterDecl
                    | PropertyDecl
GoesBackInATrait  ::= MdDecl
                    | PropertyDecl

    AST does not classify them but abstracts them as lists of Decls or lists of
    AbsDecls as follows:

TraitDecl(List<? extends Decl> decls) implements GenericDecl;

 5) CSG distinguishes kinds of modifiers for each declaration can have.  For
    example:

AbsTraitMod ::= value | test

    AST does not distinguish them but abstracts them as lists of Modifiers
    as follows:

TraitObjectAbsDeclOrDecl(List<Modifier> mods ...)

 6) CSG has productions for most of clauses.  For example:

Extends ::= extends TraitTypes

    AST does not have such productions.  For example:

TraitObjectAbsDeclOrDecl(..., Option<List<TraitType>> extendsClause ...)

 7) CSG distinguishes parameters of objects, methods, and functions.  For
    example:

ObjectValParam ::= ( ObjectParams? )
ObjectParams ::= (ObjectParam ,)* (ObjectVarargs, )? ObjectKeyword(, ObjectKeyword)*
               | (ObjectParam ,)* ObjectVarargs
               | ObjectParam (, ObjectParam)*
ObjectVarargs ::= transient Varargs
ObjectKeyword ::= ObjectParam = Expr
ObjectParam ::= ParamFldMods? Param
              | transient Param

    AST does not distinguish them but abstracts them as follows:

abstract Param(List<Modifier> mods = Collections.<Modifier>emptyList(),
               Id id);
    NormalParam(Option<TypeRef> type = None.<TypeRef>make(),
                Option<Expr> defaultExpr = None.<Expr>make());
    VarargsParam(VarargsType varargsType);

 8) CSG distinguishes various forms of left-hand sides of variable and field
    declarations.  For example:

VarDecl ::= VarMods? VarWTypes InitVal
          | VarMods? IdOrIdTuple = Expr
          | VarMods? IdOrIdTuple : TypeRef ... InitVal
          | VarMods? IdOrIdTuple : SimpleTupleType InitVal

    AST does not distinguish them but abstracts them as follows:

abstract VarAbsDeclOrDecl(List<LValueBind> lhs) implements VarFieldAbsDeclOrDecl;
LValueBind(Id id, Option<TypeRef> type = None.<TypeRef>make(),
           List<Modifier> mods = Collections.<Modifier>emptyList(),
           boolean mutable) implements LHS;

 9) CSG distinguishes functional declarations in APIs and components (AbsFnDecl
    and FnDecl, respectively) but it does not distinguish functional declarations
    with and without body expressions.  AST does not distinguishes functional
    declarations in APIs and functional declarations without body expressions
    in components (both AbsFnDecl) but it distinguishes functional declarations
    without body expressions in components (AbsFnDecl) and functional
    declarations with body expressions (FnDef) in components.  These differences
    are purely due to the different interests between the parser which cares
    about syntactic entities and the later phases of the compiler which care
    about semantic entities.

10) CSG distinguishes function, method, getter, setter, and coercion declarations
    but AST does not distinguish them.  Similarly, CSG distinguishes top-level
    variable and field declarations but AST does not.

11) A parenthesized expression in CSG:

Parenthesized ::= ( Expr )

    is represented as an Expr whose 'parenthesized" is set.

12) CSG distinguishes big operators but AST abstracts them as Op.

13) CSG syntactically restricts kinds of expressions that can appear after the
    atomic and tryatomic reserved words.  AST abstracts them as Expr.

14) Even though a function expression does not have a name, static parameters,
    nor a where clause in CSG, AST includes them in FnExpr for the interpreter's
    benefit.

15) For the interpreter to manipulate scopes within block expressions, the
    following syntax in CSG:

BlockElem ::= LocalVarFnDecl
            | Expr(, GeneratorList)?
LocalVarFnDecl ::= LocalFnDecl+
                 | LocalVarDecl

    is represented as follows:

LetExpr(List<Expr> body);
    GeneratedExpr(Expr expr, List<Generator> gens);
    LetFn(List<FnDef> fns);
    LocalVarDecl(List<LValue> lhs, Option<Expr> rhs = None.<Expr>make());

    in AST.

16) Unpasting syntax is slightly different.  The following syntax in CSG:

Unpasting ::= [ UnpastingElems ]
UnpastingElems ::= UnpastingElem RectSeparator UnpastingElems
                 | UnpastingElem
UnpastingElem ::= Id ([ UnpastingDim ])?
                | Unpasting
UnpastingDim ::= ExtentRange (BY ExtentRange)+

    is represented in AST as follows:

abstract Unpasting();
    UnpastingBind(Id id, List<ExtentRange> dim);
    UnpastingSplit(List<Unpasting> elems, int dim);

17) In CSG, only Id or IntLiteral can appear in left-hand sides of array
    comprehension clauses:

ArrayComprehensionLeft ::= IdOrInt |-> Expr
                         | ( IdOrInt, IdOrIntList ) |-> Expr
IdOrInt ::= Id
          | IntLiteral
ArrayComprehensionClause ::= ArrayComprehensionLeft | GeneratorList

    AST abstracts them as:

ArrayComprehensionClause(List<Expr> bind, Expr init, List<Generator> gens);

18) Array expression syntax is slightly different.  The following syntax in CSG:

Aggregate ::= [ RectElements ]
RectElements ::= Expr MultiDimCons*
MultiDimCons ::= RectSeparator Expr
RectSeparator ::= ;+
                | Whitespace

    is represented in AST as follows:

abstract ArrayExpr();
    ArrayElement(Expr element);
    ArrayElements(int dimension, List<ArrayExpr> elements);

19) While CSG treats parenthesized expressions and tuple expressions as
    functional arguments differently from other expressions as follows:

BaseExpr ::= NoKeyTuple
           | Parenthesized

    AST does not distinguish them.

20) Some expressions using operators cannot be parsed correctly without type
    information.  Therefore, the following syntax in CSG:

OpExpr ::= EncloserOp OpExpr? EncloserOp?
         | OpExpr EncloserOp OpExpr?
         | Primary
EncloserOp ::= Encloser
             | Op
Primary ::= LeftEncloser ExprList? RightEncloser
          | Primary . Id ([\StaticArgList\])? Parenthesized
          | Primary . Id ([\StaticArgList\])? ()
          | Primary ^ BaseExpr
          | Primary ExponentOp
          | Primary Parenthesized
          | Primary ()
          | Primary Primary

    is abstracted in AST as follows:

abstract OpExpr();
    OprExpr(OprName op,
            List<Expr> args = Collections.<Expr>emptyList());
    abstract Primary();
        Apply(Expr fn, Expr args);
        ChainExpr(Expr first, List<Pair<Op, Expr>> links);
        LooseJuxt(List<Expr> exprs);
        TightJuxt(List<Expr> exprs);
        FnRef(Expr expr,
              List<StaticArg> staticArgs = Collections.<StaticArg>emptyList());

21) Matrix types in CSG:

TypeRef ::= TypeRef ^ StaticArg
          | TypeRef ^ ( ExtentRange (BY ExtentRange)* )

    is represented as follows in AST:

MatrixType(TypeRef element, List<ExtentRange> dimensions);

22) Array sizes in CSG:

ArraySize ::= ExtentRange(, ExtentRange)*

    is represented as follows in AST:

abstract Indices();
    FixedDim(List<ExtentRange> extents);

23) CSG distinguishes prefix and postfix operators of dimensions and units:

DUPreOp ::= square | cubic | inverse
DUPostOp ::= squared | cubed

    AST does not distinguish them:

abstract DimUnitOp();
    SquareDimUnit();
    CubicDimUnit();
    InverseDimUnit();

24) AST has the following internal nodes that do not have corresponding syntax
    in CSG:

AnonymousFnName();
ConstructorFnName(GenericWithParams def);

25) CSG does not distinguish between different kinds of operators.  AST
    classifies operators as follows:

abstract OprName();
    Enclosing(Op open, Op close);
    Opr(Op op);
    PostFix(Op op);
    SubscriptAssign();
    SubscriptOp();

26) CSG distinguishes contracts used in coercion declarations and the other
    functional declarations and object declarations.  AST abstracts them
    as Contract.

27) While CSG treats parenthesized types differently from other types as follows:

NonArrowType ::= ( TypeRef? )

    AST does not have a separate node for parenthesized types but maintains
    a field describing parenthesizedness.

28) While CSG has NonArrowType for the types of domain and range of an arrow
    type, AST abstracts them as TypeRef.


* Criteria for the Differences in CSG and AST
 1) It should be possible to reverse-engineer the source code from AST.
 2) Convenience for visitors is more preferrable to instanceof testing.
 3) Subclasses for variants are more preferrable to a class with a field.
 4) Do not propogate the subtype structure of a field to the enclosing method.
 5) Only leaves should be concrete classes.
 6) Common fields should be hoisted where possible and where it makes sense.

* Frequently Asked Questions and Answers for Fortress.ast
 1) Why does it distinguish between List<TypeRef> and Option<List<TypeRef>>?
   - Each of extends and excludes clauses and static parameter lists has type
     List<...> because an empty clause or an empty list is a parse error.
   - A parameter list of a functional has type List<Param> because a functional
     always has a possibly empty parameter list.
   - Each of comprises, throws, require, ensures, and invariants clauses has
     type Option<List<...>> because we want to distinguish between:
trait T end
     and
trait T comprises {...} end
     for IDE supports.
   - A parameter list of

 2) What are the purposes of the interfaces?

 3) What does the FnName hierarchy mean?
    FnName (abstract)      : name representing a functional
        DottedId           : qualified name
        AnonymousFnName    : internal name for anonymous function expression
        ConstructorFnName  : internal name for anonymous constructor expression
        OprName (abstract) : name representing an operator
            Enclosing      : a pair of enclosing operators
            PostFix        : a postfix operator
            SubscriptAssign: subscripted assignment operator [ ] :=
            SubscriptOp    : subscripting operator [ ]
            Opr            : all the other operator

 4) What is the root of the node hierarchy, UIDObject?
   - It provides a unique identification for each node.
   - It should not include things that are applicable only to nodes.
   - It should include things that are shared by nodes and the other parts
     of the interpreter such as the "at" method.


* Nodes That May Be Added Later
 1) Separate nodes for top-level functions, local functions, dotted methods,
    functional methods, operators, coercions, getters, and setters.
