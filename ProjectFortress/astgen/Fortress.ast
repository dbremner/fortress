/*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

// REMINDER: If you modify this file, you probably ought to be
// changing ExprFactory.makeInParentheses as well.

generateEmptyConstructor yes;   // for reflective object creation
visitMethod accept;
visitorMethodPrefix for;
addGetterPrefixes yes;
usePLT yes;
tabSize 4;
allowNulls no;
generateToString no;
generateEquals yes;
generateSerializers yes;

package com.sun.fortress.nodes;
import java.math.BigInteger;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import com.sun.fortress.nodes_util.*;
import com.sun.fortress.parser_util.*;
import com.sun.fortress.parser_util.precedence_opexpr.*;
import com.sun.fortress.useful.*;
import edu.rice.cs.plt.tuple.Option;

begin ast;

/**
 * top-level node interface
 */
interface Node(ignoreForEquals Span span = new Span()) extends HasAt;
    /**
     * declaration in components or APIs
     */
    interface AbsDeclOrDecl();
        /**
         * declaration in APIs
         */
        interface AbsDecl();
        /**
         * declaration in components
         */
        interface Decl();
    /**
     * left-hand-side of assignments, local variable declarations, or
     * top-level declarations.
     */
    interface LHS();
    /**
     * with static parameters
     * implemented by trait, object, and function declarations and
     * object expressions in components or APIs
     */
    interface Generic(List<StaticParam> staticParams);
    /**
     * with value parameters
     * implemented by object declarations and object expressions in components
     * or APIs
     */
    interface HasParams(Option<List<Param>> params,
                        List<? extends AbsDeclOrDecl> decls);
    /**
     * with a where clause
     * implemented by trait and object declarations in components or APIs
     */
    interface HasWhere(WhereClause where);
    /**
     * templates
     */
    interface TemplateGap(Id id, List<Id> params);

/**
 * functional declaration or function expression
 * nodes_util.NodeUtil declares the following static methods:
 *  - String nameAsMethod(Applicable)
 *  - Option<Expr> getBody(Applicable)
 */
interface Applicable(IdOrOpOrAnonymousName name, List<StaticParam> staticParams,
                     List<Param> params, Option<Type> returnType,
                     WhereClause where) extends HasAt;

/**
 * intersections of interface types
 */
interface GenericWithParams() extends Generic, HasParams;
interface GenericAbsDeclOrDecl() extends Generic, AbsDeclOrDecl;
    interface GenericDecl() extends Decl;
interface GenericAbsDeclOrDeclWithParams() extends GenericWithParams,
                                                   GenericAbsDeclOrDecl;
    interface GenericDeclWithParams() extends GenericDecl;

/**
 * top-level node abstract class
 */
abstract AbstractNode(ignoreForEquals Span span = new Span())
                     extends UIDObject implements Node;
    /**
     * compilation unit declaration
     * CompilationUnit ::= Component | Api
     */
    abstract CompilationUnit(boolean _native = false,
                             APIName name, List<Import> imports);
        /**
         * component declaration
         * Component ::= native? component APIName Imports? Exports Decls? end
         * e.g.) component Hello
         *         export Executable
         *         run(args:String...) = print "Hello, World!\n"
         *       end
         */
        Component(List<Export> exports, List<Decl> decls);
        /**
         * API declaration
         * Api ::= native? api APIName Imports? AbsDecls? end
         * e.g.) api Executable
         *         run(args:String...):()
         *       end
         */
        Api(List<AbsDecl> decls);
    /**
     * import statement
     * Import ::= import ImportedNames | import api AliasedAPINames
     */
    abstract Import();
        /**
         * ImportedNames ::= APIName . {...} (except SimpleNames)?
         *                 | APIName . { AliasedSimpleNameList (, ...)? }
         *                 | QualifiedName (as Id)?
         */
        abstract ImportedNames(APIName api);
            /**
             * e.g.) import Set.{...} except {opr UNION, union}
             */
            ImportStar(List<IdOrOpOrAnonymousName> except);
            /**
             * e.g.) import Set.{empty, union}
             */
            ImportNames(List<AliasedSimpleName> aliasedNames);
        /**
         * e.g.) import api {Set, Map, List}
         */
        ImportApi(List<AliasedAPIName> apis);
    /**
     * aliased simple name used in import statements
     * AliasedSimpleName ::= Id (as Id)?
     *                     | opr Op (as Op)?
     *                     | opr EncloserPair (as EncloserPair)?
     * EncloserPair ::= (LeftEncloser | Encloser) (RightEncloser | Encloser)
     * e.g.) longComplexName as shortName
     */
    AliasedSimpleName(IdOrOpOrAnonymousName name,
                      Option<IdOrOpOrAnonymousName> alias = Option.<IdOrOpOrAnonymousName>none());
    /**
     * aliased API name used in import statements
     * AliasedAPIName ::= APIName (as Id)?
     * e.g.) com.sun.fortress.parser.precedence.resolver as precedence_resolver
     */
    AliasedAPIName(APIName api,
                   Option<Id> alias = Option.<Id>none());
    /**
     * export statement
     * Export ::= export APINames
     * e.g.) export Executable
     */
    Export(List<APIName> apis);
    /**
     * trait or object declaration in components or APIs
     */
    abstract TraitObjectAbsDeclOrDecl(List<Modifier> mods
                                          = Collections.<Modifier>emptyList(),
                                      Id name,
                                      List<StaticParam> staticParams
                                          = Collections.<StaticParam>emptyList(),
                                      List<TraitTypeWhere> extendsClause
                                          = Collections.<TraitTypeWhere>emptyList(),
                                      WhereClause where
                                          = FortressUtil.emptyWhereClause(),
                                      List<? extends AbsDeclOrDecl> decls)
                                     implements HasWhere, GenericAbsDeclOrDecl;
        /**
         * trait declaration in components or APIs
         */
        abstract TraitAbsDeclOrDecl(List<TraitType> excludes
                                        = Collections.<TraitType>emptyList(),
                                    Option<List<TraitType>> comprises
                                        = Option.<List<TraitType>>none(),
                                    List<? extends AbsDeclOrDecl> decls);
            /**
             * trait declaration in APIs
             * AbsTraitDecl ::= AbsTraitMods? TraitHeaderFront AbsTraitClauses
             *                  AbsGoInATrait? end
             * TraitHeaderFront ::= trait Id StaticParams? ExtendsWhere?
             * ExtendsWhere ::= extends TraitTypeWheres
             * AbsTraitClause ::= Excludes | AbsComprises | Where
             * Excludes ::= excludes TraitTypes
             * AbsComprises ::= comprises ComprisingTypes
             * ComprisingTypes ::= TraitType | { ComprisingTypeList }
             * ComprisingTypeList ::= ...
             *                      | TraitType(, TraitType)*(, ...)?
             * AbsGoInATrait ::= AbsCoercions? AbsGoFrontInATrait AbsGoBackInATrait?
             *                 | AbsCoercions? AbsGoBackInATrait
             *                 | AbsCoercions
             * AbsGoesFrontInATrait ::= ApiFldDecl
             *                        | AbsGetterSetterDecl
             *                        | PropertyDecl
             * AbsGoesBackInATrait  ::= AbsMdDecl
             *                        | PropertyDecl
             * e.g.) trait List[\alpha\] comprises {Cons[\alpha\],Empty[\alpha\]}
             *         cons(x: alph): List[\alpha\]
             *       end
             */
            AbsTraitDecl(List<AbsDecl> decls) implements AbsDecl;
            /**
             * trait declaration in components
             * TraitDecl ::= TraitMods? TraitHeaderFront TraitClauses GoInATrait?
             *               end
             * TraitClause ::= Excludes | Comprises | Where
             * Comprises ::= comprises TraitTypes
             * GoInATrait ::= Coercions? GoFrontInATrait GoBackInATrait?
             *              | Coercions? GoBackInATrait
             *              | Coercions
             * GoesFrontInATrait ::= AbsFldDecl
             *                     | GetterSetterDecl
             *                     | PropertyDecl
             * GoesBackInATrait  ::= MdDecl
             *                     | PropertyDecl
             * e.g.) trait List[\alpha\] comprises {Cons[\alpha\],Empty[\alpha\]}
             *         cons(x: alph): List[\alpha\] = Cons[\alph\](x, self)
             *       end
             */
            TraitDecl(List<Decl> decls) implements GenericDecl;
        /**
         * object declaration in components or APIs
         */
        abstract ObjectAbsDeclOrDecl(Option<List<Param>> params
                                         = Option.<List<Param>>none(),
                                     Option<List<TraitType>> throwsClause
                                         = Option.<List<TraitType>>none(),
                                     Contract contract = new Contract(),
                                     List<? extends AbsDeclOrDecl> decls)
                                    implements GenericAbsDeclOrDeclWithParams;
            /**
             * object declaration in APIs
             * AbsObjectDecl ::= AbsObjectMods? ObjectHeader AbsGoInAnObject? end
             * ObjectHeader ::= object Id StaticParams? ObjectValParam?
             *                  ExtendsWhere? FnClauses
             * FnClauses ::= Throws? Where? Contract
             * Throws ::= throws MayTraitTypes
             * ObjectValParam ::= ( ObjectParams? )
             * ObjectParams ::= (ObjectParam ,)* (ObjectVarargs, )? ObjectKeyword(, ObjectKeyword)*
             *                | (ObjectParam ,)* ObjectVarargs
             *                | ObjectParam (, ObjectParam)*
             * ObjectVarargs ::= transient Varargs
             * ObjectKeyword ::= ObjectParam = Expr
             * ObjectParam ::= ParamFldMods? Param
             *               | transient Param
             * AbsGoInAnObject ::= AbsCoercions? AbsGoFrontInAnObject AbsGoBackInAnObject?
             *                   | AbsCoercions? AbsGoBackInAnObject
             *                   | AbsCoercions
             * AbsGoesFrontInAnObject ::= ApiFldDecl
             *                          | AbsGetterSetterDecl
             *                          | PropertyDecl
             * AbsGoesBackInAnObject ::= AbsMdDecl
             *                         | PropertyDecl
             * e.g.) object Empty[\alph\]() extends List[\alpha\] end
             */
            AbsObjectDecl(List<AbsDecl> decls) implements AbsDecl;
            /**
             * object declaration in components
             * ObjectDecl ::= ObjectMods? ObjectHeader GoInAnObject? end
             * GoInAnObject ::= Coercions? GoFrontInAnObject GoBackInAnObject?
             *                | Coercions? GoBackInAnObject
             *                | Coercions
             * GoesFrontInAnObject ::= FldDecl
             *                       | GetterSetterDecl
             *                       | PropertyDecl
             * GoesBackInAnObject ::= MdDef
             *                      | PropertyDecl
             * e.g.) object Empty[\alph\]() extends List[\alpha\]
             *         length() = 0
             *       end
             */
            ObjectDecl(List<Decl> decls)
                      implements GenericDeclWithParams;
    /**
     * variable declaration in components or APIs
     */
    abstract VarAbsDeclOrDecl(List<LValueBind> lhs) implements AbsDeclOrDecl;
        /**
         * variable declaration in APIs
         * AbsVarDecl ::= AbsVarMods? VarWTypes
         *              | AbsVarMods? BindIdOrBindIdTuple : Type ...
         *              | AbsVarMods? BindIdOrBindIdTuple : SimpleTupleType
         * VarWTypes ::= VarWType | ( VarWType(, VarWType)+ )
         * VarWType ::= BindId IsType
         * BindIdOrBindIdTuple ::= BindId
         *                       | ( BindId , BindIdList )
         * BindId ::= Id | _
         * e.g.) var (x, y): ZZ64...
         */
        AbsVarDecl() implements AbsDecl, Decl;
        /**
         * variable declaration in components
         * VarDecl ::= VarMods? VarWTypes InitVal
         *           | VarMods? BindIdOrBindIdTuple = Expr
         *           | VarMods? BindIdOrBindIdTuple : Type ... InitVal
         *           | VarMods? BindIdOrBindIdTuple : SimpleTupleType InitVal
         * InitVal ::= (= | :=) Expr
         * e.g.) var (x, y): ZZ64... = (5, 6)
         */
        VarDecl(Expr init) implements Decl;
    /**
     * left-hand side of variable declaration
     */
    abstract LValue();
        /**
         * e.g.) var x: ZZ32
         */
        LValueBind(Id name, Option<Type> type = Option.<Type>none(),
                   List<Modifier> mods = Collections.<Modifier>emptyList(),
                   boolean mutable) implements LHS;
        /**
         * left-hand side of matrix unpasting
         * Unpasting ::= [ UnpastingElems ]
         */
        abstract Unpasting();
            /**
             * simple unpasting
             * UnpastingElem ::= BindId ([ UnpastingDim ])?
             *                 | Unpasting
             * UnpastingDim ::= ExtentRange (BY ExtentRange)+
             * e.g.) squareShape[m BY m]
             */
            UnpastingBind(Id name, List<ExtentRange> dim);
            /**
             * complex unpasting
             * UnpastingElems ::= UnpastingElem RectSeparator UnpastingElems
             *                  | UnpastingElem
             * e.g.) squareShape[m BY m]  rest
             */
            UnpastingSplit(List<Unpasting> elems, int dim);
    /**
     * functional declaration in components or APIs
     */
    abstract FnAbsDeclOrDecl(List<Modifier> mods
                                 = Collections.<Modifier>emptyList(),
                             IdOrOpOrAnonymousName name,
                             List<StaticParam> staticParams
                                 = Collections.<StaticParam>emptyList(),
                             List<Param> params,
                             Option<Type> returnType
                                 = Option.<Type>none(),
                             Option<List<TraitType>> throwsClause
                                 = Option.<List<TraitType>>none(),
                             WhereClause where
                                 = FortressUtil.emptyWhereClause(),
                             Contract contract = new Contract(),
                             String selfName = NodeUtil.defaultSelfName)
                            implements Applicable, GenericDecl;
        /**
         * functional declaration in components or APIs
         * AbsFnDecl ::= AbsFnMods? FnHeaderFront FnHeaderClause
         *             | FnSig
         * FnSig ::= SimpleName : ArrowType
         * FnHeaderFront ::= NamedFnHeaderFront
         *                 | OpHeaderFront
         * NamedFnHeaderFront ::= Id StaticParams? ValParam
         * OpHeaderFront ::= opr StaticParams? BIG? (LeftEncloser | Encloser)
         *                     Params (RightEncloser | Encloser)
         *                 | opr StaticParams? ValParam (Op | ExponentOp)
         *                 | opr BIG? (Op | ^ | Encloser) StaticParams? ValParam
         * FnHeaderClause ::= IsType? FnClauses
         * FnDecl ::= FnMods? FnHeaderFront FnHeaderClause
         *          | FnSig
         * e.g.) swap (x: Object, y: Object): (Object, Object)
         */
        AbsFnDecl() implements AbsDecl;
        /**
         * functional declaration in components
         * FnDecl ::= FnMods? FnHeaderFront FnHeaderClause = Expr
         * e.g.) swap (x, y) = (y, x)
         */
        abstract FnDecl();
            FnDef(Expr body);
    /**
     * value parameter of functional declarations and object declarations
     * e.g.) x: ZZ32 = 3
     * e.g.) self
     * e.g.) transient x: String
     */
    abstract Param(List<Modifier> mods = Collections.<Modifier>emptyList(),
                   Id name);
        /**
         * ValParam := BindId
         *           | ( Params? )
         * Params ::= (Param, )* (Varargs, )? Keyword(, Keyword)*
         *          | (Param, )* Varargs
         *          | Param(, Param)*
         * Keyword ::= Param = Expr
         * Param ::= BindId IsType?
         *         | Type
         */
        NormalParam(Option<Type> type = Option.<Type>none(),
                    Option<Expr> defaultExpr = Option.<Expr>none());
        /**
         * varargs parameter
         * Varargs ::= BindId : Type ...
         */
        VarargsParam(VarargsType varargsType);
    /**
     * dimension and unit declaration
     * DimUnitDecl may represent a single dimension declaration, a single
     * unit declaration, or both dimension and unit declarations.
     * DimUnitDecl ::= dim Id (= Type)? (unit | SI_unit) Id+ (= Expr)?
     *               | dim Id (= Type)? (default Id)?
     *               | (unit | SI_unit) Id+ (: Type)? (= Expr)?
     * e.g.) unit inch inches: Length
     * e.g.) dim Length SI_unit meter meters m
     */
    abstract DimUnitDecl() implements Decl, AbsDecl;
        /**
         * dimension declaration
         */
        DimDecl(Id dim, Option<Type> derived = Option.<Type>none(),
                Option<Id> default = Option.<Id>none());
        /**
         * unit declaration
         */
        UnitDecl(boolean si_unit = false,
                 List<Id> units = Collections.<Id>emptyList(),
                 Option<Type> dim = Option.<Type>none(),
                 Option<Expr> def);
    /**
     * test declaration
     * TestDecl ::= test Id [ GeneratorClauseList ] = Expr
     * e.g.) test fxLessThanFy[x <- E, y <- F] = assert(f(x) < f(y))
     */
    TestDecl(Id name, List<GeneratorClause> gens, Expr expr)
            implements Decl, AbsDecl;
    /**
     * property declaration
     * PropertyDecl ::= property (Id = )? (FORALL ValParam)? Expr
     * e.g.) property fIsMonotonic = FORALL (x:ZZ, y:ZZ) (x < y) -> (f(x) < f(y))
     */
    PropertyDecl(Option<Id> name = Option.<Id>none(), List<Param> params,
                 Expr expr) implements Decl, AbsDecl;
    /**
     * syntax expanders declaration in components or APIs
     */
    abstract ExternalSyntaxAbsDeclOrDecl(IdOrOpOrAnonymousName openExpander, Id name,
                                         IdOrOpOrAnonymousName closeExpander)
                                        implements AbsDeclOrDecl;
        /**
         * syntax expanders declaration in APIs
         * AbsExternalSyntax ::= syntax OpenExpander Id CloseExpander
         * OpenExpander ::= Id
         *                | (LeftEncloser / Encloser)
         * CloseExpander ::= Id
         *                 | (RightEncloser / Encloser)
         *                 | end
         * e.g.) syntax sql e end
         */
        AbsExternalSyntax() implements AbsDecl;
        /**
         * syntax expanders declaration in APIs
         * ExternalSyntax ::= syntax OpenExpander Id CloseExpander = Expr
         * e.g.) syntax sql e end = parseSQL(e)
         */
        ExternalSyntax(Expr expr) implements Decl;
    /**
     * grammar declaration
     */
    abstract GrammarDecl(Id name, List<Id> extends) implements AbsDecl;
        /**
         * grammar definition in grammar declarations
         */
        GrammarDef(List<GrammarMemberDecl> members);
    /**
     * grammar member (nonterminal or terminal) declaration
     */
    abstract GrammarMemberDecl(Id name,
                            Option<TraitType> type,
                            Option<? extends Modifier> modifier
                            List<Pair<Id,Type>> params) implements AbsDecl;
        /**
         * nonterminal declaration
         */
        abstract NonterminalDecl(List<SyntaxDef> syntaxDefs);
            /**
             * nonterminal definition in nonterminal declarations
             */
            NonterminalDef();
            /**
             * nonterminal extending definition in nonterminal declarations
             */
            NonterminalExtensionDef();
        /**
         * terminal declaration
         */
        abstract TerminalDecl(SyntaxDef syntaxDef);
            /**
             * terminal definition result of rewrite of keyword and token symbols in disambigutation of
             * syntax abstractions
             */
            _TerminalDef();
    /**
     * syntax declaration
     */
    abstract SyntaxDecl() implements AbsDecl;
        /**
         * syntax definition in syntax declarations
         */
        SyntaxDef(List<SyntaxSymbol> syntaxSymbols,
                  TransformationDecl transformation);
    /**
      * Transformation declaration
      */
    abstract TransformationDecl() implements AbsDecl;
        /**
         * pre template definition in template declarations
         */
        TransformationPreTemplateDef(String productionName, String transformation);
        /**
         * template definition in template declarations
         */
        TransformationTemplateDef(AbstractNode transformation);
        /**
         * template definition in template declarations
         */
        TransformationExpressionDef(Expr transformation);
    /**
      * syntax symbol
      */
    abstract SyntaxSymbol();
        /**
         * prefixed syntax symbol
         */
        PrefixedSymbol(Option<Id> id, SyntaxSymbol symbol);
        /**
         * optional syntax symbol
         */
        OptionalSymbol(SyntaxSymbol symbol);
        /**
         * repeat zero-or-more syntax symbol
         */
        RepeatSymbol(SyntaxSymbol symbol);
        /**
         * repeat one-or-more syntax symbol
         */
        RepeatOneOrMoreSymbol(SyntaxSymbol symbol);
        /**
         * ignore following whitespace syntax symbol
         */
        NoWhitespaceSymbol(SyntaxSymbol symbol);
        /**
         * special symbols syntax symbol
         */
        abstract SpecialSymbol();
            /**
             * whitespace syntax symbol
             */
            WhitespaceSymbol(String s);
            /**
             * tab syntax symbol
             */
            TabSymbol();
            /**
             * formfeed syntax symbol
             */
            FormfeedSymbol();
            /**
             * carriage return syntax symbol
             */
            CarriageReturnSymbol();
            /**
             * backspace syntax symbol
             */
            BackspaceSymbol();
            /**
             * newline syntax symbol
             */
            NewlineSymbol();
            /**
             * breakline syntax symbol
             */
            BreaklineSymbol(String s);
        /**
         * item syntax symbol
         */
        ItemSymbol(String item);
        /**
         * non-terminal syntax symbol
         */
        NonterminalSymbol(Id nonterminal);
        /**
         * keyword syntax symbol
         */
        KeywordSymbol(String token);
        /**
         * token syntax symbol
         */
        TokenSymbol(String token);
        /**
         * not predicate syntax symbol
         */
        NotPredicateSymbol(SyntaxSymbol symbol);
        /**
         * and predicate syntax symbol
         */
        AndPredicateSymbol(SyntaxSymbol symbol);
        /**
         * character class syntax symbol
         */
        CharacterClassSymbol(List<CharacterSymbol> characters);
        /**
         * character symbols
         */
        abstract CharacterSymbol();
            /**
             * character
             */
            CharSymbol(String string);
            /**
             * character interval
             */
            CharacterInterval(String begin, String end);
    /**
     * expression
     */
    abstract Expr(boolean parenthesized = false);
        /**
         * Template gap for expressions
         */
        TemplateGapExpr(Id id, List<Id> params) implements TemplateGap;
        /**
         * expression annotated with a type
         */
        abstract TypeAnnotatedExpr(Expr expr, Type type);
            /**
             * type ascription expression
             * Expr ::= Expr as Type
             * e.g.) 3 as Number
             */
            AsExpr();
            /**
             * type assumption expression
             * Expr ::= Expr asif Type
             * e.g.) Empty asif List[\String\]
             */
            AsIfExpr();
        /**
         * assignment expression
         * AssignExpr ::= AssignLefts AssignOp Expr
         * AssignLefts ::= ( AssignLeft(, AssignLeft)* )
         *               | AssignLeft
         * AssignLeft ::= SubscriptExpr
         *              | FieldSelection
         *              | QualifiedName
         * FieldSelection ::= Primary . Id
         * AssignOp ::= := | Op=
         * e.g.) x += 1
         */
        Assignment(List<LHS> lhs, Option<Op> opr, Expr rhs);
        /**
         * expressions beginning and ending with reserved words
         * Expr ::= DelimitedExpr
         */
        abstract DelimitedExpr();
            /**
             * sequence of block elements implicitly enclosed by do/end
             * BlockElems ::= BlockElem+
             * e.g.) y = x
             *       z = 2x
             *       y + z
             */
            Block(List<Expr> exprs);
            /**
             * case expression or extremum expression
             * DelimitedExpr ::= case Expr Op? of CaseClauses CaseElse? end
             *                 | case most Op of CaseClauses end
             * CaseElse ::= else => BlockElems
             * e.g.) case most > of
             *         1 mile => "miles are larger"
             *         1 kilometer => "we were wrong again"
             *       end
             */
            CaseExpr(Option<Expr> param, Option<Op> compare = Option.<Op>none(),
                     List<CaseClause> clauses,
                     Option<Block> elseClause = Option.<Block>none());
            /**
             * do expression
             * Do ::= (DoFront also)* DoFront end
             * e.g.) do
             *         accum += treeSum(t.left)
             *       also do
             *         accum += treeSum(t.right)
             *       also do
             *         accum += t.datum
             *       end
             */
            Do(List<DoFront> fronts);
            /**
             * for expression
             * DelimitedExpr ::= for GeneratorClauseList DoFront end
             * e.g.) for i <- sequential(1:5) do
             *         print (i " ")
             *       end
             */
            For(List<GeneratorClause> gens, DoFront body);
            /**
             * if expression
             * DelimitedExpr ::= if CondExpr then BlockElems Elifs? Else? end
             *                 | ( if CondExpr then BlockElems Elifs? Else end? )
             * Elif ::= elif CondExpr then BlockElems
             * Else ::= else BlockElems
             * CondExpr ::= BindId <- Expr
             *            | Expr
             * e.g.) if x IN {0, 1, 2} then 0
             *       elif x IN {3, 4, 5} then 3
             *       else 6 end
             */
            If(List<IfClause> clauses,
               Option<Block> elseClause = Option.<Block>none());
            /**
             * label expression
             * DelimitedExpr ::= label Id BlockElems end Id
             * e.g.) label I_95
             *         if goingTo(Sun)
             *         then exit I_95 with x32B
             *         else x32A
             *         end
             *       end I_95
             */
            Label(Id name, Block body);
            /**
             * object expression
             */
            abstract AbstractObjectExpr(List<TraitTypeWhere> extendsClause
                                            = Collections.<TraitTypeWhere>emptyList(),
                                        List<Decl> decls);
                /**
                 * object expression
                 * DelimitedExpr ::= object ExtendsWhere? GoInAnObject? end
                 * e.g.)  object extends {List}
                 *          cons(x) = Cons(x, self)
                 *          append (xs) = xs
                 *        end
                 */
                ObjectExpr();
                /**
                 * object expression rewritten by interpreter.rewrite.Disambiguate
                 */
                _RewriteObjectExpr(BATree<String, StaticParam> implicitTypeParameters,
                                   String genSymName,
                                   List<StaticParam> staticParams,
                                   List<StaticArg> staticArgs,
                                   Option<List<Param>> params)
                                  implements GenericWithParams;
            /**
             * try expression
             * DelimitedExpr ::= try BlockElems Catch? (forbid TraitTypes)?
             *                     (finally BlockElems)? end
             * e.g.) try
             *         inp = read (file)
             *         write (inp, newFile)
             *       forbid IOException
             *       end
             */
            Try(Block body, Option<Catch> catchClause = Option.<Catch>none(),
                List<TraitType> forbid = Collections.<TraitType>emptyList(),
                Option<Block> finallyClause = Option.<Block>none());
            /**
             * labeled expression: tuple expression or argument expression
             */
            abstract AbstractTupleExpr(List<Expr> exprs);
                /**
                 * tuple expression
                 * TupleExpr ::= ( (Expr,)+ Expr )
                 * e.g.) (1, 2, 5)
                 */
                TupleExpr();
                /**
                 * argument expression
                 * ArgExpr ::= ( (Expr,)* (Expr...,)? KeywordExpr(, KeywordExpr)* )
                 *           | ( (Expr,)* Expr... )
                 *           | TupleExpr
                 * e.g.) (1, 2, [3 4]..., x = 5)
                 */
                ArgExpr(Option<VarargsExpr> varargs
                            = Option.<VarargsExpr>none(),
                        List<KeywordExpr> keywords
                            = Collections.<KeywordExpr>emptyList(),
                        boolean inApp = false);
            /**
             * typecase expression
             * DelimitedExpr ::= typecase TypecaseBindings of TypecaseClauses
             *                     CaseElse? end
             * TypecaseBindings ::= TypecaseVars (= Expr)?
             * TypecaseVars ::= BindId
             *              |   ( BindId(, BindId)+ )
             * e.g.) typecase x = myLoser .myField of
             *         String => x.append("foo")
             *         Number => x + 3
             *         Object => yogiBerraAutograph
             *       end
             */
            Typecase(Pair<List<Id>, Option<Expr>> bind,
                     List<TypecaseClause> clauses,
                     Option<Block> elseClause = Option.<Block>none());
            /**
             * while expression
             * DelimitedExpr ::= while GeneratorClause Do
             * e.g.) while x < 10 do print x; x += 1 end
             */
            While(GeneratorClause test, Do body);
        /**
         * control flow expression
         * Expr ::= FlowExpr
         */
        abstract FlowExpr();
            /**
             * comprehension or accumulator
             */
            abstract BigOprApp(List<StaticArg> staticArgs
                                   = Collections.<StaticArg>emptyList());
                /**
                 * summation and other reduction expression
                 * FlowExpr ::= Accumulator StaticArgs?
                 *                ([ GeneratorClauseList ])? Expr
                 * Accumulator ::= SUM | PRODUCT | Big Op
                 * e.g.) PRODUCT[i <- 1:n] i
                 */
                Accumulator(OpName opr, List<GeneratorClause> gens, Expr body);
                /**
                 * array comprehension
                 * Comprehension ::= BIG? [ StaticArgs? ArrayComprehensionClause+
                 *                        ]
                 * e.g.) [(x, y, 1) |-> 0.0 | x <- 1:xSize, y <- 1:ySize ]
                 */
                ArrayComprehension(List<ArrayComprehensionClause> clauses);
            /**
             * atomic expression
             * FlowExpr ::= atomic AtomicBack
             * AtomicBack ::= AssignExpr
             *              | OpExpr
             *              | DelimitedExpr
             * e.g.) atomic sum += a[i]
             */
            AtomicExpr(Expr expr);
            /**
             * exiting labeled expressions
             * FlowExpr ::= exit Id? (with Expr)?
             * e.g.) exit I_95 with x32B
             */
            Exit(Option<Id> target = Option.<Id>none(),
                 Option<Expr> returnExpr = Option.<Expr>none());
            /**
             * spawn expression
             * FlowExpr ::= spawn Expr
             * e.g.) spawn mm(lefttop, right, resulttop)
             */
            Spawn(Expr body);
            /**
             * throw expression
             * FlowExpr ::= throw Expr
             * e.g.) throw Error
             */
            Throw(Expr expr);
            /**
             * tryatomic expression
             * FlowExpr ::= tryatomic AtomicBack
             * e.g.) tryatomic sum += a[i]
             */
            TryAtomicExpr(Expr expr);
        /**
         * function expression
         * Expr ::= fn ValParam IsType? Throws? => Expr
         * e.g.) fn x => x + 2
         */
        FnExpr(ignoreForEquals Span span, // no default -- required to produce a fnName
               boolean parenthesized = false,
               IdOrOpOrAnonymousName name = new AnonymousFnName(in_span),
               List<StaticParam> staticParams
                   = Collections.<StaticParam>emptyList(),
               List<Param> params,
               Option<Type> returnType = Option.<Type>none(),
               WhereClause where = FortressUtil.emptyWhereClause(),
               Option<List<TraitType>> throwsClause
                   = Option.<List<TraitType>>none(),
               Expr body)
              implements Applicable;
        /**
         * expression used in block expressions
         * BlockElem ::= LocalVarFnDecl
         *             | Expr(, GeneratorClauseList)?
         * LocalVarFnDecl ::= LocalFnDecl+
         *                  | LocalVarDecl
         */
        abstract LetExpr(List<Expr> body);
            /**
             * local function declaration
             * LocalFnDecl ::= LocalFnMods? NamedFnHeaderFront FnHeaderClause
             *                   = Expr
             * e.g.) localFn(x: ZZ32) = x + 2
             */
            LetFn(List<FnDef> fns);
            /**
             * local variable declaration
             * LocalVarDecl ::= var? LocalVarWTypes InitVal
             *                | var? LocalVarWTypes
             *                | var? LocalVarWoTypes = Expr
             *                | var? LocalVarWoTypes : Type ... InitVal?
             *                | var? LocalVarWoTypes : SimpleTupleType InitVal?
             * LocalVarWTypes ::= LocalVarWType
             *                  | ( LocalVarWType(, LocalVarWType)+ )
             * LocalVarWType ::= BindId IsType
             * LocalVarWoTypes ::= LocalVarWoType
             *                   | ( LocalVarWoType(, LocalVarWoType)+ )
             * LocalVarWoType ::= BindId
             *                  | Unpasting
             * e.g.) localVar x = 3
             */
            LocalVarDecl(List<LValue> lhs,
                         Option<Expr> rhs = Option.<Expr>none());
        /**
         * generated expression
         * BlockElem ::= Expr(, GeneratorClauseList)?
         * e.g.) print (i " "), i <- sequential(1:5)
         */
        GeneratedExpr(Expr expr, List<GeneratorClause> gens);
        /**
         * expression that is simple or using operators
         * Expr ::= OpExpr
         */
        abstract OpExpr();
            /**
             * subscripting expression
             * SubscriptExpr ::= Primary LeftEncloser ExprList? RightEncloser
             * e.g.) a[i]
             */
            SubscriptExpr(Expr obj, List<Expr> subs,
                          Option<Enclosing> op = Option.<Enclosing>none())
                         implements LHS;
            /**
             * primary expression
             */
            abstract Primary();
                /**
                 * literal
                 * Primary ::= LiteralExpr
                 */
                abstract LiteralExpr(String text);
                    /**
                     * number literal
                     */
                    abstract NumberLiteralExpr();
                        /**
                         * float literal
                         * e.g.) 3.5
                         */
                        FloatLiteralExpr(ignoreForEquals String text,
                                         BigInteger intPart,
                                         BigInteger numerator, int denomBase,
                                         int denomPower);
                        /**
                         * int literal
                         * e.g.) 7
                         */
                        IntLiteralExpr(String text = in_val.toString(),
                                       BigInteger val);
                    /**
                     * char literal
                     * e.g.) 'c'
                     */
                    CharLiteralExpr(int val = in_text.charAt(0));
                    /**
                     * string literal
                     * e.g.) "string"
                     */
                    StringLiteralExpr();
                    /**
                     * void literal
                     * e.g.) ()
                     */
                    VoidLiteralExpr(String text = "");
                /**
                 * variable reference
                 * VarOrFnRef ::= Id
                 * Primary ::= self
                 * e.g.) length
                 */
                VarRef(Id var) implements LHS;
                /**
                 * field selection expression
                 * Primary ::= Primary . Id
                 * e.g.) Empty.length
                 */
                abstract AbstractFieldRef(Expr obj) implements LHS;
                    /**
                     * A field selection, unless it is a method reference
                     */
                    FieldRef(Id field);
                    /**
                     * A field selection, for sure
                     * (though its implementation might be a getter/setter)
                     */
                    FieldRefForSure(Id field);
                    /**
                     * A rewritten field ref (not a getter/setter)
                     * also used to disambiguate lexical references to self/parent
                     * and within objectexprs to get access to outer scopes
                     * where the vars in the outer scopes may in turn have been
                     * API-qualified.
                     *
                     * If the reference to outer scope can be "fixed" (there is
                     * only one out scope) then it might be good to narrow this
                     * back down to an Id.
                     */
                    _RewriteFieldRef(Name field);
                /**
                 * named functional in functional applications
                 */
                abstract FunctionalRef(List<StaticArg> staticArgs
                                         = Collections.<StaticArg>emptyList());
                    /**
                     * expression with static instantiations
                     * list of ids allows cross-API overloading
                     * Primary ::= Id[\StaticArgList\]
                     * e.g.) identity[\String\]
                     */
                    FnRef(List<Id> fns,
                          List<StaticArg> staticArgs
                              = Collections.<StaticArg>emptyList());
                    /**
                     * The rewriting to explicitly name self and parent
                     * pre-interpretation may generalize the dotted
                     * list from a FnRef into something else.
                     */
                    _RewriteFnRef(Expr fn,
                                  List<StaticArg> staticArgs
                              = Collections.<StaticArg>emptyList());
                    /**
                     * operator name with (inferred) static instantiations
                     * list of operators allows cross-API overloading
                     * Primary ::= Op[\StaticArgList\]
                     * e.g.) +[\String\]
                     */
                    OpRef(List<OpName> ops,
                          List<StaticArg> staticArgs
                              = Collections.<StaticArg>emptyList());
                /**
                 * functional applicaiton
                 */
                abstract AppExpr();
                    /**
                     * juxtaposition of expressions
                     * Primary ::= Primary . Id StaticArgs? ParenthesisDelimited
                     *           | Primary TupleExpr
                     *           | Primary Primary
                     * e.g.) myString.replace("foo", "few")
                     * e.g.) log log n
                     */
                    abstract Juxt(List<Expr> exprs);
                        /**
                         * juxtaposition with intervening whitespace
                         * e.g.) 3 5
                         */
                        LooseJuxt();
                       /**
                         * juxtaposition without intervening whitespace
                         * e.g.) f(3+5)
                         */
                        TightJuxt();
                    /**
                     * expression using operators
                     * (list of ops allows cross-API overloading)
                     * OpExpr ::= EncloserOp OpExpr? EncloserOp?
                     *          | OpExpr EncloserOp OpExpr?
                     *          | Primary
                     * EncloserOp ::= Encloser
                     *              | Op
                     * Primary ::= LeftEncloser ExprList? RightEncloser
                     *           | Primary ^ Exponent
                     *           | Primary ExponentOp
                     * e.g.) 3 + 5
                     */
                    OprExpr(OpRef op,
                            List<Expr> args = Collections.<Expr>emptyList());
                    /**
                     * chain expression
                     * Certain infix mathematical operators that are
                     * traditionally regarded as relational operators,
                     * delivering boolean results, may be chained.
                     * e.g.) A SUBSETEQ B SUBSET C SUBSETEQ D
                     */
                    ChainExpr(Expr first, List<Pair<Op, Expr>> links);
                    /**
                     * coercion invocation
                     * internal node created by static analysis
                     * after inferring the implicit coercion invocations
                     */
                    CoercionInvocation(TraitType type,
                                       List<StaticArg> staticArgs
                                           = Collections.<StaticArg>emptyList(),
                                       Expr arg);
                    /**
                     * a method invocation
                     * some are created by parsing, while others require later
                     * static analysis to disambiguate from function applications
                     */
                    MethodInvocation(Expr obj, Id method,
                                     List<StaticArg> staticArgs
                                         = Collections.<StaticArg>emptyList(),
                                     Expr arg);
                /**
                 * primary expression without any dots
                 * MathPrimary ::= PrimaryFront MathItem*
                 */
                MathPrimary(Expr front, List<MathItem> rest);
                /**
                 * array expression
                 * ArrayExpr ::= [ StaticArgs? RectElements ]
                 * RectElements ::= Expr MultiDimCons*
                 * MultiDimCons ::= RectSeparator Expr
                 * RectSeparator ::= ;+
                 *                 | Whitespace
                 * e.g.) [1 2 3; 4 5 6; 7 8 9]
                 */
                abstract ArrayExpr(List<StaticArg> staticArgs
                                       = Collections.<StaticArg>emptyList());
                    /**
                     * array with a single element
                     * e.g.) [3]
                     */
                    ArrayElement(Expr element);
                    /**
                     * array with multiple elements
                     * e.g.) [3 4 5; 6 7 8]
                     */
                    ArrayElements(int dimension, List<ArrayExpr> elements);
    /**
     * type
     */
    abstract Type(ignoreForEquals boolean parenthesized = false);
        /**
         * dimension expression
         */
        abstract DimExpr();
            /* vector type or exponent dimemsion
             * resolved during parsing
             */
            ExponentType(Type base, IntExpr power);
            /* base dimension
             * DimExpr ::= Unity
             * e.g.) Unity
             */
            BaseDim();
            /* dimension identifier
             * DimExpr ::= QualifiedName
             * e.g.) com.sun.fortress.dim.Length
             */
            DimRef(Id name);
            /* dimension multiplication
             * DimExpr ::= DimExpr DOT DimExpr
             *           | DimExpr DimExpr
             * e.g.) Length Mass
             */
            ProductDim(DimExpr multiplier, DimExpr multiplicand);
            /* dimension division
             * DimExpr ::= DimExpr / DimExpr
             *           | DimExpr per DimExpr
             *           | 1 / DimExpr
             * e.g.) Length / Time
             */
            QuotientDim(DimExpr numerator, DimExpr denominator);
            /* dimension exponentiation
             * DimExpr ::= DimExpr ^ IntExpr
             * e.g.) Time^2
             */
            ExponentDim(DimExpr base, IntExpr power);
            /* dimension with operator
             * DimExpr ::= DimPrefixOp DimExpr
             *           | DimExpr DimPostfixOp
             * e.g.) Time squared
             */
            OpDim(DimExpr val, Op op);
        /**
         * arrow type
         */
        abstract AbstractArrowType(Type domain, Type range,
                                   Option<List<Type>> throwsClause
                                     = Option.<List<Type>>none(),
                                   boolean io = false);
            /**
             * arrow type
             * Type ::= Type -> Type Throws?
             * e.g.) (String, NN..., p = Printer) -> NN throws IOException
             */
            ArrowType();
            /**
             * type of a generic function, used during static checking
             */
            _RewriteGenericArrowType(List<StaticParam> staticParams
                                      = Collections.<StaticParam>emptyList(),
                                     WhereClause where
                                      = FortressUtil.emptyWhereClause());
        /**
         * nonarrow type
         */
        abstract NonArrowType();
            /**
             * bottom type
             */
            BottomType();
            /**
             * trait type
             */
            abstract TraitType();
                /**
                 * named type
                 */
                abstract NamedType(QualifiedIdName name);
                    /**
                     * type name
                     * TraitType ::= QualifiedName
                     * e.g.) T
                     */
                    IdType();
                    /**
                     * instantiated type
                     * TraitType ::= QualifiedName [\StaticArgList\]
                     * e.g.) List[\ZZ32\]
                     */
                    InstantiatedType(List<StaticArg> args);
                    /**
                     * type of a generic singleton, used during static checking
                     */
                    _RewriteGenericSingletonType(List<StaticParam> staticParams);
                /**
                 * abbreviated type
                 */
                abstract AbbreviatedType(Type element);
                    /**
                     * array type
                     * TraitType ::= Type [ ArraySize? ]
                     * e.g.) ZZ64[3, 2]
                     */
                    ArrayType(Indices indices);
                    /**
                     * matrix type
                     * TraitType ::= Type ^ IntExpr
                     *             | Type ^ ( ExtentRange (BY ExtentRange)* )
                     * e.g.)
                     */
                    MatrixType(List<ExtentRange> dimensions);
            /**
             * labeled type: tuple type or argument type
             */
            abstract AbstractTupleType(List<Type> elements);
                /**
                 * tuple type
                 * TupleType ::= ( Type, TypeList )
                 * e.g.)
                 */
                TupleType();
                /**
                 * argument type
                 * ArgType ::= ( (Type, )* (Type ... ,)? KeywordType(, KeywordType)* )
                 *           | ( (Type, )*  Type ... )
                 *           | TupleType
                 * e.g.)
                 */
                ArgType(Option<VarargsType> varargs
                            = Option.<VarargsType>none(),
                        List<KeywordType> keywords
                            = Collections.<KeywordType>emptyList(),
                        boolean inArrow = false);
            /**
             * void type
             * NonArrowType ::= ()
             * e.g.) ()
             */
            VoidType();
            /**
             * inferred type
             * Used internally for type analysis
             */
            InferenceVarType(Object id);
            /**
             * A binary intersection.  Used internally for type analysis.
             */
            AndType(Type first, Type second);
            /**
             * A binary union.  Used internally for type analysis.
             */
            OrType(Type first, Type second);
            /**
             * Fixed point (a.k.a. "mu") type.  Used internally for type analysis.
             */
            FixedPointType(Id name, Type body);
            /**
             * The type of the name given to a label expression.  Used internally.
             */
            LabelType();
            /**
             * dimension type
             */
            abstract DimType(Type type);
                /**
                 * type with dimension
                 * DimType ::= Type DimExpr (in Expr)?
                 * e.g.) RR64 Length
                 */
                TaggedDimType(DimExpr dim,
                              Option<Expr> unit = Option.<Expr>none());
                /**
                 * type with unit
                 * DimType ::= Type Expr
                 * e.g.) RR64 meter
                 */
                TaggedUnitType(Expr unit);
    /**
     * static argument
     */
    abstract StaticArg();
        /**
         * type used as static argument
         * StaticArg ::= Type
         * e.g.) List[\ZZ64\]
         */
        TypeArg(Type type);
        /**
         * integer used as static argument
         * StaticArg ::= IntExpr
         * e.g.) m + n
         */
        IntArg(IntExpr val);
        /**
         * boolean used as static argument
         * StaticArg ::= BoolExpr
         * e.g.) ninf OR pinf
         */
        BoolArg(BoolExpr bool);
        /**
         * operator used as static argument
         * StaticArg ::= Op
         * e.g.) +
         */
        OprArg(Op name);
        /**
         * dimension used as static argument
         * StaticArg ::= Type
         * e.g.) Unity
         */
        DimArg(DimExpr dim);
        /**
         * unit used as static argument
         * StaticArg ::= UnitExpr
         * e.g.) dimensionless
         */
        UnitArg(UnitExpr unit);
    /**
     * static expression
     */
    abstract StaticExpr(ignoreForEquals boolean parenthesized = false);
        /**
         * integer expression
         * StaticExpr ::= IntExpr
         */
        abstract IntExpr();
            /**
             * integer value
             * IntExpr ::= IntVal
             */
            abstract IntVal();
                /**
                 * integer number
                 * IntVal ::= IntLiteralExpr
                 * e.g.) 8
                 */
                NumberConstraint(IntLiteralExpr val);
                /**
                 * integer identifier
                 * IntVal ::= QualifiedName
                 * e.g.) m
                 */
                IntRef(Id name);
            /**
             * integer expression with an operator
             */
            abstract IntOpExpr(IntExpr left, IntExpr right);
                /**
                 * integer addition
                 * IntExpr ::= IntExpr + IntExpr
                 * e.g.) m + 2
                 */
                SumConstraint();
                /**
                 * integer subtraction
                 * IntExpr ::= IntExpr - IntExpr
                 * e.g.) m - 2
                 */
                MinusConstraint();
                /**
                 * integer multiplication
                 * IntExpr ::= IntExpr IntExpr
                 *           | IntExpr DOT IntExpr
                 * e.g.) m DOT n
                 */
                ProductConstraint();
                /**
                 * integer exponentiation
                 * IntExpr ::= IntExpr caret IntVal
                 * e.g.) 2^b
                 */
                ExponentConstraint();
        /**
         * boolean expression
         * StaticExpr ::= BoolExpr
         */
        abstract BoolExpr();
            /**
             * boolean value
             * BoolExpr ::= BoolVal
             */
            abstract BoolVal();
                /**
                 * boolean constant
                 * BoolVal ::= true | false
                 * e.g.) true
                 */
                BoolConstant(boolean bool);
                /**
                 * boolean identiier
                 * BoolVal ::= QualifiedName
                 * e.g.) ninf
                 */
                BoolRef(Id name);
            /**
             * boolean constraint
             * BoolExpr ::= BoolConstraint
             */
            abstract BoolConstraint();
                /**
                 * boolean NOT constraint
                 * BoolConstraint ::= NOT BoolExpr
                 * e.g.) NOT ninf
                 */
                NotConstraint(BoolExpr bool);
                /**
                 * binary boolean constraint
                 * e.g.) ninf OR pinf
                 */
                abstract BinaryBoolConstraint(BoolExpr left, BoolExpr right);
                    /**
                     * boolean OR constraint
                     * BoolConstraint ::= BoolExpr OR BoolExpr
                     * e.g.) ninf OR pinf
                     */
                    OrConstraint();
                    /**
                     * boolean AND constraint
                     * BoolConstraint ::= BoolExpr AND BoolExpr
                     * e.g.) ninf AND pinf
                     */
                    AndConstraint();
                    /**
                     * boolean IMPLIES constraint
                     * BoolConstraint ::= BoolExpr IMPLIES BoolExpr
                     * e.g.) ninf IMPLIES pinf
                     */
                    ImpliesConstraint();
                    /**
                     * boolean equality constraint
                     * BoolConstraint ::= BoolExpr = BoolExpr
                     * e.g.) ninf AND pinf = true
                     */
                    BEConstraint();
        /**
         * unit expression
         * StaticExpr ::= UnitExpr
         */
        abstract UnitExpr();
            /**
             * unit identifier
             * UnitExpr ::= dimensionless
             *            | QualifiedName
             * e.g.) m
             */
            UnitRef(Id name);
            /**
             * unit expression with an operator
             */
            abstract UnitOpExpr(UnitExpr left, UnitExpr right);
                /**
                 * unit multiplication
                 * UnitExpr ::= UnitExpr UnitExpr
                 *            | UnitExpr DOT UnitExpr
                 * e.g.) m DOT n
                 */
                ProductUnit();
                /* unit division
                 * UnitExpr ::= UnitExpr / UnitExpr
                 *            | UnitExpr per UnitExpr
                 * e.g.) meter / second
                 */
                QuotientUnit();
                /**
                 * unit exponentiation
                 * UnitExpr ::= UnitExpr caret UnitExpr
                 * e.g.) meter^2
                 */
                ExponentUnit();
    /**
     * where clause used in trait, object, and functional declarations
     * Where ::= where [\ WhereBindingList \] ({ WhereConstraintList })?
     *         | where { WhereConstraintList }
     * e.g.) where { ninf AND NOT nan }
     */
    WhereClause(List<WhereBinding> bindings
                    = Collections.<WhereBinding>emptyList(),
                List<WhereConstraint> constraints
                    = Collections.<WhereConstraint>emptyList());
    /**
     * hidden type variable binding declared in where clauses
     */
    abstract WhereBinding(Id name);
        /**
         * hidden type variable declared in where clauses
         * WhereBinding ::= Id Extends?
         * Extends ::= extends TraitTypes
         * e.g.) T extends Object
         */
        WhereType(List<TraitType> supers);
        /**
         * nat parameter declared in where clauses
         * WhereBinding ::= nat Id
         * e.g.) nat length
         */
        WhereNat();
        /**
         * int parameter declared in where clauses
         * WhereBinding ::= int Id
         * e.g.) int length
         */
        WhereInt();
        /**
         * bool parameter declared in where clauses
         * WhereBinding ::= bool Id
         * e.g.) bool ninf
         */
        WhereBool();
        /**
         * unit parameter declared in where clauses
         * WhereBinding ::= unit Id
         * e.g.) unit U
         */
        WhereUnit();
    /**
     * hidden type variable constraint declared in where clauses
     */
    abstract WhereConstraint();
        /**
         * type variable constraint declared in where clauses
         * WhereConstraint ::= Id Extends
         * e.g.) T extends Object
         */
        WhereExtends(Id name, List<TraitType> supers);
        /**
         * type alias declaration
         * TypeAlias ::= type Id StaticParams? = Type
         * e.g.) type IntList = List[\ZZ64\]
         */
        TypeAlias(Id name,
                  List<StaticParam> staticParams
                      = Collections.<StaticParam>emptyList(),
                  Type type)
                 implements Decl, AbsDecl;
        /**
         * coercion constraint declared in where clauses
         * WhereConstraint ::= Type coerces Type
         * e.g.) T coerces Identity[\ODOT\]
         */
        WhereCoerces(Type left, Type right);
        /**
         * widening constraint declared in where clauses
         * WhereConstraint ::= Type widens Type
         * e.g.) T widens S
         */
        WhereWidens(Type left, Type right);
        /**
         * widening coercion constraint declared in where clauses
         * CoercionWhereConstraint ::= Type widens or coerces Type
         * e.g.) T widens or coerces S
         */
        WhereWidensCoerces(Type left, Type right);
        /**
         * DootedId equality constraint declared in where clauses
         * WhereConstraint ::= QualifiedName = QualifiedName
         * e.g.) m = n
         */
        WhereEquals(Id left, Id right);
        /**
         * unit constraint used in where clauses
         * WhereConstraint ::= dimensionless = Id
         *               | Id = dimensionless
         * e.g.) U = dimensionless
         */
        UnitConstraint(Id name);
        /**
         * integer constraint used in where clauses
         * WhereConstraint ::= IntConstraint
         */
        abstract IntConstraint(IntExpr left, IntExpr right);
            /**
             * less than equal constraint declared in where clauses
             * IntConstraint ::= IntExpr <= IntExpr
             * e.g.) b <= c
             */
            LEConstraint();
            /**
             * less than constraint declared in where clauses
             * IntConstraint ::= IntExpr < IntExpr
             * e.g.) 0 < a
             */
            LTConstraint();
            /**
             * greater than equal constraint declared in where clauses
             * IntConstraint ::= IntExpr >= IntExpr
             * e.g.) b >= c
             */
            GEConstraint();
            /**
             * greater than constraint declared in where clauses
             * IntConstraint ::= IntExpr > IntExpr
             * e.g.) a > 0
             */
            GTConstraint();
            /**
             * integer equality constraint declared in where clauses
             * IntConstraint ::= IntExpr = IntExpr
             * e.g.) 8 = 2^3
             */
            IEConstraint();
        /**
         * boolean constraint declared in where clauses
         * WhereConstraint ::= BoolConstraint
         * e.g.) pinf AND ninf
         */
        BoolConstraintExpr(BoolConstraint constraint);
    /**
     * contracts used in functional declarations and object declarations
     * Contract ::= Requires? Ensures? Invariant?
     * Requires ::= requires { ExprList? }
     * Ensures ::= ensures { EnsuresClauseList? }
     * Invariant ::= invariant { ExprList? }
     * CoercionContract ::= Ensures? Invariant?
     * e.g.) requires { n GE 0 } ensures { result GE 0 }
     */
    Contract(Option<List<Expr>> requires = Option.<List<Expr>>none(),
             Option<List<EnsuresClause>> ensures =
                 Option.<List<EnsuresClause>>none(),
             Option<List<Expr>> invariants = Option.<List<Expr>>none());
    /**
     * ensures clause used in contracts
     * EnsuresClause ::= Expr (provided Expr)?
     * e.g.) sorted(result) provided sorted(input)
     */
    EnsuresClause(Expr post, Option<Expr> pre = Option.<Expr>none());
    /**
     * modifier
     * TraitMod      ::= AbsTraitMod | private
     * AbsTraitMod   ::= value | test
     * ObjectMods    ::= TraitMods
     * AbsObjectMods ::= AbsTraitMods
     * MdMod         ::= FnMod | override
     * AbsMdMod      ::= AbsFnMod | override
     * FnMod         ::= AbsFnMod | private
     * AbsFnMod      ::= LocalFnMod | test
     * LocalFnMod    ::= atomic | io
     * ParamFldMod   ::= var | hidden | settable | wrapped
     * VarMod        ::= AbsVarMod | private
     * AbsVarMod     ::= var | test
     * FldMod        ::= var | AbsFldMod
     * AbsFldMod     ::= ApiFldMod | wrapped | private
     * ApiFldMod     ::= hidden | settable | test
     */
    abstract Modifier();
        /**
         * e.g.) abstract m(x: ZZ32): ()
         */
        ModifierAbstract();
        /**
         * e.g.) atomic f(x: ZZ32): ()
         */
        ModifierAtomic();
        /**
         * e.g.) getter velocity(): (RR Velocity)^3
         */
        ModifierGetter();
        /**
         * e.g.) hidden x: ZZ32
         */
        ModifierHidden();
        /**
         * e.g.) io print(s: String): ()
         */
        ModifierIO();
        /**
         * e.g.) override m(x: ZZ32): ()
         */
        ModifierOverride();
        /**
         * e.g.) private f(): ()
         */
        ModifierPrivate();
        /**
         * e.g.) settable message: Maybe[\String\]
         */
        ModifierSettable();
        /**
         * e.g.) setter velocity(v: (RR Velocity)^3): ()
         */
        ModifierSetter();
        /**
         * e.g.) test object TestSuite(testFunctions = {}) end
         */
        ModifierTest();
        /**
         * e.g.) object O(transient x: ZZ32) end
         */
        ModifierTransient();
        /**
         * e.g.) value object IntEmpty extends List[\ZZ32\] end
         */
        ModifierValue();
        /**
         * e.g.) var x: ZZ32
         */
        ModifierVar();
        /**
         * e.g.) coerce (x: RR32) widens = ...
         */
        ModifierWidens();
        /**
         * e.g.) wrapped val: Dictionary[\T\]
         */
        ModifierWrapped();
    /**
     * static parameter
     */
    abstract StaticParam();
        /**
         * operator parameter
         * StaticParam ::= opr Op
         * e.g.) opr ODOT
         */
        OprParam(Op name);
        /**
         * static parameter with a name field of type Id
         */
        abstract IdStaticParam(Id name);
           /**
            * bool parameter
            * StaticParam ::= bool Id
            * e.g.) bool nan
            */
            BoolParam();
           /**
            * dimension parameter
            * StaticParam ::= dim Id
            * e.g.) dim D
            */
            DimParam();
           /**
            * int parameter
            * StaticParam ::= int Id
            * e.g.) int i
            */
            IntParam();
           /**
            * nat parameter
            * StaticParam ::= nat Id
            * e.g.) nat len
            */
            NatParam();
           /**
            * type parameter
            * StaticParam ::= Id Extends? (absorbs unit)?
            * e.g.) EltType extends Number absorbs unit
            */
            TypeParam(List<TraitType> extendsClause =
                          Collections.<TraitType>emptyList(),
                      boolean absorbs = false);
           /**
            * unit parameter
            * StaticParam ::= unit Id (: Type)? (absorbs unit)?
            * e.g.) unit U absrbs unit
            */
            UnitParam(Option<Type> dim = Option.<Type>none(),
                      boolean absorbs = false);
    /**
     * name used in declarations and references
     */
    abstract Name();
        /**
         * unstructured sequence of ids naming an API or component
         * APIName ::= Id(.Id)*
         * e.g.) com.sun.fortress.nodes_util
         */
        APIName(List<Id> ids);
        /**
         * name prefixed by an optional API name
         */
        abstract QualifiedName(Option<APIName> api = Option.<APIName>none(),
                               IdOrOpOrAnonymousName name);
            /**
             * qualified id name
             * QualifiedName ::= Id(.Id)*
             * e.g.) com.sun.fortress.nodes_util.getName
             */
            QualifiedIdName(Id name);
        /**
         * non-API name
         * SimpleName ::= Id
         *              | opr Op
         *              | opr EncloserPair
         */
        abstract IdOrOpOrAnonymousName(Option<APIName> api
                                           = Option.<APIName>none());
            /**
             * identifier or operator name
             */
            abstract IdOrOpName();
                /**
                 * identifier name
                 * e.g.) hashCode
                 */
                Id(String text);
                /**
                 * operator name
                 */
                abstract OpName();
                    /**
                     * non-enclosing operator
                     * e.g.) COMPOSE
                     * e.g.) ===
                     */
                    Op(String text,
                       Option<Fixity> fixity = Option.<Fixity>none());
                    /**
                     * pair of enclosing operators
                     * EncloserPair ::= (LeftEncloser | Encloser)
                     *                    (RightEncloser | Encloser)
                     * e.g.) </ />
                     */
                    Enclosing(Op open, Op close);
            /**
             * anonymous name; used internally
             */
            abstract AnonymousName();
                /**
                 * internal name for anonymous function expressions
                 * not created during parsing but during evaluation
                 * e.g.) name for "fn x => x + 1"
                 */
                AnonymousFnName();
                /**
                 * internal name for anonymous constructor expressions
                 * not created during parsing but during evaluation
                 * e.g.) name for "object extends List cons(x) = Cons(x, self) end"
                 */
                ConstructorFnName(GenericWithParams def);
    /**
     * array comprehension clause
     * ArrayComprehensionClause ::= ArrayComprehensionLeft | GeneratorClauseList
     * ArrayComprehensionLeft ::= IdOrInt |-> Expr
     *                          | ( IdOrInt, IdOrIntList ) |-> Expr
     * IdOrInt ::= Id
     *           | IntLiteralExpr
     * e.g.) (x, y) = 0 | x <- {0, 1, 2}, y <- {0, 1, 2}
     */
    ArrayComprehensionClause(List<Expr> bind, Expr init,
                             List<GeneratorClause> gens);
    /**
     * keyword expression used in argument expressions
     * KeywordExpr ::= BindId = Expr
     * e.g.) x = myLoser.myField
     */
    KeywordExpr(Id name, Expr init);
    /**
     * case clause used in case expressions and extremum expressions
     * CaseClause ::= Expr => BlockElems
     * e.g.) { Jupiter, Saturn, Uranus, Neptune } => "outer"
     */
    CaseClause(Expr match, Block body);
    /**
     * catch clause used in try expressions
     * Catch ::= catch BindId CatchClauses
     * e.g.) catch e IOException => throw ForbiddenException(e)
     */
    Catch(Id name, List<CatchClause> clauses);
    /**
     * each clause in a catch clause used in try expressions
     * CatchClause ::= TraitType => BlockElems
     * e.g.) IOException => throw ForbiddenException(e)
     */
    CatchClause(TraitType match, Block body);
    /**
     * block expression used in do expressions
     * DoFront ::= (at Expr)? atomic? do BlockElems?
     * e.g.) at a.region(j) do w := a_j
     */
    DoFront(Option<Expr> loc = Option.<Expr>none(), boolean atomic = false,
            Block expr);
    /**
     * if clause used in if expressions
     * DelimitedExpr ::= if Expr then BlockElems Elifs? Else? end
     * Elif ::= elif Expr then BlockElems
     * e.g.) if x IN { 0, 1, 2 } then 0
     */
    IfClause(GeneratorClause test, Block body);
    /**
     * typecase clause used in typecase expressions
     * TypecaseClause ::= TypecaseTypes => BlockElems
     * TypecaseTypes ::= ( TypeList )
     *                 | Type
     * e.g.) String => x.append("foo")
     */
    TypecaseClause(List<Type> match, Block body);
    /**
     * array and matrix size
     * ExtentRange ::= StaticArg? # StaticArg?
     *               | StaticArg? : StaticArg?
     *               | StaticArg
     * e.g.) 3#5
     */
    ExtentRange(Option<StaticArg> base, Option<StaticArg> size);
    /**
     * generator
     * GeneratorClauseList ::= GeneratorBinding (, GeneratorClause)*
     * GeneratorBinding ::= BindIdOrBindIdTuple <- Expr
     * GeneratorClause ::= GeneratorBinding
     *                   | Expr
     * e.g.) (i, j) <- my2DArray.indices
     */
    GeneratorClause(List<Id> bind, Expr init);
    /**
     * varargs expression used in tuple expressions
     * Expr...
     * e.g.) [3 4 5]...
     */
    VarargsExpr(Expr varargs);
    /**
     * varargs type used in tuple types and varargs parameters
     * Type ...
     * e.g.) ZZ32...
     */
    VarargsType(Type type);
    /**
     * keyword type used in tuple types
     * KeywordType ::= BindId = Type
     * e.g.) x = String
     */
    KeywordType(Id name, Type type);
    /**
     * trait type with a where clause used in extends clauses
     * TraitTypeWhere ::= TraitType Where?
     */
    TraitTypeWhere(TraitType type, WhereClause where);
    /**
     * array dimensionality
     * ArraySize ::= ExtentRange(, ExtentRange)*
     * e.g.) 3, 2#1, 3:5
     */
    Indices(List<ExtentRange> extents);
    /**
     * mathematical item
     */
    abstract MathItem();
        /**
         * mathematical item that is an expression element
         */
        abstract ExprMI(Expr expr);
            /**
             * mathematical item that is a parenthesis delimited expression
             * MathItem ::= ParenthesisDelimited
             */
            ParenthesisDelimitedMI();
            /**
             * mathematical item that is not a parenthesis delimited expression
             * MathItem ::= VarOrFnRef
             *            | LiteralExpr
             *            | self
             */
            NonParenthesisDelimitedMI();
        /**
         * mathematical item that is a non-expression element
         */
        abstract NonExprMI();
            /**
             * mathematical item that is an exponentiation
             * MathItem ::= Exponentiation
             */
            ExponentiationMI(Op op, Option<Expr> expr);
            /**
             * mathematical item that is a subscripting
             * MathItem ::= Subscripting
             */
            SubscriptingMI(Enclosing op, List<Expr> exprs);
    /**
     * operator fixity
     */
    abstract Fixity();
        /**
         * e.g.) 3 + 5
         */
        InFixity();
        /**
         * e.g.) -5
         */
        PreFixity();
        /**
         * e.g.) 3!
         */
        PostFixity();
        /**
         * e.g.) :
         */
        NoFixity();
        /**
         * e.g.) S1 BY S2 BY S3
         */
        MultiFixity();
        /**
         * left encloser or right encloser
         * e.g.) <|
         */
        EnclosingFixity();
        /**
         * BIG operator
         */
        BigFixity();
end;
