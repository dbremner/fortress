/*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

generateEmptyConstructor yes;   // for reflective object creation
visitMethod accept;
visitorMethodPrefix for;
addGetterPrefixes yes;
usePLT yes;
tabSize 4;
allowNulls no;
generateToString no;
generateEquals yes;
generateSerializers yes;

package com.sun.fortress.nodes;
import java.io.IOException;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import com.sun.fortress.nodes_util.*;
import com.sun.fortress.parser_util.*;
import com.sun.fortress.useful.*;
import edu.rice.cs.plt.tuple.Option;

begin ast;

/**
 * top-level node interface
 */
interface Node(ignoreForEquals Span span = new Span()) extends HasAt;
    /**
     * declaration in components or APIs
     */
    interface AbsDeclOrDecl();
        /**
         * declaration in APIs
         */
        interface AbsDecl();
        /**
         * declaration in components
         */
        interface Decl();
    /**
     * left-hand-side of assignments, local variable declarations, or
     * top-level declarations.
     */
    interface LHS();
    /**
     * with static parameters
     * implemented by TraitAbsDeclOrDecl, ObjectAbsDeclOrDecl and FnAbsDeclOrDecl
     */
    interface Generic(List<StaticParam> staticParams);
    /**
     * with value parameters
     * implemented by object declarations and object expressions
     */
    interface HasParams(Option<List<Param>> params,
                        List<? extends AbsDeclOrDecl> decls);
    /**
     * with a where clause
     * implemented by trait and object declarations in components or APIs
     */
    interface HasWhere(List<WhereClause> where);
    /**
     * right-hand side of unit declarations
     * implemented by Expr and UnitExpr
     */
    interface ExprOrUnitExpr();

/**
 * functional declaration or function expression
 * nodes_util.NodeUtil declares the following static methods:
 *  - String nameAsMethod(Applicable)
 *  - Option<Expr> getBody(Applicable)
 */
interface Applicable(SimpleName name, List<StaticParam> staticParams,
                     List<Param> params, Option<Type> returnType,
                     List<WhereClause> where) extends HasAt;

/**
 * intersections of interface types
 */
interface GenericWithParams() extends Generic, HasParams;
interface GenericAbsDeclOrDecl() extends Generic, AbsDeclOrDecl;
    interface GenericDecl() extends Decl;
interface GenericAbsDeclOrDeclWithParams() extends GenericWithParams,
                                                   GenericAbsDeclOrDecl;
    interface GenericDeclWithParams() extends GenericDecl;

/**
 * top-level node abstract class
 */
abstract AbstractNode(ignoreForEquals Span span = new Span())
                     extends UIDObject implements Node;
    /**
     * compilation unit declaration
     * CompilationUnit ::= Component | Api
     */
    abstract CompilationUnit(DottedName name, List<Import> imports);
        /**
         * component declaration
         * Component ::= component DottedName Imports? Exports Decls? end
         * e.g.) component Hello
         *         export Executable
         *         run(args:String...) = print "Hello, World!\n"
         *       end
         */
        Component(List<Export> exports, List<Decl> decls);
        /**
         * API declaration
         * Api ::= api DottedName Imports? AbsDecls? end
         * e.g.) api Executable
         *         run(args:String...):()
         *       end
         */
        Api(List<AbsDecl> decls);
    /**
     * import statement
     * Import ::= import ImportFrom | import AliasedDottedNames
     */
    abstract Import();
        /**
         * ImportFrom ::= * (except Names)? from DottedName
         *              | AliasedNames from DottedName
         * Name ::= Id
         *        | opr Op
         *        | opr EncloserPair
         */
        abstract ImportFrom(DottedName api);
            /**
             * e.g.) import * except {opr UNION, union} from Set
             */
            ImportStar(List<SimpleName> except);
            /**
             * e.g.) import {empty, union} from Set
             */
            ImportNames(List<AliasedName> aliasedNames);
        /**
         * e.g.) import {Set, Map, List}
         */
        ImportApi(List<AliasedDottedName> apis);
    /**
     * export statement
     * Export ::= export DottedNames
     * e.g.) export Executable
     */
    Export(List<DottedName> apis);
    /**
     * aliased name used in import statements
     * AliasedName ::= Id (as Id)?
     *               | opr Op (as Op)?
     *               | opr EncloserPair (as EncloserPair)?
     * EncloserPair ::= LeftEncloser RightEncloser
     * e.g.) longComplexName as shortName
     */
    AliasedName(SimpleName name, Option<SimpleName> alias = Option.<SimpleName>none());
    /**
     * aliased dotted id used in import statements
     * AliasedDottedName ::= DottedName (as DottedName)?
     * e.g.) com.sun.fortress.parser.precedence.resolver as precedence.resolver
     */
    AliasedDottedName(DottedName api,
                      Option<DottedName> alias = Option.<DottedName>none());
    /**
     * trait or object declaration in components or APIs
     */
    abstract TraitObjectAbsDeclOrDecl(List<Modifier> mods
                                          = Collections.<Modifier>emptyList(),
                                      IdName name,
                                      List<StaticParam> staticParams
                                          = Collections.<StaticParam>emptyList(),
                                      List<TraitTypeWhere> extendsClause
                                          = Collections.<TraitTypeWhere>emptyList(),
                                      List<WhereClause> where
                                          = Collections.<WhereClause>emptyList(),
                                      List<? extends AbsDeclOrDecl> decls)
                                     implements HasWhere, GenericAbsDeclOrDecl;
        /**
         * trait declaration in components or APIs
         */
        abstract TraitAbsDeclOrDecl(List<TraitType> excludes
                                        = Collections.<TraitType>emptyList(),
                                    Option<List<TraitType>> comprises
                                        = Option.<List<TraitType>>none(),
                                    List<? extends AbsDeclOrDecl> decls);
            /**
             * trait declaration in APIs
             * AbsTraitDecl ::= AbsTraitMods? TraitHeaderFront AbsTraitClauses
             *                  AbsGoInATrait? end
             * TraitHeaderFront ::= trait Id StaticParams? Extends?
             * AbsTraitClause ::= Excludes | AbsComprises | Where
             * Extends ::= extends TraitTypes
             * Excludes ::= excludes TraitTypes
             * AbsComprises ::= comprises ComprisingTypes
             * ComprisingTypes ::= TraitType | { ComprisingTypeList }
             * ComprisingTypeList ::= ...
             *                      | TraitType(, TraitType)*(, ...)?
             * AbsGoInATrait ::= AbsCoercions? AbsGoFrontInATrait AbsGoBackInATrait?
             *                 | AbsCoercions? AbsGoBackInATrait
             * AbsGoesFrontInATrait ::= ApiFldDecl
             *                        | AbsGetterSetterDecl
             *                        | PropertyDecl
             * AbsGoesBackInATrait  ::= AbsMdDecl
             *                        | PropertyDecl
             * e.g.) trait List[\alpha\] comprises {Cons[\alpha\],Empty[\alpha\]}
             *         cons(x: alph): List[\alpha\]
             *       end
             */
            AbsTraitDecl(List<AbsDecl> decls) implements AbsDecl;
            /**
             * trait declaration in components
             * TraitDecl ::= TraitMods? TraitHeaderFront TraitClauses GoInATrait?
             *                 end
             * TraitClause ::= Excludes | Comprises | Where
             * Comprises ::= comprises TraitTypes
             * GoInATrait ::= Coercions? GoFrontInATrait GoBackInATrait?
             *              | Coercions? GoBackInATrait
             * GoesFrontInATrait ::= AbsFldDecl
             *                     | GetterSetterDecl
             *                     | PropertyDecl
             * GoesBackInATrait  ::= MdDecl
             *                     | PropertyDecl
             * e.g.) trait List[\alpha\] comprises {Cons[\alpha\],Empty[\alpha\]}
             *         cons(x: alph): List[\alpha\] = Cons[\alph\](x, self)
             *       end
             */
            TraitDecl(List<Decl> decls) implements GenericDecl;
        /**
         * object declaration in components or APIs
         */
        abstract ObjectAbsDeclOrDecl(Option<List<Param>> params
                                         = Option.<List<Param>>none(),
                                     Option<List<TraitType>> throwsClause
                                         = Option.<List<TraitType>>none(),
                                     Contract contract = new Contract(),
                                     List<? extends AbsDeclOrDecl> decls)
                                    implements GenericAbsDeclOrDeclWithParams;
            /**
             * object declaration in APIs
             * AbsObjectDecl ::= AbsObjectMods? ObjectHeader AbsGoInAnObject? end
             * ObjectHeader ::= object Id StaticParams? ObjectValParam? Extends?
             *                  FnClauses
             * FnClauses ::= Throws? Where? Contract
             * Throws ::= throws MayTraitTypes
             * ObjectValParam ::= ( ObjectParams? )
             * ObjectParams ::= (ObjectParam ,)* (ObjectVarargs, )? ObjectKeyword(, ObjectKeyword)*
             *                | (ObjectParam ,)* ObjectVarargs
             *                | ObjectParam (, ObjectParam)*
             * ObjectVarargs ::= transient Varargs
             * ObjectKeyword ::= ObjectParam = Expr
             * ObjectParam ::= ParamFldMods? Param
             *               | transient Param
             * AbsGoInAnObject ::= AbsCoercions? AbsGoFrontInAnObject AbsGoBackInAnObject?
             *                   | AbsCoercions? AbsGoBackInAnObject
             * AbsGoesFrontInAnObject ::= ApiFldDecl
             *                          | AbsGetterSetterDecl
             *                          | PropertyDecl
             * AbsGoesBackInAnObject ::= AbsMdDecl
             *                         | PropertyDecl
             * e.g.) object Empty[\alph\]() extends List[\alpha\] end
             */
            AbsObjectDecl(List<AbsDecl> decls) implements AbsDecl;
            /**
             * object declaration in components
             * ObjectDecl ::= ObjectMods? ObjectHeader GoInAnObject? end
             * GoInAnObject ::= Coercions? GoFrontInAnObject GoBackInAnObject?
             *                | Coercions? GoBackInAnObject
             * GoesFrontInAnObject ::= FldDecl
             *                       | GetterSetterDecl
             *                       | PropertyDecl
             * GoesBackInAnObject ::= MdDecl
             *                      | PropertyDecl
             * e.g.) object Empty[\alph\]() extends List[\alpha\]
             *         length() = 0
             *       end
             */
            ObjectDecl(List<Decl> decls)
                      implements GenericDeclWithParams;
    /**
     * variable declaration in components or APIs
     */
    abstract VarAbsDeclOrDecl(List<LValueBind> lhs) implements AbsDeclOrDecl;
        /**
         * variable declaration in APIs
         * AbsVarDecl ::= AbsVarMods? VarWTypes
         *              | AbsVarMods? IdOrIdTuple : Type ...
         *              | AbsVarMods? IdOrIdTuple : SimpleTupleType
         * VarWTypes ::= VarWType | ( VarWType(, VarWType)+ )
         * VarWType ::= Id IsType
         * e.g.) var (x, y): ZZ64...
         */
        AbsVarDecl() implements AbsDecl, Decl;
        /**
         * variable declaration in components
         * VarDecl ::= VarMods? VarWTypes InitVal
         *           | VarMods? IdOrIdTuple = Expr
         *           | VarMods? IdOrIdTuple : Type ... InitVal
         *           | VarMods? IdOrIdTuple : SimpleTupleType InitVal
         * InitVal ::= (= | :=) Expr
         * e.g.) var (x, y): ZZ64... = (5, 6)
         */
        VarDecl(Expr init) implements Decl;
    /**
     * left-hand side of variable declaration
     */
    abstract LValue();
        /**
         * e.g.) var x: ZZ32
         */
        LValueBind(IdName name, Option<Type> type = Option.<Type>none(),
                   List<Modifier> mods = Collections.<Modifier>emptyList(),
                   boolean mutable) implements LHS;
        /**
         * left-hand side of matrix unpasting
         * Unpasting ::= [ UnpastingElems ]
         */
        abstract Unpasting();
            /**
             * simple unpasting
             * UnpastingElem ::= Id ([ UnpastingDim ])?
             *                 | Unpasting
             * UnpastingDim ::= ExtentRange (BY ExtentRange)+
             * e.g.) squareShape[m BY m]
             */
            UnpastingBind(IdName name, List<ExtentRange> dim);
            /**
             * complex unpasting
             * UnpastingElems ::= UnpastingElem RectSeparator UnpastingElems
             *                  | UnpastingElem
             * e.g.) squareShape[m BY m]  rest
             */
            UnpastingSplit(List<Unpasting> elems, int dim);
    /**
     * functional declaration in components or APIs
     */
    abstract FnAbsDeclOrDecl(List<Modifier> mods
                                 = Collections.<Modifier>emptyList(),
                             SimpleName name,
                             List<StaticParam> staticParams
                                 = Collections.<StaticParam>emptyList(),
                             List<Param> params,
                             Option<Type> returnType
                                 = Option.<Type>none(),
                             Option<List<TraitType>> throwsClause
                                 = Option.<List<TraitType>>none(),
                             List<WhereClause> where
                                 = Collections.<WhereClause>emptyList(),
                             Contract contract = new Contract(),
                             String selfName = NodeUtil.defaultSelfName)
                            implements Applicable, GenericDecl;
        /**
         * functional declaration in APIs
         * AbsFnDecl ::= AbsFnMods? FnHeaderFront FnHeaderClause
         *             | FnSig
         * FnSig ::= Name : ArrowType
         * FnHeaderFront ::= Id StaticParams? ValParam
         *                 | OpHeaderFront
         * OpHeaderFront ::= opr StaticParams? (LeftEncloser | Encloser) Params
         *                     (RightEncloser | Encloser)
         *                     (:= ( SubscriptAssignParam ))?
         *                 | opr StaticParams? ValParam Op
         *                 | opr (Op | ExponentOp | Encloser) StaticParams? ValParam
         * SubscriptAssignParam ::= Varargs | Param
         * FnHeaderClause ::= IsType? FnClauses
         * FnDecl ::= FnMods? FnHeaderFront FnHeaderClause
         *          | FnSig
         * e.g.) swap (x: Object, y: Object): (Object, Object)
         */
        AbsFnDecl() implements AbsDecl;
        /**
         * functional declaration in components
         * FnDecl ::= FnMods? FnHeaderFront FnHeaderClause = Expr
         * e.g.) swap (x, y) = (y, x)
         */
        abstract FnDecl();
            FnDef(Expr body);
    /**
     * value parameter of functional declarations and object declarations
     * e.g.) x: ZZ32 = 3
     * e.g.) self
     * e.g.) transient x: String
     */
    abstract Param(List<Modifier> mods = Collections.<Modifier>emptyList(),
                   IdName name);
        /**
         * ValParam := Id
         *           | (Params?)
         * Params ::= (Param, )* (Varargs, )? Keyword(, Keyword)*
         *          | (Param, )* Varargs
         *          | Param(, Param)*
         *
         * Keyword ::= Param = Expr
         * PlainParam ::= Id IsType?
         *              | Type
         */
        NormalParam(Option<Type> type = Option.<Type>none(),
                    Option<Expr> defaultExpr = Option.<Expr>none());
        /**
         * varargs parameter
         * VarargsParam ::= Id : Type ...
         */
        VarargsParam(VarargsType varargsType);
    /**
     * dimension and unit declaration
     * DimUnitDecl may represent a single dimension declaration, a single
     * unit declaration, or both dimension and unit declarations.
     * DimUnitDecl ::= dim Id (= DimExpr)? (unit | SI_unit) Id+ (= Expr)?
     *               | dim Id (= DimExpr)? (unit | SI_unit) Id+ (= UnitExpr)?
     *               | dim Id (= DimExpr)? (default Id)?
     *               | (unit | SI_unit) Id+ (: DimExpr)? (= Expr)?
     *               | (unit | SI_unit) Id+ (: DimExpr)? (= UnitExpr)?
     * e.g.) unit inch inches: Length
     * e.g.) dim Length SI_unit meter meters m
     */
    DimUnitDecl(Option<IdName> dim = Option.<IdName>none(),
                Option<DimExpr> derived = Option.<DimExpr>none(),
                Option<IdName> default = Option.<IdName>none(),
                boolean si_unit = false,
                List<IdName> units = Collections.<IdName>emptyList(),
                Option<ExprOrUnitExpr> def)
               implements Decl, AbsDecl;
    /**
     * test declaration
     * TestDecl ::= test Id [GeneratorList] = Expr
     * e.g.) test fxLessThanFy[x <- E, y <- F] = assert(f(x) < f(y))
     */
    TestDecl(IdName name, List<Generator> gens, Expr expr) implements Decl, AbsDecl;
    /**
     * property declaration
     * PropertyDecl ::= property (Id = )? (FORALL ValParam)? Expr
     * e.g.) property fIsMonotonic = FORALL (x:ZZ, y:ZZ) (x < y) -> (f(x) < f(y))
     */
    PropertyDecl(Option<IdName> name = Option.<IdName>none(), List<Param> params,
                 Expr expr) implements Decl, AbsDecl;
    /**
     * syntax expanders declaration in components or APIs
     */
    abstract ExternalSyntaxAbsDeclOrDecl(SimpleName openExpander, IdName name,
                                         SimpleName closeExpander)
                                        implements AbsDeclOrDecl;
        /**
         * syntax expanders declaration in APIs
         * AbsExternalSyntax ::= syntax OpenExpander Id CloseExpander
         * OpenExpander ::= Id
         *                | LeftEncloser
         * CloseExpander ::= Id
         *                 | RightEncloser
         *                 | end
         * e.g.) syntax sql e end
         */
        AbsExternalSyntax() implements AbsDecl;
        /**
         * syntax expanders declaration in APIs
         * ExternalSyntax ::= syntax OpenExpander Id CloseExpander = Expr
         * e.g.) syntax sql e end = parseSQL(e)
         */
        ExternalSyntax(Expr expr) implements Decl;
    /**
     * grammar declaration
     */
    abstract GrammarDecl(IdName name, List<? extends QualifiedName> extends) implements AbsDecl;
        /**
         * grammar definition in grammar declarations
         */
        GrammarDef(List<ProductionDef> productions);
    /**
     * production declaration
     */
    abstract ProductionDecl(QualifiedName name, IdName type, Option<? extends QualifiedName> extends) implements AbsDecl;
        /**
         * production definition in production declarations
         */
        ProductionDef(List<SyntaxDef> syntaxDefs);
    /**
     * syntax declaration
     */
    abstract SyntaxDecl() implements AbsDecl;
        /**
         * syntax definition in syntax declarations
         */
        SyntaxDef(List<SyntaxSymbol> syntaxSymbols, Expr transformationExpression);
    /**
      * syntax symbol
      */
    SyntaxSymbol();
        /**
         * optional syntax symbol
         */
        OptionalSymbol(SyntaxSymbol symbol);
        /**
         * repeat zero-or-more syntax symbol
         */
        RepeatSymbol(SyntaxSymbol symbol);
        /**
         * repeat one-or-more syntax symbol
         */
        RepeatOneOrMoreSymbol(SyntaxSymbol symbol);
        /**
         * whitespace syntax symbol
         */
        WhitespaceSymbol(SyntaxSymbol symbol);
        /**
         * item syntax symbol
         */
        ItemSymbol(String item);
        /**
         * token syntax symbol
         */
        TokenSymbol(String token);
        /**
         * non-terminal syntax symbol
         */
        NonterminalSymbol(QualifiedName nonterminal);
    /**
     * expression
     */
    abstract Expr(boolean parenthesized = false) implements ExprOrUnitExpr;
        /**
         * type ascription expression
         * Expr ::= Expr as Type
         * e.g.) 3 as Number
         */
        AsExpr(Expr expr, Type type);
        /**
         * type assumption expression
         * Expr ::= Expr asif Type
         * e.g.) Empty asif List[\String\]
         */
        AsIfExpr(Expr expr, Type type);
        /**
         * expression with a unit
         */
        abstract TaggedUnitExpr(Expr val, UnitExpr unit);
            /**
             * unit multiplication
             * Expr ::= Expr dimensionless
             * e.g.) 32 dimensionless
             */
            ProductUnitExpr();
            /**
             * unit division
             * Expr ::= Expr per UnitExpr
             * e.g.) meter per second
             */
            QuotientUnitExpr();
        /**
         * unit change
         * Expr ::= Expr in UnitExpr
         * e.g.) 1.3 m in nm
         */
        ChangeUnitExpr(Expr val, UnitExpr unit);
        /**
         * assignment expression
         * Expr ::= AssignLefts AssignOp Expr
         * AssignLefts ::= ( AssignLeft(, AssignLeft)* )
         *               | AssignLeft
         * AssignLeft ::= SubscriptExpr
         *              | MemberSelection
         *              | Id
         * AssignOp ::= := | Op=
         * e.g.) x += 1
         */
        Assignment(List<LHS> lhs, Option<Opr> opr, Expr rhs);
        /**
         * expressions beginning and ending with reserved words
         * Expr ::= DelimitedExpr
         */
        abstract DelimitedExpr();
            /**
             * sequence of block elements implicitly enclosed by do/end
             * BlockElems ::= BlockElem+
             * e.g.) y = x
             *       z = 2x
             *       y + z
             */
            Block(List<Expr> exprs);
            /**
             * case expression or extremum expression
             * DelimitedExpr ::= case Expr Op? of CaseClauses CaseElse? end
             *                 | case largest Op? of CaseClauses end
             *                 | case smallest Op? of CaseClauses end
             * CaseElse ::= else => BlockElems
             * e.g.) case largest of
             *         1 mile => "miles are larger"
             *         1 kilometer => "we were wrong again"
             *       end
             */
            CaseExpr(CaseParam param, Option<Opr> compare = Option.<Opr>none(),
                     List<CaseClause> clauses,
                     Option<Block> elseClause = Option.<Block>none());
            /**
             * do expression
             * Do ::= (DoFront also)* DoFront end
             * e.g.) do
             *         accum += treeSum(t.left)
             *       also do
             *         accum += treeSum(t.right)
             *       also do
             *         accum += t.datum
             *       end
             */
            Do(List<DoFront> fronts);
            /**
             * for expression
             * DelimitedExpr ::= for GeneratorList DoFront end
             * e.g.) for i <- sequential(1:5) do
             *         print (i " ")
             *       end
             */
            For(List<Generator> gens, DoFront body);
            /**
             * if expression
             * DelimitedExpr ::= if Expr then BlockElems Elifs? Else? end
             *                 | ( if Expr then blockElems Elifs? Else end? )
             * Elif ::= elif Expr then BlockElems
             * Else ::= else BlockElems
             * e.g.) if x IN {0, 1, 2} then 0
             *       elif x IN {3, 4, 5} then 3
             *       else 6 end
             */
            If(List<IfClause> clauses,
               Option<Block> elseClause = Option.<Block>none());
            /**
             * label expression
             * DelimitedExpr ::= label Id BlockElems end Id
             * e.g.) label I_95
             *         if goingTo(Sun)
             *         then exit I_95 with x32B
             *         else x32A
             *         end
             *       end I_95
             */
            Label(IdName name, Block body);
            /**
             * object expression
             */
            abstract AbstractObjectExpr(List<TraitTypeWhere> extendsClause
                                            = Collections.<TraitTypeWhere>emptyList(),
                                        List<Decl> decls);
                /**
                 * object expression
                 * DelimitedExpr ::= object Extends? GoInAnObject end
                 * e.g.)  object extends {List}
                 *          cons(x) = Cons(x, self)
                 *          append (xs) = xs
                 *        end
                 */
                ObjectExpr();
                /**
                 * object expression rewritten by interpreter.rewrite.Disambiguate
                 */
                _RewriteObjectExpr(BATree<String, StaticParam> implicitTypeParameters,
                                   String genSymName,
                                   List<StaticParam> staticParams,
                                   List<StaticArg> staticArgs,
                                   Option<List<Param>> params)
                                  implements GenericWithParams;
            /**
             * try expression
             * DelimitedExpr ::= try BlockElems Catch? (forbid TraitTypes)?
             *                     (finally BlockElems)? end
             * e.g.) try
             *         inp = read (file)
             *         write (inp, newFile)
             *       forbid IOException
             *       end
             */
            Try(Block body, Option<Catch> catchClause = Option.<Catch>none(),
                List<TraitType> forbid = Collections.<TraitType>emptyList(),
                Option<Block> finallyClause = Option.<Block>none());
            /**
             * tuple expression
             * TupleExpr ::= ( (Expr,)*  (Expr...,)? Binding(, Binding)* )
             *             | NoKeyTuple
             * NoKeyTuple ::= ( (Expr,)* Expr... )
             *              | ( (Expr,)+ Expr )
             * e.g.) (1, 2, [3 4]..., x = 5)
             */
            TupleExpr(List<Expr> exprs,
                      Option<VarargsExpr> varargs = Option.<VarargsExpr>none(),
                      List<Binding> keywords = Collections.<Binding>emptyList());
            /**
             * typecase expression
             * DelimitedExpr ::= typecase TypecaseBindings of TypecaseClauses
             *                     CaseElse? end
             * TypecaseBindings ::= ( BindgingList )
             *                    | Binding
             *                    | Id
             * e.g.) typecase x = myLoser .myField of
             *         String => x.append("foo")
             *         Number => x + 3
             *         Object => yogiBerraAutograph
             *       end
             */
            Typecase(List<Binding> bind, List<TypecaseClause> clauses,
                     Option<Block> elseClause = Option.<Block>none());
            /**
             * while expression
             * DelimitedExpr ::= while Expr Do
             * e.g.) while x < 10 do print x; x += 1 end
             */
            While(Expr test, Do body);
        /**
         * control flow expression
         * Expr ::= FlowExpr
         */
        abstract FlowExpr();
            /**
             * summation and other reduction expression
             * FlowExpr ::= Accumulator ([ GeneratorList ])? Expr
             * Accumulator ::= SUM | PRODUCT | Big Op
             * e.g.) PRODUCT[i <- 1:n] i
             */
            Accumulator(Opr opr, List<Generator> gens, Expr body);
            /**
             * atomic expression
             * FlowExpr ::= atomic AtomicBack
             * AtomicBack ::= AssignLefts AssignOp Expr
             *              | OpExpr
             *              | DelimitedExpr
             * e.g.) atomic sum += a[i]
             */
            AtomicExpr(Expr expr);
            /**
             * exiting labeled expressions
             * FlowExpr ::= exit Id? (with Expr)?
             * e.g.) exit I_95 with x32B
             */
            Exit(Option<IdName> target = Option.<IdName>none(),
                 Option<Expr> returnExpr = Option.<Expr>none());
            /**
             * spawn expression
             * FlowExpr ::= spawn Expr
             * e.g.) spawn mm(lefttop, right, resulttop)
             */
            Spawn(Expr body);
            /**
             * throw expression
             * FlowExpr ::= throw Expr
             * e.g.) throw Error
             */
            Throw(Expr expr);
            /**
             * tryatomic expression
             * FlowExpr ::= tryatomic AtomicBack
             * e.g.) tryatomic sum += a[i]
             */
            TryAtomicExpr(Expr expr);
        /**
         * function expression
         * Expr ::= fn ValParam IsType? Throws? => Expr
         * e.g.) fn x => x + 2
         */
        FnExpr(ignoreForEquals Span span, // no default -- required to produce a fnName
               boolean parenthesized = false,
               SimpleName name = new AnonymousFnName(in_span),
               List<StaticParam> staticParams
                   = Collections.<StaticParam>emptyList(),
               List<Param> params,
               Option<Type> returnType = Option.<Type>none(),
               List<WhereClause> where = Collections.<WhereClause>emptyList(),
               Option<List<TraitType>> throwsClause
                   = Option.<List<TraitType>>none(),
               Expr body)
              implements Applicable;
        /**
         * expression used in block expressions
         * BlockElem ::= LocalVarFnDecl
         *             | Expr(, GeneratorList)?
         * LocalVarFnDecl ::= LocalFnDecl+
         *                  | LocalVarDecl
         */
        abstract LetExpr(List<Expr> body);
            /**
             * local function declaration
             * LocalVarFnDecl ::= LocalFnDecl+
             * LocalFnDecl ::= LocalFnMods? FnHeaderFront FnHeaderClause = Expr
             * e.g.) localFn(x: ZZ32) = x + 2
             */
            LetFn(List<FnDef> fns);
            /**
             * local variable declaration
             * LocalVarDecl ::= var? LocalVarWTypes InitVal
             *                | var? LocalVarWTypes
             *                | var? LocalVarWoTypes = Expr
             *                | var? LocalVarWoTypes : Type ... InitVal?
             *                | var? LocalVarWoTypes : SimpleTupleType InitVal?
             * LocalVarWTypes ::= LocalVarWType
             *                  | ( LocalVarWType(, LocalVarWType)+ )
             * LocalVarWType ::= Id IsType
             * LocalVarWoTypes ::= LocalVarWoType
             *                   | ( LocalVarWoType(, LocalVarWoType)+ )
             * LocalVarWoType ::= Id
             *                  | Unpasting
             * e.g.) localVar x = 3
             */
            LocalVarDecl(List<LValue> lhs, Option<Expr> rhs = Option.<Expr>none());
        /**
         * generated expression
         * BlockElem ::= Expr(, GeneratorList)?
         * e.g.) print (i " "), i <- sequential(1:5)
         */
        GeneratedExpr(Expr expr, List<Generator> gens);
        /**
         * expression that is simple or using operators
         * Expr ::= OpExpr
         */
        abstract OpExpr();
            /**
             * expression using operators (list of ops allows cross-API overloading)
             * OpExpr ::= EncloserOp OpExpr? EncloserOp?
             *          | OpExpr EncloserOp OpExpr?
             *          | Primary
             * EncloserOp ::= Encloser
             *              | Op
             * Primary ::= LeftEncloser ExprList? RightEncloser
             *           | Primary ^ BaseExpr
             *           | Primary ExponentOp
             * e.g.) 3 + 5
             */
            OprExpr(List<QualifiedOpName> ops,
                    List<Expr> args = Collections.<Expr>emptyList());
            /**
             * subscripting expression
             * SubscriptExpr ::= Primary [ ExprList? ]
             *                 | Primary LeftEncloser ExprList? RightEncloser
             * e.g.) a[i]
             */
            SubscriptExpr(Expr obj, List<Expr> subs,
                          Option<SubscriptOp> op = Option.<SubscriptOp>none())
                         implements LHS;
            /**
             * primary expression
             */
            abstract Primary();
                /**
                 * coercion invocation
                 * internal node created by static analysis
                 * after inferring the implicit coercion invocations
                 */
                CoercionInvocation(TraitType type,
                                   List<StaticArg> staticArgs
                                       = Collections.<StaticArg>emptyList(),
                                   Expr arg);
                /**
                 * a method invocation
                 * some are created by parsing, while others require later
                 * static analysis to disambiguate from function applications
                 */
                MethodInvocation(Expr obj, IdName method,
                                 List<StaticArg> staticArgs
                                     = Collections.<StaticArg>emptyList(),
                                 Expr arg);
                /**
                 * field selection expression
                 * Primary ::= Primary . Id
                 * e.g.) Empty.length
                 */
                abstract AbstractFieldRef(Expr obj) implements LHS;
                    /**
                     * A field selection, unless it is a method reference
                     */
                    FieldRef(IdName field);
                    /**
                     * A field selection, for sure.
                     * (though its implementation might be a getter/setter).
                     */
                    FieldRefForSure(IdName field);
                    /**
                     * A rewritten field ref (not a getter/setter).
                     * also used to disambiguate lexical references to self/parent
                     * and within objectexprs to get access to outer scopes
                     * where the vars in the outer scopes may in turn have been
                     * API-qualified.
                     *
                     * If the reference to outer scope can be "fixed" (there is
                     * only one out scope) then it might be good to narrow this
                     * back down to an IdName.
                     */
                    _RewriteFieldRef(Name field);

                /**
                 * juxtaposition of expressions
                 * Primary ::= Primary . Id ([\StaticArgList\])? Parenthesized
                 *           | Primary . Id ([\StaticArgList\])? ()
                 *           | Primary Parenthesized
                 *           | Primary ()
                 *           | Primary Primary
                 * e.g.) myString.replace("foo", "few")
                 * e.g.) log log n
                 */
                abstract Juxt(List<Expr> exprs);
                    /**
                     * juxtaposition with intervening whitespace
                     * e.g.) 3 5
                     */
                    LooseJuxt();
                    /**
                     * juxtaposition without intervening whitespace
                     * e.g.) f(3+5)
                     */
                    TightJuxt();
                /**
                 * chain expression
                 * Certain infix mathematical operators that are traditionally
                 * regarded as relational operators, delivering boolean results,
                 * may be chained.
                 * e.g.) A SUBSETEQ B SUBSET C SUBSETEQ D
                 */
                ChainExpr(Expr first, List<Pair<Opr, Expr>> links);
                /**
                 * expression with static instantiations
                 * list of ids allows cross-API overloading
                 * Primary ::= Id[\StaticArgList\]
                 * e.g.) identity[\String\]
                 */
                FnRef(List<QualifiedIdName> fns,
                      List<StaticArg> staticArgs
                          = Collections.<StaticArg>emptyList());

                /**
                 * The rewriting to explicitly name self and parent
                 * pre-interpretation may generalize the dotted
                 * list from a FnRef into something else.
                 */
                _RewriteFnRef(Expr fn,
                              List<StaticArg> staticArgs
                          = Collections.<StaticArg>emptyList());

                /**
                 * simple expression
                 * Primary ::= BaseExpr
                 */
                abstract BaseExpr();
                    /**
                     * variable reference
                     * BaseExpr ::= Id
                     *            | self
                     * e.g.) length
                     */
                    VarRef(QualifiedIdName var) implements LHS;
                    /**
                     * literal
                     * BaseExpr ::= Literal
                     */
                    abstract Literal(String text);
                        /**
                         * number literal
                         */
                        abstract NumberLiteral();
                            /**
                             * float literal
                             * e.g.) 3.5
                             */
                            FloatLiteral(ignoreForEquals String text,
                                         BigInteger intPart,
                                         BigInteger numerator, int denomBase,
                                         int denomPower);
                            /**
                             * int literal
                             * e.g.) 7
                             */
                            IntLiteral(String text = in_val.toString(),
                                       BigInteger val);
                        /**
                         * char literal
                         * e.g.) 'c'
                         */
                        CharLiteral(int val = in_text.charAt(0));
                        /**
                         * string literal
                         * e.g.) "string"
                         */
                        StringLiteral();
                        /**
                         * void literal
                         * e.g.) ()
                         */
                        VoidLiteral(String text = "");
                    /**
                     * aggregate expression
                     * BaseExpr ::= Aggregate
                     */
                    abstract Aggregate();
                        /**
                         * map expression
                         * Aggregate ::= { Entry (, Entry)* }
                         * e.g.) { 'a' |-> 0, 'b' |-> 1, 'c' |-> 2 }
                         */
                        MapExpr(List<Entry> elements);
                        /**
                         * array expression
                         * Aggregate ::= [ RectElements ]
                         * RectElements ::= Expr MultiDimCons*
                         * MultiDimCons ::= RectSeparator Expr
                         * RectSeparator ::= ;+
                         *                 | Whitespace
                         * e.g.) [1 2 3; 4 5 6; 7 8 9]
                         */
                        abstract ArrayExpr();
                            /**
                             * array with a single element
                             * e.g.) [3]
                             */
                            ArrayElement(Expr element);
                            /**
                             * array with multiple elements
                             * e.g.) [3 4 5; 6 7 8]
                             */
                            ArrayElements(int dimension,
                                          List<ArrayExpr> elements);
                /**
                 * comprehension expression
                 * Primary ::= Comprehension
                 */
                abstract Comprehension();
                    /**
                     * array comprehension
                     * Comprehension ::= [ ArrayComprehensionClause+ ]
                     * e.g.) [(x, y, 1) |-> 0.0 | x <- 1:xSize, y <- 1:ySize ]
                     */
                    ArrayComprehension(List<ArrayComprehensionClause> clauses);
                    /**
                     * comprehension with generators
                     */
                    abstract GeneratedComprehension(List<Generator> gens);
                        /**
                         * set comprehension
                         * Comprehension ::= { Expr | GeneratorList }
                         * e.g.) { x^2 | x <- {0, 1, 2, 3, 4, 5}, x MOD 2 = 0 }
                         */
                        SetComprehension(Expr element);
                        /**
                         * map comprehension
                         * Comprehension ::= { Entry | GeneratorList }
                         * e.g.) { x^2 |-> x^3 | x <- {0, 1, 2, 3, 4, 5} }
                         */
                        MapComprehension(Entry entry);
                        /**
                         * list comprehension
                         * Comprehension ::= <| Expr | GeneratorList |>
                         * e.g.)
                         */
                        ListComprehension(Expr element);
    /**
     * type
     * Type ::= ArrowType
     *        | NonArrowType
     */
    abstract Type(boolean parenthesized = false);
        /**
         * arrow type
         * ArrowType ::= NonArrowType -> NonArrowType Throws?
         * e.g.) (String, NN..., p = Printer) -> NN throws IOException
         */
        ArrowType(Type domain, Type range,
                  Option<List<TraitType>> throwsClause);
        /**
         * nonarrow type
         */
        abstract NonArrowType();
            /**
             * trait type
             */
            abstract TraitType();
                /**
                 * array type
                 * TraitType ::= Type [ ArraySize? ]
                 * e.g.) ZZ64[3, 2]
                 */
                ArrayType(Type element, Indices indices);
                /**
                 * type name
                 * TraitType ::= QualifiedIdName
                 * e.g.) T
                 */
                IdType(QualifiedIdName name);
                /**
                 * matrix type
                 * TraitType ::= Type ^ StaticArg
                 *             | Type ^ ( ExtentRange (BY ExtentRange)* )
                 * e.g.)
                 */
                MatrixType(Type element, List<ExtentRange> dimensions);
                /**
                 * instantiated type
                 * TraitType ::= QualifiedIdName [\StaticArgList\]
                 * e.g.) List[\ZZ32\]
                 */
                InstantiatedType(QualifiedIdName name, List<StaticArg> args);
            /**
             * tuple type
             * TupleType ::= ( (Type, )* (Type ... ,)? KeywordType(, KeywordType)* )
             *             | ( (Type, )*  Type ... )
             *             | SimpleTupleType
             * SimpleTupleType ::= ( Type, TypeList )
             * e.g.)
             */
            TupleType(List<Type> elements,
                      Option<VarargsType> varargs = Option.<VarargsType>none(),
                      List<KeywordType> keywords
                          = Collections.<KeywordType>emptyList());
            /**
             * void type
             * NonArrowType ::= ()
             * e.g.) ()
             */
            VoidType();
            /**
             * dimension type
             */
            abstract DimType(Type type);
                /**
                 * type with dimension
                 * DimType ::= Type DimExpr (in UnitExpr)?
                 * e.g.) RR64 Length
                 */
                TaggedDimType(DimExpr dim, Option<UnitExpr> unit);
                /**
                 * type with unit
                 * DimType ::= Type UnitExpr
                 * e.g.) RR64 meter
                 */
                TaggedUnitType(UnitExpr unit);
        /**
         * static argument
         */
        abstract StaticArg();
            /**
             * identifier used as static argument
             * StaticArg ::= QualifiedIdName
             * e.g.) m
             */
            IdArg(QualifiedIdName name);
            /**
             * type used as static argument
             * StaticArg ::= Type
             * e.g.) List[\ZZ64\]
             */
            TypeArg(Type type);
            /**
             * integer used as static argument
             * StaticArg ::= IntExpr
             * e.g.) m + n
             */
            IntArg(IntExpr val);
            /**
             * boolean used as static argument
             * StaticArg ::= BoolExpr
             * e.g.) ninf OR pinf
             */
            BoolArg(BoolExpr bool);
            /**
             * operator used as static argument
             * StaticArg ::= Op
             * e.g.) +
             */
            OprArg(SimpleName name);
            /**
             * dimension used as static argument
             * StaticArg ::= DimExpr
             * e.g.) Unity
             */
            DimArg(DimExpr dim);
            /**
             * unit used as static argument
             * StaticArg ::= UnitExpr
             * e.g.) dimensionless
             */
            UnitArg(UnitExpr unit);
        _RewriteImplicitType();    
    /**
     * static expression
     */
    abstract StaticExpr(boolean parenthesized = false);
        /**
         * integer expression
         */
        abstract IntExpr();
            /**
             * integer value
             * IntExpr ::= IntVal
             */
            abstract IntVal();
                /**
                 * integer number
                 * IntVal ::= Number
                 * e.g.) 8
                 */
                NumberConstraint(IntLiteral val);
                /**
                 * integer identiier
                 * IntVal ::= QualifiedIdName
                 * e.g.) m
             */
                IntRef(QualifiedIdName name);
            /**
             * integer addition
             * IntExpr ::= IntExpr + IntExpr
             * e.g.) m + 2
             */
            SumConstraint(IntExpr left, IntExpr right);
                /**
             * integer subtraction
             * IntExpr ::= IntExpr - IntExpr
             * e.g.) m - 2
                 */
            MinusConstraint(IntExpr left, IntExpr right);
                /**
             * integer multiplication
             * IntExpr ::= IntExpr IntExpr
             *           | IntExpr DOT IntExpr
             * e.g.) m DOT n
                 */
            ProductConstraint(IntExpr multiplier, IntExpr multiplicand);
                /**
             * integer exponentiation
             * IntExpr ::= IntExpr caret IntVal
             * e.g.) 2^b
                 */
            ExponentConstraint(IntExpr base, IntVal power);
                /**
         * boolean expression
         * StaticExpr ::= BoolExpr
                 */
        abstract BoolExpr();
                /**
             * boolean value
             * BoolExpr ::= BoolVal
                 */
            abstract BoolVal();
            /**
                 * boolean constant
                 * BoolVal ::= true | false
                 * e.g.) true
             */
                BoolConstant(boolean bool);
                /**
                 * boolean identiier
                 * BoolVal ::= QualifiedIdName
                 * e.g.) ninf
                 */
                BoolRef(QualifiedIdName name);
                /**
             * boolean constraint
             * BoolExpr ::= BoolConstraint
                 */
            abstract BoolConstraint();
                /**
                 * boolean NOT constraint
                 * BoolConstraint ::= NOT BoolExpr
                 * e.g.) NOT ninf
                 */
                NotConstraint(BoolExpr bool);
                /**
                 * boolean OR constraint
                 * BoolConstraint ::= BoolExpr OR BoolExpr
                 * e.g.) ninf OR pinf
                 */
                OrConstraint(BoolExpr left, BoolExpr right);
                /**
                 * boolean AND constraint
                 * BoolConstraint ::= BoolExpr AND BoolExpr
                 * e.g.) ninf AND pinf
                 */
                AndConstraint(BoolExpr left, BoolExpr right);
                /**
                 * boolean IMPLIES constraint
                 * BoolConstraint ::= BoolExpr IMPLIES BoolExpr
                 * e.g.) ninf IMPLIES pinf
                 */
                ImpliesConstraint(BoolExpr left, BoolExpr right);
                /**
                 * boolean equality constraint
                 * BoolConstraint ::= BoolExpr = BoolExpr
                 * e.g.) ninf AND pinf = true
                 */
                BEConstraint(BoolExpr left, BoolExpr right);
                /**
         * dimension expression
         */
        abstract DimExpr();
            /* base dimension
             * DimExpr ::= Unity
             * e.g.) Unity
             */
            BaseDim();
            /* dimension identifier
             * DimExpr ::= QualifiedIdName
             * e.g.) com.sun.fortress.dim.Length
             */
            DimRef(QualifiedIdName name);
            /* dimension multiplication
             * DimExpr ::= DimExpr DOT DimExpr
             *           | DimExpr DimExpr
             * e.g.) Length Mass
             */
            ProductDim(DimExpr multiplier, DimExpr multiplicand);
            /* dimension division
             * DimExpr ::= DimExpr / DimExpr
             *           | DimExpr per DimExpr
             *           | 1 / DimExpr
             * e.g.) Length / Time
             */
            QuotientDim(DimExpr numerator, DimExpr denominator);
            /* dimension exponentiation
             * DimExpr ::= DimExpr ^ IntLiteral
             * e.g.) Time^2
             */
            ExponentDim(DimExpr base, IntLiteral power);
            /* dimension with operator
             * DimExpr ::= DUPreOp DimExpr
             *           | DimExpr DUPostOp
             * e.g.) Time squared
                 */
            OpDim(DimExpr val, DimUnitOp op);
            /**
         * unit expression
         */
        abstract UnitExpr() implements ExprOrUnitExpr;
            /* base unit
             * UnitExpr ::= dimensionless
             * e.g.) dimensionless
             */
            BaseUnit();
            /* unit identifier
             * UnitExpr ::= QualifiedIdName
             * e.g.) com.sun.fortress.dim.Length
             */
            UnitRef(QualifiedIdName name);
            /* unit multiplication
             * UnitExpr ::= UnitExpr DOT UnitExpr
             *            | UnitExpr UnitExpr
             * e.g.) Length Mass
             */
            ProductUnit(UnitExpr multiplier, UnitExpr multiplicand);
            /* unit division
             * UnitExpr ::= UnitExpr / UnitExpr
             *            | UnitExpr per UnitExpr
             *            | 1 / UnitExpr
             * e.g.) Length / Time
             */
            QuotientUnit(UnitExpr numerator, UnitExpr denominator);
            /* unit exponentiation
             * UnitExpr ::= UnitExpr ^ IntLiteral
             * e.g.) Time^2
             */
            ExponentUnit(UnitExpr base, IntLiteral power);
            /* unit with operator
             * UnitExpr ::= DUPreOp UnitExpr
             *            | UnitExpr DUPostOp
             * e.g.) Time squared
             */
            OpUnit(UnitExpr val, DimUnitOp op);
    /**
     * where clause used in trait, object, and functional declarations
     * Where ::= where { WhereClauseList }
     * CoercionWhere ::= where { CoercionWhereClauseList }
     * e.g.) where { ninf AND NOT nan }
     */
    abstract WhereClause();
        /**
         * hidden type variable declared in where clauses
         * WhereClause ::= Id Extends
         * e.g.) T extends Object
         */
        WhereExtends(IdName name, List<TraitType> supers);
        /**
         * type alias declaration
         * TypeAlias ::= type Id StaticParams? = Type
         * e.g.) type IntList = List[\ZZ64\]
         */
        TypeAlias(IdName name,
                  List<StaticParam> staticParams
                      = Collections.<StaticParam>emptyList(),
                  Type type)
                 implements Decl, AbsDecl;
        /**
         * nat parameter declared in where clauses
         * WhereClause ::= nat Id
         * e.g.) nat length
         */
        WhereNat(IdName name);
        /**
         * int parameter declared in where clauses
         * WhereClause ::= int Id
         * e.g.) int length
         */
        WhereInt(IdName name);
        /**
         * bool parameter declared in where clauses
         * WhereClause ::= bool Id
         * e.g.) bool ninf
         */
        WhereBool(IdName name);
        /**
         * unit parameter declared in where clauses
         * WhereClause ::= unit Id
         * e.g.) unit U
         */
        WhereUnit(IdName name);
        /**
         * coercion constraint declared in where clauses
         * WhereClause ::= Type coerces Type
         * e.g.) T coerces Identity[\ODOT\]
         */
        WhereCoerces(Type left, Type right);
        /**
         * widening constraint declared in where clauses
         * WhereClause ::= Type widens Type
         * e.g.) T widens S
         */
        WhereWidens(Type left, Type right);
        /**
         * widening coercion constraint declared in where clauses
         * CoercionWhereClause ::= Type widens or coerces Type
         * e.g.) T widens or coerces S
         */
        WhereWidensCoerces(Type left, Type right);
        /**
         * DootedId equality constraint declared in where clauses
         * WhereClause ::= QualifiedIdName = QualifiedIdName
         * e.g.) m = n
         */
        WhereEquals(QualifiedIdName left, QualifiedIdName right);
        /**
         * unit constraint used in where clauses
         * WhereClause ::= dimensionless = Id
         *               | Id = dimensionless
         * e.g.) U = dimensionless
         */
        UnitConstraint(IdName name);
        /**
         * integer constraint used in where clauses
         * WhereClause ::= IntConstraint
         */
        abstract IntConstraint();
            /**
             * less than equal constraint declared in where clauses
             * IntConstraint ::= IntExpr <= IntExpr
             * e.g.) b <= c
             */
            LEConstraint(IntExpr left, IntExpr right);
            /**
             * less than constraint declared in where clauses
             * IntConstraint ::= IntExpr < IntExpr
             * e.g.) 0 < a
             */
            LTConstraint(IntExpr left, IntExpr right);
            /**
             * greater than equal constraint declared in where clauses
             * IntConstraint ::= IntExpr <= IntExpr
             * e.g.) b >= c
             */
            GEConstraint(IntExpr left, IntExpr right);
            /**
             * greater than constraint declared in where clauses
             * IntConstraint ::= IntExpr < IntExpr
             * e.g.) a > 0
             */
            GTConstraint(IntExpr left, IntExpr right);
            /**
             * integer equality constraint declared in where clauses
             * IntConstraint ::= IntExpr = IntExpr
             * e.g.) 8 = 2^3
             */
            IEConstraint(IntExpr left, IntExpr right);
        /**
         * boolean constraint declared in where clauses
         * WhereClause ::= BoolConstraint
         * e.g.) pinf AND ninf
         */
        BoolConstraintExpr(BoolConstraint constraint);
    /**
     * contracts used in functional declarations and object declarations
     * Contract ::= Requires? Ensures? Invariant?
     * Requires ::= requires { ExprList? }
     * Ensures ::= ensures { EnsuresClauseList? }
     * Invariant ::= invariant { ExprList? }
     * CoercionContract ::= Ensures? Invariant?
     * e.g.) requires { n GE 0 } ensures { result GE 0 }
     */
    Contract(Option<List<Expr>> requires = Option.<List<Expr>>none(),
             Option<List<EnsuresClause>> ensures =
                 Option.<List<EnsuresClause>>none(),
             Option<List<Expr>> invariants = Option.<List<Expr>>none());
    /**
     * ensures clause used in contracts
     * EnsuresClause ::= Expr (provided Expr)?
     * e.g.) sorted(result) provided sorted(input)
     */
    EnsuresClause(Expr post, Option<Expr> pre = Option.<Expr>none());
    /**
     * modifier
     * TraitMod      ::= AbsTraitMod | private
     * AbsTraitMod   ::= value | test
     * ObjectMods    ::= TraitMods
     * AbsObjectMods ::= AbsTraitMods
     * MdMod         ::= FnMod | override
     * AbsMdMod      ::= AbsFnMod | override
     * FnMod         ::= AbsFnMod | private
     * AbsFnMod      ::= LocalFnMod | test
     * LocalFnMod    ::= atomic | io
     * ParamFldMod   ::= var | hidden | settable | wrapped
     * VarMod        ::= AbsVarMod | private
     * AbsVarMod     ::= var | test
     * FldMod        ::= var | AbsFldMod
     * AbsFldMod     ::= ApiFldMod | wrapped | private
     * ApiFldMod     ::= hidden | settable | test
     */
    abstract Modifier();
        /**
         * e.g.) abstract m(x: ZZ32): ()
         */
        ModifierAbstract();
        /**
         * e.g.) atomic f(x: ZZ32): ()
         */
        ModifierAtomic();
        /**
         * e.g.) getter velocity(): (RR Velocity)^3
         */
        ModifierGetter();
        /**
         * e.g.) hidden x: ZZ32
         */
        ModifierHidden();
        /**
         * e.g.) io print(s: String): ()
         */
        ModifierIO();
        /**
         * e.g.) override m(x: ZZ32): ()
         */
        ModifierOverride();
        /**
         * e.g.) private f(): ()
         */
        ModifierPrivate();
        /**
         * e.g.) settable message: Maybe[\String\]
         */
        ModifierSettable();
        /**
         * e.g.) setter velocity(v: (RR Velocity)^3): ()
         */
        ModifierSetter();
        /**
         * e.g.) test object TestSuite(testFunctions = {}) end
         */
        ModifierTest();
        /**
         * e.g.) object O(transient x: ZZ32) end
         */
        ModifierTransient();
        /**
         * e.g.) value object IntEmpty extends List[\ZZ32\] end
         */
        ModifierValue();
        /**
         * e.g.) var x: ZZ32
         */
        ModifierVar();
        /**
         * e.g.) coerce (x: RR32) widens = ...
         */
        ModifierWidens();
        /**
         * e.g.) wrapped val: Dictionary[\T\]
         */
        ModifierWrapped();
    /**
     * static parameter
     */
    abstract StaticParam();
        /**
         * operator parameter
         * StaticParam ::= opr Op
         * e.g.) opr ODOT
         */
        OperatorParam(OpName name);
        /**
         * static parameter with a name field
         * of type IdName
         */
        abstract IdStaticParam(IdName name);
           /**
            * bool parameter
            * StaticParam ::= bool Id
            * e.g.) bool nan
            */
            BoolParam();
           /**
            * dimension parameter
            * StaticParam ::= dim Id
            * e.g.) dim D
            */
            DimensionParam();
           /**
            * int parameter
            * StaticParam ::= int Id
            * e.g.) int i
            */
            IntParam();
           /**
            * nat parameter
            * StaticParam ::= nat Id
            * e.g.) nat len
            */
            NatParam();
           /**
            * type parameter
            * StaticParam ::= Id Extends? (absorbs unit)?
            * e.g.) EltType extends Number absorbs unit
            */
            SimpleTypeParam(List<TraitType> extendsClause =
                                Collections.<TraitType>emptyList(),
                            boolean absorbs = false);
           /**
            * unit parameter
            * StaticParam ::= unit Id (: DimExpr)? (absorbs unit)?
            * e.g.) unit U absrbs unit
            */
            UnitParam(Option<DimExpr> dim = Option.<DimExpr>none(),
                      boolean absorbs = false);
    /**
     * Names used in declarations and references.
     */
    abstract Name();
        /**
         * unstructured sequence of ids naming an API or component
         * DottedName ::= (Id.)*Id
         * e.g.) com.sun.fortress.nodes_util
         */
        DottedName(List<Id> ids);
        /**
         * name prefixed by an optional API name
         */
        abstract QualifiedName(Option<DottedName> api = Option.<DottedName>none(),
                               SimpleName name);
            /**
             * qualified id name
             * QualifiedIdName ::= (Id.)*Id
             * e.g.) com.sun.fortress.nodes_util.getName
             */
            QualifiedIdName(IdName name);
            /**
             * qualified operator name
             * internal uses only
             * e.g.) com.sun.fortress.nodes_util.+
             */
            QualifiedOpName(OpName name);
        /**
         * unqualified name
         */
        abstract SimpleName();
            /**
             * unqualified id name
             */
            IdName(Id id);
            /**
             * unqualified operator name
             */
            abstract OpName();
                /**
                 * infix/prefix/nofix/multifix operator
                 * e.g.) COMPOSE
                 * e.g.) +
                 */
                Opr(Op op);
                /**
                 * postfix operator
                 * e.g.) 3!
                 */
                PostFix(Op op);
                /**
                 * pair of enclosing operators
                 * EncloserPair ::= LeftEncloser RightEncloser
                 * e.g.) </ />
                 */
                abstract Enclosing(Op open, Op close);
                    /**
                     * bracketing operator
                     * e.g.) a[i]
                     */
                    Bracketing();
                    /**
                     * subscripting operator
                     * e.g.) a[i]
                     */
                    SubscriptOp();
                    /**
                     * subscripted assignment operator
                     * e.g.) a[i] := 1
                     */
                    SubscriptAssign();
            /**
             * internal name for anonymous function expressions
             * not created during parsing but during evaluation
             * e.g.) name for "fn x => x + 1"
             */
            AnonymousFnName();
            /**
             * internal name for anonymous constructor expressions
             * not created during parsing but during evaluation
             * e.g.) name for "object extends List cons(x) = Cons(x, self) end"
             */
            ConstructorFnName(GenericWithParams def);
    /**
     * array comprehension clause
     * ArrayComprehensionLeft ::= IdOrInt |-> Expr
     *                          | ( IdOrInt, IdOrIntList ) |-> Expr
     * IdOrInt ::= Id
     *           | IntLiteral
     * ArrayComprehensionClause ::= ArrayComprehensionLeft | GeneratorList
     * e.g.) (x, y) = 0 | x <- {0, 1, 2}, y <- {0, 1, 2}
     */
    ArrayComprehensionClause(List<Expr> bind, Expr init, List<Generator> gens);
    /**
     * binding used in tuple expressions and typecase expressions
     * Binding ::= Id = Expr
     * e.g.) x = myLoser.myField
     */
    Binding(IdName name, Expr init);
    /**
     * case clause used in case expressions and extremum expressions
     * CaseClause ::= Expr => BlockElems
     * e.g.) { Jupiter, Saturn, Uranus, Neptune } => "outer"
     */
    CaseClause(Expr match, Block body);
    /**
     * condition expression used in case expressions and extremum expressions
     */
    abstract CaseParam();
        /**
         * condition expression used in case expressions
         */
        CaseParamExpr(Expr expr);
        /**
         * "largest" used in extremum expressions
         */
        CaseParamLargest();
        /**
         * "smallest" used in extremum expressions
         */
        CaseParamSmallest();
    /**
     * catch clause used in try expressions
     * Catch ::= catch Id CatchClauses
     * e.g.) catch e IOException => throw ForbiddenException(e)
     */
    Catch(IdName name, List<CatchClause> clauses);
    /**
     * each clause in a catch clause used in try expressions
     * CatchClause ::= TraitType => BlockElems
     * e.g.) IOException => throw ForbiddenException(e)
     */
    CatchClause(TraitType match, Block body);
    /**
     * block expression used in do expressions
     * DoFront ::= (at Expr)? atomic? do BlockElems?
     * e.g.) at a.region(j) do w := a_j
     */
    DoFront(Option<Expr> loc = Option.<Expr>none(),
            boolean atomic = false, Block expr);
    /**
     * if clause used in if expressions
     * DelimitedExpr ::= if Expr then BlockElems Elifs? Else? end
     * Elif ::= elif Expr then BlockElems
     * e.g.) if x IN { 0, 1, 2 } then 0
     */
    IfClause(Expr test, Block body);
    /**
     * typecase clause used in typecase expressions
     * TypecaseClause ::= TypecaseTypes => BlockElems
     * TypecaseTypes ::= ( TypeList )
     *                    | Type
     * e.g.) String => x.append("foo")
     */
    TypecaseClause(List<Type> match, Block body);
    /**
     * key/value pair used in map expressions and map comprehensions
     * Entry ::= Expr |-> Expr
     * e.g.) 'a' |-> 0
     */
    Entry(Expr key, Expr value);
    /**
     * array and matrix size
     * ExtentRange ::= StaticArg? # StaticArg?
     *               | StaticArg? : StaticArg?
     *               | StaticArg
     * e.g.) 3#5
     */
    ExtentRange(Option<StaticArg> base, Option<StaticArg> size);
    /**
     * generator
     * Generator ::= IdOrIdTuple <- Expr
     *             | Expr
     * IdOrIdTuple ::= Id
     *               | ( Id, IdList )
     * e.g.) (i, j) <- my2DArray.indices
     */
    Generator(List<IdName> bind, Expr init);
    /**
     * identifier
     * e.g.) hashCode
     */
    Id(String text);
    /**
     * operator symbol
     * e.g.) ===
     */
    Op(String text);
    /**
     * varargs expression used in tuple expressions
     * Expr...
     * e.g.) [3 4 5]...
     */
    VarargsExpr(Expr varargs);
    /**
     * varargs type used in tuple types and varargs parameters
     * Type ...
     * e.g.) ZZ32...
     */
    VarargsType(Type type);
    /**
     * keyword type used in tuple types
     * KeywordType ::= Id = Type
     * e.g.) x = String
     */
    KeywordType(IdName name, Type type);
    /**
     * trait type with a where clause used in extends clauses
     * TraitTypeWhere ::= TraitType Where?
     */
    TraitTypeWhere(TraitType type, List<WhereClause> where);
    /**
     * array indices
     */
    abstract Indices();
        /**
         * array dimensionality
         * ArraySize ::= ExtentRange(, ExtentRange)*
         * e.g.) 3, 2#1, 3:5
         */
        FixedDim(List<ExtentRange> extents);
    /**
     * operator on dimensions and units
     * DUPreOp ::= square | cubic | inverse
     * DUPostOp ::= squared | cubed
     */
    abstract DimUnitOp();
        /**
         * e.g.) second squared
         */
        SquareDimUnit();
        /**
         * e.g.) cubic centimeter
         */
        CubicDimUnit();
        /**
         * e.g.) inverse ohms
         * e.g.) grams per cubic centimeter
         */
        InverseDimUnit();
end;
