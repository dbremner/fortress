/*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

generateEmptyConstructor yes;   // for reflective object creation
visitMethod accept;
visitorMethodPrefix for;
addGetterPrefixes yes;
usePLT yes;
tabSize 4;
allowNulls no;
generateToString no;
generateEquals yes;
generateSerializers yes;

package com.sun.fortress.nodes;
import java.math.BigInteger;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import com.sun.fortress.nodes_util.*;
import com.sun.fortress.parser_util.*;
import com.sun.fortress.useful.*;
import edu.rice.cs.plt.tuple.Option;

begin ast;

/**
 * top-level node interface
 */
interface Node(ignoreForEquals Span span = new Span()) extends HasAt;
    /**
     * declaration in components or APIs
     */
    interface AbsDeclOrDecl();
        /**
         * declaration in APIs
         */
        interface AbsDecl();
        /**
         * declaration in components
         */
        interface Decl();
    /**
     * left-hand-side of assignments, local variable declarations, or
     * top-level declarations.
     */
    interface LHS();
    /**
     * with static parameters
     * implemented by trait, object, and function declarations and
     * object expressions in components or APIs
     */
    interface Generic(List<StaticParam> staticParams);
    /**
     * with value parameters
     * implemented by object declarations and object expressions in components
     * or APIs
     */
    interface HasParams(Option<List<Param>> params,
                        List<? extends AbsDeclOrDecl> decls);
    /**
     * with a where clause
     * implemented by trait and object declarations in components or APIs
     */
    interface HasWhere(WhereClause where);

/**
 * functional declaration or function expression
 * nodes_util.NodeUtil declares the following static methods:
 *  - String nameAsMethod(Applicable)
 *  - Option<Expr> getBody(Applicable)
 */
interface Applicable(SimpleName name, List<StaticParam> staticParams,
                     List<Param> params, Option<Type> returnType,
                     WhereClause where) extends HasAt;

/**
 * intersections of interface types
 */
interface GenericWithParams() extends Generic, HasParams;
interface GenericAbsDeclOrDecl() extends Generic, AbsDeclOrDecl;
    interface GenericDecl() extends Decl;
interface GenericAbsDeclOrDeclWithParams() extends GenericWithParams,
                                                   GenericAbsDeclOrDecl;
    interface GenericDeclWithParams() extends GenericDecl;

/**
 * top-level node abstract class
 */
abstract AbstractNode(ignoreForEquals Span span = new Span())
                     extends UIDObject implements Node;
    /**
     * compilation unit declaration
     * CompilationUnit ::= Component | Api
     */
    abstract CompilationUnit(boolean _native = false,
                             APIName name, List<Import> imports);
        /**
         * component declaration
         * Component ::= component APIName Imports? Exports Decls? end
         * e.g.) component Hello
         *         export Executable
         *         run(args:String...) = print "Hello, World!\n"
         *       end
         */
        Component(List<Export> exports, List<Decl> decls);
        /**
         * API declaration
         * Api ::= api APIName Imports? AbsDecls? end
         * e.g.) api Executable
         *         run(args:String...):()
         *       end
         */
        Api(List<AbsDecl> decls);
    /**
     * import statement
     * Import ::= import ImportedNames | import api AliasedAPINames
     */
    abstract Import();
        /**
         * ImportedNames ::= APIName . {...} (except SimpleNames)?
         *                 | APIName . { AliasedSimpleNameList (, ...)? }
         *                 | QualifiedName (as Id)?
         */
        abstract ImportedNames(APIName api);
            /**
             * e.g.) import Set.{...} except {opr UNION, union}
             */
            ImportStar(List<SimpleName> except);
            /**
             * e.g.) import Set.{empty, union}
             */
            ImportNames(List<AliasedSimpleName> aliasedNames);
        /**
         * e.g.) import api {Set, Map, List}
         */
        ImportApi(List<AliasedAPIName> apis);
    /**
     * aliased simple name used in import statements
     * AliasedSimpleName ::= Id (as Id)?
     *                     | opr Op (as Op)?
     *                     | opr EncloserPair (as EncloserPair)?
     * EncloserPair ::= (LeftEncloser | Encloser) (RightEncloser | Encloser)
     * e.g.) longComplexName as shortName
     */
    AliasedSimpleName(SimpleName name,
                      Option<SimpleName> alias = Option.<SimpleName>none());
    /**
     * aliased API name used in import statements
     * AliasedAPIName ::= APIName (as Id)?
     * e.g.) com.sun.fortress.parser.precedence.resolver as precedence_resolver
     */
    AliasedAPIName(APIName api,
                   Option<Id> alias = Option.<Id>none());
    /**
     * export statement
     * Export ::= export APINames
     * e.g.) export Executable
     */
    Export(List<APIName> apis);
    /**
     * trait or object declaration in components or APIs
     */
    abstract TraitObjectAbsDeclOrDecl(List<Modifier> mods
                                          = Collections.<Modifier>emptyList(),
                                      Id name,
                                      List<StaticParam> staticParams
                                          = Collections.<StaticParam>emptyList(),
                                      List<TraitTypeWhere> extendsClause
                                          = Collections.<TraitTypeWhere>emptyList(),
                                      WhereClause where
                                          = FortressUtil.emptyWhereClause(),
                                      List<? extends AbsDeclOrDecl> decls)
                                     implements HasWhere, GenericAbsDeclOrDecl;
        /**
         * trait declaration in components or APIs
         */
        abstract TraitAbsDeclOrDecl(List<TraitType> excludes
                                        = Collections.<TraitType>emptyList(),
                                    Option<List<TraitType>> comprises
                                        = Option.<List<TraitType>>none(),
                                    List<? extends AbsDeclOrDecl> decls);
            /**
             * trait declaration in APIs
             * AbsTraitDecl ::= AbsTraitMods? TraitHeaderFront AbsTraitClauses
             *                  AbsGoInATrait? end
             * TraitHeaderFront ::= trait Id StaticParams? ExtendsWhere?
             * ExtendsWhere ::= extends TraitTypeWheres
             * AbsTraitClause ::= Excludes | AbsComprises | Where
             * Excludes ::= excludes TraitTypes
             * AbsComprises ::= comprises ComprisingTypes
             * ComprisingTypes ::= TraitType | { ComprisingTypeList }
             * ComprisingTypeList ::= ...
             *                      | TraitType(, TraitType)*(, ...)?
             * AbsGoInATrait ::= AbsCoercions? AbsGoFrontInATrait AbsGoBackInATrait?
             *                 | AbsCoercions? AbsGoBackInATrait
             *                 | AbsCoercions
             * AbsGoesFrontInATrait ::= ApiFldDecl
             *                        | AbsGetterSetterDecl
             *                        | PropertyDecl
             * AbsGoesBackInATrait  ::= AbsMdDecl
             *                        | PropertyDecl
             * e.g.) trait List[\alpha\] comprises {Cons[\alpha\],Empty[\alpha\]}
             *         cons(x: alph): List[\alpha\]
             *       end
             */
            AbsTraitDecl(List<AbsDecl> decls) implements AbsDecl;
            /**
             * trait declaration in components
             * TraitDecl ::= TraitMods? TraitHeaderFront TraitClauses GoInATrait?
             *               end
             * TraitClause ::= Excludes | Comprises | Where
             * Comprises ::= comprises TraitTypes
             * GoInATrait ::= Coercions? GoFrontInATrait GoBackInATrait?
             *              | Coercions? GoBackInATrait
             *              | Coercions
             * GoesFrontInATrait ::= AbsFldDecl
             *                     | GetterSetterDecl
             *                     | PropertyDecl
             * GoesBackInATrait  ::= MdDecl
             *                     | PropertyDecl
             * e.g.) trait List[\alpha\] comprises {Cons[\alpha\],Empty[\alpha\]}
             *         cons(x: alph): List[\alpha\] = Cons[\alph\](x, self)
             *       end
             */
            TraitDecl(List<Decl> decls) implements GenericDecl;
        /**
         * object declaration in components or APIs
         */
        abstract ObjectAbsDeclOrDecl(Option<List<Param>> params
                                         = Option.<List<Param>>none(),
                                     Option<List<TraitType>> throwsClause
                                         = Option.<List<TraitType>>none(),
                                     Contract contract = new Contract(),
                                     List<? extends AbsDeclOrDecl> decls)
                                    implements GenericAbsDeclOrDeclWithParams;
            /**
             * object declaration in APIs
             * AbsObjectDecl ::= AbsObjectMods? ObjectHeader AbsGoInAnObject? end
             * ObjectHeader ::= object Id StaticParams? ObjectValParam?
             *                  ExtendsWhere? FnClauses
             * FnClauses ::= Throws? Where? Contract
             * Throws ::= throws MayTraitTypes
             * ObjectValParam ::= ( ObjectParams? )
             * ObjectParams ::= (ObjectParam ,)* (ObjectVarargs, )? ObjectKeyword(, ObjectKeyword)*
             *                | (ObjectParam ,)* ObjectVarargs
             *                | ObjectParam (, ObjectParam)*
             * ObjectVarargs ::= transient Varargs
             * ObjectKeyword ::= ObjectParam = Expr
             * ObjectParam ::= ParamFldMods? Param
             *               | transient Param
             * AbsGoInAnObject ::= AbsCoercions? AbsGoFrontInAnObject AbsGoBackInAnObject?
             *                   | AbsCoercions? AbsGoBackInAnObject
             *                   | AbsCoercions
             * AbsGoesFrontInAnObject ::= ApiFldDecl
             *                          | AbsGetterSetterDecl
             *                          | PropertyDecl
             * AbsGoesBackInAnObject ::= AbsMdDecl
             *                         | PropertyDecl
             * e.g.) object Empty[\alph\]() extends List[\alpha\] end
             */
            AbsObjectDecl(List<AbsDecl> decls) implements AbsDecl;
            /**
             * object declaration in components
             * ObjectDecl ::= ObjectMods? ObjectHeader GoInAnObject? end
             * GoInAnObject ::= Coercions? GoFrontInAnObject GoBackInAnObject?
             *                | Coercions? GoBackInAnObject
             *                | Coercions
             * GoesFrontInAnObject ::= FldDecl
             *                       | GetterSetterDecl
             *                       | PropertyDecl
             * GoesBackInAnObject ::= MdDef
             *                      | PropertyDecl
             * e.g.) object Empty[\alph\]() extends List[\alpha\]
             *         length() = 0
             *       end
             */
            ObjectDecl(List<Decl> decls)
                      implements GenericDeclWithParams;
    /**
     * variable declaration in components or APIs
     */
    abstract VarAbsDeclOrDecl(List<LValueBind> lhs) implements AbsDeclOrDecl;
        /**
         * variable declaration in APIs
         * AbsVarDecl ::= AbsVarMods? VarWTypes
         *              | AbsVarMods? BindIdOrBindIdTuple : Type ...
         *              | AbsVarMods? BindIdOrBindIdTuple : SimpleTupleType
         * VarWTypes ::= VarWType | ( VarWType(, VarWType)+ )
         * VarWType ::= BindId IsType
         * BindIdOrBindIdTuple ::= BindId
         *                       | ( BindId , BindIdList )
         * BindId ::= Id | _
         * e.g.) var (x, y): ZZ64...
         */
        AbsVarDecl() implements AbsDecl, Decl;
        /**
         * variable declaration in components
         * VarDecl ::= VarMods? VarWTypes InitVal
         *           | VarMods? BindIdOrBindIdTuple = Expr
         *           | VarMods? BindIdOrBindIdTuple : Type ... InitVal
         *           | VarMods? BindIdOrBindIdTuple : SimpleTupleType InitVal
         * InitVal ::= (= | :=) Expr
         * e.g.) var (x, y): ZZ64... = (5, 6)
         */
        VarDecl(Expr init) implements Decl;
    /**
     * left-hand side of variable declaration
     */
    abstract LValue();
        /**
         * e.g.) var x: ZZ32
         */
        LValueBind(Id name, Option<Type> type = Option.<Type>none(),
                   List<Modifier> mods = Collections.<Modifier>emptyList(),
                   boolean mutable) implements LHS;
        /**
         * left-hand side of matrix unpasting
         * Unpasting ::= [ UnpastingElems ]
         */
        abstract Unpasting();
            /**
             * simple unpasting
             * UnpastingElem ::= BindId ([ UnpastingDim ])?
             *                 | Unpasting
             * UnpastingDim ::= ExtentRange (BY ExtentRange)+
             * e.g.) squareShape[m BY m]
             */
            UnpastingBind(Id name, List<ExtentRange> dim);
            /**
             * complex unpasting
             * UnpastingElems ::= UnpastingElem RectSeparator UnpastingElems
             *                  | UnpastingElem
             * e.g.) squareShape[m BY m]  rest
             */
            UnpastingSplit(List<Unpasting> elems, int dim);
    /**
     * functional declaration in components or APIs
     */
    abstract FnAbsDeclOrDecl(List<Modifier> mods
                                 = Collections.<Modifier>emptyList(),
                             SimpleName name,
                             List<StaticParam> staticParams
                                 = Collections.<StaticParam>emptyList(),
                             List<Param> params,
                             Option<Type> returnType
                                 = Option.<Type>none(),
                             Option<List<TraitType>> throwsClause
                                 = Option.<List<TraitType>>none(),
                             WhereClause where
                                 = FortressUtil.emptyWhereClause(),
                             Contract contract = new Contract(),
                             String selfName = NodeUtil.defaultSelfName)
                            implements Applicable, GenericDecl;
        /**
         * functional declaration in components or APIs
         * AbsFnDecl ::= AbsFnMods? FnHeaderFront FnHeaderClause
         *             | FnSig
         * FnSig ::= SimpleName : ArrowType
         * FnHeaderFront ::= NamedFnHeaderFront
         *                 | OpHeaderFront
         * NamedFnHeaderFront ::= Id StaticParams? ValParam
         * OpHeaderFront ::= opr StaticParams? BIG? (LeftEncloser | Encloser)
         *                     Params (RightEncloser | Encloser)
         *                 | opr StaticParams? ValParam (Op | ExponentOp)
         *                 | opr BIG? (Op | ^ | Encloser) StaticParams? ValParam
         * FnHeaderClause ::= IsType? FnClauses
         * FnDecl ::= FnMods? FnHeaderFront FnHeaderClause
         *          | FnSig
         * e.g.) swap (x: Object, y: Object): (Object, Object)
         */
        AbsFnDecl() implements AbsDecl;
        /**
         * functional declaration in components
         * FnDecl ::= FnMods? FnHeaderFront FnHeaderClause = Expr
         * e.g.) swap (x, y) = (y, x)
         */
        abstract FnDecl();
            FnDef(Expr body);
    /**
     * value parameter of functional declarations and object declarations
     * e.g.) x: ZZ32 = 3
     * e.g.) self
     * e.g.) transient x: String
     */
    abstract Param(List<Modifier> mods = Collections.<Modifier>emptyList(),
                   Id name);
        /**
         * ValParam := BindId
         *           | ( Params? )
         * Params ::= (Param, )* (Varargs, )? Keyword(, Keyword)*
         *          | (Param, )* Varargs
         *          | Param(, Param)*
         * Keyword ::= Param = Expr
         * Param ::= BindId IsType?
         *         | Type
         */
        NormalParam(Option<Type> type = Option.<Type>none(),
                    Option<Expr> defaultExpr = Option.<Expr>none());
        /**
         * varargs parameter
         * Varargs ::= BindId : Type ...
         */
        VarargsParam(VarargsType varargsType);
    /**
     * dimension and unit declaration
     * DimUnitDecl may represent a single dimension declaration, a single
     * unit declaration, or both dimension and unit declarations.
     * DimUnitDecl ::= dim Id (= DimExpr)? (unit | SI_unit) Id+ (= Expr)?
     *               | dim Id (= DimExpr)? (default Id)?
     *               | (unit | SI_unit) Id+ (: DimExpr)? (= Expr)?
     * e.g.) unit inch inches: Length
     * e.g.) dim Length SI_unit meter meters m
     */
    DimUnitDecl(Option<Id> dim = Option.<Id>none(),
                Option<DimExpr> derived = Option.<DimExpr>none(),
                Option<Id> default = Option.<Id>none(),
                boolean si_unit = false,
                List<Id> units = Collections.<Id>emptyList(),
                Option<Expr> def)
               implements Decl, AbsDecl;
    /**
     * test declaration
     * TestDecl ::= test Id [ GeneratorClauseList ] = Expr
     * e.g.) test fxLessThanFy[x <- E, y <- F] = assert(f(x) < f(y))
     */
    TestDecl(Id name, List<GeneratorClause> gens, Expr expr)
            implements Decl, AbsDecl;
    /**
     * property declaration
     * PropertyDecl ::= property (Id = )? (FORALL ValParam)? Expr
     * e.g.) property fIsMonotonic = FORALL (x:ZZ, y:ZZ) (x < y) -> (f(x) < f(y))
     */
    PropertyDecl(Option<Id> name = Option.<Id>none(), List<Param> params,
                 Expr expr) implements Decl, AbsDecl;
    /**
     * syntax expanders declaration in components or APIs
     */
    abstract ExternalSyntaxAbsDeclOrDecl(SimpleName openExpander, Id name,
                                         SimpleName closeExpander)
                                        implements AbsDeclOrDecl;
        /**
         * syntax expanders declaration in APIs
         * AbsExternalSyntax ::= syntax OpenExpander Id CloseExpander
         * OpenExpander ::= Id
         *                | (LeftEncloser / Encloser)
         * CloseExpander ::= Id
         *                 | (RightEncloser / Encloser)
         *                 | end
         * e.g.) syntax sql e end
         */
        AbsExternalSyntax() implements AbsDecl;
        /**
         * syntax expanders declaration in APIs
         * ExternalSyntax ::= syntax OpenExpander Id CloseExpander = Expr
         * e.g.) syntax sql e end = parseSQL(e)
         */
        ExternalSyntax(Expr expr) implements Decl;
    /**
     * grammar declaration
     */
    abstract GrammarDecl(QualifiedIdName name, List<QualifiedIdName> extends)
                        implements AbsDecl;
        /**
         * grammar definition in grammar declarations
         */
        GrammarDef(List<NonterminalDecl> nonterminals);
    /**
     * nonterminal declaration
     */
    abstract NonterminalDecl(Option<? extends Modifier> modifier,
                            QualifiedIdName name, Option<TraitType> type,
                            List<SyntaxDef> syntaxDefs) implements AbsDecl;
        /**
         * nonterminal definition in nonterminal declarations
         */
        NonterminalDef();
        /**
         * nonterminal extending definition in nonterminal declarations
         */
        NonterminalExtensionDef();
    /**
     * syntax declaration
     */
    abstract SyntaxDecl() implements AbsDecl;
        /**
         * syntax definition in syntax declarations
         */
        SyntaxDef(List<SyntaxSymbol> syntaxSymbols,
                  Expr transformationExpression);
    /**
      * syntax symbol
      */
    SyntaxSymbol();
        /**
         * prefixed syntax symbol
         */
        PrefixedSymbol(Option<Id> id, SyntaxSymbol symbol);
        /**
         * optional syntax symbol
         */
        OptionalSymbol(SyntaxSymbol symbol);
        /**
         * repeat zero-or-more syntax symbol
         */
        RepeatSymbol(SyntaxSymbol symbol);
        /**
         * repeat one-or-more syntax symbol
         */
        RepeatOneOrMoreSymbol(SyntaxSymbol symbol);
        /**
         * whitespace syntax symbol
         */
        WhitespaceSymbol(String s);
        /**
         * ignore following whitespace syntax symbol
         */
        NoWhitespaceSymbol(SyntaxSymbol symbol);
        /**
         * tab syntax symbol
         */
        TabSymbol();
        /**
         * formfeed syntax symbol
         */
        FormfeedSymbol();
        /**
         * carriage return syntax symbol
         */
        CarriageReturnSymbol();
        /**
         * backspace syntax symbol
         */
        BackspaceSymbol();
        /**
         * newline syntax symbol
         */
        NewlineSymbol();
        /**
         * breakline syntax symbol
         */
        BreaklineSymbol(String s);
        /**
         * item syntax symbol
         */
        ItemSymbol(String item);
        /**
         * non-terminal syntax symbol
         */
        NonterminalSymbol(QualifiedName nonterminal);
        /**
         * keyword syntax symbol
         */
        KeywordSymbol(String token);
        /**
         * token syntax symbol
         */
        TokenSymbol(String token);
        /**
         * not predicate syntax symbol
         */
        NotPredicateSymbol(SyntaxSymbol symbol);
        /**
         * and predicate syntax symbol
         */
        AndPredicateSymbol(SyntaxSymbol symbol);
        /**
         * character class syntax symbol
         */
        CharacterClassSymbol(List<CharacterSymbol> characters);
        /**
         * character symbols
         */
        CharacterSymbol();
            /**
             * character
             */
            CharSymbol(String s);
            /**
             * character interval
             */
            CharacterInterval(String begin, String end);
    /**
     * expression
     */
    abstract Expr(boolean parenthesized = false);
        /**
         * type ascription expression
         * Expr ::= Expr as Type
         * e.g.) 3 as Number
         */
        AsExpr(Expr expr, Type type);
        /**
         * type assumption expression
         * Expr ::= Expr asif Type
         * e.g.) Empty asif List[\String\]
         */
        AsIfExpr(Expr expr, Type type);
        /**
         * assignment expression
         * AssignExpr ::= AssignLefts AssignOp Expr
         * AssignLefts ::= ( AssignLeft(, AssignLeft)* )
         *               | AssignLeft
         * AssignLeft ::= SubscriptExpr
         *              | FieldSelection
         *              | QualifiedName
         * FieldSelection ::= Primary . Id
         * AssignOp ::= := | Op=
         * e.g.) x += 1
         */
        Assignment(List<LHS> lhs, Option<Op> opr, Expr rhs);
        /**
         * expressions beginning and ending with reserved words
         * Expr ::= DelimitedExpr
         */
        abstract DelimitedExpr();
            /**
             * sequence of block elements implicitly enclosed by do/end
             * BlockElems ::= BlockElem+
             * e.g.) y = x
             *       z = 2x
             *       y + z
             */
            Block(List<Expr> exprs);
            /**
             * case expression or extremum expression
             * DelimitedExpr ::= case Expr Op? of CaseClauses CaseElse? end
             *                 | case most Op of CaseClauses end
             * CaseElse ::= else => BlockElems
             * e.g.) case most > of
             *         1 mile => "miles are larger"
             *         1 kilometer => "we were wrong again"
             *       end
             */
            CaseExpr(Option<Expr> param, Option<Op> compare = Option.<Op>none(),
                     List<CaseClause> clauses,
                     Option<Block> elseClause = Option.<Block>none());
            /**
             * do expression
             * Do ::= (DoFront also)* DoFront end
             * e.g.) do
             *         accum += treeSum(t.left)
             *       also do
             *         accum += treeSum(t.right)
             *       also do
             *         accum += t.datum
             *       end
             */
            Do(List<DoFront> fronts);
            /**
             * for expression
             * DelimitedExpr ::= for GeneratorClauseList DoFront end
             * e.g.) for i <- sequential(1:5) do
             *         print (i " ")
             *       end
             */
            For(List<GeneratorClause> gens, DoFront body);
            /**
             * if expression
             * DelimitedExpr ::= if Expr then BlockElems Elifs? Else? end
             *                 | ( if Expr then BlockElems Elifs? Else end? )
             * Elif ::= elif Expr then BlockElems
             * Else ::= else BlockElems
             * e.g.) if x IN {0, 1, 2} then 0
             *       elif x IN {3, 4, 5} then 3
             *       else 6 end
             */
            If(List<IfClause> clauses,
               Option<Block> elseClause = Option.<Block>none());
            /**
             * label expression
             * DelimitedExpr ::= label Id BlockElems end Id
             * e.g.) label I_95
             *         if goingTo(Sun)
             *         then exit I_95 with x32B
             *         else x32A
             *         end
             *       end I_95
             */
            Label(Id name, Block body);
            /**
             * object expression
             */
            abstract AbstractObjectExpr(List<TraitTypeWhere> extendsClause
                                            = Collections.<TraitTypeWhere>emptyList(),
                                        List<Decl> decls);
                /**
                 * object expression
                 * DelimitedExpr ::= object ExtendsWhere? GoInAnObject? end
                 * e.g.)  object extends {List}
                 *          cons(x) = Cons(x, self)
                 *          append (xs) = xs
                 *        end
                 */
                ObjectExpr();
                /**
                 * object expression rewritten by interpreter.rewrite.Disambiguate
                 */
                _RewriteObjectExpr(BATree<String, StaticParam> implicitTypeParameters,
                                   String genSymName,
                                   List<StaticParam> staticParams,
                                   List<StaticArg> staticArgs,
                                   Option<List<Param>> params)
                                  implements GenericWithParams;
            /**
             * try expression
             * DelimitedExpr ::= try BlockElems Catch? (forbid TraitTypes)?
             *                     (finally BlockElems)? end
             * e.g.) try
             *         inp = read (file)
             *         write (inp, newFile)
             *       forbid IOException
             *       end
             */
            Try(Block body, Option<Catch> catchClause = Option.<Catch>none(),
                List<TraitType> forbid = Collections.<TraitType>emptyList(),
                Option<Block> finallyClause = Option.<Block>none());
            /**
             * tuple expression
             * TupleExpr ::= ( (Expr,)* (Expr...,)? Binding(, Binding)* )
             *             | NoKeyTuple
             * NoKeyTuple ::= ( (Expr,)* Expr... )
             *              | ( (Expr,)+ Expr )
             * e.g.) (1, 2, [3 4]..., x = 5)
             */
            TupleExpr(List<Expr> exprs,
                      Option<VarargsExpr> varargs = Option.<VarargsExpr>none(),
                      List<Binding> keywords = Collections.<Binding>emptyList());
            /**
             * typecase expression
             * DelimitedExpr ::= typecase TypecaseBindings of TypecaseClauses
             *                     CaseElse? end
             * TypecaseBindings ::= ( BindgingList )
             *                    | Binding
             *                    | BindId
             * e.g.) typecase x = myLoser .myField of
             *         String => x.append("foo")
             *         Number => x + 3
             *         Object => yogiBerraAutograph
             *       end
             */
            Typecase(List<Binding> bind, List<TypecaseClause> clauses,
                     Option<Block> elseClause = Option.<Block>none());
            /**
             * while expression
             * DelimitedExpr ::= while Expr Do
             * e.g.) while x < 10 do print x; x += 1 end
             */
            While(Expr test, Do body);
        /**
         * control flow expression
         * Expr ::= FlowExpr
         */
        abstract FlowExpr();
            /**
             * summation and other reduction expression
             * FlowExpr ::= Accumulator ([ GeneratorClauseList ])? Expr
             * Accumulator ::= SUM | PRODUCT | Big Op
             * e.g.) PRODUCT[i <- 1:n] i
             */
            Accumulator(OpName opr, List<GeneratorClause> gens, Expr body);
            /**
             * array comprehension
             * Comprehension ::= [ ArrayComprehensionClause+ ]
             * e.g.) [(x, y, 1) |-> 0.0 | x <- 1:xSize, y <- 1:ySize ]
             */
            ArrayComprehension(List<ArrayComprehensionClause> clauses);
            /**
             * atomic expression
             * FlowExpr ::= atomic AtomicBack
             * AtomicBack ::= AssignExpr
             *              | OpExpr
             *              | DelimitedExpr
             * e.g.) atomic sum += a[i]
             */
            AtomicExpr(Expr expr);
            /**
             * exiting labeled expressions
             * FlowExpr ::= exit Id? (with Expr)?
             * e.g.) exit I_95 with x32B
             */
            Exit(Option<Id> target = Option.<Id>none(),
                 Option<Expr> returnExpr = Option.<Expr>none());
            /**
             * spawn expression
             * FlowExpr ::= spawn Expr
             * e.g.) spawn mm(lefttop, right, resulttop)
             */
            Spawn(Expr body);
            /**
             * throw expression
             * FlowExpr ::= throw Expr
             * e.g.) throw Error
             */
            Throw(Expr expr);
            /**
             * tryatomic expression
             * FlowExpr ::= tryatomic AtomicBack
             * e.g.) tryatomic sum += a[i]
             */
            TryAtomicExpr(Expr expr);
        /**
         * function expression
         * Expr ::= fn ValParam IsType? Throws? => Expr
         * e.g.) fn x => x + 2
         */
        FnExpr(ignoreForEquals Span span, // no default -- required to produce a fnName
               boolean parenthesized = false,
               SimpleName name = new AnonymousFnName(in_span),
               List<StaticParam> staticParams
                   = Collections.<StaticParam>emptyList(),
               List<Param> params,
               Option<Type> returnType = Option.<Type>none(),
               WhereClause where = FortressUtil.emptyWhereClause(),
               Option<List<TraitType>> throwsClause
                   = Option.<List<TraitType>>none(),
               Expr body)
              implements Applicable;
        /**
         * expression used in block expressions
         * BlockElem ::= LocalVarFnDecl
         *             | Expr(, GeneratorClauseList)?
         * LocalVarFnDecl ::= LocalFnDecl+
         *                  | LocalVarDecl
         */
        abstract LetExpr(List<Expr> body);
            /**
             * local function declaration
             * LocalFnDecl ::= LocalFnMods? NamedFnHeaderFront FnHeaderClause = Expr
             * e.g.) localFn(x: ZZ32) = x + 2
             */
            LetFn(List<FnDef> fns);
            /**
             * local variable declaration
             * LocalVarDecl ::= var? LocalVarWTypes InitVal
             *                | var? LocalVarWTypes
             *                | var? LocalVarWoTypes = Expr
             *                | var? LocalVarWoTypes : Type ... InitVal?
             *                | var? LocalVarWoTypes : SimpleTupleType InitVal?
             * LocalVarWTypes ::= LocalVarWType
             *                  | ( LocalVarWType(, LocalVarWType)+ )
             * LocalVarWType ::= BindId IsType
             * LocalVarWoTypes ::= LocalVarWoType
             *                   | ( LocalVarWoType(, LocalVarWoType)+ )
             * LocalVarWoType ::= BindId
             *                  | Unpasting
             * e.g.) localVar x = 3
             */
            LocalVarDecl(List<LValue> lhs,
                         Option<Expr> rhs = Option.<Expr>none());
        /**
         * generated expression
         * BlockElem ::= Expr(, GeneratorClauseList)?
         * e.g.) print (i " "), i <- sequential(1:5)
         */
        GeneratedExpr(Expr expr, List<GeneratorClause> gens);
        /**
         * expression that is simple or using operators
         * Expr ::= OpExpr
         */
        abstract OpExpr();
            /**
             * expression using operators (list of ops allows cross-API overloading)
             * OpExpr ::= EncloserOp OpExpr? EncloserOp?
             *          | OpExpr EncloserOp OpExpr?
             *          | Primary
             * EncloserOp ::= Encloser
             *              | Op
             * Primary ::= LeftEncloser ExprList? RightEncloser
             *           | Primary ^ BaseExpr
             *           | Primary ExponentOp
             * e.g.) 3 + 5
             */
            OprExpr(List<QualifiedOpName> ops,
                    List<Expr> args = Collections.<Expr>emptyList());
            /**
             * subscripting expression
             * SubscriptExpr ::= Primary LeftEncloser ExprList? RightEncloser
             * e.g.) a[i]
             */
            SubscriptExpr(Expr obj, List<Expr> subs,
                          Option<Enclosing> op = Option.<Enclosing>none())
                         implements LHS;
            /**
             * primary expression
             */
            abstract Primary();
                /**
                 * coercion invocation
                 * internal node created by static analysis
                 * after inferring the implicit coercion invocations
                 */
                CoercionInvocation(TraitType type,
                                   List<StaticArg> staticArgs
                                       = Collections.<StaticArg>emptyList(),
                                   Expr arg);
                /**
                 * a method invocation
                 * some are created by parsing, while others require later
                 * static analysis to disambiguate from function applications
                 */
                MethodInvocation(Expr obj, Id method,
                                 List<StaticArg> staticArgs
                                     = Collections.<StaticArg>emptyList(),
                                 Expr arg);
                /**
                 * field selection expression
                 * Primary ::= Primary . Id
                 * e.g.) Empty.length
                 */
                abstract AbstractFieldRef(Expr obj) implements LHS;
                    /**
                     * A field selection, unless it is a method reference
                     */
                    FieldRef(Id field);
                    /**
                     * A field selection, for sure.
                     * (though its implementation might be a getter/setter).
                     */
                    FieldRefForSure(Id field);
                    /**
                     * A rewritten field ref (not a getter/setter).
                     * also used to disambiguate lexical references to self/parent
                     * and within objectexprs to get access to outer scopes
                     * where the vars in the outer scopes may in turn have been
                     * API-qualified.
                     *
                     * If the reference to outer scope can be "fixed" (there is
                     * only one out scope) then it might be good to narrow this
                     * back down to an Id.
                     */
                    _RewriteFieldRef(Name field);

                /**
                 * juxtaposition of expressions
                 * Primary ::= Primary . Id ([\StaticArgList\])? Parenthesized
                 *           | Primary . Id ([\StaticArgList\])? ()
                 *           | Primary Parenthesized
                 *           | Primary ()
                 *           | Primary Primary
                 * e.g.) myString.replace("foo", "few")
                 * e.g.) log log n
                 */
                abstract Juxt(List<Expr> exprs);
                    /**
                     * juxtaposition with intervening whitespace
                     * e.g.) 3 5
                     */
                    LooseJuxt();
                    /**
                     * juxtaposition without intervening whitespace
                     * e.g.) f(3+5)
                     */
                    TightJuxt();
                /**
                 * primary expression without any dots
                 * MathPrimary ::= PrimaryFront MathItem*
                 */
                MathPrimary(Expr front, List<MathItem> rest);
                /**
                 * chain expression
                 * Certain infix mathematical operators that are traditionally
                 * regarded as relational operators, delivering boolean results,
                 * may be chained.
                 * e.g.) A SUBSETEQ B SUBSET C SUBSETEQ D
                 */
                ChainExpr(Expr first, List<Pair<Op, Expr>> links);
                /**
                 * expression with static instantiations
                 * list of ids allows cross-API overloading
                 * Primary ::= Id[\StaticArgList\]
                 * e.g.) identity[\String\]
                 */
                FnRef(List<QualifiedIdName> fns,
                      List<StaticArg> staticArgs
                          = Collections.<StaticArg>emptyList());

                /**
                 * The rewriting to explicitly name self and parent
                 * pre-interpretation may generalize the dotted
                 * list from a FnRef into something else.
                 */
                _RewriteFnRef(Expr fn,
                              List<StaticArg> staticArgs
                          = Collections.<StaticArg>emptyList());

                /**
                 * simple expression
                 * Primary ::= BaseExpr
                 */
                abstract BaseExpr();
                    /**
                     * variable reference
                     * BaseExpr ::= Id
                     *            | self
                     * e.g.) length
                     */
                    VarRef(QualifiedIdName var) implements LHS;
                    /**
                     * literal
                     * BaseExpr ::= LiteralExpr
                     */
                    abstract LiteralExpr(String text);
                        /**
                         * number literal
                         */
                        abstract NumberLiteralExpr();
                            /**
                             * float literal
                             * e.g.) 3.5
                             */
                            FloatLiteralExpr(ignoreForEquals String text,
                                             BigInteger intPart,
                                             BigInteger numerator, int denomBase,
                                             int denomPower);
                            /**
                             * int literal
                             * e.g.) 7
                             */
                            IntLiteralExpr(String text = in_val.toString(),
                                           BigInteger val);
                        /**
                         * char literal
                         * e.g.) 'c'
                         */
                        CharLiteralExpr(int val = in_text.charAt(0));
                        /**
                         * string literal
                         * e.g.) "string"
                         */
                        StringLiteralExpr();
                        /**
                         * void literal
                         * e.g.) ()
                         */
                        VoidLiteralExpr(String text = "");
                    /**
                     * array expression
                     * ArrayExpr ::= [ RectElements ]
                     * RectElements ::= Expr MultiDimCons*
                     * MultiDimCons ::= RectSeparator Expr
                     * RectSeparator ::= ;+
                     *                 | Whitespace
                     * e.g.) [1 2 3; 4 5 6; 7 8 9]
                     */
                    abstract ArrayExpr();
                        /**
                         * array with a single element
                         * e.g.) [3]
                         */
                        ArrayElement(Expr element);
                        /**
                         * array with multiple elements
                         * e.g.) [3 4 5; 6 7 8]
                         */
                        ArrayElements(int dimension, List<ArrayExpr> elements);
    /**
     * type
     * Type ::= ArrowType
     *        | NonArrowType
     */
    abstract Type(boolean parenthesized = false);
        /**
         * arrow type
         * ArrowType ::= NonArrowType -> NonArrowType Throws?
         * e.g.) (String, NN..., p = Printer) -> NN throws IOException
         */
        ArrowType(Type domain, Type range,
                  Option<List<Type>> throwsClause,
                  boolean io = false);
            /**
             * type of a generic function, used during static checking
             */
            _RewriteGenericArrowType(List<StaticParam> staticParams
                                      = Collections.<StaticParam>emptyList(),
                                     WhereClause where
                                      = FortressUtil.emptyWhereClause());
        /**
         * nonarrow type
         */
        abstract NonArrowType();
            BottomType();
            /**
             * trait type
             */
            abstract TraitType();
                /**
                 * array type
                 * TraitType ::= Type [ ArraySize? ]
                 * e.g.) ZZ64[3, 2]
                 */
                ArrayType(Type element, Indices indices);
                /**
                 * type name
                 * TraitType ::= QualifiedName
                 * e.g.) T
                 */
                IdType(QualifiedIdName name);

                InferenceVarType(Object id);
                /**
                 * matrix type
                 * TraitType ::= Type ^ StaticArg
                 *             | Type ^ ( ExtentRange (BY ExtentRange)* )
                 * e.g.)
                 */
                MatrixType(Type element, List<ExtentRange> dimensions);
                /**
                 * instantiated type
                 * TraitType ::= QualifiedName [\StaticArgList\]
                 * e.g.) List[\ZZ32\]
                 */
                InstantiatedType(QualifiedIdName name, List<StaticArg> args);
            /**
             * tuple type
             * TupleType ::= ( (Type, )* (Type ... ,)? KeywordType(, KeywordType)* )
             *             | ( (Type, )*  Type ... )
             *             | SimpleTupleType
             * SimpleTupleType ::= ( Type, TypeList )
             * e.g.)
             */
            TupleType(List<Type> elements,
                      Option<VarargsType> varargs = Option.<VarargsType>none(),
                      List<KeywordType> keywords
                          = Collections.<KeywordType>emptyList());
            /**
             * void type
             * NonArrowType ::= ()
             * e.g.) ()
             */
            VoidType();

            IntersectionType(Set<Type> elements);
            UnionType(Set<Type> elements);
            AndType(Type first, Type second);
            OrType(Type first, Type second);
            /**
             * dimension type
             */
            abstract DimType(Type type);
                /**
                 * type with dimension
                 * DimType ::= Type DimExpr (in Expr)?
                 * e.g.) RR64 Length
                 */
                TaggedDimType(DimExpr dim, Option<Expr> unit);
                /**
                 * type with unit
                 * DimType ::= Type Expr
                 * e.g.) RR64 meter
                 */
                TaggedUnitType(Expr unit);
        /**
         * static argument
         */
        abstract StaticArg();
            /**
             * identifier used as static argument
             * StaticArg ::= QualifiedName
             * e.g.) m
             */
            IdArg(QualifiedIdName name);
            /**
             * type used as static argument
             * StaticArg ::= Type
             * e.g.) List[\ZZ64\]
             */
            TypeArg(Type type);
            /**
             * integer used as static argument
             * StaticArg ::= IntExpr
             * e.g.) m + n
             */
            IntArg(IntExpr val);
            /**
             * boolean used as static argument
             * StaticArg ::= BoolExpr
             * e.g.) ninf OR pinf
             */
            BoolArg(BoolExpr bool);
            /**
             * operator used as static argument
             * StaticArg ::= Op
             * e.g.) +
             */
            OprArg(Op name);
            /**
             * dimension used as static argument
             * StaticArg ::= DimExpr
             * e.g.) Unity
             */
            DimArg(DimExpr dim);
            /**
             * unit used as static argument
             * StaticArg ::= Expr
             * e.g.) dimensionless
             */
            UnitArg(Expr unit);
        /**
         * a fresh type variable, used by type inference
         */
        _RewriteImplicitType();
        /**
         * intersection type, used during static checking
         */
        _RewriteIntersectionType(List<Type> elements);
        /**
         * union type, used during static checking
         */
        _RewriteUnionType(List<Type> elements);
        /**
         * fixed point (a.k.a. "mu") type, used during witness finding
         */
        _RewriteFixedPointType(_RewriteImplicitType var, Type body);

    /**
     * static expression
     */
    abstract StaticExpr(boolean parenthesized = false);
        /**
         * integer expression
         * StaticExpr ::= IntExpr
         */
        abstract IntExpr();
            /**
             * integer value
             * IntExpr ::= IntVal
             */
            abstract IntVal();
                /**
                 * integer number
                 * IntVal ::= IntLiteralExpr
                 * e.g.) 8
                 */
                NumberConstraint(IntLiteralExpr val);
                /**
                 * integer identifier
                 * IntVal ::= QualifiedName
                 * e.g.) m
                 */
                IntRef(QualifiedIdName name);
            /**
             * integer expression with an operator
             */
            abstract IntOpExpr(IntExpr left, IntExpr right);
                /**
                 * integer addition
                 * IntExpr ::= IntExpr + IntExpr
                 * e.g.) m + 2
                 */
                SumConstraint();
                /**
                 * integer subtraction
                 * IntExpr ::= IntExpr - IntExpr
                 * e.g.) m - 2
                 */
                MinusConstraint();
                /**
                 * integer multiplication
                 * IntExpr ::= IntExpr IntExpr
                 *           | IntExpr DOT IntExpr
                 * e.g.) m DOT n
                 */
                ProductConstraint();
                /**
                 * integer exponentiation
                 * IntExpr ::= IntExpr caret IntVal
                 * e.g.) 2^b
                 */
                ExponentConstraint();
        /**
         * boolean expression
         * StaticExpr ::= BoolExpr
         */
        abstract BoolExpr();
            /**
             * boolean value
             * BoolExpr ::= BoolVal
             */
            abstract BoolVal();
                /**
                 * boolean constant
                 * BoolVal ::= true | false
                 * e.g.) true
                 */
                BoolConstant(boolean bool);
                /**
                 * boolean identiier
                 * BoolVal ::= QualifiedName
                 * e.g.) ninf
                 */
                BoolRef(QualifiedIdName name);
            /**
             * boolean constraint
             * BoolExpr ::= BoolConstraint
             */
            abstract BoolConstraint();
                /**
                 * boolean NOT constraint
                 * BoolConstraint ::= NOT BoolExpr
                 * e.g.) NOT ninf
                 */
                NotConstraint(BoolExpr bool);
                /**
                 * binary boolean constraint
                 * e.g.) ninf OR pinf
                 */
                abstract BinaryBoolConstraint(BoolExpr left, BoolExpr right);
                    /**
                     * boolean OR constraint
                     * BoolConstraint ::= BoolExpr OR BoolExpr
                     * e.g.) ninf OR pinf
                     */
                    OrConstraint();
                    /**
                     * boolean AND constraint
                     * BoolConstraint ::= BoolExpr AND BoolExpr
                     * e.g.) ninf AND pinf
                     */
                    AndConstraint();
                    /**
                     * boolean IMPLIES constraint
                     * BoolConstraint ::= BoolExpr IMPLIES BoolExpr
                     * e.g.) ninf IMPLIES pinf
                     */
                    ImpliesConstraint();
                    /**
                     * boolean equality constraint
                     * BoolConstraint ::= BoolExpr = BoolExpr
                     * e.g.) ninf AND pinf = true
                     */
                    BEConstraint();
        /**
         * dimension expression
         */
        abstract DimExpr();
            /* base dimension
             * DimExpr ::= Unity
             * e.g.) Unity
             */
            BaseDim();
            /* dimension identifier
             * DimExpr ::= QualifiedName
             * e.g.) com.sun.fortress.dim.Length
             */
            DimRef(QualifiedIdName name);
            /* dimension multiplication
             * DimExpr ::= DimExpr DOT DimExpr
             *           | DimExpr DimExpr
             * e.g.) Length Mass
             */
            ProductDim(DimExpr multiplier, DimExpr multiplicand);
            /* dimension division
             * DimExpr ::= DimExpr / DimExpr
             *           | DimExpr per DimExpr
             *           | 1 / DimExpr
             * e.g.) Length / Time
             */
            QuotientDim(DimExpr numerator, DimExpr denominator);
            /* dimension exponentiation
             * DimExpr ::= DimExpr ^ IntLiteralExpr
             * e.g.) Time^2
             */
            ExponentDim(DimExpr base, IntLiteralExpr power);
            /* dimension with operator
             * DimExpr ::= DUPreOp DimExpr
             *           | DimExpr DUPostOp
             * e.g.) Time squared
             */
            OpDim(DimExpr val, DimUnitOp op);
    /**
     * where clause used in trait, object, and functional declarations
     * Where ::= where [\ WhereBindingList \] ({ WhereConstraintList })?
     *         | where { WhereConstraintList }
     * e.g.) where { ninf AND NOT nan }
     */
    WhereClause(List<WhereBinding> bindings
                    = Collections.<WhereBinding>emptyList(),
                List<WhereConstraint> constraints
                    = Collections.<WhereConstraint>emptyList());
    /**
     * hidden type variable binding declared in where clauses
     */
    abstract WhereBinding();
        /**
         * hidden type variable declared in where clauses
         * WhereBinding ::= Id Extends?
         * Extends ::= extends TraitTypes
         * e.g.) T extends Object
         */
        WhereType(Id name, List<TraitType> supers);
        /**
         * nat parameter declared in where clauses
         * WhereBinding ::= nat Id
         * e.g.) nat length
         */
        WhereNat(Id name);
        /**
         * int parameter declared in where clauses
         * WhereBinding ::= int Id
         * e.g.) int length
         */
        WhereInt(Id name);
        /**
         * bool parameter declared in where clauses
         * WhereBinding ::= bool Id
         * e.g.) bool ninf
         */
        WhereBool(Id name);
        /**
         * unit parameter declared in where clauses
         * WhereBinding ::= unit Id
         * e.g.) unit U
         */
        WhereUnit(Id name);
    /**
     * hidden type variable constraint declared in where clauses
     */
    abstract WhereConstraint();
        /**
         * type variable constraint declared in where clauses
         * WhereConstraint ::= Id Extends
         * e.g.) T extends Object
         */
        WhereExtends(Id name, List<TraitType> supers);
        /**
         * type alias declaration
         * TypeAlias ::= type Id StaticParams? = Type
         * e.g.) type IntList = List[\ZZ64\]
         */
        TypeAlias(Id name,
                  List<StaticParam> staticParams
                      = Collections.<StaticParam>emptyList(),
                  Type type)
                 implements Decl, AbsDecl;
        /**
         * coercion constraint declared in where clauses
         * WhereConstraint ::= Type coerces Type
         * e.g.) T coerces Identity[\ODOT\]
         */
        WhereCoerces(Type left, Type right);
        /**
         * widening constraint declared in where clauses
         * WhereConstraint ::= Type widens Type
         * e.g.) T widens S
         */
        WhereWidens(Type left, Type right);
        /**
         * widening coercion constraint declared in where clauses
         * CoercionWhereConstraint ::= Type widens or coerces Type
         * e.g.) T widens or coerces S
         */
        WhereWidensCoerces(Type left, Type right);
        /**
         * DootedId equality constraint declared in where clauses
         * WhereConstraint ::= QualifiedName = QualifiedName
         * e.g.) m = n
         */
        WhereEquals(QualifiedIdName left, QualifiedIdName right);
        /**
         * unit constraint used in where clauses
         * WhereConstraint ::= dimensionless = Id
         *               | Id = dimensionless
         * e.g.) U = dimensionless
         */
        UnitConstraint(Id name);
        /**
         * integer constraint used in where clauses
         * WhereConstraint ::= IntConstraint
         */
        abstract IntConstraint(IntExpr left, IntExpr right);
            /**
             * less than equal constraint declared in where clauses
             * IntConstraint ::= IntExpr <= IntExpr
             * e.g.) b <= c
             */
            LEConstraint();
            /**
             * less than constraint declared in where clauses
             * IntConstraint ::= IntExpr < IntExpr
             * e.g.) 0 < a
             */
            LTConstraint();
            /**
             * greater than equal constraint declared in where clauses
             * IntConstraint ::= IntExpr >= IntExpr
             * e.g.) b >= c
             */
            GEConstraint();
            /**
             * greater than constraint declared in where clauses
             * IntConstraint ::= IntExpr > IntExpr
             * e.g.) a > 0
             */
            GTConstraint();
            /**
             * integer equality constraint declared in where clauses
             * IntConstraint ::= IntExpr = IntExpr
             * e.g.) 8 = 2^3
             */
            IEConstraint();
        /**
         * boolean constraint declared in where clauses
         * WhereConstraint ::= BoolConstraint
         * e.g.) pinf AND ninf
         */
        BoolConstraintExpr(BoolConstraint constraint);
    /**
     * contracts used in functional declarations and object declarations
     * Contract ::= Requires? Ensures? Invariant?
     * Requires ::= requires { ExprList? }
     * Ensures ::= ensures { EnsuresClauseList? }
     * Invariant ::= invariant { ExprList? }
     * CoercionContract ::= Ensures? Invariant?
     * e.g.) requires { n GE 0 } ensures { result GE 0 }
     */
    Contract(Option<List<Expr>> requires = Option.<List<Expr>>none(),
             Option<List<EnsuresClause>> ensures =
                 Option.<List<EnsuresClause>>none(),
             Option<List<Expr>> invariants = Option.<List<Expr>>none());
    /**
     * ensures clause used in contracts
     * EnsuresClause ::= Expr (provided Expr)?
     * e.g.) sorted(result) provided sorted(input)
     */
    EnsuresClause(Expr post, Option<Expr> pre = Option.<Expr>none());
    /**
     * modifier
     * TraitMod      ::= AbsTraitMod | private
     * AbsTraitMod   ::= value | test
     * ObjectMods    ::= TraitMods
     * AbsObjectMods ::= AbsTraitMods
     * MdMod         ::= FnMod | override
     * AbsMdMod      ::= AbsFnMod | override
     * FnMod         ::= AbsFnMod | private
     * AbsFnMod      ::= LocalFnMod | test
     * LocalFnMod    ::= atomic | io
     * ParamFldMod   ::= var | hidden | settable | wrapped
     * VarMod        ::= AbsVarMod | private
     * AbsVarMod     ::= var | test
     * FldMod        ::= var | AbsFldMod
     * AbsFldMod     ::= ApiFldMod | wrapped | private
     * ApiFldMod     ::= hidden | settable | test
     */
    abstract Modifier();
        /**
         * e.g.) abstract m(x: ZZ32): ()
         */
        ModifierAbstract();
        /**
         * e.g.) atomic f(x: ZZ32): ()
         */
        ModifierAtomic();
        /**
         * e.g.) getter velocity(): (RR Velocity)^3
         */
        ModifierGetter();
        /**
         * e.g.) hidden x: ZZ32
         */
        ModifierHidden();
        /**
         * e.g.) io print(s: String): ()
         */
        ModifierIO();
        /**
         * e.g.) override m(x: ZZ32): ()
         */
        ModifierOverride();
        /**
         * e.g.) private f(): ()
         */
        ModifierPrivate();
        /**
         * e.g.) settable message: Maybe[\String\]
         */
        ModifierSettable();
        /**
         * e.g.) setter velocity(v: (RR Velocity)^3): ()
         */
        ModifierSetter();
        /**
         * e.g.) test object TestSuite(testFunctions = {}) end
         */
        ModifierTest();
        /**
         * e.g.) object O(transient x: ZZ32) end
         */
        ModifierTransient();
        /**
         * e.g.) value object IntEmpty extends List[\ZZ32\] end
         */
        ModifierValue();
        /**
         * e.g.) var x: ZZ32
         */
        ModifierVar();
        /**
         * e.g.) coerce (x: RR32) widens = ...
         */
        ModifierWidens();
        /**
         * e.g.) wrapped val: Dictionary[\T\]
         */
        ModifierWrapped();
    /**
     * static parameter
     */
    abstract StaticParam();
        /**
         * operator parameter
         * StaticParam ::= opr Op
         * e.g.) opr ODOT
         */
        OperatorParam(Op name);
        /**
         * static parameter with a name field of type Id
         */
        abstract IdStaticParam(Id name);
           /**
            * bool parameter
            * StaticParam ::= bool Id
            * e.g.) bool nan
            */
            BoolParam();
           /**
            * dimension parameter
            * StaticParam ::= dim Id
            * e.g.) dim D
            */
            DimensionParam();
           /**
            * int parameter
            * StaticParam ::= int Id
            * e.g.) int i
            */
            IntParam();
           /**
            * nat parameter
            * StaticParam ::= nat Id
            * e.g.) nat len
            */
            NatParam();
           /**
            * type parameter
            * StaticParam ::= Id Extends? (absorbs unit)?
            * e.g.) EltType extends Number absorbs unit
            */
            SimpleTypeParam(List<TraitType> extendsClause =
                                Collections.<TraitType>emptyList(),
                            boolean absorbs = false);
           /**
            * unit parameter
            * StaticParam ::= unit Id (: DimExpr)? (absorbs unit)?
            * e.g.) unit U absrbs unit
            */
            UnitParam(Option<DimExpr> dim = Option.<DimExpr>none(),
                      boolean absorbs = false);
    /**
     * name used in declarations and references
     */
    abstract Name();
        /**
         * unstructured sequence of ids naming an API or component
         * APIName ::= Id(.Id)*
         * e.g.) com.sun.fortress.nodes_util
         */
        APIName(List<Id> ids);
        /**
         * name prefixed by an optional API name
         */
        abstract QualifiedName(Option<APIName> api = Option.<APIName>none(),
                               SimpleName name);
            /**
             * qualified id name
             * QualifiedName ::= Id(.Id)*
             * e.g.) com.sun.fortress.nodes_util.getName
             */
            QualifiedIdName(Id name);
            /**
             * qualified operator name
             * internal uses only
             * e.g.) com.sun.fortress.nodes_util.+
             */
            QualifiedOpName(OpName name);
        /**
         * unqualified name
         * SimpleName ::= Id
         *              | opr Op
         *              | opr EncloserPair
         */
        abstract SimpleName();
            /**
             * unqualified identifier
             * e.g.) hashCode
             */
            Id(String text);
            /**
             * unqualified operator name
             */
            abstract OpName();
                /**
                 * non-enclosing operator
                 * e.g.) COMPOSE
                 * e.g.) ===
                 */
                Op(String text, boolean postfix = false);
                /**
                 * pair of enclosing operators
                 * EncloserPair ::= (LeftEncloser | Encloser)
                 *                    (RightEncloser | Encloser)
                 * e.g.) </ />
                 */
                Enclosing(Op open, Op close);
            /**
             * internal name for anonymous function expressions
             * not created during parsing but during evaluation
             * e.g.) name for "fn x => x + 1"
             */
            AnonymousFnName();
            /**
             * internal name for anonymous constructor expressions
             * not created during parsing but during evaluation
             * e.g.) name for "object extends List cons(x) = Cons(x, self) end"
             */
            ConstructorFnName(GenericWithParams def);
    /**
     * array comprehension clause
     * ArrayComprehensionClause ::= ArrayComprehensionLeft | GeneratorClauseList
     * ArrayComprehensionLeft ::= IdOrInt |-> Expr
     *                          | ( IdOrInt, IdOrIntList ) |-> Expr
     * IdOrInt ::= Id
     *           | IntLiteralExpr
     * e.g.) (x, y) = 0 | x <- {0, 1, 2}, y <- {0, 1, 2}
     */
    ArrayComprehensionClause(List<Expr> bind, Expr init,
                             List<GeneratorClause> gens);
    /**
     * binding used in tuple expressions and typecase expressions
     * Binding ::= BindId = Expr
     * e.g.) x = myLoser.myField
     */
    Binding(Id name, Expr init);
    /**
     * case clause used in case expressions and extremum expressions
     * CaseClause ::= Expr => BlockElems
     * e.g.) { Jupiter, Saturn, Uranus, Neptune } => "outer"
     */
    CaseClause(Expr match, Block body);
    /**
     * catch clause used in try expressions
     * Catch ::= catch BindId CatchClauses
     * e.g.) catch e IOException => throw ForbiddenException(e)
     */
    Catch(Id name, List<CatchClause> clauses);
    /**
     * each clause in a catch clause used in try expressions
     * CatchClause ::= TraitType => BlockElems
     * e.g.) IOException => throw ForbiddenException(e)
     */
    CatchClause(TraitType match, Block body);
    /**
     * block expression used in do expressions
     * DoFront ::= (at Expr)? atomic? do BlockElems?
     * e.g.) at a.region(j) do w := a_j
     */
    DoFront(Option<Expr> loc = Option.<Expr>none(), boolean atomic = false,
            Block expr);
    /**
     * if clause used in if expressions
     * DelimitedExpr ::= if Expr then BlockElems Elifs? Else? end
     * Elif ::= elif Expr then BlockElems
     * e.g.) if x IN { 0, 1, 2 } then 0
     */
    IfClause(Expr test, Block body);
    /**
     * typecase clause used in typecase expressions
     * TypecaseClause ::= TypecaseTypes => BlockElems
     * TypecaseTypes ::= ( TypeList )
     *                 | Type
     * e.g.) String => x.append("foo")
     */
    TypecaseClause(List<Type> match, Block body);
    /**
     * array and matrix size
     * ExtentRange ::= StaticArg? # StaticArg?
     *               | StaticArg? : StaticArg?
     *               | StaticArg
     * e.g.) 3#5
     */
    ExtentRange(Option<StaticArg> base, Option<StaticArg> size);
    /**
     * generator
     * GeneratorClauseList ::= GeneratorBinding (, GeneratorClause)*
     * GeneratorBinding ::= BindIdOrBindIdTuple <- Expr
     * GeneratorClause ::= GeneratorBinding
     *                   | Expr
     * e.g.) (i, j) <- my2DArray.indices
     */
    GeneratorClause(List<Id> bind, Expr init);
    /**
     * varargs expression used in tuple expressions
     * Expr...
     * e.g.) [3 4 5]...
     */
    VarargsExpr(Expr varargs);
    /**
     * varargs type used in tuple types and varargs parameters
     * Type ...
     * e.g.) ZZ32...
     */
    VarargsType(Type type);
    /**
     * keyword type used in tuple types
     * KeywordType ::= BindId = Type
     * e.g.) x = String
     */
    KeywordType(Id name, Type type);
    /**
     * trait type with a where clause used in extends clauses
     * TraitTypeWhere ::= TraitType Where?
     */
    TraitTypeWhere(TraitType type, WhereClause where);
    /**
     * array dimensionality
     * ArraySize ::= ExtentRange(, ExtentRange)*
     * e.g.) 3, 2#1, 3:5
     */
    Indices(List<ExtentRange> extents);
    /**
     * operator on dimensions and units
     * DUPreOp ::= square | cubic | inverse
     * DUPostOp ::= squared | cubed
     */
    abstract DimUnitOp();
        /**
         * e.g.) second squared
         */
        SquareDimUnit();
        /**
         * e.g.) cubic centimeter
         */
        CubicDimUnit();
        /**
         * e.g.) inverse ohms
         * e.g.) grams per cubic centimeter
         */
        InverseDimUnit();
    /**
     * mathematical item
     */
    abstract MathItem();
        /**
         * mathematical item that is an expression element
         */
        abstract ExprMI(Expr expr);
            /**
             * mathematical item that is a parenthesis delimited expression
             * MathItem ::= ParenthesisDelimited
             */
            ParenthesisDelimitedMI();
            /**
             * mathematical item that is not a parenthesis delimited expression
             * MathItem ::= VarOrFnRef
             *            | LiteralExpr
             *            | self
             */
            NonParenthesisDelimitedMI();
        /**
         * mathematical item that is a non-expression element
         */
        abstract NonExprMI();
            /**
             * mathematical item that is an exponentiation
             * MathItem ::= Exponentiation
             */
            ExponentiationMI(Op op, Option<Expr> expr);
            /**
             * mathematical item that is a subscripting
             * MathItem ::= Subscripting
             */
            SubscriptingMI(Enclosing op, List<Expr> exprs);
end;
