(*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component aStar

import Heap.{...}
import ArrayList.{...}
export Executable

(** To perform a search, define an object containing the search state.
    This object must extend SearchInstance[\Cost\] for some
    totally-ordered type Cost.  We're searching for a min-cost solution.
    Example instantiations for Cost are ZZ32 and RR64 (disallowing NaN).

    The AStar code asks a SearchInstance to generate its children.
    You must write either the children() method, or the generate()
    method; in either case the SearchInstances can (should) be
    generated in parallel, and you should make sure that more than one
    SearchInstance can exist at a time.

    For example, if you're using this to solve something like Sudoku,
    you'd want the children() to represent distinct Sudoku boards,
    rather than updating a single board in place.  You can do this
    either by copying the board state or by using some kind of
    updatable board data structure.
 **)

trait SearchInstance[\Self extends SearchInstance[\Cost\],
                      Cost (* extends StandardTotalOrder[\Cost\] *)\]
        extends Generator[\Self\]
    (** isComplete() returns true if no further searching is possible
        from this point, and returns false if further searching is
        required. **)
    getter isComplete(): Boolean

    (** cost returns an estimate of the *total* cost of this search
        instance from start to finish (note: NOT the cost from this
        point to the final solution, but the total cost from the start
        of time).  When isComplete() is true this should give the
        precise cost. **)
    getter cost(): Cost

    (** children() returns the children of this particular search
        state.  If you wish to generate the children in parallel, you
        should use a parallel generator.  If isComplete() is true,
        this probably ought to return an empty generator.  If you
        write the children() getter you do not need to write the
        generate() method.  **)
    getter children(): Generator[\Self\] = self

    (** If you don't write the children() getter you should write the
        generate() method. **)
    generate[\R\](r: Reduction[\R\], body: Self->R): R =
        children().generate[\R\](r,body)
end

aStarPair[\T extends SeachInstance[\T,C\],C\](a:T):(C,T) = (a.cost(),a)

(** Perform an A* search starting from root. **)
aStar[\T extends SearchInstance[\T,C\],C\](root: T): Maybe[\T\] =
    label succeed
        q : Pairing[\C,T\] := singletonPairing[\C,T\](aStarPair[\T,C\](root))
        while NOT q.isEmpty() do
            (_,best,q') = q.extractMin()
            println("Chose:\n" best)
            if best.isComplete() then
                exit succeed with Just(best)
            end
            println("************************************************************")
            q := q'.merge(heap(best.children().map[\(C,T)\](aStarPair[\T,C\])))
            println("**")
        end
        Nothing[\T\]() (** If we get here the search failed. **)
    end succeed

(************************************************************
 * Sample problem
 ************************************************************)

trait BoardState
        comprises { No, Perhaps, Yes }
    getter cand(): Boolean = true
    getter propagated(): Boolean = false
end

object No extends BoardState
    getter cand(): Boolean = false
end

object Perhaps extends BoardState end

object Yes extends BoardState
    getter propagated(): Boolean = true
end

(* Stupid, really inefficient but complete Sudoku solver.  We maintain
   a 9x9x9-space of booleans: Perhaps or Yes at (i,j,k) indicates that k
   is a candidate value for point (i,j) in the Sukoku grid.  The cost
   metric is Perhaps entries + 9 Yes entries.  A step consists of
   choosing one Perhaps entry to propagate and set to Yes.  Infeasible
   solutions are pruned.  However, we don't do full forward
   propagation, and we don't cache information about solvedness, so
   this is MASSIVELY SLOW. *)
object Sudoku(cands : ZZ32, props : ZZ32, state : Array3[\BoardState,0,9,0,9,0,9\])
        extends SearchInstance[\Sudoku, ZZ32\]
    (* legalState check is expensive, so we compute it lazily and cache the result. *)
    consistent : BoardState := Perhaps
    getter isConsistent(): Boolean =
        if NOT consistent.cand() then false
        elif consistent.propagated() then true
        elif cands < 81 then
            consistent := No
            false
        elif legalState(state) then
            consistent := Yes
            true
        else
            consistent := No
            false
        end
    getter cost(): ZZ32 = cands - props
    getter isComplete(): ZZ32 = cands = 81 AND: isConsistent()
    getter toString(): String =
        (BIG STRING [i<-0#9] (
             BIG STRING [j<-0#9] (
                 (BIG STRING [k<-0#9] if state[i,j,k].propagated() then "" (k+1)
                                      elif state[i,j,k].cand() then "."
                                      else " " end) "|")
             ) "\n") "Remaining: " cands " Fixed: " props
    getter children(): Generator[\Sudoku\] =
        if isConsistent() then
            incons : Sudoku = Sudoku(inconsistent,props+1,state)
            <|  if c.cand() AND NOT c.propagated() then
                    state' = state.copy()
                    delta = fillState(state',ijk)
                    cd = cands - delta
                    if delta > 0 AND: cd >= 81 then
                        (* Note: we permit inconsistent states to get through,
                           and just live with it. *)
                        println("Trying " ijk)
                        Sudoku(cd,props+1,state')
                    else
                        println("Skipping " ijk)
                        incons
                    end
                else
                    incons
                end
              | (ijk,c) <- state.indexValuePairs() |>.filter(
                    fn (s:Sudoku): Boolean => cands < inconsistent)
        else
            emptyList[\Sudoku\]()
        end
end

inconsistent : ZZ32 = 2^30

legalState(state:Array3[\BoardState,0,9,0,9,0,9\]): Boolean =
    (BIG AND [i<-0#9,j<-0#9] (BIG OR [k<-0#9] state[i,j,k].cand())) AND
    (BIG AND [i<-0#9,k<-0#9] (BIG OR [j<-0#9] state[i,j,k].cand())) AND
    (BIG AND [j<-0#9,k<-0#9] (BIG OR [i<-0#9] state[i,j,k].cand())) AND
    (BIG AND [i0<-0#3,j0<-0#3,k<-0#9]
          (BIG OR [i<- (3 i0)#3,j<-(3 j0)#3] state[i,j,k].cand()))

(* fillState modifies the state array by committing to i,j,k,
   and returns the number of entries that changed. *)
fillState(state:Array3[\BoardState,0,9,0,9,0,9\],ijk:(ZZ32,ZZ32,ZZ32)):ZZ32 = do
    state[ijk] := Yes
    (i,j,k) = ijk
    (SUM [i' <- 0#9]
        if i =/= i' AND state[i',j,k].cand() then
            state[i',j,k] := No
            1
        else 0 end) +
    (SUM [j' <- 0#9]
        if j =/= j' AND state[i,j',k].cand() then
            state[i,j',k] := No
            1
        else 0 end) +
    (SUM [k' <- 0#9]
        if k =/= k' AND state[i,j,k'].cand() then
            state[i,j,k'] := No
            1
        else 0 end) +
    (SUM [i' <- (3 (i DIV 3))#3, j' <- (3 (j DIV 3))#3]
        if (i'=/=i AND j'=/=j) AND state[i',j',k].cand() then
                state[i',j',k] := No
                1
        else 0 end)
  end

sudoku(givens:(ZZ32,ZZ32,ZZ32)...): Sudoku = do
    st0 = array3[\BoardState,9,9,9\]().fill(Perhaps)
    for (i,j,k) <- givens do
        _ = fillState(st0,(i-1,j-1,k-1))
    end
    res = Sudoku(SUM [v<-st0] if v.cand() then 1 else 0 end,
                 SUM [v<-st0] if v.propagated() then 1 else 0 end,
                 st0)
    if legalState(st0) then
        res
    else
        fail("Bad initial state:\n" res)
    end
  end

run(args:String...):()=do
    init = sudoku((1,1,8),(1,3,6),(1,4,1),(1,6,9),(1,7,3),(1,9,5),
                  (2,2,9),(2,5,8),(2,7,4),
                  (3,2,7),(3,3,1),(3,9,6),
                  (4,4,9),(4,5,2),(4,7,5),(4,8,3),
                  (5,3,9),(5,5,6),(5,7,7),
                  (6,2,3),(6,3,4),(6,5,7),(6,6,8),
                  (7,1,3),(7,7,1),(7,8,4),
                  (8,3,5),(8,5,1),(8,8,9),
                  (9,1,9),(9,3,7),(9,4,8),(9,6,4),(9,7,6),(9,9,2))
    println("Here's the initial:\n")
    res = aStar[\Sudoku,ZZ32\](init)
    println("Final result:\n" res)
end

end
