(*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component aStar

import Heap.{...}
import ArrayList.{...}
export Executable

(** To perform a search, define an object containing the search state.
    This object must extend SearchInstance[\Cost\] for some
    totally-ordered type Cost.  We're searching for a min-cost solution.
    Example instantiations for Cost are ZZ32 and RR64 (disallowing NaN).

    The AStar code asks a SearchInstance to generate its children.
    You must write either the children() method, or the generate()
    method; in either case the SearchInstances can (should) be
    generated in parallel, and you should make sure that more than one
    SearchInstance can exist at a time.

    For example, if you're using this to solve something like Sudoku,
    you'd want the children() to represent distinct Sudoku boards,
    rather than updating a single board in place.  You can do this
    either by copying the board state or by using some kind of
    updatable board data structure.
 **)

trait SearchInstance[\Self extends SearchInstance[\Cost\],
                      Cost (* extends StandardTotalOrder[\Cost\] *)\]
        extends Generator[\Self\]
    (** isComplete() returns true if no further searching is possible
        from this point, and returns false if further searching is
        required. **)
    getter isComplete(): Boolean

    (** cost returns an estimate of the *total* cost of this search
        instance from start to finish (note: NOT the cost from this
        point to the final solution, but the total cost from the start
        of time).  When isComplete() is true this should give the
        precise cost. **)
    getter cost(): Cost

    (** children() returns the children of this particular search
        state.  If you wish to generate the children in parallel, you
        should use a parallel generator.  If isComplete() is true,
        this probably ought to return an empty generator.  If you
        write the children() getter you do not need to write the
        generate() method.  **)
    getter children(): Generator[\Self\] = self

    (** If you don't write the children() getter you should write the
        generate() method. **)
    generate[\R\](r: Reduction[\R\], body: Self->R): R =
        children().generate[\R\](r,body)
end

aStarPair[\T extends SeachInstance[\T,C\],C\](a:T):(C,T) = (a.cost(),a)

(** Perform an A* search starting from root. **)
aStar[\T extends SearchInstance[\T,C\],C\](root: T): Maybe[\T\] =
    label succeed
        q : Pairing[\C,T\] := singletonPairing[\C,T\](aStarPair[\T,C\](root))
        while NOT q.isEmpty() do
            (_,best,q') = q.extractMin()
            if best.isComplete() then
                exit succeed with Just(best)
            end
            println("************************************************************")
            q := q'.merge(heap(best.children().map(aStarPair[\T,C\])))
            println("**")
        end
        Nothing[\T\]() (** If we get here the search failed. **)
    end succeed

(************************************************************
 * Sample problem
 ************************************************************)

(* Stupid, really inefficient but complete Sudoku solver.  We maintain
   a 9x9x9-space of booleans: T at (i,j,k) indicates that k is a
   candidate value for point (i,j) in the Sukoku grid.  The cost
   metric is the number of T entries remaining in the grid.  A step
   consists of setting one T entry to F.  Infeasible solutions are
   pruned.  However, we don't do full forward propagation, and we
   don't cache information about solvedness, so this is MASSIVELY
   SLOW. *)
object Sudoku(trues : ZZ32, state : Array3[\Boolean,0,9,0,9,0,9\])
        extends SearchInstance[\Sudoku, ZZ32\]
    getter cost(): ZZ32 = trues
    getter isComplete(): ZZ32 = trues = 81
    getter toString(): String =
        (BIG STRING [i<-0#9] (
             BIG STRING [j<-0#9] (
                 (BIG STRING [k<-0#9] if state[i,j,k] then "" (k+1) else " " end) ".")
             ) "\n") "Remaining: " trues
    getter children(): Generator[\Sudoku\] = do
        incons : Sudoku = Sudoku(inconsistent,state)
        <| if c then
                state0 : Array3[\Boolean,0,9,0,9,0,9\] = state.replica[\ZZ32\]()
                state' = state0.fill(fn (ijk':(ZZ32,ZZ32,ZZ32)): Boolean => state[ijk'])
                delta = fillState(state',ijk)
                td = trues - delta
                if delta > 0 AND: td >= 81 AND: legalState(state') then
                    println("Trying " ijk)
                    Sudoku(td,state')
                else
                    println("Skipping " ijk)
                    incons
                end
            else
                incons
            end
          | (ijk,c) <- state.indexValuePairs() |>.filter(
                fn (s:Sudoku): Boolean => s.cost() < inconsistent)
      end
end

inconsistent : ZZ32 = 2^30

legalState(state:Array3[\Boolean,0,9,0,9,0,9\]): Boolean =
    (BIG AND [i<-0#9,j<-0#9] (BIG OR [k<-0#9] state[i,j,k])) AND
    (BIG AND [i<-0#9,k<-0#9] (BIG OR [j<-0#9] state[i,j,k])) AND
    (BIG AND [j<-0#9,k<-0#9] (BIG OR [i<-0#9] state[i,j,k])) AND
    (BIG AND [i0<-0#3,j0<-0#3,k<-0#9]
          (BIG OR [i<- (3 i0)#3,j<-(3 j0)#3] state[i,j,k]))

truesState(state:Array3[\Boolean,0,9,0,9,0,9\]) =
    SUM [ f <- state ] if f then 1 else 0 end

(* fillState modifies the state array by committing to i,j,k,
   and returns the number of entries that changed. *)
fillState(state:Array3[\Boolean,0,9,0,9,0,9\],ijk:(ZZ32,ZZ32,ZZ32)):ZZ32 = do
    (i,j,k) = ijk
    (SUM [i' <- 0#9]
        if i =/= i' AND state[i',j,k] then
            state[i',j,k] := false
            1
        else 0 end) +
    (SUM [j' <- 0#9]
        if j =/= j' AND state[i,j',k] then
            state[i,j',k] := false
            1
        else 0 end) +
    (SUM [k' <- 0#9]
        if k =/= k' AND state[i,j,k'] then
            state[i,j,k'] := false
            1
        else 0 end) +
    (SUM [i' <- (3 (i DIV 3))#3, j' <- (3 (j DIV 3))#3]
        if (i'=/=i AND j'=/=j) AND state[i',j',k] then
                state[i',j',k] := false
                1
        else 0 end)
  end

sudoku(givens:(ZZ32,ZZ32,ZZ32)...): Sudoku = do
    st0 = array3[\Boolean,9,9,9\]().fill(true)
    su = Sudoku(9^3, st0)
    for (i,j,k) <- givens do
        _ = fillState(st0,(i-1,j-1,k-1))
    end
    res = Sudoku(truesState(st0),st0)
    if legalState(st0) then
        res
    else
        fail("Bad initial state:\n" res)
    end
  end

run(args:String...):()=do
    init = sudoku((1,1,8),(1,3,6),(1,4,1),(1,6,9),(1,7,3),(1,9,5),
                  (2,2,9),(2,5,8),(2,7,4),
                  (3,2,7),(3,3,1),(3,9,6),
                  (4,4,9),(4,5,2),(4,7,5),(4,8,3),
                  (5,3,9),(5,5,6),(5,7,7),
                  (6,2,3),(6,3,4),(6,5,7),(6,6,8),
                  (7,1,3),(7,7,1),(7,8,4),
                  (8,3,5),(8,5,1),(8,8,9),
                  (9,1,9),(9,3,7),(9,4,8),(9,6,4),(9,7,6),(9,9,2))
    println("Here's the initial:\n" init)
    res = aStar[\Sudoku,ZZ32\](init)
    println("Final result:\n" res)
end

end
