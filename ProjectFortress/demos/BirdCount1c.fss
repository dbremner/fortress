(*******************************************************************************
Copyright 2010 Michael Zody and Sun Microsystems, Inc. 
All rights reserved.

Sun Microsystems, Inc. is the Copyright owner of the Fortress programming language software, and Michael Zody is the developer of the algorithm which this software implements and the Copyright owner of the software implementation of the algorithm, to which Sun Microsystems, Inc. has a perpetual, irrevocable, royalty free right and license to use and distribute. 

Use is subject to license terms accompanying the software.

 ******************************************************************************)

(*) a. Delete `validTransitions` map and `isValidPairTransition` method; recode `isValidTransition` method algorithmically.
(*) b. Delete `conversion` map; recode `convert` method algorithmically.


component BirdCount1c
import File.{...}
import FileSupport.{...}
import FlatString.{...}
import List.{...}
import Map.{...}
import Set.{...}
import System.{getProperty}

export Executable

inverseConversion:Map[\String,Char\] =
    {[\String, Char\]
        "A0" |-> 'A',
        "A1" |-> 'C',
        "A2" |-> 'G',
        "A3" |-> 'T',
        "C0" |-> 'C',
        "C1" |-> 'A',
        "C2" |-> 'T',
        "C3" |-> 'G',
        "G0" |-> 'G',
        "G1" |-> 'T',
        "G2" |-> 'A',
        "G3" |-> 'C',
        "T0" |-> 'T',
        "T1" |-> 'G',
        "T2" |-> 'C',
        "T3" |-> 'A'
    }

(* if I could read these in from the file I would, but I don't know how to convert a string to an RR64 *)

singleErrorRates:Map[\String,Map[\ZZ32,RR64\]\] =
     {[\String, Map[\ZZ32, RR64\]\]
    "10a_LA_Frag35_20080704_white_leghorn_A" |-> 
                {[\ZZ32,RR64\] 0 |-> 0.00134,
                               1 |-> 0.00045, 
                               2 |-> 0.00039, 
                               3 |-> 0.00073, 
                               4 |-> 0.00021, 
                               5 |-> 0.00012, 
                               6 |-> 0.00008, 
                               7 |-> 0.00006, 
                               8 |-> 0.00010, 
                               9 |-> 0.00015, 
                               10 |-> 0.00011, 
                               11 |-> 0.00007, 
                               12 |-> 0.00007, 
                               13 |-> 0.00007, 
                               14 |-> 0.00010, 
                               15 |-> 0.00016, 
                               16 |-> 0.00012, 
                               17 |-> 0.00010, 
                               18 |-> 0.00011, 
                               19 |-> 0.00017, 
                               20 |-> 0.00027, 
                               21 |-> 0.00022, 
                               22 |-> 0.00022, 
                               23 |-> 0.00023, 
                               24 |-> 0.00034, 
                               25 |-> 0.00060, 
                               26 |-> 0.00060, 
                               27 |-> 0.00062, 
                               28 |-> 0.00060, 
                               29 |-> 0.00095, 
                               30 |-> 0.00161, 
                               31 |-> 0.00184, 
                               32 |-> 0.00225, 
                               33 |-> 0.00265, 
                               34 |-> 0.00000 },
    "10b_LA_Frag35_20080704_white_leghorn_B" |-> 
                {[\ZZ32,RR64\] 0 |-> 0.00028,
                               1 |-> 0.00012, 
                               2 |-> 0.00010, 
                               3 |-> 0.00012, 
                               4 |-> 0.00010, 
                               5 |-> 0.00012, 
                               6 |-> 0.00007, 
                               7 |-> 0.00006, 
                               8 |-> 0.00007, 
                               9 |-> 0.00007, 
                               10 |-> 0.00010, 
                               11 |-> 0.00008, 
                               12 |-> 0.00007, 
                               13 |-> 0.00008, 
                               14 |-> 0.00009, 
                               15 |-> 0.00014, 
                               16 |-> 0.00011, 
                               17 |-> 0.00010, 
                               18 |-> 0.00012, 
                               19 |-> 0.00014, 
                               20 |-> 0.00023, 
                               21 |-> 0.00023, 
                               22 |-> 0.00022, 
                               23 |-> 0.00022, 
                               24 |-> 0.00032, 
                               25 |-> 0.00056, 
                               26 |-> 0.00058, 
                               27 |-> 0.00056, 
                               28 |-> 0.00063, 
                               29 |-> 0.00088, 
                               30 |-> 0.00283, 
                               31 |-> 0.00282, 
                               32 |-> 0.00151, 
                               33 |-> 0.00252, 
                               34 |-> 0.00000 }
}

multipleErrorRates:Map[\String,Map[\ZZ32,RR64\]\] =
     {[\String, Map[\ZZ32, RR64\]\]
    "10a_LA_Frag35_20080704_white_leghorn_A" |-> 
                {[\ZZ32,RR64\] 0 |-> 0.04331,
                               1 |-> 0.03910,
                               2 |-> 0.01894, 
                               3 |-> 0.02443, 
                               4 |-> 0.03466, 
                               5 |-> 0.00876, 
                               6 |-> 0.01211, 
                               7 |-> 0.00658, 
                               8 |-> 0.00796, 
                               9 |-> 0.01411, 
                               10 |->0.01342, 
                               11 |->0.01010, 
                               12 |->0.00846, 
                               13 |->0.00907, 
                               14 |->0.00952, 
                               15 |->0.01544, 
                               16 |->0.01709, 
                               17 |->0.01165, 
                               18 |->0.01247, 
                               19 |->0.01336, 
                               20 |->0.02285, 
                               21 |->0.02293, 
                               22 |->0.01948, 
                               23 |->0.02129, 
                               24 |->0.02037, 
                               25 |->0.03367, 
                               26 |->0.03527, 
                               27 |->0.03708, 
                               28 |->0.03491, 
                               29 |->0.03672, 
                               30 |->0.05487, 
                               31 |->0.06012, 
                               32 |->0.07016, 
                               33 |->0.06959, 
                               34 |->0.07209},
    "10b_LA_Frag35_20080704_white_leghorn_B" |-> 
                {[\ZZ32,RR64\] 0 |-> 0.00895, 
                               1 |-> 0.00954, 
                               2 |-> 0.00664, 
                               3 |-> 0.00843, 
                               4 |-> 0.00863, 
                               5 |-> 0.00850, 
                               6 |-> 0.01045, 
                               7 |-> 0.00593, 
                               8 |-> 0.00825, 
                               9 |-> 0.00757, 
                               10 |->0.01032, 
                               11 |->0.01131, 
                               12 |->0.00809, 
                               13 |->0.00928, 
                               14 |->0.00915, 
                               15 |->0.01354, 
                               16 |->0.01589, 
                               17 |->0.01044, 
                               18 |->0.01367, 
                               19 |->0.01300, 
                               20 |->0.01934, 
                               21 |->0.02271, 
                               22 |->0.01978, 
                               23 |->0.01934, 
                               24 |->0.02105, 
                               25 |->0.03057, 
                               26 |->0.03541, 
                               27 |->0.03346, 
                               28 |->0.03289, 
                               29 |->0.03943, 
                               30 |->0.04918, 
                               31 |->0.13046, 
                               32 |->0.05682, 
                               33 |->0.05955, 
                               34 |->0.07790 }
}

var coverage:Map[\String, Map[\ZZ32,ZZ32\]\]:= {[\String, Map [\ZZ32, ZZ32\] \] }

referenceChickenFile:String = getProperty("fortress.automhome",".") || "/ProjectFortress/demos/chickenData/chr10.fa.head" 
sampleFilesDir:String = getProperty("fortress.automhome",".") || "/ProjectFortress/demos/chickenData/test_data"
sampleFilesFileName:String = "chr10.csfasta.ma.sorted.head"
errorFilesFileName:String = "composite_error_model.txt"

sampleChickens:List[\String\] = <|[\String\]
    "10a_LA_Frag35_20080704_white_leghorn_A",
    "10b_LA_Frag35_20080704_white_leghorn_B"
(*    "17_LA_Frag35_20080909_high_grow_line",
    "18_LA_Frag35_20080909_low_grow_line",
    "17.1_LA_Frag35_20080925_high_grow_line",
    "18.1_LA_Frag35_20080925_low_grow_line",
    "16_LA_Frag35_20080829_broiler",
    "22_LA_Frag35_20081016_RJF",
    "16.1_LA_Frag35_20080925_broiler",
    "22.1_LA_Frag35_20081114_RJF" *)
|>

encodeACGT(c: Char): ZZ32 = case c of 'A' => 0; 'C' => 1; 'G' => 2; 'T' => 3; end

convert(c1:Char, c2:Char): Char =
    if (c1 = 'N') OR (c2 = 'N') then '4' else char('0'.codePoint + (encodeACGT(c1) BITXOR encodeACGT(c2))) end

object Pairs[\T\](g: Generator[\T\]) extends Generator[\(T,T)\]
    generate[\R\](red: Reduction[\R\], m:(T,T)->R): R =
    if (l,v,r) <- g.generate[\Maybe[\(T,R,T)\]\](PairReduction[\T,R\](red,m),
                             fn (t:T) => Just[\(T,R,T)\](t, red.empty(), t))
        then v else red.empty() end
end

object PairReduction[\T,R\](red: Reduction[\R\], m:(T,T)->R)
        extends Reduction[\Maybe[\(T,R,T)\]\]
    empty():Maybe[\(T,R,T)\] = Nothing[\(T,R,T)\]
    join(left:Maybe[\(T,R,T)\], right:Maybe[\(T,R,T)\]) : Maybe[\(T,R,T)\]=
    if (l, v_l, m_l) <- left then
        if (m_r, v_r, r) <- right then
            Just[\(T,R,T)\](l, red.join(red.join(v_l, m(m_l, m_r)), v_r), r)
        else left end
    else right end
end 


trait dna comprises {dnaSequence, EmptySequence}
       getter colorSequence(): String
       opr OPLUS(self, other: dna) : dna
end


(* left and right are ACGT encoded, middle is color encoded *)

object dnaSequence(left:Char, middle:String, right:Char) extends dna
   getter colorSequence():String = middle
   opr OPLUS(self, other:dnaSequence):dnaSequence =
       dnaSequence(left, middle || convert(right, other.left) || other.middle(), other.right)
   opr OPLUS(self, other:EmptySequence) = self
end

object EmptySequence() extends dna
    getter colorSequence():String = ""
    opr OPLUS(self, other:dna) = other
end

object dnaSequenceReduction extends { MonoidReduction[\dna\],
                               ReductionWithZeroes[\dna,dna\] }
    getter asString() = "dnaSequenceReduction"
    empty(): dna = EmptySequence()
    join(a: dna, b: dna): dna = a OPLUS b
end

opr BIG OPLUS[\T\](): BigReduction[\dna, dna\] =
   BigReduction[\dna,dna\](dnaSequenceReduction)

opr BIG OPLUS[\T\](g:Generator[\dna\]) = 
   __bigOperatorSugar[\dna,dna,dna,dna\](BIG OPLUS[\T\](), g)


processReferenceFileLine(input:String):dna = do
    if input[0] = '>' 
        then EmptySequence()
    else 
        n = |input|
        dnaSequence(input[0], BIG || [p<- Pairs(input)](convert(p)), input[n-1])
    end
end

readReferenceFileLine(input:String):String = do
    if input[0] = '>' 
        then ""
    else 
        input
    end
end

processReferenceFile(name:String):String=do
   var rs:FileReadStream = FileReadStream(name)
   var res:dna  = BIG OPLUS [l<-rs.lines()] processReferenceFileLine(l)
   colors = res.colorSequence()
   colors
end

readReferenceFile(name:String):String=do
   var rs:FileReadStream = FileReadStream(name)
   var res:String = BIG || [l<-rs.lines()] readReferenceFileLine(l)
   res
end

object Snip(header:String, sequence:String, name:String, pos:ZZ32, length:ZZ32, seqend:ZZ32, 
            referenceChickenColorsSnip:String, sampleChickenColorsSnip:String,
            referenceChickenAGCTSnip:String) 
    getter header():String = header
    getter sequence():String = sequence
    getter name():String = name
    getter pos():ZZ32 = pos
    getter length():ZZ32 = length
    getter seqend():ZZ32 = seqend
    getter referenceChickenColorsSnip():String = referenceChickenColorsSnip
    getter sampleChickenColorsSnip():String = sampleChickenColorsSnip
    getter referenceChickenAGCTSnip():String = referenceChickenAGCTSnip    
    getter asString():String = pos || "  " || name || "  " || referenceChickenColorsSnip || "  " sampleChickenColorsSnip || "  " || referenceChickenAGCTSnip 

    sampleChickenAGCTSnip():String = do

        l:ZZ32 = |sampleChickenColorsSnip|
        var i:ZZ32 := 0
        var result:String := ""
        var current:Char := sampleChickenColorsSnip[0]
        var c:Char = referenceChickenAGCTSnip[0]

        while (i < l) do
          result := result || c
          current := sampleChickenColorsSnip[i]
          temp:String = c.asString() || current.asString()
          c:= inverseConversion.member(temp).get
          i:= i+1
        end
        result := result || c
        result
    end

(*
       BIG || [(x,y) <- referenceChickenAGCTSnip.zip[\Char\](referenceChickenColorsSnip.javaSubstr(0,1) || sampleChickenColorsSnip)] inverseConversion.member(x.asString() || y.asString()).get()

*)

    printSnip():() = do
        println("Snip:" name pos() "  ")
        println(" " referenceChickenColorsSnip)
        println(" " sampleChickenColorsSnip)
        println(referenceChickenAGCTSnip)
(*        println(sampleChickenAGCTSnip())  *)
    end


end

reverse(sequence:String):String = BIG || [c<-sequence.reverse()] c

negativeOrientation(header:String):Boolean =  do
   pattern:String = ">\\w*,\\d*_-.*"
   header.javaRegExpMatches(pattern)
end

getAdjustedLocation(negativeOri:Boolean, location:String, length:ZZ32):ZZ32 = do
   if (negativeOri) then
      strToInt(location.asFlatString().javaSubstr(1), 10) - length + 1        
   else 
      strToInt(location) - 1
   end
end

getReferenceChickenColorsSnip(adjustedLoc:ZZ32, seqEnd:ZZ32):FlatString = do
   referenceChickenColors[adjustedLoc:seqEnd+1].asFlatString()
end

getAdjustedSequence(negativeOri:Boolean, sequence:String, refChickenColorsSnip:FlatString):FlatString = do
    temp:FlatString = sequence.asFlatString().javaSubstr(1)
    tempLength:ZZ32 = |temp|
    if (negativeOri) then
        ((reverse(temp).asFlatString().javaSubstr(0, tempLength - 1 )).asFlatString() || refChickenColorsSnip.asFlatString().javaSubstr(tempLength - 1, tempLength).asFlatString()).asFlatString()
    else
        (refChickenColorsSnip.asFlatString().javaSubstr(0,1) || temp.asFlatString().javaSubstr(1).asFlatString()).asFlatString()
    end
end


readASnip(r:ReadStream):Snip = do
   header:String = r.uncheckedReadLine()
   var sequence:String = r.uncheckedReadLine()

   if sequence = "" then Snip(header, sequence,"", 0, 0, 0, "","","") else
      name:String = header.asFlatString().javaRegExpSplit(",",0)
      loc:String = header.asFlatString().javaRegExpSplit(",",1).asFlatString().javaRegExpSplit("_",1).asFlatString().javaRegExpSplit("\\.",0)
      length:ZZ32 = sequence.asFlatString().size() - 1
      negativeOri:Boolean = negativeOrientation(header)
      adjustedLocation:ZZ32 = getAdjustedLocation(negativeOri, loc, length)
      sequenceEnd:ZZ32 = adjustedLocation + length - 1
      referenceChickenColorsSnip:FlatString = getReferenceChickenColorsSnip(adjustedLocation, sequenceEnd)
      adjustedSequence:FlatString := getAdjustedSequence(negativeOri, sequence, referenceChickenColorsSnip)
      referenceChickenAGCTSnip:String = referenceChickenAGCT.asFlatString().javaSubstr(adjustedLocation, sequenceEnd + 2)

      Snip(header, adjustedSequence, name, adjustedLocation, length, sequenceEnd, referenceChickenColorsSnip, adjustedSequence, referenceChickenAGCTSnip)
   end
end

ChunkSize:ZZ32 = 10000


(* Given two samples, this creates a list of the positions where they differ *)

object Event(s:Snip, diffs:String, startPos:ZZ32, endPos:ZZ32, errorProb:RR64, fileName:String)
    getter snip():Snip = s
    getter startPos():ZZ32 = startPos
    getter endPos():ZZ32 = endPos
    getter diffs():String = diffs
    getter asString():String = do
      var result:String := fileName || "    " || refStart() || "    " || refEnd() || "    " 
      result := result || referenceChickenColorsSnip() || "    " || sampleChickenColorsSnip() || "   "
      result := result || refChickenAGCTSnip() || "    " || sampleChickenDiffSnip() || "   "
      result := result || errorProb
      result
    end
    getter errorProb():RR64 = errorProb
    getter fileName():String = fileName
    valid():Boolean =  isValidTransition(s, startPos,diffs)
    refStart():ZZ32 = s.pos() + startPos
    refEnd():ZZ32 = refStart() + endPos - 1

    referenceChickenColorsSnip() = s.referenceChickenColorsSnip.javaSubstr(startPos, endPos + startPos) 
    sampleChickenColorsSnip() = s.sampleChickenColorsSnip.javaSubstr(startPos, endPos + startPos) 

    sampleChickenDiffSnip():String = do
       var i:ZZ32 := 0
       var c:Char := s.referenceChickenAGCTSnip[startPos]
       var result:String :=  c.asString()
       while (i < endPos) do
          next:Char = inverseConversion[c.asString() || s.sampleChickenColorsSnip[i + startPos].asString]
          result := result || next
          c := next
          i := i+1
       end
       result
    end

   refChickenAGCTSnip():String = s.referenceChickenAGCTSnip.javaSubstr(startPos, endPos+startPos+1)

    printEvent():() = do
       eventStart:ZZ32 = s.pos() + startPos
       eventEnd:ZZ32 = eventStart + endPos - 1
       snipEnd:ZZ32 = endPos + startPos
       
       print(s.header() "  " errorProb " "  eventStart "  " eventEnd "  ")
       print(s.referenceChickenColorsSnip.javaSubstr(startPos, snipEnd) "  ")
       print(s.sampleChickenColorsSnip.javaSubstr(startPos, snipEnd) "  ")
       if valid() then
          print "VALID" 
          print("  " refChickenAGCTSnip() "   ")
          print(sampleChickenDiffSnip())
       else
          print "inv" 
          print("  " refChickenAGCTSnip() "   ")
          xs:String = "xxxxxxxxxxxxxxxxxx"
          print(xs.javaSubstr(0, endPos+1))
       end
       println("    " startPos) 
    end
end

object MergedEvent(count:ZZ32, refStart:ZZ32, refEnd:ZZ32, 
                    referenceNumberFormat:String, sampleNumberFormat:String,
                    referenceAGCTFormat:String, sampleAGCTFormat:String,
                    totalCoverage:RR64,
                    probability:RR64, eventList:List[\Event\])
  getter count():ZZ32 = count
  getter refStart():ZZ32 = refStart
  getter refEnd():ZZ32 = refEnd
  getter referenceNumberFormat():String = referenceNumberFormat
  getter sampleNumberFormat():String = sampleNumberFormat
  getter referenceAGCTFormat():String = referenceAGCTFormat
  getter sampleAGCTFormat():String = sampleAGCTFormat
  getter totalCoverage():RR64 = totalCoverage
  getter probability():RR64 = probability
  getter eventList():List[\Event\] = eventList
  getter asString():String = do
      var result:String = count || "  " 
      result := result || refStart || "  " || refEnd || "  "
      result := result || referenceNumberFormat || "  " || sampleNumberFormat || "  "
      result := result || referenceAGCTFormat || "  " || sampleAGCTFormat || "  "
      result := result || totalCoverage || "  " 
      result := result || probability || "  "
      result
  end
end
   
opr UNIONUNION(a:Map[\String, List[\Event\]\], 
               b:Map[\String, List[\Event\]\]):Map[\String, List[\Event\]\] =
           a.union(fn(k,x,y) => x || y, b)


opr BIG UNIONUNION(): BigReduction[\Map[\String, List[\Event\]\],Map[\String, List[\Event\]\]\] =
    embiggen[\Map[\String, List[\Event\]\]\](fn(a,b) => a UNIONUNION b, {[\String,List[\Event\]\]})

makeDatabase(e:Event):Map[\String,List[\Event\]\] = do
   var database:Map[\String, List[\Event\]\] := {[\String, List[\Event\]\]}
   database := database.add(e.fileName(), <|[\Event\] e |>)
   database
end

makeChangeDatabase(e:Event):Map[\String,List[\Event\]\] = do
   var database:Map[\String, List[\Event\]\] := {[\String, List[\Event\]\]}
   database := database.add(e.sampleChickenDiffSnip(),  <|[\Event\] e |>)
   database
end

(* This may change with newer technology, but for now it is OK. *)
readSize:ZZ32 = 35
var minlibpval:RR64 := 1.0
var combpval:RR64 := 0.0

calculateCoverage(fileName:String, refEnd:ZZ32):ZZ32 = do
    rangeStart:ZZ32 = refEnd - readSize + 1
    rangeEnd:ZZ32 = refEnd
    var count:ZZ32 := 0

    for i <- seq(rangeStart:rangeEnd) do
        count := count + coverage.member(fileName).get().member(i,0)
    end

    count
end

calculateBonferroniLibrary(fileName:String, events:List[\Event\]):RR64 = do
   count:ZZ32 = |events|
   first:Event = events.left().get()
   var probability:RR64 := 1.0
   var gmp:RR64 := 1.0
   var libpval:RR64 :=0 
   for event <- seq(events) do
      probability := probability event.errorProb()
   end
   gmp := probability^(1.0/count)
   cov:ZZ32 = calculateCoverage(fileName, first.refEnd())
   for j <- seq(count:cov) do
      libpval := libpval + ((gmp^j) comb(cov, j))
   end
   minlibpval := minlibpval cov
   libpval
end

calculateBonferroniTotal(EventsByFile:Map[\String, List[\Event\]\]):RR64 = do
   var totcov:ZZ32 := 0
   var totcalls:ZZ32 := 0
   var totprob:RR64 := 1.0
   for (file, events) <- seq(EventsByFile) do
      var probability:RR64 := 1.0
      totcov := totcov +  calculateCoverage(file, events.left().get().refEnd())
      totcalls := totcalls + |events|
      for event <- seq(events) do
         probability := probability event.errorProb()
      end
      totprob := totprob probability
   end
   gmp:RR64 = totprob^(1.0/totcalls)
   for j <-seq(totcalls:totcov) do
      combpval += (gmp^j) comb(totcov, j)
   end
   combpval   
end

calculateBonferroni(EventsByFile:Map[\String, List[\Event\]\]):RR64 = do
   for (file, events) <- seq(EventsByFile) do
      minlibpval := calculateBonferroniLibrary(file, events) MIN minlibpval
   end
   calculateBonferroniTotal(EventsByFile)
   result:RR64 = (2 combpval) MIN (2 minlibpval)
   result
end

calculateTotalCoverage(EventsByFile:Map[\String, List[\Event\]\]):ZZ32 = do
   var totcov:ZZ32 := 0
   for (file, events) <- seq(EventsByFile) do
      totcov := totcov +  calculateCoverage(file, events.left().get().refEnd())
   end
   totcov
end
         
getFirstEvent(EventsByFile:Map[\String, List[\Event\]\]):Event = do
   var first:Event
   (* There has to be a better way, but I'm in a hurry shame shame *)
   for (file, events) <- seq(EventsByFile) do
      first := events.left().get()
   end
   first
end

maybeUpdateMergedDatabase(mergedDatabase:Map[\(ZZ32, String),List[\MergedEvent\]\],
                          key:ZZ32, entryList:List[\Event\]):Map[\(ZZ32,String),  List[\MergedEvent\]\] = do
   var resultMergedDatabase:Map[\(ZZ32, String), List[\MergedEvent\]\] := mergedDatabase
   validEvents:List[\Event\] := <|[\Event\] event | event <- entryList, event.valid() |>
   EventsByChange:Map[\String, List[\Event\]\] := BIG UNIONUNION [event <- validEvents] makeChangeDatabase(event)

   for (change, changeEvents) <- seq(EventsByChange) do
      EventsByFile:Map[\String, List[\Event\]\] := BIG UNIONUNION [event <- changeEvents] makeDatabase(event)
      var mergedEvents:List[\MergedEvent\] := <|[\MergedEvent\]|>

      if (|changeEvents| > 0) then
         first:Event = changeEvents.left().get()
         probability:RR64 := calculateBonferroni(EventsByFile)
         totalCoverage:ZZ32 := calculateTotalCoverage(EventsByFile) 
   
         snipPos = first.snip().pos()
         refStart = first.refStart()
         refEnd = first.refEnd()
         referenceNumberFormat = first.referenceChickenColorsSnip()
         sampleNumberFormat = first.sampleChickenColorsSnip()
         referenceAGCTFormat = first.refChickenAGCTSnip()
         sampleAGCTFormat = first.sampleChickenDiffSnip()

         me:MergedEvent = MergedEvent(|changeEvents|, refStart, refEnd, 
                                referenceNumberFormat, sampleNumberFormat,
                                referenceAGCTFormat, sampleAGCTFormat,
                                totalCoverage, probability, changeEvents)
         mergedEvents :=  mergedEvents || <| me |>
         resultMergedDatabase := resultMergedDatabase.update((key, change), mergedEvents)
      end
   end
   resultMergedDatabase
end
   


(* This code is a little obtuse.  The idea is that if the sample differs from the reference 
   chicken in more than one consecutive location it may be an interesting mutation.  We look
   for these potential interesting mutations and return a list of them.
 *)

makeEvent(s:Snip, basicDiffs:String, diffs:String, loc:ZZ32, name:String):Event = do
   var index:ZZ32 = loc
   while (index < |diffs| AND: diffs[index] = 'X') do index := index + 1 end
   lenOfEvent = index - loc
   if lenOfEvent = 2 then
        temp = singleErrorRates.member(name).get().member(loc).get()
        Event(s, diffs, loc, lenOfEvent, temp, name)
               
   else
     var errorProb:RR64 := 1
     index := 0
     while (index < lenOfEvent) do
        temp = multipleErrorRates.member(name).get().member(loc+index).get()
        if basicDiffs[loc+index] = 'X' then
           errorProb := errorProb temp
        end
        index := index + 1
     end
     Event(s, diffs, loc, lenOfEvent, errorProb, name)
   end
end   

isSingletonX(loc:ZZ32, diffs:String):Boolean =  
   if loc = |diffs| - 1 then true
   elif diffs[loc] = 'X' AND: diffs[loc+1] = '.' then true
   else false
   end


 
isInterestingPosition(loc:ZZ32, diffs:String):Boolean = do
   len:ZZ32 = |diffs|
   if loc = 0 AND: diffs[0] = 'X' AND: diffs[1] = 'X' then true
   elif loc = 0 then false
   elif loc = (len - 1) then false
   elif diffs[loc] = '.'  OR: (diffs[loc-1] = 'X') OR: isSingletonX(loc, diffs) then
      false
   else true
   end
end

isValidTransition(reference:String, sample:String) = do
    var i:ZZ32 := 0
    var result:Boolean := true
    while (i < |reference| - 1) do
        r = reference.javaSubstr(i, i+2)
        s = sample.javaSubstr(i, i+2)
        result := result AND ((r[0].codePoint BITXOR r[1].codePoint) = (s[0].codePoint BITXOR s[1].codePoint))
        i := i + 1
    end
    result
end

isValidTransition(s:Snip, loc:ZZ32, diffs:String):Boolean = do
   len:ZZ32 := loc
   while (len < ((|diffs|) - 1) AND: diffs[len] = 'X') do len := len + 1 end
   sample:String = s.sampleChickenColorsSnip().javaSubstr(loc, len)
   reference:String = s.referenceChickenColorsSnip().javaSubstr(loc, len)
   isValidTransition(reference, sample)
end

isInteresting(s:Snip, loc:ZZ32, diffs:String):Boolean = 
   if isInterestingPosition(loc, diffs) then
       true
   else
       false
   end


sampleCompare(ref:String, sample:String):String = do
   BIG || [(x,y) <- ref.zip[\Char\](sample)] (if (x =/= y) then "X" else "." end)
end

(* X.X should be replaced with XXX *)
factorOutProblemChildren(diffs:String) = do
   var index:ZZ32 := 2
   var result:String := ""
   if diffs.asFlatString().javaSubstr(0,4) = "X.XX" then 
      result := result || "XX" 
   else result := result || diffs[0] || diffs[1]
   end

   while (index < |diffs| - 2) do
      if diffs[index] = 'X' then result := result || "X"
      elif diffs.asFlatString().javaSubstr(index-2, index+3) = ".X.X." then
         result := result || "X"
      elif diffs.asFlatString().javaSubstr(index-2, index+3) = ".X.XX" then
         result := result || "X"
      elif diffs.asFlatString().javaSubstr(index-2, index+3) = "XX.X." then
         result := result || "X"
      else result := result || "."
      end
      index := index + 1
   end 

(* The following code wreaks havoc and destruction or at least confuses the interpreter.
   if diffs.asFlatString().javaSubstr(index - 2, 4) = "XX.X" then
*)

   if diffs[index-2] =  'X' AND: diffs[index-1] = 'X' AND: diffs[index] = '.' AND: diffs[index+1] = 'X' then
      result := result || "XX"
   else 
      result := result || diffs[|diffs| - 2] || diffs[|diffs| - 1]  
   end

   result
end   

(* Given two samples this creates events *)

eventGenerator(s:Snip, name:String) = do
    basicDiffs = sampleCompare(s.referenceChickenColorsSnip(),s.sampleChickenColorsSnip())
    diffs = factorOutProblemChildren(basicDiffs)
    stop = |diffs| - 1
    var database:Map[\ZZ32, List[\Event\]\] := {[\ZZ32, List[\Event\]\]}


    for x <- seq(0:stop) do
        if isInteresting(s,x,diffs) then
           database := database.add(x + s.pos(), <| makeEvent(s, basicDiffs, diffs, x, name) |>)
        end
    end

    database
end

combine(k:ZZ32, val1:List[\Event\], val2:List[\Event\]):List[\Event\] = val1 || val2

processSampleChicken(name:String):Map[\ZZ32, List[\Event\]\] = do
    max:ZZ32 = referenceChickenColors.size()
    var rs:FileReadStream = 
        FileReadStream(sampleFilesDir || "/" || name || "/" || sampleFilesFileName)
    fg:FileGenerator[\Snip\]  = FileGenerator[\Snip\](rs,60,readASnip)
    var database:Map[\ZZ32, List[\Event\]\] := {[\ZZ32, List[\Event\]\]}
    coverageDatabase:Map[\ZZ32,ZZ32\] = { [\ZZ32, ZZ32\] }
    
    for s <- seq(fg) do
       coverageDatabase := coverageDatabase.updateWith(fn(mx) => Just[\ZZ32\](mx.getDefault(0)+1), s.pos())
       database := database.union(combine, eventGenerator(s, name))
    end
    coverage := coverage.add(name, coverageDatabase)
    database
end

var referenceChickenColors:String := ""
var referenceChickenAGCT:String := ""


(* This is a simple port of the perl code. I have no idea what it does *)

comb(n:ZZ32, m:ZZ32) = do
   var k:ZZ32 := n - m
   var m1:ZZ32 := m
   if (k > m) then (k,m1) := (m,k) end
   var prod:RR64 := 1.0
   var i:ZZ32 := n
   var j:ZZ32 := k
   while (i > m1) do
      prod := prod (i/j)
      i := i - 1
      j := j - 1
   end
   prod
end


run() = do

    referenceChickenAGCT   := readReferenceFile(referenceChickenFile)
    referenceChickenColors := processReferenceFile(referenceChickenFile)
    var database:Map[\ZZ32, List[\Event\]\] := {[\ZZ32, List[\Event\]\]} 
    var mergedDatabase:Map[\(ZZ32,String), List[\MergedEvent\]\] := {[\(ZZ32, String), List[\MergedEvent\]\]} 

    for sampleChicken <- seq(sampleChickens) do
        database := database.union(combine,processSampleChicken(sampleChicken))
    end

    println("Events")
    var i:ZZ32 := 0
    for (key,entries) <- seq(database) do
       mergedDatabase := maybeUpdateMergedDatabase(mergedDatabase, key, entries) 
       for entry <- seq(entries) do
          entry.printEvent()
       end
    end

   println("Merged Events:")
   
   for (dontcare , events) <- seq(mergedDatabase) do
      for event <- seq(events) do
             println(event)
             for e <- seq(event.eventList()) do println(e) end
             println("-------")
      end
   end
 
end  
end
