(*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

(* Pythagorean Triples

This file explores two approaches for generating Pythagorean triples:

1. search directly for (a,b,c) where a^2 + b^2 = c^2
2. search meta-variables n & m using Euclid's formula (see Wikipedia)

Successive versions build ever more efficient approaches. *)

component trips
import List.{...}
import Set.{...}
export Executable

opr |  (x:Number, y:Number):Number  = x DIVIDES y
coPrime(x:Number, y:Number):Boolean = (1 = x GCD y)
even (x) =    2|x
odd  (x) = NOT (2|x)

(* The specification defines a builtin symbol for DIVIDES. Until it's
implemented, I define it myself. *)

object trip (a:Number, b:Number, c:Number)
    extends StandardTotalOrder[\trip\]
    opr CMP(self, other:trip):TotalComparison =
        (a CMP other.a) LEXICO (b CMP other.b) LEXICO (c CMP other.c)
    toString():String = "[trip " a " " b  " " c "]"
end trip

(* When I did this exercise, using an object was a much faster way to
represent a triple than a tuple or a list, likely due to genericity.
Perhaps that will always be so, as data structures shoud be cheap.

Note: CMP & toString follow canonical patterns. Perhaps they could be
specified implicitly. *)

orderedTrip(a:Number, b:Number, c:Number):trip =
    trip ((a MIN b), (a MAX b), c)

(* In this exercise, I define a number of triple generators. A
generator object contains the generator, a doc string, and a
recommended max value as the argument. *)

object generator(fun:ZZ32->List[\trip\], doc:String, max:ZZ32)
    extends StandardTotalOrder[\trip\]
    opr CMP(self, other:generator):TotalComparison = doc CMP other.doc
    toString():String = "[generator " doc " max: " max "]"
end generator


search0(max:ZZ32) =
    <| trip (a,b,c) |
        a<-3:max, b<-3:max, c<-3:max,
        a < b < c,
        a^2 + b^2 = c^2,
        coPrime (a,b)
    |>
g0 = generator (search0, "Naive search: Triple loop, then filter", 25)
(* Can I set up a global mutable collection of generators?
var generators:Set[\generator\] = set()
generators UNION= {generator (search0, "Naive search: Triple loop, then filter", 20)}
*)

search1(max:ZZ32) =
    <| trip(a,b,cInt) |
        a<-3:max, b<-3:max,
        a < b,
        c<-just(SQRT(a^2 + b^2)), cInt<-just(narrow |\c/|), c = cInt,
        c <= max,
        coPrime (a,b)
    |>
g1 = generator (search1, "Naive search: Double loop, calculate c", 100)
(* Narrow will go away with automatic coercion. *)

search2(max:ZZ32) =
    <| trip(a,b,cInt) |
        a<-3:(max-1),
        b<-(a+1):narrow(|\SQRT(max^2 - a^2)/|),
        c<-just(SQRT(a^2 + b^2)), cInt<-just(narrow |\c/|), c = cInt,
        coPrime (a,b)
    |>
g2 = generator (search2, "Naive search: fold a<b and c<max into generators", 100)

search3(max:ZZ32) =
    <| trip(a,b,cInt) |
        a<-3:(max-1),
        b<-(a+1):narrow(|\SQRT(max^2 - a^2)/|),
        (odd a) OR (odd b),
        c<-just(SQRT(a^2 + b^2)), cInt<-just(narrow |\c/|), c = cInt,
        coPrime (a,b)
    |>
g3 = generator (search3, "Naive search: promote 2 as a common factor", 100)

search4(max:ZZ32) =
    <| trip(a,b,cInt) |
        a<-3:(max-1),
        bb<-do
            bMin = a+1
            bMax = narrow(|\SQRT(max^2 - a^2)/|)
            bDiff = bMax-a
            bCount  = if odd a then bDiff else narrow(|\ bDiff/2 /|) end
            0:bCount
        end,
        b<-if odd a then <| (a+1) + bb|> else  <| (a+1) + (2 bb) |> end,
        c<-just(SQRT(a^2 + b^2)), cInt<-just(narrow |\c/|), c = cInt,
        coPrime (a,b)
    |>
g4 = generator (search4, "Naive search: absorb 2 into b striding", 100)

(* Once strides are implemented, we'll be able to write:
b<-(a+1):narrow(|\SQRT(max^2 - a^2)/|):(if odd a then 1 else 2 end)

Is the following simpler?
b<-(a+1):narrow(|\SQRT(max^2 - a^2)/|):(2 - a MOD 2)
Yes, but it's not as easy to understand by most people, I
suspect. Again, I'd like to do some binding here.  *)

euclid0(max:ZZ32) =
    <| orderedTrip(a, b, c) |
        n<-1:max,
        m<-n+1:max,
        (even n) XOR (even m), coPrime (n, m),
        a<-just(2 n m),
        b<-just(m^2 - n^2),
        c<-just(m^2 + n^2),
        c <= max |>
e0 = generator (euclid0, "Euclid's formula with naive upper bounds", 100)

(* I'd really like to do explicit binding in a sequence of generators
with an explicit syntax, but the overloaded use of = makes this hard.
In this context, = indicates a predicate. *)

euclid1(max:ZZ32) =
    <| orderedTrip(2 n m, m^2 - n^2, m^2 + n^2) |
        n<-1:max,
        m<-n+1:max,
        (even n) XOR (even m), coPrime (n, m),
        m^2 + n^2 <= max |>
e1 = generator (euclid1, "Euclid's formula, naive upper bounds, no binding", 100)

(* Promoting the quadratic filters above to the range upper bounds below in a
compiler is a challenge, perhaps a good thesis. *)

euclid2(max:ZZ32) =
    <| orderedTrip(2 n m, m^2 - n^2, m^2 + n^2) |
        n<-1:(narrow (|\SQRT(max DIV 2)/|)),
        m<-n+1:(narrow(|\SQRT(max - n^2)/|)),
        (even n) XOR (even m), coPrime (n, m) |>
e2 = generator (euclid2, "Euclid's, (m^2+n^2<=max) & n<m => upper bounds", 100000)

wiki0(max:ZZ32) = do
    Wikipedia100 = (* Wikipedia lists triples under 100. *)
        <|trip ( 3, 4, 5), trip ( 5,12,13), trip ( 7,24,25), trip ( 8,15,17),
         trip ( 9,40,41), trip (11,60,61), trip (12,35,37), trip (13,84,85),
         trip (16,63,65), trip (20,21,29), trip (28,45,53), trip (33,56,65),
         trip (36,77,85), trip (39,80,89), trip (48,55,73), trip (65,72,97)|>
    tripsTo (Wikipedia100, max)
end
w0 = generator (wiki0, "Wikipedia 100", 100000)

generators = <|g0, g1, g2, g3, g4, e0, e1, e2, w0|>

tripsTo(ts, x:Number) = { t | t<-ts, t.a <= x, t.b <= x, t.c <= x }

getTimeMS() = (nanoTime() + (500 TIMES 1000)) DIV (1000 TIMES 1000)
totalTime:ZZ64 := 0

(* This sort of thing might be nice to have generally available:
getTimeNS() = nanoTime()
getTimeMS() = (nanoTime() + (500 TIMES 1000)) DIV (1000 TIMES 1000)
Jan suggested using floating point
*)

timeIt(g:generator, n:ZZ32, timeAndPrint:Boolean) =
    if n > g.max then <|[\trip\] |>
    elif NOT timeAndPrint then g.fun n
    else start = getTimeMS()
         ts = g.fun n
         time =  getTimeMS() - start
         atomic totalTime += time
         println (|ts| " triples under " n " in " time " ms --- " g.doc)
         ts
    end

(* Are all the elements of a list the same? I had been thinking of
this as a BIG = operation, but reductions are (T,T)->T, and = is
(T,T)->Boolean ... . *)

allSame (xs):Boolean = do
    same = if   (x,ys) <- xs.extractLeft()
           then BIG AND <| compareTwo(x,y) | y<-ys |>
           else true end
    assert (same, true, "No match for this set: " xs)
end

compareTwo(ps,qs):Boolean = do
    psMax =  if |ps| = 0 then 0 else BIG MAX [p<-ps] p.a MAX p.b MAX p.c end
    qsMax =  if |qs| = 0 then 0 else BIG MAX [q<-qs] q.a MAX q.b MAX q.c end
    truncatedMatch = (tripsTo (ps, qsMax) = tripsTo (qs, psMax))
    lengthMatch    = if (psMax = qsMax) then (|ps| = |qs|) else true end
    truncatedMatch AND lengthMatch
end

(* subsequencing is nice: ss[2:4] and subindexing would also be nice:
    sameAcross = allSame ss[<0,2,5,7>]
    sameAcross =
        allSame <| ss[i] | i<-<|0,2,5,7|>,
                 i >= (case n of 301:=>7; 101:300=>5; 21:100=>2; else=>0 end) |>
*)

(* Using = for binding means parens are needed in the = tests above.
I'd prefer to use another symbol for binding. How about "IS"?  as in x
IS 5? I had been noodling left arrow for binding & "double left arrow"
for generation, but someone in the community has suggested the former
for sequential generation and the later for parallel generation
... interesting!  *)

run(args:String...) = do
    (n, timeAndPrint) =
       if |args| = 0
       then (100,               false)
       else (strToInt(args[0]), true)  end
    if timeAndPrint then
        totalTime := 0
        println("Irreducible Pythagorean triples under " n " ...")
        allSame <|timeIt(g,n,true) | g<-generators|>
        println("... in " totalTime " ms")
    else allSame <|timeIt(g,n,false) | g<-generators|>
    end
end

test compareEmAll() = do
    (min,max,stride) = (5,150,7)
    println ("Comparing " min " to " max " with stride " stride)
    var n:ZZ32 = min
    while n<=max do
        println ("\nGenerate triples under " n)
        allSame <|timeIt(g,n,true) | g<-generators|>
        n += stride
    end
(* once striding is implemented ...
    for n<-seq(min:max:stride) do
        println ("\nGenerate triples under " n)
        allSame <|timeIt(g,n,true) | g<-generators|>
    end
*)
end

end trips
