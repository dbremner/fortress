(* Satisfiability Library using DPLL with Watched Literals *)

component Satisfiability
import File.{...}
import List.{...}
export Satisfiability

(*
    Function parseLine parses a line and returns a list.
*)

parseLine(e:List[\ZZ32\], l:String, s:ZZ32, n:ZZ32) =
        if |l| = 0 then
                e
        elif l[0] = 'c' OR l[0] = 'p' then
                e
        else
                c = l[0]
                if c = '-' then
                        parseLine(e, l[1:], -s, n)
                elif c = '0' then
                        parseLine(e, l[1:], s, 10 n + 0)
                elif c = '1' then
                        parseLine(e, l[1:], s, 10 n + 1)
                elif c = '2' then
                        parseLine(e, l[1:], s, 10 n + 2)
                elif c = '3' then
                        parseLine(e, l[1:], s, 10 n + 3)
                elif c = '4' then
                        parseLine(e, l[1:], s, 10 n + 4)
                elif c = '5' then
                        parseLine(e, l[1:], s, 10 n + 5)
                elif c = '6' then
                        parseLine(e, l[1:], s, 10 n + 6)
                elif c = '7' then
                        parseLine(e, l[1:], s, 10 n + 7)
                elif c = '8' then
                        parseLine(e, l[1:], s, 10 n + 8)
                elif c = '9' then
                        parseLine(e, l[1:], s, 10 n + 9)
                elif c = ' ' then
                        if n =/= 0 then
                                parseLine((e || <|[\ZZ32\] s n|>), l[1:], 1, 0)
                        else
                                parseLine(e, l[1:], s, n)
                        end
                end
        end

(*
    Function parseFile reads from a FileReadStream and returns
    a list of lists.
*)

parseFile(f:FileReadStream) = 
        if f.ready then
                l = f.readLine()
                e = parseLine(<|[\ZZ32\]|>, l, 1, 0)
                if |e| > 0 then
                        (<|e|> || parseFile(f))
                else
                        parseFile(f)
                end
        else
                <|[\List[\ZZ32\]\]|>
        end

(*
    Function readQuery receives a filename and reads SAT problem in DIMACS format.
*)

readQuery(filename:String) = do
        f = FileReadStream(filename)
        q = parseFile(f)
        f.close()
        q
end

(*
    Function unitPropagation finds values of free variables in unit clauses.
*)

unitPropagation(f, theta) = 
do
        (*) remove unnecessary clauses
        lst = f.filter(fn h => |h.filter(fn h'' => h'' IN theta)| = 0)
        (*) remove unnecessary literals
        lst' = <| h.filter(fn h' => NOT (-h' IN theta)) | h <- lst |>
        (*) make literals in unit clauses true by assigning appropriate values to variables
        theta' = <| k | k' <- lst', k <- k', |k'| = 1 |>
        (*) return the result
        (lst', theta')
end

(*
    Function isSatisfied returns true
    if no clause in the formula has no true literal.
    It returns false otherwise.
*)

isSatisfied(f, theta) = |f.filter(fn g => (|g.filter(fn h => h IN theta)| = 0))| = 0

(*
    Function isConflictin returns 1
    if a clause in the formula has no literal or all false literals.
    It returns 0 otherwise.
*)

isConflicting(f, theta) = label found

        for h <- f do
                if |h| = 0 then exit found with 1 
                elif |h.filter(fn h' => NOT (-h' IN theta))| = 0 then exit found with 1 
                end
        end
        0
end found

(*
    Function chooseFreeVariable returns a free variable.
*)

chooseFreeVariable(f, theta) = label found
        for g <- f, h <- g, NOT (h IN theta), NOT (-h IN theta) do
                exit found with |h|
        end
        0 
end found

(*
    Function dpll solves satisfiability problem using DPLL algorithm.
*)

dpll(f, theta) =
do
        (f', t) = unitPropagation(f, theta)
        theta':List[\ZZ32\] = (theta || t)
        if isConflicting(f', theta') = 1 then
                <|[\ZZ32\] 0|>
        elif (isSatisfied(f', theta')) then
                theta'
        else
                x = chooseFreeVariable(f', theta')
                theta'':List[\ZZ32\] = dpll(f', theta'.addRight(x))
                if (theta'' =/= <|[\ZZ32\] 0|>) then
                        theta''
                else
                        dpll(f', theta'.addRight(-x))
                end
        end
end

(*
    Function satisfiability is a wrapper for dpll.
*)

satisfiability(f:List[\List[\ZZ32\]\]):List[\ZZ32\] = dpll(f, <|[\ZZ32\]|>)

end

