(*******************************************************************************
Copyright 2010 Michael Zody and Sun Microsystems, Inc. 
All rights reserved.

Sun Microsystems, Inc. is the Copyright owner of the Fortress programming language software, and Michael Zody is the developer of the algorithm which this software implements and the Copyright owner of the software implementation of the algorithm, to which Sun Microsystems, Inc. has a perpetual, irrevocable, royalty free right and license to use and distribute. 

Use is subject to license terms accompanying the software.

 ******************************************************************************)

component BirdCount1jy
import File.{...}
import FileSupport.{...}
import FlatString.{...}
import List.{...}
import Map.{...}
import Set.{...}
import System.{getProperty}

export Executable

inverseConversion:Map[\String,Char\] =
    {[\String, Char\]
        "A0" |-> 'A',
        "A1" |-> 'C',
        "A2" |-> 'G',
        "A3" |-> 'T',
        "C0" |-> 'C',
        "C1" |-> 'A',
        "C2" |-> 'T',
        "C3" |-> 'G',
        "G0" |-> 'G',
        "G1" |-> 'T',
        "G2" |-> 'A',
        "G3" |-> 'C',
        "T0" |-> 'T',
        "T1" |-> 'G',
        "T2" |-> 'C',
        "T3" |-> 'A'
    }

(* if I could read these in from the file I would, but I don't know how to convert a string to an RR64 *)

singleErrorRates:Map[\String,Map[\ZZ32,RR64\]\] =
     {[\String, Map[\ZZ32, RR64\]\]
    "10a_LA_Frag35_20080704_white_leghorn_A" |-> 
                {[\ZZ32,RR64\] 0 |-> 0.00134,
                               1 |-> 0.00045, 
                               2 |-> 0.00039, 
                               3 |-> 0.00073, 
                               4 |-> 0.00021, 
                               5 |-> 0.00012, 
                               6 |-> 0.00008, 
                               7 |-> 0.00006, 
                               8 |-> 0.00010, 
                               9 |-> 0.00015, 
                               10 |-> 0.00011, 
                               11 |-> 0.00007, 
                               12 |-> 0.00007, 
                               13 |-> 0.00007, 
                               14 |-> 0.00010, 
                               15 |-> 0.00016, 
                               16 |-> 0.00012, 
                               17 |-> 0.00010, 
                               18 |-> 0.00011, 
                               19 |-> 0.00017, 
                               20 |-> 0.00027, 
                               21 |-> 0.00022, 
                               22 |-> 0.00022, 
                               23 |-> 0.00023, 
                               24 |-> 0.00034, 
                               25 |-> 0.00060, 
                               26 |-> 0.00060, 
                               27 |-> 0.00062, 
                               28 |-> 0.00060, 
                               29 |-> 0.00095, 
                               30 |-> 0.00161, 
                               31 |-> 0.00184, 
                               32 |-> 0.00225, 
                               33 |-> 0.00265, 
                               34 |-> 0.00000 },
    "10b_LA_Frag35_20080704_white_leghorn_B" |-> 
                {[\ZZ32,RR64\] 0 |-> 0.00028,
                               1 |-> 0.00012, 
                               2 |-> 0.00010, 
                               3 |-> 0.00012, 
                               4 |-> 0.00010, 
                               5 |-> 0.00012, 
                               6 |-> 0.00007, 
                               7 |-> 0.00006, 
                               8 |-> 0.00007, 
                               9 |-> 0.00007, 
                               10 |-> 0.00010, 
                               11 |-> 0.00008, 
                               12 |-> 0.00007, 
                               13 |-> 0.00008, 
                               14 |-> 0.00009, 
                               15 |-> 0.00014, 
                               16 |-> 0.00011, 
                               17 |-> 0.00010, 
                               18 |-> 0.00012, 
                               19 |-> 0.00014, 
                               20 |-> 0.00023, 
                               21 |-> 0.00023, 
                               22 |-> 0.00022, 
                               23 |-> 0.00022, 
                               24 |-> 0.00032, 
                               25 |-> 0.00056, 
                               26 |-> 0.00058, 
                               27 |-> 0.00056, 
                               28 |-> 0.00063, 
                               29 |-> 0.00088, 
                               30 |-> 0.00283, 
                               31 |-> 0.00282, 
                               32 |-> 0.00151, 
                               33 |-> 0.00252, 
                               34 |-> 0.00000 }
}

multipleErrorRates:Map[\String,Map[\ZZ32,RR64\]\] =
     {[\String, Map[\ZZ32, RR64\]\]
    "10a_LA_Frag35_20080704_white_leghorn_A" |-> 
                {[\ZZ32,RR64\] 0 |-> 0.04331,
                               1 |-> 0.03910,
                               2 |-> 0.01894, 
                               3 |-> 0.02443, 
                               4 |-> 0.03466, 
                               5 |-> 0.00876, 
                               6 |-> 0.01211, 
                               7 |-> 0.00658, 
                               8 |-> 0.00796, 
                               9 |-> 0.01411, 
                               10 |->0.01342, 
                               11 |->0.01010, 
                               12 |->0.00846, 
                               13 |->0.00907, 
                               14 |->0.00952, 
                               15 |->0.01544, 
                               16 |->0.01709, 
                               17 |->0.01165, 
                               18 |->0.01247, 
                               19 |->0.01336, 
                               20 |->0.02285, 
                               21 |->0.02293, 
                               22 |->0.01948, 
                               23 |->0.02129, 
                               24 |->0.02037, 
                               25 |->0.03367, 
                               26 |->0.03527, 
                               27 |->0.03708, 
                               28 |->0.03491, 
                               29 |->0.03672, 
                               30 |->0.05487, 
                               31 |->0.06012, 
                               32 |->0.07016, 
                               33 |->0.06959, 
                               34 |->0.07209},
    "10b_LA_Frag35_20080704_white_leghorn_B" |-> 
                {[\ZZ32,RR64\] 0 |-> 0.00895, 
                               1 |-> 0.00954, 
                               2 |-> 0.00664, 
                               3 |-> 0.00843, 
                               4 |-> 0.00863, 
                               5 |-> 0.00850, 
                               6 |-> 0.01045, 
                               7 |-> 0.00593, 
                               8 |-> 0.00825, 
                               9 |-> 0.00757, 
                               10 |->0.01032, 
                               11 |->0.01131, 
                               12 |->0.00809, 
                               13 |->0.00928, 
                               14 |->0.00915, 
                               15 |->0.01354, 
                               16 |->0.01589, 
                               17 |->0.01044, 
                               18 |->0.01367, 
                               19 |->0.01300, 
                               20 |->0.01934, 
                               21 |->0.02271, 
                               22 |->0.01978, 
                               23 |->0.01934, 
                               24 |->0.02105, 
                               25 |->0.03057, 
                               26 |->0.03541, 
                               27 |->0.03346, 
                               28 |->0.03289, 
                               29 |->0.03943, 
                               30 |->0.04918, 
                               31 |->0.13046, 
                               32 |->0.05682, 
                               33 |->0.05955, 
                               34 |->0.07790 }
}

var coverage:Map[\String, Map[\ZZ32,ZZ32\]\]:= {[\String, Map [\ZZ32, ZZ32\] \] }

referenceChickenFile:String = getProperty("fortress.automhome",".") || "/ProjectFortress/demos/chickenData/chr10.fa.head" 
sampleFilesDir:String = getProperty("fortress.automhome",".") || "/ProjectFortress/demos/chickenData/test_data"
sampleFilesFileName:String = "chr10.csfasta.ma.sorted.head"
errorFilesFileName:String = "composite_error_model.txt"

sampleChickens:List[\String\] = <|[\String\]
    "10a_LA_Frag35_20080704_white_leghorn_A",
    "10b_LA_Frag35_20080704_white_leghorn_B"
(*    "17_LA_Frag35_20080909_high_grow_line",
    "18_LA_Frag35_20080909_low_grow_line",
    "17.1_LA_Frag35_20080925_high_grow_line",
    "18.1_LA_Frag35_20080925_low_grow_line",
    "16_LA_Frag35_20080829_broiler",
    "22_LA_Frag35_20081016_RJF",
    "16.1_LA_Frag35_20080925_broiler",
    "22.1_LA_Frag35_20081114_RJF" *)
|>

encodeACGT(c: Char): ZZ32 = case c of 'A' => 0; 'C' => 1; 'G' => 2; 'T' => 3; end

convert(c1:Char, c2:Char): Char =
    if (c1 = 'N') OR (c2 = 'N') then '4' else char('0'.codePoint + (encodeACGT(c1) BITXOR encodeACGT(c2))) end

object Pairs[\T\](g: Generator[\T\]) extends Generator[\(T,T)\]
    generate[\R\](red: Reduction[\R\], m:(T,T)->R): R =
    if (l,v,r) <- g.generate[\Maybe[\(T,R,T)\]\](PairReduction[\T,R\](red,m),
                             fn (t:T) => Just[\(T,R,T)\](t, red.empty(), t))
        then v else red.empty() end
end

object PairReduction[\T,R\](red: Reduction[\R\], m:(T,T)->R)
        extends Reduction[\Maybe[\(T,R,T)\]\]
    empty():Maybe[\(T,R,T)\] = Nothing[\(T,R,T)\]
    join(left:Maybe[\(T,R,T)\], right:Maybe[\(T,R,T)\]) : Maybe[\(T,R,T)\]=
    if (l, v_l, m_l) <- left then
        if (m_r, v_r, r) <- right then
            Just[\(T,R,T)\](l, red.join(red.join(v_l, m(m_l, m_r)), v_r), r)
        else left end
    else right end
end 


trait dna comprises {dnaSequence, EmptySequence}
       getter colorSequence(): String
       opr OPLUS(self, other: dna) : dna
end


(* left and right are ACGT encoded, middle is color encoded *)

object dnaSequence(left:Char, middle:String, right:Char) extends dna
   getter colorSequence():String = middle
   opr OPLUS(self, other:dnaSequence):dnaSequence =
       dnaSequence(left, middle || convert(right, other.left) || other.middle(), other.right)
   opr OPLUS(self, other:EmptySequence) = self
end

object EmptySequence() extends dna
    getter colorSequence():String = ""
    opr OPLUS(self, other:dna) = other
end

object dnaSequenceReduction extends { MonoidReduction[\dna\],
                               ReductionWithZeroes[\dna,dna\] }
    getter asString() = "dnaSequenceReduction"
    empty(): dna = EmptySequence()
    join(a: dna, b: dna): dna = a OPLUS b
end

opr BIG OPLUS[\T\](): BigReduction[\dna, dna\] =
   BigReduction[\dna,dna\](dnaSequenceReduction)

opr BIG OPLUS[\T\](g:Generator[\dna\]) = 
   __bigOperatorSugar[\dna,dna,dna,dna\](BIG OPLUS[\T\](), g)


processReferenceFileLine(input:String):dna = do
    if input[0] = '>' 
        then EmptySequence()
    else 
        n = |input|
        dnaSequence(input[0], BIG || [p<- Pairs(input)](convert(p)), input[n-1])
    end
end

readReferenceFileLine(input:String):String = do
    if input[0] = '>' 
        then ""
    else 
        input
    end
end

processReferenceFile(name:String):String=do
   var rs:FileReadStream = FileReadStream(name)
   var res:dna  = BIG OPLUS [l<-rs.lines()] processReferenceFileLine(l)
   colors = res.colorSequence()
   colors
end

readReferenceFile(name:String):String=do
   var rs:FileReadStream = FileReadStream(name)
   var res:String = BIG || [l<-rs.lines()] readReferenceFileLine(l)
   res
end

object Snip(header:String, sequence:String, name:String, pos:ZZ32, length:ZZ32, seqend:ZZ32, 
            referenceChickenColorsSnip:String, sampleChickenColorsSnip:String,
            referenceChickenACGTSnip:String) 
    getter header():String = header
    getter sequence():String = sequence
    getter name():String = name
    getter pos():ZZ32 = pos
    getter length():ZZ32 = length
    getter seqend():ZZ32 = seqend
    getter referenceChickenColorsSnip():String = referenceChickenColorsSnip
    getter sampleChickenColorsSnip():String = sampleChickenColorsSnip
    getter referenceChickenACGTSnip():String = referenceChickenACGTSnip    
    getter asString():String = pos || "  " || name || "  " || referenceChickenColorsSnip || "  " sampleChickenColorsSnip || "  " || referenceChickenACGTSnip 

    sampleChickenACGTSnip():String =
        (referenceChickenACGTSnip[0] ||
            (BIG ||[i <- sampleChickenColorsSnip.indices]
                inverseConversion[referenceChickenACGTSnip[0].asString ||
                                  char('0'.codePoint BITOR (BIG BITXOR[j <- 0#(i+1)] (sampleChickenColorsSnip[i].codePoint BITAND 3)))]))

    printSnip():() = do
        println("Snip:" name pos() "  ")
        println(" " referenceChickenColorsSnip)
        println(" " sampleChickenColorsSnip)
        println(referenceChickenACGTSnip)
(*        println(sampleChickenACGTSnip())  *)
    end


end

reverse(sequence:String):String = BIG || [c<-sequence.reverse()] c

negativeOrientation(header:String):Boolean =  do
   pattern:String = ">\\w*,\\d*_-.*"
   header.javaRegExpMatches(pattern)
end

getAdjustedLocation(negativeOri:Boolean, location:String, length:ZZ32):ZZ32 = do
   if (negativeOri) then
      strToInt(location.asFlatString().javaSubstr(1), 10) - length + 1        
   else 
      strToInt(location) - 1
   end
end

getReferenceChickenColorsSnip(adjustedLoc:ZZ32, seqEnd:ZZ32):FlatString = do
   referenceChickenColors[adjustedLoc:seqEnd+1].asFlatString()
end

getAdjustedSequence(negativeOri:Boolean, sequence:String, refChickenColorsSnip:FlatString):FlatString = do
    temp:FlatString = sequence.asFlatString().javaSubstr(1)
    tempLength:ZZ32 = |temp|
    if (negativeOri) then
        ((reverse(temp).asFlatString().javaSubstr(0, tempLength - 1 )).asFlatString() || refChickenColorsSnip.asFlatString().javaSubstr(tempLength - 1, tempLength).asFlatString()).asFlatString()
    else
        (refChickenColorsSnip.asFlatString().javaSubstr(0,1) || temp.asFlatString().javaSubstr(1).asFlatString()).asFlatString()
    end
end


readASnip(r:ReadStream):Snip = do
   header:String = r.uncheckedReadLine()
   var sequence:String = r.uncheckedReadLine()

   if sequence = "" then Snip(header, sequence,"", 0, 0, 0, "","","") else
      name:String = header.asFlatString().javaRegExpSplit(",",0)
      loc:String = header.asFlatString().javaRegExpSplit(",",1).asFlatString().javaRegExpSplit("_",1).asFlatString().javaRegExpSplit("\\.",0)
      length:ZZ32 = sequence.asFlatString().size() - 1
      negativeOri:Boolean = negativeOrientation(header)
      adjustedLocation:ZZ32 = getAdjustedLocation(negativeOri, loc, length)
      sequenceEnd:ZZ32 = adjustedLocation + length - 1
      referenceChickenColorsSnip:FlatString = getReferenceChickenColorsSnip(adjustedLocation, sequenceEnd)
      adjustedSequence:FlatString := getAdjustedSequence(negativeOri, sequence, referenceChickenColorsSnip)
      referenceChickenACGTSnip:String = referenceChickenACGT.asFlatString().javaSubstr(adjustedLocation, sequenceEnd + 2)

      Snip(header, adjustedSequence, name, adjustedLocation, length, sequenceEnd, referenceChickenColorsSnip, adjustedSequence, referenceChickenACGTSnip)
   end
end

ChunkSize:ZZ32 = 10000


(* Given two samples, this creates a list of the positions where they differ *)

object Event(s:Snip, diffs:String, startPos:ZZ32, endPos:ZZ32, errorProb:RR64, fileName:String)
    getter snip():Snip = s
    getter startPos():ZZ32 = startPos
    getter endPos():ZZ32 = endPos
    getter diffs():String = diffs
    getter asString():String = do
      var result:String := fileName || "    " || refStart() || "    " || refEnd() || "    " 
      result := result || referenceChickenColorsSnip() || "    " || sampleChickenColorsSnip() || "   "
      result := result || refChickenACGTSnip() || "    " || sampleChickenDiffSnip() || "   "
      result := result || errorProb
      result
    end
    getter errorProb():RR64 = errorProb
    getter fileName():String = fileName
    valid():Boolean =  isValidTransition(s, startPos,diffs)
    refStart():ZZ32 = s.pos() + startPos
    refEnd():ZZ32 = refStart() + endPos - 1

    referenceChickenColorsSnip() = s.referenceChickenColorsSnip.javaSubstr(startPos, endPos + startPos) 
    sampleChickenColorsSnip() = s.sampleChickenColorsSnip.javaSubstr(startPos, endPos + startPos) 


    sampleChickenDiffSnip():String = do
       var i:ZZ32 := 0
       var c:Char := s.referenceChickenACGTSnip[startPos]
       var result:String :=  c.asString()
       while (i < endPos) do
          next:Char = inverseConversion[c.asString() || s.sampleChickenColorsSnip[i + startPos].asString]
          result := result || next
          c := next
          i := i+1
       end
       result
    end

(*
    sampleChickenDiffSnip():String =
        (s.referenceChickenACGTSnip[startPos] ||
            (BIG ||[i <- 0 # endPos]
                inverseConversion[s.referenceChickenACGTSnip[startPos].asString ||
                                  char('0'.codePoint BITOR (BIG BITXOR[j <- 0#(i+1)] (sampleChickenColorsSnip[j+startPos].codePoint BITAND 3)))]))
*)
    refChickenACGTSnip():String = s.referenceChickenACGTSnip.javaSubstr(startPos, endPos+startPos+1)

    printEvent():() = do
       eventStart:ZZ32 = s.pos() + startPos
       eventEnd:ZZ32 = eventStart + endPos - 1
       snipEnd:ZZ32 = endPos + startPos
       
       print(s.header() "  " errorProb " "  eventStart "  " eventEnd "  ")
       print(s.referenceChickenColorsSnip.javaSubstr(startPos, snipEnd) "  ")
       print(s.sampleChickenColorsSnip.javaSubstr(startPos, snipEnd) "  ")
       if valid() then
          print "VALID" 
          print("  " refChickenACGTSnip() "   ")
          print(sampleChickenDiffSnip())
       else
          print "inv" 
          print("  " refChickenACGTSnip() "   ")
          xs:String = "xxxxxxxxxxxxxxxxxx"
          print(xs.javaSubstr(0, endPos+1))
       end
       println("    " startPos) 
    end
end

object MergedEvent(count:ZZ32, refStart:ZZ32, refEnd:ZZ32, 
                    referenceNumberFormat:String, sampleNumberFormat:String,
                    referenceACGTFormat:String, sampleACGTFormat:String,
                    totalCoverage:RR64,
                    probability:RR64, eventList:List[\Event\])
  getter count():ZZ32 = count
  getter refStart():ZZ32 = refStart
  getter refEnd():ZZ32 = refEnd
  getter referenceNumberFormat():String = referenceNumberFormat
  getter sampleNumberFormat():String = sampleNumberFormat
  getter referenceACGTFormat():String = referenceACGTFormat
  getter sampleACGTFormat():String = sampleACGTFormat
  getter totalCoverage():RR64 = totalCoverage
  getter probability():RR64 = probability
  getter eventList():List[\Event\] = eventList
  getter asString():String = do
      var result:String = count || "  " 
      result := result || refStart || "  " || refEnd || "  "
      result := result || referenceNumberFormat || "  " || sampleNumberFormat || "  "
      result := result || referenceACGTFormat || "  " || sampleACGTFormat || "  "
      result := result || totalCoverage || "  " 
      result := result || probability || "  "
      result
  end
end

opr UNIONCAT[\T\](a: Map[\T, List[\Event\]\], b: Map[\T, List[\Event\]\]): Map[\T, List[\Event\]\] =
    a.union(fn(k,x,y) => x || y, b)

opr BIG UNIONCAT[\T\](): BigReduction[\Map[\T, List[\Event\]\],Map[\T, List[\Event\]\]\] =
    embiggen[\Map[\T, List[\Event\]\]\](fn(a,b) => a UNIONCAT b, {[\T,List[\Event\]\]})
   
opr UNIONPLUS[\T\](a: Map[\T, ZZ32\], b: Map[\T, ZZ32\]): Map[\T, ZZ32\] =
    a.union(fn(k,x,y) => x + y, b)

opr BIG UNIONPLUS[\T\](): BigReduction[\Map[\T, ZZ32\],Map[\T, ZZ32\]\] =
    embiggen[\Map[\T, ZZ32\]\](fn(a,b) => a UNIONPLUS b, {[\T,ZZ32\]})

makeDatabase(e:Event):Map[\String,List[\Event\]\] = do
   var database:Map[\String, List[\Event\]\] := {[\String, List[\Event\]\]}
   database := database.add(e.fileName(), <|[\Event\] e |>)
   database
end

makeChangeDatabase(e:Event):Map[\String,List[\Event\]\] = do
   var database:Map[\String, List[\Event\]\] := {[\String, List[\Event\]\]}
   database := database.add(e.sampleChickenDiffSnip(),  <|[\Event\] e |>)
   database
end

(* This may change with newer technology, but for now it is OK. *)
readSize:ZZ32 = 35

calculateCoverage(fileName:String, refEnd:ZZ32):ZZ32 =
    SUM[i <- seq(refEnd - readSize + 1 : refEnd)] coverage[fileName].member(i,0)

(*
calculateBonferroniLibrary(fileName:String, events:List[\Event\]):RR64 = do
   count:ZZ32 = |events|
   first:Event = events.left().get()
   probability: RR64 := PROD[event <- seq(events)] event.errorProb
   var gmp: RR64 := probability^(1.0/count)
   cov:ZZ32 = calculateCoverage(fileName, first.refEnd())
   SUM[j <- seq(count:cov)] ((gmp^j) comb(cov, j))
end

calculateBonferroniLibrary(fileName:String, events:List[\Event\]):RR64 = do
   gmp = (PROD[event <- events] event.errorProb)^(1.0/(|events|))
   cov = calculateCoverage(fileName, events.left().get().refEnd())
   SUM[j <- seq(count:cov)] ((gmp^j) comb(cov, j))
end
*)

calculateBonferroniLibrary(fileName:String, events:List[\Event\]):RR64 = do
   gmp = geometricMean <|[\RR64\] e.errorProb | e <- events |>
   cov = calculateCoverage(fileName, events.left().get().refEnd())
   SUM[j <- seq((|events|):cov)] gmp^j comb(cov, j)
end

geometricMean(xs: List[\RR64\]) = (PROD xs)^(1.0/(|xs|))

calculateBonferroniTotal(EventsByFile:Map[\String, List[\Event\]\]):RR64 = do
   totcov = SUM[(file, events) <- EventsByFile] calculateCoverage(file, events.left().get().refEnd())
   totcalls = SUM[(_, events) <- EventsByFile] |events|
   gmp = geometricMean <|[\RR64\] e.errorProb | (_, events) <- seq(EventsByFile), e <- seq(events) |>
   SUM[j <- seq(totcalls:totcov)] gmp^j comb(totcov, j)   
end

calculateBonferroni(EventsByFile:Map[\String, List[\Event\]\]):RR64 = do
   minlibpval: RR64 = BIG MIN[(file, events) <- EventsByFile] calculateBonferroniLibrary(file, events)
   combpval: RR64 = calculateBonferroniTotal(EventsByFile)
   2 (combpval MIN minlibpval)
end

maybeUpdateMergedDatabase(mergedDatabase:Map[\(ZZ32, String),List[\MergedEvent\]\],
                          key:ZZ32, entryList:List[\Event\]):Map[\(ZZ32,String),  List[\MergedEvent\]\] = do
   var resultMergedDatabase:Map[\(ZZ32, String), List[\MergedEvent\]\] := mergedDatabase
   validEvents:List[\Event\] := <|[\Event\] event | event <- entryList, event.valid() |>
   EventsByChange:Map[\String, List[\Event\]\] := BIG UNIONCAT[\String\] [event <- validEvents] makeChangeDatabase(event)

   for (change, changeEvents) <- seq(EventsByChange) do
      EventsByFile:Map[\String, List[\Event\]\] := BIG UNIONCAT[\String\] [event <- changeEvents] makeDatabase(event)
      var mergedEvents:List[\MergedEvent\] := <|[\MergedEvent\]|>

      if (|changeEvents| > 0) then
         firstEvent:Event = changeEvents.left().get()
         probability:RR64 := calculateBonferroni(EventsByFile)
         totalCoverage:ZZ32 := SUM[(file, events) <- EventsByFile] calculateCoverage(file, events.left().get().refEnd()) 
   
         snipPos = firstEvent.snip().pos()
         refStart = firstEvent.refStart()
         refEnd = firstEvent.refEnd()
         referenceNumberFormat = firstEvent.referenceChickenColorsSnip()
         sampleNumberFormat = firstEvent.sampleChickenColorsSnip()
         referenceACGTFormat = firstEvent.refChickenACGTSnip()
         sampleACGTFormat = firstEvent.sampleChickenDiffSnip()

         me:MergedEvent = MergedEvent(|changeEvents|, refStart, refEnd, 
                                referenceNumberFormat, sampleNumberFormat,
                                referenceACGTFormat, sampleACGTFormat,
                                totalCoverage, probability, changeEvents)
         mergedEvents :=  mergedEvents || <| me |>
         resultMergedDatabase := resultMergedDatabase.update((key, change), mergedEvents)
      end
   end
   resultMergedDatabase
end
   


(* This code is a little obtuse.  The idea is that if the sample differs from the reference 
   chicken in more than one consecutive location it may be an interesting mutation.  We look
   for these potential interesting mutations and return a list of them.
 *)

makeEvent(s:Snip, basicDiffs:String, diffs:String, loc:ZZ32, name:String):Event = do
   var index:ZZ32 = loc
   while (index < |diffs| AND: diffs[index] = 'X') do index := index + 1 end
   len = index - loc
   errorProb = if (len = 2) then
                 (singleErrorRates[name])[loc]
               else
                 PROD[i <- seq(loc#len), basicDiffs[i] = 'X'] (multipleErrorRates[name])[i]
               end
   Event(s, diffs, loc, len, errorProb, name)
end   

isSingletonX(loc:ZZ32, diffs:String):Boolean =  
   if loc = |diffs| - 1 then true
   elif diffs[loc] = 'X' AND: diffs[loc+1] = '.' then true
   else false
   end

isInterestingPosition(loc:ZZ32, diffs:String):Boolean = do
   len:ZZ32 = |diffs|
   if loc = 0 AND: diffs[0] = 'X' AND: diffs[1] = 'X' then true
   elif loc = 0 then false
   elif loc = (len - 1) then false
   elif diffs[loc] = '.'  OR: (diffs[loc-1] = 'X') OR: isSingletonX(loc, diffs) then
      false
   else true
   end
end

isValidTransition(reference:String, sample:String) =
    BIG AND[i <- 0 # |reference| - 1]  ((reference[i].codePoint BITXOR reference[i+1].codePoint) = (sample[i].codePoint BITXOR sample[i+1].codePoint))

isValidTransition(s:Snip, loc:ZZ32, diffs:String):Boolean = do
   len:ZZ32 := loc
   while (len < ((|diffs|) - 1) AND: diffs[len] = 'X') do len := len + 1 end
   sample:String = s.sampleChickenColorsSnip().javaSubstr(loc, len)
   reference:String = s.referenceChickenColorsSnip().javaSubstr(loc, len)
   isValidTransition(reference, sample)
end

isInteresting(s:Snip, loc:ZZ32, diffs:String): Boolean = isInterestingPosition(loc, diffs)

sampleCompare(ref:String, sample:String):String = do
   BIG || [(x,y) <- ref.zip[\Char\](sample)] (if (x =/= y) then "X" else "." end)
end

(* X.X should be replaced with XXX *)
factorOutProblemChildren(diffs:String) = do
   var index:ZZ32 := 2
   var result:String := ""
   if diffs.asFlatString().javaSubstr(0,4) = "X.XX" then 
      result := result || "XX" 
   else result := result || diffs[0] || diffs[1]
   end

   while (index < |diffs| - 2) do
      if diffs[index] = 'X' then result := result || "X"
      elif diffs.asFlatString().javaSubstr(index-2, index+3) = ".X.X." then
         result := result || "X"
      elif diffs.asFlatString().javaSubstr(index-2, index+3) = ".X.XX" then
         result := result || "X"
      elif diffs.asFlatString().javaSubstr(index-2, index+3) = "XX.X." then
         result := result || "X"
      (*) The following case was not in BirdCount0
      elif diffs.asFlatString().javaSubstr(index-2, index+3) = "XX.XX" then
         result := result || "X"
      else result := result || "."
      end
      index := index + 1
   end 

(* The following code wreaks havoc and destruction or at least confuses the interpreter.
   if diffs.asFlatString().javaSubstr(index - 2, 4) = "XX.X" then
*)

   if diffs[index-2] =  'X' AND: diffs[index-1] = 'X' AND: diffs[index] = '.' AND: diffs[index+1] = 'X' then
        ()
 (*)     result := result || "XX"
   else 
      result := result || diffs[|diffs| - 2] || diffs[|diffs| - 1]  
   end

   result
end   

(* Given two samples this creates events *)

eventGenerator(s:Snip, name:String) = do
    basicDiffs = sampleCompare(s.referenceChickenColorsSnip(),s.sampleChickenColorsSnip())
    diffs = factorOutProblemChildren(basicDiffs)

    BIG UPLUS[\ZZ32, List[\Event\]\][x <- 0 # |diffs|, isInteresting(s,x,diffs)] {[\ZZ32, List[\Event\]\] x + s.pos() |-> <| makeEvent(s, basicDiffs, diffs, x, name) |> }
end

trait SampleEvents comprises { MatchRun, RangeSet }
  getter ranges(): List[\CompactFullRange[\ZZ32\]\]
  opr ZAMJAX(self, x: SampleEvents): SampleEvents
end

object MatchRun(n: ZZ32) extends SampleEvents
  getter ranges() = <|[\CompactFullRange[\ZZ32\]\] |>
  opr ZAMJAX(self, other: MatchRun) = MatchRun(n + other.n)
  opr ZAMJAX(self, other: RangeSet) = RangeSet(n + other.left, other.ranges, other.right)
end

object RangeSet(left: ZZ32, ranges: List[\CompactFullRange[\ZZ32\]\], right: ZZ32) extends SampleEvents
  getter ranges() = ranges
  opr ZAMJAX(self, other: MatchRun) = RangeSet(left, ranges, right + other.n)
  opr ZAMJAX(self, other: RangeSet) =
    if right + other.left >= 2 then
      RangeSet(left, ranges || other.ranges, other.right)
    else
      (ps, p) = ranges.extractRight.get()
      (q, qs) = other.ranges.extractLeft.get()
      RangeSet(left, ps || <| p.left.get():q.right.get() |> || qs, other.right)
    end
end


object SampleEventsSequenceReduction extends { MonoidReduction[\SampleEvents\],
                               ReductionWithZeroes[\SampleEvents,SampleEvents\] }
    getter asString() = "SampleEventsSequenceReduction"
    empty(): SampleEvents = MatchRun(0)
    join(a: SampleEvents, b: SampleEvents): SampleEvents = a ZAMJAX b
end

opr BIG ZAMJAX[\T\](): BigReduction[\SampleEvents, SampleEvents\] =
   BigReduction[\SampleEvents,SampleEvents\](SampleEventsSequenceReduction)

opr BIG ZAMJAX[\T\](g:Generator[\SampleEvents\]) = 
   __bigOperatorSugar[\SampleEvents,SampleEvents,SampleEvents,SampleEvents\](BIG ZAMJAX[\T\](), g)

singleSampleMatch = MatchRun(1)

(*
eventGenerator(s:Snip, name:String): Map[\ZZ32, List[\Event\]\] = do
   ref = s.referenceChickenColorsSnip()
   sample = s.sampleChickenColorsSnip()
   events = (BIG ZAMJAX[i <- 0 # |sample|] (if sample[i]=ref[i] then singleSampleMatch else RangeSet(0, <|[\CompactFullRange[\ZZ32\]\] i:i |>, 0) end))
   {[\ZZ32, List[\Event\]\] s.pos + r.lower |-> <|[\Event\] Event(s, makeDiffString(events), r.lower, |r|, errorProbability(ref, sample, r, name), name) |> | r <- events.ranges, |r| > 1 }
end
*)

errorProbability(ref: String, sample: String, r: CompactFullRange[\ZZ32\], name: String) =
    if (|r| = 2) then
        (singleErrorRates[name])[r.lower]
    else
        PROD[i <- seq(r), sample[i] =/= ref[i]] (multipleErrorRates[name])[i]
    end

makeDiffString(es: MatchRun): String = (".")^(es.n)

makeDiffString(es: RangeSet): String =
  ((".")^(es.left) ||
   ("X")^(|es.ranges[0]|) ||
   (BIG || [(r, s) <- Pairs(es.ranges)] ((".")^(s.lower-r.upper-1) || (("X")^(|s|)))) ||
   (".")^(es.right))
 

combine(k:ZZ32, val1:List[\Event\], val2:List[\Event\]):List[\Event\] = val1 || val2

processSampleChicken(name:String): (Map[\ZZ32, List[\Event\]\], Map[\String, Map[\ZZ32, ZZ32\]\]) = do
    rs: FileReadStream = FileReadStream(sampleFilesDir || "/" || name || "/" || sampleFilesFileName)
    fg: FileGenerator[\Snip\]  = FileGenerator[\Snip\](rs, 60, readASnip)
    snipData = <| (eventGenerator(snip, name), snip.pos) | snip <- fg |>
    database = BIG UNIONCAT[\ZZ32\][sd <- snipData] first(sd)
    coverageDatabase = BIG UNIONPLUS[\ZZ32\][sd <- snipData] {[\ZZ32, ZZ32\] second(sd) |-> 1 }
    (database, {[\String, Map[\ZZ32, ZZ32\]\] name |-> coverageDatabase })
end

var referenceChickenColors:String := ""
var referenceChickenACGT:String := ""


(* This is a simple port of the perl code. I have no idea what it does *)

comb(n:ZZ32, m:ZZ32) = do
   var k:ZZ32 := n - m
   var m1:ZZ32 := m
   if (k > m) then (k,m1) := (m,k) end
   var prod:RR64 := 1.0
   var i:ZZ32 := n
   var j:ZZ32 := k
   while (i > m1) do
      prod := prod (i/j)
      i := i - 1
      j := j - 1
   end
   prod
end


run() = do

    referenceChickenACGT   := readReferenceFile(referenceChickenFile)
    referenceChickenColors := processReferenceFile(referenceChickenFile)
    var database:Map[\ZZ32, List[\Event\]\] := {[\ZZ32, List[\Event\]\] } 
    var mergedDatabase:Map[\(ZZ32,String), List[\MergedEvent\]\] := {[\(ZZ32, String), List[\MergedEvent\]\] } 

    for sampleChicken <- seq(sampleChickens) do  (*) Intentionally sequential processing of files
(*)        (db:  Map[\ZZ32, List[\Event\]\], covdb: Map[\String, Map[\ZZ32, ZZ32\]\]) = processSampleChicken(sampleChicken)
        (db, covdb) = processSampleChicken(sampleChicken)
        database UNIONCAT= db
        coverage UPLUS= covdb
    end

    for (key,entries) <- seq(database) do
       mergedDatabase := maybeUpdateMergedDatabase(mergedDatabase, key, entries) 
    end

    println("Events")
    for (_, entries) <- seq(database), entry <- seq(entries) do entry.printEvent() end

    println("Merged Events:")
   
    for (_, events) <- seq(mergedDatabase), event <- seq(events) do
        println(event)
        for e <- seq(event.eventList()) do println(e) end
        println("-------")
    end
end  

end
