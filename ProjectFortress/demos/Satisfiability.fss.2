(* Satisfiability Library with DPLL *)

component Satisfiability
import File.{...}
import List.{...}
export Satisfiability

(*
    Function parseLine parses a line and returns a list.
*)

parseLine(e:List[\ZZ32\], l:String, s:ZZ32, n:ZZ32) =
        if |l| = 0 then
                e
        elif l[0] = 'c' OR l[0] = 'p' then
                e
        else
                c = l[0]
                if c = '-' then
                        parseLine(e, l[1:], -s, n)
                elif c = '0' then
                        parseLine(e, l[1:], s, 10 n + 0)
                elif c = '1' then
                        parseLine(e, l[1:], s, 10 n + 1)
                elif c = '2' then
                        parseLine(e, l[1:], s, 10 n + 2)
                elif c = '3' then
                        parseLine(e, l[1:], s, 10 n + 3)
                elif c = '4' then
                        parseLine(e, l[1:], s, 10 n + 4)
                elif c = '5' then
                        parseLine(e, l[1:], s, 10 n + 5)
                elif c = '6' then
                        parseLine(e, l[1:], s, 10 n + 6)
                elif c = '7' then
                        parseLine(e, l[1:], s, 10 n + 7)
                elif c = '8' then
                        parseLine(e, l[1:], s, 10 n + 8)
                elif c = '9' then
                        parseLine(e, l[1:], s, 10 n + 9)
                elif c = ' ' then
                        if n =/= 0 then
                                parseLine((e || <|[\ZZ32\] s n|>), l[1:], 1, 0)
                        else
                                parseLine(e, l[1:], s, n)
                        end
                end
        end

(*
    Function parseFile reads from a FileReadStream and returns
    a list of lists.
*)

parseFile(f:FileReadStream) = 
        if f.ready then
                l = f.readLine()
                e = parseLine(<|[\ZZ32\]|>, l, 1, 0)
                if |e| > 0 then
                        (<|e|> || parseFile(f))
                else
                        parseFile(f)
                end
        else
                <|[\List[\ZZ32\]\]|>
        end

(*
    Function readQuery receives a filename and reads SAT problem in DIMACS format.
*)

readQuery(filename:String) = do
        f = FileReadStream(filename)
        q = parseFile(f)
        f.close()
        q
end

(*
unitPropagation(f, theta) =
do
        f' = <| g.filter(fn h => NOT (-h IN theta)) | g<-f |>
        f'' = <| g'.left.getDefault(0) | g'<-f', |g'| = 1 |>

        f''
end
*)

unitPropagation(f, theta) = 
do
        lst = f.filter(fn h => |h.filter(fn h'' => h'' IN theta)| = 0)
        lst'' = <| h.filter(fn h' => NOT (-h' IN theta)) | h <- lst |>
        theta' = <| k | k' <- lst'', k <- k', |k'| = 1 |>
        (lst'', theta')
end

isSatisfied(f, theta) = |f.filter(fn g => (|g.filter(fn h => h IN theta)| = 0))| = 0

isConflicting(f, theta) = |f.filter(fn g => (|g.filter(fn h => NOT (-h IN theta))| = 0))| > 0

chooseFreeVariable(f, theta) = <| |h| | g<-f, h<-g, NOT (h IN theta), NOT (-h IN theta) |>.left.getDefault(0)

dpll(f, theta) =
do
        (f', t) = unitPropagation(f, theta)
        theta':List[\ZZ32\] = (theta || t)
        if (isConflicting(f', theta')) then
                <|[\ZZ32\] 0|>
        elif (isSatisfied(f', theta')) then
                theta'
        else
                x = chooseFreeVariable(f', theta')
                theta'':List[\ZZ32\] = dpll(f', theta'.addRight(x))
                if (theta'' =/= <|[\ZZ32\] 0|>) then
                        theta''
                else
                        dpll(f', theta'.addRight(-x))
                end
        end
end

satisfiability(f:List[\List[\ZZ32\]\]):List[\ZZ32\] = dpll(f, <|[\ZZ32\]|>)

end
