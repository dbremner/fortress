(*******************************************************************************
    Copyright 2010 Kang Seonghoon, KAIST
    All rights reserved.
 ******************************************************************************)

export Executable
import Reflect.{...}
import List.{...}
import Set.{...}

trait A end
trait B extends A end
trait C extends A excludes B end
trait D extends {B,C} comprises {E,F} end
object E extends D end
object F extends D end

testType(): () = do
    zz32 = theType[\ZZ32\]()
    rr64 = theType[\RR64\]()
    assert(set join(zz32, rr64) = {[\Type\] rr64}, "incorrect join(" zz32 "," rr64 ")")
    assert(set meet(zz32, rr64) = {[\Type\] zz32}, "incorrect meet(" zz32 "," rr64 ")")
    assert(zz32 SUBTYPEOF zz32, zz32 " <: " zz32 " doesn't hold")
    assert(zz32 SUBTYPEOF rr64, zz32 " <: " rr64 " doesn't hold")
    assert(NOT (rr64 SUBTYPEOF zz32), rr64 " <: " zz32 " (wrongly) hold")

    string = theType[\String\]()
    charlist = theType[\List[\Char\]\]()
    assert(set join(string, charlist) = {[\Type\] theType[\ZeroIndexed[\Char\]\]()},
           "incorrect join(" string "," charlist ")")
    assert(set meet(string, charlist) = {[\Type\] bottomType},
           "incorrect meet(" string "," charlist ")")
    assert(NOT (string SUBTYPEOF charlist), string " <: " charlist " (wrongly) hold")
    assert(NOT (charlist SUBTYPEOF string), charlist " <: " string " (wrongly) hold")

    a = theType[\A\]()
    b = theType[\B\]()
    c = theType[\C\]()
    d = theType[\D\]()
    e = theType[\E\]()
    f = theType[\F\]()
    assert(instanceOf[\TraitType\](a), a " is not a trait type?")
    assert(instanceOf[\ObjectType\](e), e " is not an object type?")
    assert(set a.typeExtends = {[\Type\] objectType}, "incorrect " a ".typeExtends")
    assert(set b.typeExtends = {[\Type\] a}, "incorrect " b ".typeExtends")
    assert(set c.typeExtends = {[\Type\] a}, "incorrect " c ".typeExtends")
    assert(set d.typeExtends = {[\Type\] b, c}, "incorrect " d ".typeExtends")
    assert(set e.typeExtends = {[\Type\] d}, "incorrect " e ".typeExtends")
    assert(set b.typeExcludes INTERSECTION {[\Type\] a,b,c,d,e,f} = {[\Type\] c},
           "incorrect " b ".typeExcludes")
    assert(set c.typeExcludes INTERSECTION {[\Type\] a,b,c,d,e,f} = {[\Type\] b},
           "incorrect " c ".typeExcludes")
    assert(NOT a.typeComprises.holds, "incorrect " a ".typeComprises")
    assert(d.typeComprises.holds AND set d.typeComprises.get = {[\Type\] e, f},
           "incorrect " b ".typeComprises")
    assert(f.typeComprises.holds AND f.typeComprises.get.isEmpty,
           "incorrect " f ".typeComprises")
    assert(set join(b, c) = {[\Type\] a}, "incorrect join(" b "," c ")")
    (* not working correctly for now *)
    (*assert(set meet(b, c) = {[\Type\] d}, "incorrect meet(" b "," c ")")*)

    arrow = theType[\ZZ32->String\]()
    assert(arrow.domain = theType[\ZZ32\](), "incorrect domain for " arrow)
    assert(arrow.range = theType[\String\](), "incorrect range for " arrow)
    assert(instanceOf[\ArrowType\](arrow), arrow " is not an arrow type?")

    tuple = theType[\(Char,Boolean,ZZ32)\]()
    assert(|tuple| = 3, "incorrect length for " tuple)
    assert(tuple[0] = theType[\Char\](), "incorrect value for " tuple)
    assert(tuple[1] = theType[\Boolean\](), "incorrect value for " tuple)
    assert(tuple[2] = theType[\ZZ32\](), "incorrect value for " tuple)
    assert("/".join[\Type\](tuple) = "Char/Boolean/ZZ32", "generator for " tuple " doesn't work")
end

checkTypeOf[\T\](obj:Any): () = do
    objstr = typecase obj of
        ZZ32->ZZ32 => "(function ZZ32->ZZ32)"
        ()->() => "(function ()->())"
        else => "" obj
    end
    assert(typeOf obj SUBTYPEOF theType[\T\](),
           objstr " is not a subtype of " theType[\T\]() " but " typeOf obj)
end

testTypeOf(): () = do
    checkTypeOf[\()\]()
    checkTypeOf[\ZZ32\](42)
    checkTypeOf[\RR64\](3.14)
    checkTypeOf[\Boolean\](true)
    checkTypeOf[\Char\]('c')
    checkTypeOf[\String\]("car")
    checkTypeOf[\((ZZ32,ZZ32),ZZ32)\]((3,4), 5)
    checkTypeOf[\ZZ32->ZZ32\]((fn (x:ZZ32):ZZ32 => 42))
    checkTypeOf[\()->()\](testTypeOf)
    checkTypeOf[\List[\ZZ32\]\](<|[\ZZ32\] 1, 2, 3 |>)
    checkTypeOf[\TraitType\](theType[\A\]())
    checkTypeOf[\ObjectType\](typeOf E)
    checkTypeOf[\ArrowType\](typeOf (fn (x:ZZ32):ZZ32 => 42))
    checkTypeOf[\TupleType\](typeOf (0,1))
    checkTypeOf[\BottomType\](bottomType)
end

run(): () = do
    testType()
    testTypeOf()
    (*)dumpType(typeOf ("Blah", 42, false, fn () => throw ForbiddenException))
end

