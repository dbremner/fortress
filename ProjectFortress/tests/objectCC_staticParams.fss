component objectCC_staticParams
export Executable

trait T[\X\]
    x():ZZ32
    y():ZZ32
    z():Boolean
    a():X
end

trait Y 
end

object YObj extends Y
end

object O[\X extends String, bool b, nat n\](var v:ZZ32, s:X)
    foo():ZZ32 = 3
    (* After we move checking of method calls to be after
       type inference, remove the explicit return type T. *)
    bar():T[\X\] = object extends T[\X\]
                x():ZZ32 = foo()
                y():ZZ32 = quack()
                z():ZZ32 = do 
                    _ = O[\X, b, 3\](v, s)
                    if b then n else (n-1) end
                end
                a():X = s
            end
    quack():ZZ32 = self.v
    name():X = s
end

(* Referring to var with static type param, when the static type is not
   explitictly referred in object expression body; if the closure conversion
   works correctly, the unparse output should type check *)
object O2[\X extends String, Z, ZObj extends Z\](var v:ZZ32, s:X, s2:ZObj)
    foo():ZZ32 = 3
    bar():T[\X\] = object extends T[\X\]
                x():ZZ32 = foo()
                y():ZZ32 = quack()
                z() = s2
                a():X = s
            end
    quack():ZZ32 = self.v
    name():X = s
end

run(args:String...):() = do
    o:O[\String, true, 7\] = O[\String, true, 7\](4, "Hello");
    o.v := o.v + 1
    t:T[\String\] = o.bar()
    assert( o.foo(), t.x(), "t.x() failed." )
    assert( o.quack(), t.y(), "t.y() failed." )
    assert( 7, t.z(), "t.z() failed." )
    assert( o.s, t.a(), "t.a() failed." )
end

end

