(*******************************************************************************
    Copyright 2007 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component FortressLibrary
import * from NativeArray
import * from NativeThread

export Executable

(** The following function is actually recognized as a special piece
    of built-in magic by the Fortress interpreter.  The javaClass
    argument names a Java Class which is a subclass of
    com.sun.fortress.interpreter.glue.NativeApp, which provides code
    for the closure which is used in place of the call to
    builtinPrimitive.  Meanwhile all the necessary type information,
    argument names, etc. must be declared here in Fortress-land.  For
    examples see the end of this file.

    In practice if you're extending the interpreter you will probably
    want to extend com.sun.fortress.interpreter.glue.NativeFn0,1,2,3,4
    or one of their subclasses defined in
    com.sun.fortress.interpreter.glue.primitive.  These types are
    generally easier to work with, and the boilerplate packing and
    unpacking of values is done for you.
*)

builtinPrimitive[\T\](javaClass:String):T =
  fail ("Implementation should not invoke builtinPrimitive " javaClass)

(** Builtin types from evaluator.Primitives.java:

Here "object" really implies non-extensibility.

trait  Number        extends { Any }         excludes { String, Boolean }
trait  Integral      extends { Number }      excludes { String, Boolean, RR64, FloatLiteral }
object ZZ32          extends { Integral }    excludes { String, Boolean, RR64, FloatLiteral }
object ZZ64          extends { Integral }    excludes { String, Boolean, RR64, FloatLiteral }
object RR64          extends { Number }      excludes { String, Boolean }
object String        extends { Any }         excludes { IntLiteral, FloatLiteral, Boolean }
object IntLiteral    extends { ZZ32, ZZ64, RR64 }
object FloatLiteral  extends { RR64 }
object Boolean       extends { Any }

trait  Any           extends {}
  Note that everything is considered to extend the type Any.

Note also that there isn't (yet) a trait Object!  Eventually
user-written trait and object declarations will extend Object by
default; right now they instead extend Any by default.

Note also that most of these types should not form a hierarchy, but
instead a flat type space with coercions between constituents.  Due to
the absence of coercion we have the rather unfortunate situation you
see here.

*)

(** Equality *)

(* Ideally equality will become a more ubiquitous functional method.
   Right now bugs mean equality is not a functional method. *)
opr =(a:Any, b:Any):Boolean = false
opr =/=(a:Any, b:Any):Boolean = NOT (a=b)

(** Assertion *)
assert(flag:Boolean): () =
    if NOT flag then
        fail("Assertion failed!")
    end

assert(flag: Boolean, failMsg: String): () =
    if NOT flag then
        fail(failMsg)
    end

assert(x:Any, y:Any, failMsg: Any...): () =
    if x =/= y then
        msg = (x " =/= " y "; "
               failMsg.generate[\String\](StringReduction, fn (x:Any) => "" x))
        fail(msg)
    end

(** Generator
 *
 * We say an object which extends Generator[\T\] "generates objects of
 * type T."
 *
 * Generators are used to express iteration in Fortress.  Every
 * generated expression in Fortress (eg for loop, comprehension) is
 * desugared into calls to methods of Generator, chiefly the generate
 * method.
 *
 * Every generator has a notion of a "natural order" (which by default is
 * unspecified), which describes the ordering of reduction operations,
 * and also describes the order in which elements are produced by the
 * sequential version of the same generator (given by the seq(self)
 * method).  The default implementation of seq(self) guarantees that these
 * orders will match.
 *
 * Note in particular that the natural order of a Generator must be
 * consistent; that is, if a SEQV b then a and b must yield SEQV
 * elements in the same natural order.  However, note that unless a type
 * specifically documents otherwise, no particular element ordering is
 * guaranteed, nor is it necessary to guarantee that a=b have the same
 * natural order when equality is defined.
 *
 * Note that more complex derived generators are specified further
 * down in the definition of Generator.  These have the same notions
 * of natural order and by default are defined in terms of the
 * generate() method.
 *
 * Minimal complete definition of a Generator is the generate(...) method.
 *)
trait Generator[\E\]
    excludes { Number }
    (** generate is the core of Generator.  It generates elements of
        type E and passes them to the body function.  This generation
        can occur using any mixture of serial and parallel execution
        desired by the author of the generator; by default uses of a
        generator must assume every call to the body occurs in
        parallel.

        The results of generation are combined using the reduction
        object R, which specifies a monoidal operation (associative
        and with an identity).  Body results must be combined together
        following the natural order of the generator.  The author of
        the generator is free to use the identity element anywhere
        desired in this computation, and to group reductions in any
        way desired; if no elements are generated the identity must be
        returned. *)
    generate[\R\](r: Reduction[\R\], body: E->R): R

    (** Transforming generators into new generators *)
    (** map applies a function f to each element generated and yields
        the result.  The resulting generator must have the same
        ordering and cross product properties as the generator from
        which it is derived. *)
    map[\G\](f: E->G): Generator[\G\] = SimpleMappedGenerator[\E,G\](self,f)
    (** seq produces a sequential version of the same generator, in
        which elements are produced in the generator's natural order. *)
    seq(self): SequentialGenerator[\E\] = NaiveSeqGenerator[\E\](self)

    (** Nesting of two generators; the innermost is data-dependent
        upon the outer one.  This is specifically designed to be
        overloaded so that the combined generators have properties
        appropriate to the pairing.  Because of the data dependency
        the natural order of the nesting is the natural order of the
        inner generators, in the natural order the outer nesting
        produces them.  So for example, if we write:
          (0#3).nest[\ZZ32\](\(n:ZZ32):Generator[\ZZ32\] => (n*100#4))
        then the natural order is 0,1,2,3,100,101,102,103,200,201,202,203
     **)
    nest[\G\](f: E -> Generator[\G\]): Generator[\G\] =
        SimpleNestedGenerator[\E,G\](self,f)

    (** Cross product of two generators.  This is specifically
        designed to be overloaded, such that pairs of independent
        generators can be combined to produce a generator which
        possibly interleaves the iteration spaces of the two
        generators.  For example, we might combine (0#16).cross(0#32)
        such that it first splits the second range in half, then the
        first range in half, then the second, and so forth.

        Consider a grid for which the rows are labeled from top to
        bottom with the elements of a in natural order, and the
        columns are labeled from left to right with the elements of g
        in natural order.  Each point in the grid corresponds to a
        pair (a,b) that must be generated by self.cross(g).  In the
        natural order of the cross product, an element must occur
        after those that lie above and to the left of it in the grid.
        By default the natural order of the cross product is
        left-to-right, top to bottom.  Programmers must not rely on
        the default order, except that cross products involving one or
        more sequential generators are always performed in the default
        order.  Note that this means that the following have the same
        natural order:
           seq(a).cross(b)
           a.cross(seq(b))
           seq(a).cross(seq(b))
        But seq(a.cross(b)) may have a different natural order. *)
    cross[\G\](g: Generator[\G\]): Generator[\(E,G)\] =
        SimplePairGenerator[\E,G\](self, g)

    (** Derived generation operations *)
    (** mapReduce is equivalent to generate, but takes an explicit join
        and zero which can have any type.  It still assumes join is
        associative and that zero is the identity of join. **)
    mapReduce[\R\](body: E->R, join:(R,R)->R, zero:R): R =
        generate[\R\](MapReduceReduction[\R\](join,zero), body)
    (** reduce works much like generate or mapReduce,
        but has no body expression **)
    reduce(j:(E,E)->E, z:E):E = mapReduce[\E\](fn (e:E)=>e, j, z)
    reduce(r: Reduction[\E\]):E = generate[\E\](r, fn(e:E)=>e)
    (** loop is a version of generate which discards the void results
        of the body computation.  It is used to translated
        reduction-variable-free for loops. **)
    loop(f:E->()): () = generate[\()\](VoidReduction, f)
    (** The contains method shouldn't be used directly; programmers
        should use the IN operator instead.  It exists simply to work
        around bugs. **)
    contains(x:E) = self.generate[\Boolean\](OrReduction, fn (y:E)=> x=y)
end

trait SequentialGenerator[\E\] extends { Generator[\E\] }
    seq(self) = self
    map[\G\](f: E->G): SequentialGenerator[\G\] =
        SimpleMappedSeqGenerator[\E,G\](self,f)
    (* TODO: make overloaded *)
    nest[\G\](f: E -> Generator[\G\]): Generator[\G\] =
        typecase f of
            E -> SequentialGenerator[\G\] =>
                SimpleNestedSeqGenerator[\E,G\](self,f)
            else => SimpleNestedGenerator[\E,G\](self,f)
        end
    (* TODO: make overloaded *)
    cross[\F\](g:Generator[\F\]): Generator[\(E,F)\] =
        typecase g of
            SequentialGenerator[\F\] =>
                    SimplePairSeqGenerator[\E,F\](self,g)
            else => SimplePairGenerator[\E,F\](self,g)
        end
end

(** Operations which use generation internally.  Should be functional
    methods of Generator, but that didn't work when last tested. **)

(** IN returns true if any element generated by its second argument is
    = to its first argument.  x NOTIN g is simply NOT (x IN g).
    Unless documented otherwise, this is O(n) for an n-element
    Generator (it simply performs naive matching).  **)
opr IN[\E\](x: E, this: Generator[\E\]): Boolean = this.contains(x)
opr NOTIN[\E\](x: E, this: Generator[\E\]): Boolean = NOT (x IN this)

(* seq[\T\](g:Generator[\T\]):SequentialGenerator[\T\] = g.seq() *)
sequential[\T\](g:Generator[\T\]):SequentialGenerator[\T\] = seq(g)


(** Maybe type *)

(* This makes excludes work without where clauses, and allows opr =()
   to remain non-parametric. *)
value trait MaybeType extends { Equality } excludes { Number }
        (* comprises Maybe[\T\] where [\T\] *)
    getter isJust() : Boolean
end

(** Maybe[\T\] represents either Nothing or a single element of type T
    (Just[\T\]), which may be retrieved by calling unJust().  An
    object of type Maybe[\T\] can be used as a generator; it is either
    empty (Nothing) or generates the single element yielded by unJust,
    so there is no issue of canonical order.

    Thus Just[\T\] can be used as a single-element generator, and
    Nothing can be used as an empty generator. *)
value trait Maybe[\T\]
        extends { MaybeType, SequentialGenerator[\T\], ZeroIndexed[\T\] }
        comprises { Nothing[\T\], Just[\T\] }
    getter unJust() : T throws UnJustNothing
    unJust(t:T): T
    maybe[\R\](nothingAction: ()->R, justAction: T->R): R
end

value object Just[\T\](x:T) extends {Maybe[\T\]}
    getter size()=1
    getter toString():String = "Just(" x ")"
    getter isJust() = true
    getter unJust() = x
    unJust(_:T): T = x
    generate[\R\](_:Reduction[\R\],m:T->R): R = m(x)
    opr[i:ZZ32]:T = if i=0 then x else fail("Maybe[" i "] nonzero index") end
    opr[r:Range[\ZZ32\]]:Maybe[\T\] = do
        r' = (0#1)[r]
        if r'.extent()=0 then Nothing[\T\]() else self end
      end

    map[\G\](f: T->G): Generator[\G\] = Just[\G\](f(x))
    cross[\G\](g: Generator[\G\]): Generator[\(T,G)\] =
        g.map[\(T,G)\](fn (e:G):(T,G) => (x,e))

    mapReduce[\R\](m: T->R, _:(R,R)->R, _:R): R = m(x)
    reduce(_:(T,T)->T, _:T):T = x
    reduce(_: Reduction[\T\]):T = x
    loop(f:T->()): () = f(x)
    maybe[\R\](_: ()->R, justAction: T->R): R = justAction(x)
    contains(y:T): Boolean = x=y
    eq(o:Just[\T\]): Boolean = x=o.unJust()
end

(* Obviously ought to be a non-parametric singleton when we get where
   clauses working. *)
value object Nothing[\T\]() extends { Maybe[\T\] }
    getter size()=0
    getter isJust() = false
    getter unJust() = throw UnJustNothing
    getter toString():String = "Nothing"
    unJust(t:T):T = t
    generate[\R\](r:Reduction[\R\],_:T->R): R = r.empty()
    opr[_:ZZ32]: T = fail("Cannot index Nothing")
    opr[r:Range[\ZZ32\]]: Nothing[\T\] = do
        r' = (0#0)[r]   (* Bounds check; 0-based/empty ranges only *)
        self
      end

    map[\G\](f: T->G): Generator[\G\] = Nothing[\G\]()
    cross[\G\](g: Generator[\G\]): Generator[\(T,G)\] = Nothing[\(T,G)\]()

    mapReduce[\R\](_: T->R, _:(R,R)->R, z:R): R = z
    reduce(_:(T,T)->T, z:T):T = z
    reduce(r: Reduction[\T\]):T = r.empty()
    loop(f:T->()): () = ()
    maybe[\R\](nothingAction: ()->R, _: T->R): R = nothingAction()
    contains(x:T): Boolean = false
    eq(_:Nothing[\T\]) = true
end

(** Exception hierarchy *)

trait Exception comprises { UncheckedException, CheckedException }
end

(* Exceptions which are not checked *)

trait UncheckedException extends Exception excludes CheckedException
end

object FailCalled(s:String) extends UncheckedException
  toString(): String = "FAIL: " s
end

object DivisionByZero extends UncheckedException
end

object UnpastingError extends UncheckedException
end

object CallerViolation extends UncheckedException
end

object CalleeViolation extends UncheckedException
end

object TestFailure extends UncheckedException
end

object ContractHierarchyViolation extends UncheckedException
end

object NoEqualityOnFunctions extends UncheckedException
end

object InvalidRange extends UncheckedException
end

object ForbiddenException(chain : Exception) extends UncheckedException
end

(* Should this be called "IndexNotFound" instead? *)
object NotFound extends UncheckedException
end

object IndexOutOfBounds extends UncheckedException
end

object NegativeLength extends UncheckedException
end

object IntegerOverflow extends UncheckedException
end

object RationalComparisonError extends UncheckedException
end

object FloatingComparisonError extends UncheckedException
end

(* Checked Exceptions *)

trait CheckedException extends Exception excludes UncheckedException
end

object CastError extends CheckedException
end

object IOFailure extends CheckedException
end

object MatchFailure extends CheckedException
end

object UnJustNothing extends CheckedException
end

(* SetsNotDisjoint? *)
object DisjointUnionError extends CheckedException
end

object APIMissing extends CheckedException
end

object APINameCollision extends CheckedException
end

object ExportedAPIMissing extends CheckedException
end

object HiddenAPIMissing extends CheckedException
end

trait TryAtomicFailure extends {CheckedException}
  comprises {AtomicAborted, AtomicConflict}
end

object AtomicAborted extends TryAtomicFailure
end

object AtomicConflict extends TryAtomicFailure
end

(* Should take a spawned thread as an argument *)
object AtomicSpawnSynchronization extends {UncheckedException}
end

(** Casting *)

cast[\T extends Any\](x:Any):T =
  typecase x of
    T => x
    else => printTaskTrace(); throw CastError
  end

instanceOf[\T extends Any\](x:Any):Boolean =
  typecase x of
    T => true
    else => false
  end

(** Useful functions *)

ignore(_:Any):() = ()

identity[\T extends Any\](x:T):T = x

(** Transactional retry *)
retry[\T\]():T = fail("Transactional retry not yet implemented.")

(* Should we depracate tuple and use identity instead?  Decision: no. *)
tuple[\T\](x:T):T = x

(* Function composition *)
opr COMPOSE[\A,B,C\](f: B->C, g: A->B): A->C = fn (a:A): C => f(g(a))

(* Retrieve values from tuples in a well-typed way. *)
first[\T\](t:T, u:Any...): T = t

second[\A,T\](a:A, t:T, u:Any...): T = t

third[\A,B,T\](a:A, b:B, t:T, u:Any...): T = t

(** Reflection for run-time integers into compile-time nat parameters.
 *
 *  Basically you can call the function reflect(n) and it will return
 *  an instance of NatParam.  But every instance of NatParam is an
 *  object N[\n\], so we can write a function which takes N[\n\] and
 *  pass it a NatParam; within that function n becomes a static nat
 *  parameter.
 *)
trait NatParam
  (* comprises { N[\n\] } where [\ nat n \] *)
  getter toZZ() : ZZ32
  getter toString()
end

value object N[\nat n\]() extends { NatParam }
  toZZ() = n
  toString() = "" n
end

(* Inner loop of reflect, hoisted to top level because of incomplete
 * implementation of generic local functions.  This basically
 * decomposes the argument x into binary digits, and does the same
 * operations on the static parameter r as it does so.
 *
 * Really this just proves that it can be done without extending the
 * language.  Having proven that, we ought to build it in and document
 * it in the spec for clarity and sanity's sake.
 *)
  __refl'[\nat r, nat b\](x:ZZ32):NatParam =
    if x=0 then N[\r\]()
    elif (x REM (b+b)) = 0 then
      __refl'[\r, b+b\](x)
    else
      __refl'[\r+b, b+b\](x-b)
    end

(* Actually convert a ZZ32 into a NatParam. *)
reflect(z:ZZ32):NatParam = do
  if z < 0 then
    fail("reflect(" z "): " negative argument)
  else
    __refl'[\0,1\](z)
  end
end

(** Reflection of static type parameters for overloading purposes.
    Works around shortcomings in the story on parametric overloading
    (all overloadings must have the same parameters with the same
    bounds).  Allows us to overload a function based on the parametric
    type of an output. *)

object __Proxy[\T extends (* U *) Any\]()
    (* extends { __Proxy[\U\], Object } where { U extends Any } *)
  getter toString() = "__Proxy object, should not be user-visible."
end

(** Boilerplate code for Array *)

fail(s:String) = do
   println("FAIL: " s)
   printTaskTrace()
   throwError(s)
   throw FailCalled(s)
end

oops(s:ZZ32, l:ZZ32, sz:ZZ32, got:ZZ32):() = do
   fail("Index of dimension " s " out of bounds; got " got " which is not in " l "#" sz);
end

trait Equality excludes { Number }
  eq(o:Equality):Boolean = false
end

opr =(a:Equality, b:Equality):Boolean = a.eq(b)

trait HasRank extends Equality excludes { Number, MaybeType }
  (* comprises Array[\T,E,I\] where [\T,E,I\]{ T extends Array[\T,E,I\] } *)
  rank():ZZ32
end

(* Declared Rank-n-ness *)
trait Rank[\ nat n \] extends HasRank
  rank():ZZ32 = n
end

(* Potemkin exclusion traits.  Really we just want to say that
 * Rank[\n\] excludes Rank[\m\] where { m =/= n }, but we can't yet. *)

trait Rank1 extends { Rank[\1\]} excludes { Rank2, Rank3, Number, String }
end

trait Rank2 extends { Rank[\2\]} excludes { Rank3, Number, String }
end

trait Rank3 extends { Rank[\3\]} excludes { Number, String }
end

(* The trait Indexed_i[\n\] indicates that something has an i^th
 * dimension of size n.  In general anything which extends Indexed_i
 * must also extend Indexed_j for j < i. *)

trait Indexed1[\ nat n \] end

trait Indexed2[\ nat n \] end

trait Indexed3[\ nat n \] end

(** The indexed trait indicates that an object of type T can be
indexed using type I to obtain elements with type E.

An object i that's an instance of Indexed defines three basic things:
  The indexing operator opr [], which must be defined for every instance of
    the type.

  A suite of generators: i.indices generates the index space of the
    array.  i itself generates the values contained at those indices.
    i.indexValuePairs yields pairs of (index,value).  All of these
    share the same natural order.  It is necessary to define one of
    indices() and indexValuePairs(), in addition to generate() (but
    the latter requirement can be dispensed by instead extending
    DelegatedIndexed).

  A set of utility functions, assign, fill, and copy.  Only fill and
    copy need to be defined.
**)
trait Indexed[\E, I\] extends Generator[\E\]
    getter isEmpty(): Boolean = size()=0
    getter size()
    getter bounds(): Range[\I\]
    getter indexValuePairs(): Indexed[\(I,E),I\] =
        indices().map[\(I,E)\](fn (i:I): (I,E) => (i,self[i]))
    getter indices(): Indexed[\I,I\] =
        indexValuePairs().map[\I\](fn (i:I, e:E): I => i)
    opr[i:I] : E

    (** Indexing by ranges.  The results are 0-based when the
        underlying index type has a notion of 0.  This ensures
        consistency of behavior between types such as vectors that
        *only* support 0 indexing and types such as arrays that permit
        other choices of lower bounds.  The easiest way to index by
        ranges is to take advantage of indexing on the ranges
        themselves by writing bounds()[r] in order to narrow and
        bounds check the range r and obtain a closed range of indices
        on the underlying data. **)
    opr[r:Range[\I\]] : Indexed[\E,I\]
    opr[_:OpenRange[\Any\]] : Indexed[\E,I\] = self[OpenRange[\I\]()]

    (** The ivmap function isn't merely a convenient shortcut.  It's
        actually intended to create a copy of the underlying indexed
        structure when that is appropriate.

        The usual map function in Generator should do the same (and does
        for the instances in this library).  Copying
        can be bad for space, but is complexity-preserving if the mapped
        generator is used more than once. **)
    ivmap[\R\](f:(I,E)->R): Indexed[\R, I\] = indexValuePairs().map[\R\](f)
    map[\R\](f:E->R): Indexed[\R, I\] = SimpleMappedIndexed[\E,R,I\](self,f)
end

trait ZeroIndexed[\E\] extends Indexed[\E,ZZ32\]
    bounds(): Range[\ZZ32\] = 0#size()
end

toArray[\E\](g:Indexed[\E,ZZ32\]): Array[\E,ZZ32\] = do
    bnds = g.bounds()
    r = array[\E\](bnds.size()).shift(bnds.lower())
    for (i,v) <- g.indexValuePairs() do
        r.init(i,v)
    end
    r
  end

(** DelegatedIndexed is an Indexed generator that has recourse to
    another Indexed generator() internally.  By default this in turn
    is defined in terms of indexValuePairs().  Thus it's only
    necessary to define either indexValuePairs() or indices().

    This class is designed for convenience; it shouldn't be used as a
    type in runing code, but only as a supertype in lieu of Indexed.
**)
trait DelegatedIndexed[\E,I\] extends Indexed[\E,I\]
    getter generator(): Generator[\E\] =
        indexValuePairs().map[\E\](fn (i:I, e:E): E => e)
    getter size(): ZZ32 = generator().size()
    generate[\R\](r: Reduction[\R\], body: E->R): R =
        generator().generate[\R\](r,body)
    map[\G\](f: E->G): Generator[\G\] =
        generator().map[\G\](f)
    seq(self): SequentialGenerator[\E\] = sequential(generator())
    cross[\G\](g: Generator[\G\]): Generator[\(E,G)\] =
        generator().cross[\G\](g)
    mapReduce[\R\](body: E->R, join:(R,R)->R, zero:R): R =
        generator().mapReduce[\R\](body,join,zero)
    reduce(j:(E,E)->E, z:E):E = generator().reduce(j,z)
    reduce(r: Reduction[\E\]):E = generator().reduce(r)
    loop(f:E->()): () = generator().loop(f)
end

(** The MutableIndexed trait is an indexed trait whose elements can be
    mutated using indexed assignment.  Right now we're using this type
    in a somewhat dangerous way, since eg Array1[\E,b0,s0\] extends
    both Indexed[\Array1[\E,b0,s0\],E,ZZ32\] and
    Indexed[\Array[\E,ZZ32\],E,ZZ32\].  We will need to find a
    solution to this at some point.

    In addition to the functionality in Indexed, MutableIndexed provides:
      Indexed assignment, which each instance must define.
      A set of utility functions, assign, fill, and copy.  Only copy needs
        to be defined.
**)
trait MutableIndexed[\T extends MutableIndexed[\T, E, I\], E, I\]
    extends { Indexed[\E,I\] }
  opr[i:I]:=(v:E) : ()

  (** For Ranged assignment, the extents of r and v.bounds() must
      match, but the lower bounds need not. **)
  opr[r:Range[\I\]]:=(v:Indexed[\E,I\]) : ()
  opr[_:OpenRange[\Any\]]:=(v:Indexed[\E,I\]) : () = do self[bounds()] := v end

  (** init is a version of assignment that is specifically for initialization;
      it may omit a write barrier, perform already-initialized error
      checking, etc. **)
  init(i:I, v:E): () = do self[i] := v end

  fill(f:I->E):T = do
      indices().loop(fn (i:I):() => init(i,f(i)))
      self
    end
  fill(v:E):T = fill(fn (i:I):E => v)
  copy():T
end

(* Array whose bounds are implicit rather than static. *)
trait Array[\E,I\] extends { HasRank, MutableIndexed[\Array[\E,I\],E,I\] }
    getter bounds(): FullRange[\I\]
    (** Create a fresh array structurally identical to the present
        one, but holding elements of type U. **)
    replica[\U\]():Array[\U,I\]

    (** Shift the origin of an array.  This should yield a new view of
        the same array; ie updates to either will be reflected in the
        other. **)
    shift(newOrigin:I):Array[\E,I\]
    toArray(): Array[\E,I\] = self
end

(* Factory for arrays which returns an empty 0-indexed array of a given
   run-time-determined size. *)
array[\E\](x:ZZ32):Array[\E,ZZ32\] = __arr'(__Proxy[\E\](),reflect(x))
array[\E\](x:ZZ32,y:ZZ32):Array[\E,(ZZ32,ZZ32)\] =
   __arr'(__Proxy[\E\](),reflect(x), reflect(y))
array[\E\](x:ZZ32,y:ZZ32,z:ZZ32):Array[\E,(ZZ32,ZZ32,ZZ32)\] =
   __arr'(__Proxy[\E\](),reflect(x), reflect(y), reflect(z))

(* This should be local to array, but we don't support local
   parametric methods in the language spec at all at the moment. *)
__arr'[\E, nat n, nat m, nat p\](w:__Proxy[\E\],x:N[\n\]):Array1[\E,0,n\] =
   array1[\E,n\]()
__arr'[\E, nat n, nat m, nat p\](w:__Proxy[\E\],x:N[\n\],y:N[\m\]):
    Array2[\E,0,n,0,m\] = array2[\E,n,m\]()
__arr'[\E, nat n, nat m, nat p\](w:__Proxy[\E\],x:N[\n\],y:N[\m\],z:N[\p\]):
    Array3[\E,0,n,0,m,0,p\] = array3[\E,n,m,p\]()

primitiveArray[\E\](x:ZZ32):Array[\E,ZZ32\] = __parr(__Proxy[\E\](),reflect(x))
__parr[\E, nat n\](w:__Proxy[\E\],x:N[\n\]):PrimitiveArray[\E,n\] =
    PrimitiveArray[\E,n\]()

(** A repository for tons of default array functionality. **)
trait StandardArrayType[\T extends StandardArrayType[\T,E,I\],E,I\]
      extends { Array[\E,I\], MutableIndexed[\T,E,I\], DelegatedIndexed[\E,I\] }
    (** CONCRETE GETTERS
        Default implementations of getters based on abstract methods
        below. **)
    getter indices(): Indexed[\I,I\] = bounds()
    getter indexValuePairs(): Indexed[\(I,E),I\] =
        zeroIndices().map[\(I,E)\](fn (i:I):(I,E) => (toIndex(i),get(i)))
    getter generator(): Indexed[\E,I\] =
        zeroIndices().map[\E\](fn (i:I):E => get(i))
    (** ABSTRACT METHODS **)
    (** 0-based non-bounds-checked indexing **)
    get(i:I): E
    put(i:I, e:E): ()
    init0(i:I, e:E): ()
    zeroIndices(): FullRange[\I\]
    (** Convert from base()-based indexing to 0-based indexing,
        performing bounds checking. **)
    offset(i:I): I
    (** Convert from 0-based indexing to base()-based indexing **)
    toIndex(i:I): I
    (** CONCRETE METHODS
        Default implementations of most array stuff based on the above.
        The things we can't provide are anything involving replica. **)
    opr[i:I]:E = get(offset(i))
    opr[i:I]:=(v:E):() = put(offset(i),v)
    init(i:I, v:E) = init0(offset(i),v)

    opr[r:Range[\I\]]:=(a:Indexed[\E,I\]):() = do
        a0 = a[a.bounds()]      (* Make a have 0 origin *)
        s0 = self[r]            (* Make self have 0 origin *)
        if a0.bounds() = s0.bounds() then
            for (i,v) <- a.indexValuePairs() do
                s0.put(i,v)
            end
        else
            fail("Can't assign indexed with bounds " a.bounds()
                 "\n to differently-sized subarray " self.bounds())
        end
      end

    generate[\R\](r: Reduction[\R\], body: E->R): R =
        generator().generate[\R\](r,body)
    map[\G\](f: E->G): Indexed[\G,I\]
    ivmap[\G\](f: (I,E)->G): Indexed[\G,I\]
    seq(self): SequentialGenerator[\E\] = sequential(generator())

    assign(v:T):T = do
        for i <- zeroIndices() do put(i,v.get(i)) end
        self
      end
    assign(f:I->E):T = do
        for i <- zeroIndices() do put(i,f(toIndex(i))) end
        self
      end
    fill(f:I->E):T = do
        for i <- zeroIndices() do init0(i,f(toIndex(i))) end
        self
      end
    fill(v:E):T = do
        for i <- zeroIndices() do init0(i,v) end
        self
      end
    copy():T
    eq(other: T): Boolean =
      zeroIndices().generate[\Boolean\](AndReduction,
                                 fn (i:I):Boolean => get(i)=other.get(i))
end

(* Canonical partitioning of a positive number x into two pieces.  If
     (a,b) = partition(n)
   and n > 0 then 0 < a <= b,  n = a + b.
   As it turns out we choose a to be the largest power of 2 < n.
*)
partition(x:ZZ32):(ZZ32,ZZ32) = do
    m = partitionL(x)
    (m,x-m)
  end

(** Array1[\T,b0,s0\] is a 1-dimension array whose s0 elements are of
    type T, and whose lowest index is b0.

    The natural order of all generators is from b0 to b0+s0-1. **)
trait Array1[\T, nat b0, nat s0\]
    extends { Indexed1 [\s0\], Rank1,
              StandardArrayType[\Array1[\T,b0,s0\],T,ZZ32\] }
    excludes {Number, String}
  getter size():ZZ32 = s0
  getter bounds():ScalarRange[\ZZ32\] = b0#s0
  getter toString() = do
    r = "[" b0 "#" s0 "] = ["
    if s0=0 then
      r "]"
    else
      f(i:ZZ32,t:T):String = " " t
      j(a:String,b:String) = a b
      r indexValuePairs().mapReduce[\String\](f,j,"") " ]"
    end
  end

  (* Get and put come from implementation.  They are always 0-indexed
     and unchecked. *)
  get(i:ZZ32):T
  put(i:ZZ32, v:T)

  (* Offset converts from b0 indexing to 0 indexing,
     bounds checking en route *)
  offset(i:ZZ32):ZZ32 = do
    r = i - b0
    if r >= s0 OR r < 0 then oops(1, b0, s0, i) end
    r
  end
  toIndex(i:ZZ32):ZZ32 = i + b0

  zeroIndices(): ScalarRange[\ZZ32\] = 0#s0

  shift(o:ZZ32): Array[\T,ZZ32\] =
      if o=0 then
          self
      else
          __subarray(self,reflect(o),N[\s0\](),N[\b0\]())
      end

  opr[r: Range[\ZZ32\]] : Array[\T,ZZ32\] = do
      r' = bounds()[r]
      z = N[\0\]()
      s = reflect(r'.size())
      l = reflect(r'.lower())
      __subarray(self,z,s,l)
    end

  (** subarray selects a subarray of this array based on static parameters.
      b#s are the new bounds of the array; o is
      the index of the subarray within the current array. **)
  subarray[\nat b, nat s, nat o\]():Array1[\T, b, s\] = do
    boundsCheck = bounds()[o#s]
    __SimpleSubArray1[\T,b,s,b0,s0\](self,o-b0,1)
  end

  (* the replica method returns a replica of the array (similar layout
     etc.) but with a different element type. *)
  replica[\U\]():Array1[\U,b0,s0\] = __builtinFactory1[\U,b0,s0\]()

  copy():Array1[\T,b0,s0\] = replica[\T\]().assign(self)

  map[\R\](f:T->R): Array1[\R,b0,s0\] =
      replica[\R\]().fill(fn (i:ZZ32):R => f(get(i-b0)))
  ivmap[\R\](f:(ZZ32,T)->R): Array1[\R,b0,s0\] =
      replica[\R\]().fill(fn (i:ZZ32):R => f(i,get(i-b0)))
end

(* WORK AROUND absence of type inference in method calls. *)
__subarray[\T, nat b0, nat s0, nat b, nat s, nat o\]
          (it:Array1[\T,b0,s0\],
           _:N[\b\],_:N[\s\],_:N[\o\]):Array1[\T,b,s\] = it.subarray[\b,s,o\]()


(* A 1-D subarray of an Array1.
   b_a#s_a is the underlying array's bounds; b0#s0 is the
   result bounds.  o0 is the starting offset in the underlying array,
   defined in 0-indexed space.  m0 the stride within that array.
   Invariant: (s0-1) m0 + o0 - b_a) < s_a *)
object __SimpleSubArray1[\T, nat b0, nat s0, nat b_a, nat s_a\]
       (arr:Array1[\T,b_a,s_a\], o0:ZZ32, m0:ZZ32)
       extends Array1[\T, b0, s0\]
    index(i:ZZ32):T = i m0 + o0
    get(i:ZZ32):T = arr.get(index(i))
    put(i:ZZ32,v:T): () = arr.put(index(i),v)
    init0(i:ZZ32,v:T): () = arr.init0(index(i),v)
    subarray[\nat b, nat s, nat o\]():Array1[\T, b, s\] = do
        boundsCheck = bounds()[o#s]
        o_n : ZZ32 = o - b0
        __SimpleSubArray1[\T, b, s, b_a, s_a\](arr, index(o_n), m0)
      end
end

trait Vector[\T extends Number, nat s0\] extends Array1[\T,0,s0\]
    add(v:Vector[\T,s0\]): Vector[\T,s0\] =
        ivmap[\T\](fn (i:ZZ32, e: T):T => e + v.get(i))
    subtract(v:Vector[\T,s0\]): Vector[\T,s0\] =
        ivmap[\T\](fn (i:ZZ32, e: T):T => e - v.get(i))
    negate(): Vector[\T,s0\] = map[\T\](fn (e: T):T => - e)
    scale(t: T): Vector[\T,s0\] = map[\T\](fn (v) => t v)
    pmul(v: Vector[\T,s0\]): Vector[\T,s0\] =
        ivmap[\T\](fn (i:ZZ32, e: T):T => e v.get(i))
    dot(v: Vector[\T,s0\]): T =
        indexValuePairs().generate[\T\](SumReduction[\T\](),
                                        fn (i:ZZ32, me_i:T):T => me_i v.get(i))
end

object __DefaultVector[\T, nat s0\]() extends Vector[\T,s0\]
  mem: PrimitiveArray[\T,s0\] = PrimitiveArray[\T,s0\]()
  get(i:ZZ32):T = mem.get(i)
  put(i:ZZ32, v:T) = mem.put(i,v)
  init0(i:ZZ32, v:T) = mem.init0(i,v)
  replica[\U\]() = array1[\T,s0\]()
end

(* builtinFactory1 must be a non-overloaded 0-parameter factory for
   0-indexed 1-D arrays.  The type parameters are enshrined in
   LHSEvaluator.java and NonPrimitive.java; the factory name is
   enshrined in WellKnownNames.java.  There must be some factory,
   named in this file, with this type signature.  A similar thing is
   true for K-dimensional array types. *)
__builtinFactory1[\T, nat b0, nat s0\]():Array1[\T,b0,s0\] = do
    r = array1[\T,s0\]()
    typecase _ = N[\b0\]() of
        N[\0\] => r
        else => r.subarray[\b0,s0,0\]()
    end
  end

(* TODO: fix when Number is covariant. *)
array1[\T, nat s0\]():Array1[\T,0,s0\] =
    typecase _ = __Proxy[\T\]() of
        __Proxy[\ZZ32\] => vector[\T,s0\]()
        __Proxy[\ZZ64\] => vector[\T,s0\]()
        __Proxy[\Integral\] => vector[\T,s0\]()
        __Proxy[\RR64\] => vector[\T,s0\]()
        __Proxy[\Number\] => vector[\T,s0\]()
        else => PrimitiveArray[\T,s0\]()
    end
array1[\T, nat s0\](v:T):Array1[\T,0,s0\] = array1[\T,s0\]().fill(v)
array1[\T, nat s0\](f:ZZ32->T):Array1[\T,0,s0\] = array1[\T,s0\]().fill(f)

(* vector is the same as array1, but specialized to numeric type arguments *)
vector[\T extends Number, nat s0\]():Vector[\T,s0\] = __DefaultVector[\T,s0\]()
vector[\T extends Number, nat s0\](v:T):Vector[\T,s0\] =
    vector[\T,s0\]().fill(v)
vector[\T extends Number, nat s0\](f:ZZ32->T):Vector[\T,s0\] =
    vector[\T,s0\]().fill(f)


opr +[\ T extends Number, nat n, nat m \]
     (me : Vector[\T,n\], other : Vector[\T,n\]):Vector[\T,n\] = me.add(other)

opr -[\ T extends Number, nat n, nat m \]
     (me : Vector[\T,n\], other : Vector[\T,n\]):Vector[\T,n\] =
    me.subtract(other)

opr -[\ T extends Number, nat n, nat m \]
     (me : Vector[\T,n\]):Vector[\T,n\] = me.negate()

pmul[\ T extends Number, nat k \]
    (a : Vector[\T,k\], b : Vector[\T,k\]):Vector[\T,k\] = a.pmul(b)

opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (me : Vector[\T,n\], other : Vector[\T,n\]):T = me.dot(other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (me : Vector[\T,n\], other : Vector[\T,n\]):T = me.dot(other)

opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (me : Vector[\T,n\], other : T) : Vector[\T,n\] = me.scale(other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (me : Vector[\T,n\], other : T) : Vector[\T,n\] = me.scale(other)

opr DOT[\ T extends Number, nat n, nat m, nat p \]
        (other : T, me : Vector[\T,n\]) : Vector[\T,n\] = me.scale(other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (other : T, me : Vector[\T,n\]) : Vector[\T,n\] = me.scale(other)

squaredNorm[\T extends Number, nat s0\](a:Vector[\T,s0\]):T = a.dot(a)

opr [\ T extends Number, nat k \]
    ||me : Vector[\T,k\]|| : RR64 = SQRT squaredNorm(me)

(** Array2[\T,b0,s0,b1,s1\] is the type of 2-dimensional arrays of
    element type T, with size s0 in the first dimension and s1 in the
    second dimension and lowest index (b0,b1).  Natural order for all
    generators in each dimension is from b to b+s-1; the overall order
    of elements need only be consistent with the cross product of
    these orderings (see Generator.cross()). **)
trait Array2[\T, nat b0, nat s0, nat b1, nat s1\]
    extends { Indexed1[\s0\], Indexed2[\s1\], Rank2,
              StandardArrayType[\Array2[\T,b0,s0,b1,s1\],T,(ZZ32,ZZ32)\] }
    excludes { Number, String }
  getter size():ZZ32 = s0 s1
  getter bounds():Tuple2Range[\ZZ32,ZZ32\] = (b0,b1)#(s0,s1)
  getter toString() = do
    r : String := "[" b0 "#" s0 "," b1 "#" s1 "] ="
    row(i) =
      for j <- sequential(0#s1) do
         r := r " " get(i,j)
      end
    if s0 = 0 then
      r " []"
    else
      r := r "\n["
      row(0)
      for i <- sequential(1#(s0-1)) do
        r := r "\n "
        row(i)
      end
      r " ]"
    end
  end
  (* Translate from b0,b1-indexing to 0-indexing, checking bounds. *)
  offset(t:(ZZ32,ZZ32)):(ZZ32,ZZ32) = do
    (a0,a1) = t
    c0 = a0 - b0
    c1 = a1 - b1
    if c0 < 0 OR c0 >= s0 OR c1 < 0 OR c1 >= s1 then
      if c0 < 0 OR c0 >= s0 then
        oops(1,b0,s0,a0)
      else
        oops(2,b1,s1,a1)
      end
    end
    (c0,c1)
  end
  toIndex(t:(ZZ32,ZZ32)):(ZZ32,ZZ32) = do (a0,a1)=t; (a0+b0,a1+b1) end
  opr[x:ZZ32,y:ZZ32]:=(v:T):() = do self[ (x,y) ] := v end
  opr[r:Range[\(ZZ32,ZZ32)\]]: Array[\T,(ZZ32,ZZ32)\] = do
      r' = bounds()[r]
      (z0,z1) = r'.extent()
      (l0,l1) = r'.lower()
      __subarray(N[\0\](),reflect(z0), N[\0\](),reflect(z1),
                 reflect(l0),reflect(l1))
    end
  shift(t:(ZZ32,ZZ32)): Array[\T,(ZZ32,ZZ32)\] = do
      (o0,o1)=t
      if o0=0 AND o1=0 then
          self
      else
          __subarray(reflect(o0),N[\s0\], reflect(o1),N[\s1\], N[\b0\],N[\b1\])
      end
    end

  (** 2-D subarray given static subarray parameters.
      (bo1,bo2)#(so1,so2) are output bounds.
      The result is the subarray starting at (o0,o1) in the original array.
   **)
  subarray[\nat bo0, nat so0, nat bo1, nat so1, nat o0, nat o1\]
          (): Array2[\T,bo0,so0,bo1,so1\] = do
      boundsCheck = bounds()[ (o0,o1)#(so0,so1) ]
      SubArray2[\T,bo0,so0,bo1,so1,b0,s0,b1,s1\](self,1,o0,1,o1)
    end

  __subarray[\nat bo0, nat so0, nat bo1, nat so1, nat o0, nat o1\]
          (_:N[\bo0\],_:N[\so0\],_:N[\bo1\],_:N[\so1\],
           _:N[\o0\],_:N[\o1\]): Array2[\T,bo0,so0,bo1,so1\] =
      subarray[\bo0,so0,bo1,so1,o0,o1\]()

  zeroIndices():Tuple2Range[\ZZ32,ZZ32\] = (0,0)#(s0,s1)

  replica[\U\]():Array2[\U,b0,s0,b1,s1\] =
      __builtinFactory2[\U,b0,s0,b1,s1\]()
  copy():Array2[\T,b0,s0,b1,s1\] = self.replica[\T\]().assign(self)
  put(t:(ZZ32, ZZ32), v:T) : ()
  get(t:(ZZ32, ZZ32)):T
  t():Array2[\T,b1,s1,b0,s0\] = TransposedArray2[\T,b1,s1,b0,s0\](self)
  (* Copied here for better return type information. *)
  map[\R\](f:T->R): Array2[\R,b0,s0,b1,s1\] =
      replica[\R\]().fill(fn (i:ZZ32,j:ZZ32):R => f(get(i-b0,j-b1)))
  ivmap[\R\](f:((ZZ32,ZZ32),T)->R): Array2[\R,b0,s0,b1,s1\] =
      replica[\R\]().fill(fn (i:ZZ32,j:ZZ32):R => f((i,j),get(i-b0,j-b1)))
end

(** Default array is column-major, but we could switch it. **)
object __DefaultArray2[\T, nat b0, nat s0, nat b1, nat s1\]()
    extends Array2[\T, b0, s0, b1, s1\]
  mem:PrimitiveArray[\T, (s0 s1) \] = PrimitiveArray[\T, (s0 s1) \]()
  init0(t:(ZZ32,ZZ32), v:T) : () = do (i,j)=t; mem.init0(i s1 + j, v) end
  put(t:(ZZ32,ZZ32), v:T) : () = do (i,j)=t; mem.put(i s1 + j, v) end
  get(t:(ZZ32,ZZ32)):T = do (i,j)=t; mem.get(i s1 + j) end
end

(** Transposes the index of the underlying array mem, and transposes
    its natural order as well. **)
object TransposedArray2[\T, nat b0, nat s0, nat b1, nat s1\]
                       (mem:Array2[\T,b1,s1,b0,s0\])
    extends Array2[\T, b0, s0, b1, s1\]
  replica[\U\]():Array2[\U,b0,s0,b1,s1\] = mem.replica[\U\]().t()

  init0(t:(ZZ32,ZZ32), v:T) : () = do (i,j)=t; mem.init0((j,i),v) end
  put(t:(ZZ32,ZZ32), v:T) : () = do (i,j)=t; mem.put((j,i),v) end
  get(t:(ZZ32,ZZ32)):T = do (i,j)=t; mem.get(j,i) end
  t() = mem
end

(** Simple 2-D subarray, used when we have no other knowledge of the
    underlying structure.  If we're on top of a PrimitiveArray we can
    really do much better than this.
    (b0,b1)#(s0,s1) are the bounds of the subarray.
    (bu0,bu1)#(su0,su1) are the bounds of the underlying array.
    m_i, o_i are multiplier and offset (0-based) of dimension i.
**)
object SubArray2[\T, nat b0, nat s0, nat b1, nat s1,
                     nat bu0, nat su0, nat bu1, nat su1\]
                (mem: Array2[\T,bu0,su0,bu1,su1\],
                 m0:ZZ32, o0:ZZ32, m1:ZZ32, o1:ZZ32)
        extends Array2[\T,b0,s0,b1,s1\]
    index(a0:ZZ32, a1:ZZ32): (ZZ32,ZZ32) = (m0 a0 + o0, m1 a1 + o1)
    init0(t:(ZZ32,ZZ32), v:T): () = mem.init0(index(t),v)
    put(t:(ZZ32,ZZ32), v:T): () = mem.put(index(t),v)
    get(t:(ZZ32,ZZ32)): T = mem.get(index(t))
end

trait Matrix[\T, nat s0, nat s1\] extends Array2[\T, 0, s0, 0, s1\]
    add(v:Matrix[\T,s0,s1\]): Matrix[\T,s0,s1\] =
        ivmap[\T\](fn (i:(ZZ32,ZZ32),e:T):T => e + v.get(i))
    subtract(v:Matrix[\T,s0,s1\]): Matrix[\T,s0,s1\] =
        ivmap[\T\](fn (i:(ZZ32,ZZ32),e:T):T => e - v.get(i))
    negate(): Matrix[\T,s0,s1\] = map[\T\](fn (e:T):T => - e)
    scale(t: T): Matrix[\T,s0,s1\] = map[\T\](fn (e:T):T => t e)
    mul[\ nat s2 \](other: Matrix[\T,s1,s2\]): Matrix[\T,s0,s2\] = do
        res = matrix[\T,s0,s2\]()
        mma(a:ZZ32,i:ZZ32,b:ZZ32,j:ZZ32,c:ZZ32,k:ZZ32):() =
            if k>=i AND k>=j then
              if k=1 then
                pr : T = get(a,b) other.get(b,c)
                (* If this were atomic, we could parallelize j-partition. *)
                res.put((a,c), res.get(a,c) + pr)
              else
                (k0,k1) = partition(k)
                (mma(a,i,b,j,c,k0),mma(a,i,b,j,c+k0,k1))
              end
            elif j>=i then
                (j0,j1) = partition(j)
                mma(a,i,b,j0,c,k)
                mma(a,i,b+j0,j1,c,k)
            else
                (i0,i1) = partition(i)
                (mma(a,i0,b,j,c,k),mma(a+i0,i1,b,j,c,k))
            end
        mm(a:ZZ32,i:ZZ32,b:ZZ32,j:ZZ32,c:ZZ32,k:ZZ32):() =
            if k>=i AND k>=j then
              if k=1 then
                res.put((a,c), get(a,b) other.get(b,c))
              else
                (k0,k1) = partition(k)
                (mm(a,i,b,j,c,k0),mm(a,i,b,j,c+k0,k1))
              end
            elif j>=i then
                (j0,j1) = partition(j)
                mm(a,i,b,j0,c,k)
                mma(a,i,b+j0,j1,c,k)
            else
                (i0,i1) = partition(i)
                (mm(a,i0,b,j,c,k),mm(a+i0,i1,b,j,c,k))
            end
        if s0=0 OR s1=0 OR s2=0 then
          res
        else
          mm(0,s0,0,s1,0,s2)
          res
        end
      end
    rmul(v: Vector[\T,s1\]): Vector[\T,s0\] = do
        row(i:ZZ32):T =
            v.indexValuePairs().generate[\T\](SumReduction[\T\](),
                                      fn (j:ZZ32, v_j):T => get(i,j) v_j)
        vector[\T,s0\]().fill(row)
      end
    lmul(v: Vector[\T,s0\]): Vector[\T,s1\] = do
        col(i:ZZ32):T =
            v.indexValuePairs().generate[\T\](SumReduction[\T\](),
                                      fn (j:ZZ32, v_j):T => v_j get(j,i))
        vector[\T,s1\]().fill(col)
      end
    t(): Matrix[\T,s1,s0\] = TransposedMatrix[\T,s1,s0\](self)
end

(* Default matrix should match default array in column vs row-major. *)
object __DefaultMatrix[\T, nat s0, nat s1\]()
    extends Matrix[\T, s0, s1\]
  mem:PrimitiveArray[\T, (s0 s1) \] = PrimitiveArray[\T, (s0 s1) \]()
  init0(t:(ZZ32,ZZ32), v:T) : () = do (i,j)=t; mem.init0(i s1 + j, v) end
  put(t:(ZZ32,ZZ32), v:T) : () = do (i,j)=t; mem.put(i s1 + j, v) end
  get(t:(ZZ32,ZZ32)):T = do (i,j)=t; mem.get(i s1 + j) end
end

object TransposedMatrix[\T, nat s0, nat s1\](mem:Matrix[\T,s1,s0\])
        extends Matrix[\T, s0, s1\]
    replica[\U\]():Array2[\U,0,s0,0,s1\] = mem.replica[\U\]().t()

    init0(t:(ZZ32,ZZ32), v:T) : () = do (i,j)=t; mem.init0((j,i),v) end
    put(t:(ZZ32,ZZ32), v:T) : () = do (i,j)=t; mem.put((j,i),v) end
    get(t:(ZZ32,ZZ32)):T = do (i,j)=t; mem.get(j,i) end
    t(): Matrix[\T,s1,s0\] = mem
    add(v:TransposedMatrix[\T,s0,s1\]): Matrix[\T,s0,s1\] = mem.add(v.t()).t()
    subtract(v:Matrix[\T,s0,s1\]): Matrix[\T,s0,s1\] = mem.subtract(v.t()).t()
    negate(): Matrix[\T,s0,s1\] = mem.negate().t()
    scale(f: T): Matrix[\T,s0,s1\] = mem.scale(f).t()
    rmul(v: Vector[\T,s1\]): Vector[\T,s0\] = mem.lmul(v)
    lmul(v: Vector[\T,s0\]): Vector[\T,s1\] = mem.rmul(v)
(*  Can't overload generic methods yet, but this is preferable.
    mul[\nat s2\](v:TransposedMatrix[\T,s1,s2\]): Matrix[\T,s0,s2\] =
        v.t().mul(mem).t()
*)
end

__builtinFactory2[\T,nat b0,nat s0,nat b1,nat s1\]():Array2[\T,b0,s0,b1,s1\] =
    if b0=0 AND b1=0 then
        array2[\T,s0,s1\]()
    else
        __DefaultArray2[\T,b0,s0,b1,s1\]()
    end

(* array2 is a factory for 0-based 2-D arrays. *)
(* TODO: fix when Number is covariant. *)
array2[\T, nat s0, nat s1\]():Array2[\T,0,s0,0,s1\] =
    typecase _ = __Proxy[\T\]() of
        __Proxy[\ZZ32\] => matrix[\T,s0,s1\]()
        __Proxy[\ZZ64\] => matrix[\T,s0,s1\]()
        __Proxy[\Integral\] => matrix[\T,s0,s1\]()
        __Proxy[\RR64\] => matrix[\T,s0,s1\]()
        __Proxy[\Number\] => matrix[\T,s0,s1\]()
        else => __DefaultArray2[\T,0,s0,0,s1\]()
    end
array2[\T, nat s0, nat s1\](v:T):Array2[\T,0,s0,0,s1\] =
  array2[\T,s0,s1\]().fill(v)
array2[\T, nat s0, nat s1\](f:(ZZ32,ZZ32)->T):Array2[\T,0,s0,0,s1\] =
  array2[\T,s0,s1\]().fill(f)

(* matrix is the same as array1, but specialized to numeric type
   arguments, except that the default value (if given) is used to
   construct a multiple of the identity matrix. *)
matrix[\T extends Number, nat s0, nat s1\]():Matrix[\T,s0,s1\] =
  __DefaultMatrix[\T,s0,s1\]()
matrix[\T extends Number, nat s0, nat s1\](v:T):Matrix[\T,s0,s1\] =
  array2[\T,s0,s1\]().fill(fn (x:ZZ32,y:ZZ32):T => if x=y then v else 0 end)

opr +[\ T extends Number, nat n, nat m \]
     (me:Matrix[\T,n,m\], other:Matrix[\T,n,m\]): Matrix[\T,n,m\] =
        me.add(other)

opr -[\ T extends Number, nat n, nat m \]
     (me:Matrix[\T,n,m\], other:Matrix[\T,n,m\]) : Matrix[\T,n,m\] =
        me.subtract(other)

opr -[\ T extends Number, nat n, nat m \]
     (me:Matrix[\T,n,m\]): Matrix[\T,n,m\] =
        me.negate()

(* Matrix multiplication; used to use a cache-oblivious algorithm, but
   we ran into trouble due to lack of support for atomic increment of
   matrix elements. *)
opr DOT[\ T extends Number, nat n, nat m, nat p\]
       (me:Matrix[\T,n,m\], other:Matrix[\T,m,p\]): Matrix[\T,n,p\] =
        me.mul[\p\](other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p\]
     (me:Matrix[\T,n,m\], other:Matrix[\T,m,p\]): Matrix[\T,n,p\] =
        me.mul[\p\](other)


(* matrix-vector multiplication *)
opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (me:Matrix[\T,n,m\], v:Vector[\T,m\]):Vector[\T,n\] = me.rmul(v)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (me:Matrix[\T,n,m\], v:Vector[\T,m\]):Vector[\T,n\] = me.rmul(v)

(* vector-matrix multiplication *)
opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (v:Vector[\T,n\], me:Matrix[\T,n,m\]):Vector[\T,m\] = me.lmul(v)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (v:Vector[\T,n\], me:Matrix[\T,n,m\]):Vector[\T,m\] = me.lmul(v)

opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (me : Matrix[\T,n,m\], other : T) : Matrix[\T,n,m\] = me.scale(other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (me : Matrix[\T,n,m\], other : T) : Matrix[\T,n,m\] = me.scale(other)

opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (other : T, me : Matrix[\T,n,m\]) : Matrix[\T,n,m\] = me.scale(other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (other : T, me : Matrix[\T,n,m\]) : Matrix[\T,n,m\] = me.scale(other)

(** Array3[\T,b0,s0,b1,s1,b2,s2\] is the type of 3-dimensional arrays
    of element type T, with size s_i in the i^th dimension and lowest
    index (b0,b1,b2).  Natural order for all generators in each
    dimension is from b to b+s-1; the overall order of elements need
    only be consistent with the cross product of these orderings (see
    Generator.cross()). **)
trait Array3[\T, nat b0, nat s0, nat b1, nat s1, nat b2, nat s2\]
  extends { Indexed1 [\s0\], Indexed2 [\s1\], Indexed3 [\s2\], Rank3,
            StandardArrayType[\Array3[\T,b0,s0,b1,s1,b2,s2\],T,
                                  (ZZ32,ZZ32,ZZ32)\] }
  excludes { Number, String }

  getter size():ZZ32 = s0 s1 s2
  getter bounds():Tuple3Range[\ZZ32,ZZ32,ZZ32\] = (b0,b1,b2)#(s0,s1,s2)

  getter toString():String = do
    r : String := "[" b0 "#" s0 "," b1 "#" s1 "," b2 "#" s2 "] ="
    row(i,j) =
        for k <- sequential(0#s2) do
          r := r " " get(i,j,k)
        end
    plane(i) =
      if s1 > 0 then
        for j <- sequential(0#(s1-1)) do
          row(i,j)
        end
      end
    if s0=0 then
      r " []"
    else
      r := r "\n[ "
      plane(0)
      for i <- sequential(1#(s0-1)) do
        r := r ";;\n  "
        plane(i)
      end
      r " ]"
    end
  end

  (* Again, offset performs bounds checking and shifts to 0 indexing. *)
  offset(t:(ZZ32,ZZ32,ZZ32)):(ZZ32,ZZ32,ZZ32) = do
    (a0,a1,a2)=t
    c0 = a0 - b0; c1 = a1 - b1; c2 = a2 - b2
    if c0 >= s0 OR c0 < 0 then oops(1, b0, s0, a0); end
    if c1 >= s1 OR c1 < 0 then oops(2, b1, s1, a1); end
    if c2 >= s2 OR c2 < 0 then oops(3, b2, s2, a2); end
    (c0,c1,c2)
  end
  toIndex(t:(ZZ32,ZZ32,ZZ32)):(ZZ32,ZZ32,ZZ32) =
      do (a0,a1,a2) = t; (a0+b0,a1+b1,a2+b2) end

  (* And get and put are 0-indexed without bounds checks. *)
  put(t:(ZZ32,ZZ32,ZZ32), v:T) : ()
  get(t:(ZZ32,ZZ32,ZZ32)):T

  opr[i:ZZ32, j:ZZ32, k:ZZ32] := (v:T) = do self[ (i,j,k) ] := v end
  opr[r:Range[\(ZZ32,ZZ32,ZZ32)\]]: Array[\T,(ZZ32,ZZ32,ZZ32)\] = do
      r' = bounds()[r]
      (z0,z1,z2) = r'.size()
      (l0,l1,l2) = r'.lower()
      __subarray(N[\0\](),reflect(z0), N[\0\](),reflect(z1),
                 N[\0\](),reflect(z2), reflect(l0),reflect(l1), reflect(l2))
    end
  shift(t:(ZZ32,ZZ32,ZZ32)): Array[\T,(ZZ32,ZZ32)\] = do
      (o0,o1,o2)=t
      if o0=0 AND o1=0 AND o2=0 then
          self
      else
          __subarray(reflect(o0),N[\s0\], reflect(o1),N[\s1\],
                     reflect(o2),N[\s2\], N[\b0\],N[\b1\],N[\b2\])
      end
    end

  (** 2-D subarray given static subarray parameters.
      (bo1,bo2)#(so1,so2) are output bounds.
      The result is the subarray starting at (o0,o1) in the original array.
   **)
  subarray[\nat bo0, nat so0, nat bo1, nat so1, nat bo2, nat so2,
            nat o0, nat o1, nat o2\]
          (): Array3[\T,bo0,so0,bo1,so1,bo2,so2\] = do
      boundsCheck = bounds()[ (o0,o1,o2)#(so0,so1,so2) ]
      SubArray3[\T,bo0,so0,bo1,so1,bo2,so2,b0,s0,b1,s1,b2,s2\]
               (self,1,o0,1,o1,1,o2)
    end

  __subarray[\nat bo0, nat so0, nat bo1, nat so1, nat bo2, nat so2,
              nat o0, nat o1, nat o2\]
          (_:N[\bo0\],_:N[\so0\],_:N[\bo1\],_:N[\so1\],_:N[\bo2\],_:N[\so2\],
           _:N[\o0\],_:N[\o1\],_:N[\o2\]): Array3[\T,bo0,so0,bo1,so1,bo2,so2\] =
      subarray[\bo0,so0,bo1,so1,bo2,so2,o0,o1,o2\]()

  zeroIndices():Tuple3Range[\ZZ32,ZZ32,ZZ32\] = (0,0,0)#(s0,s1,s2)

  replica[\U\]():Array3[\U,b0,s0,b1,s1,b2,s2\] =
      __DefaultArray3[\T,b0,s0,b1,s1,b2,s2\]
  copy():Array3[\T,b0,s0,b1,s1,b2,s2\] = self.replica[\T\]().assign(self)
  map[\R\](f:T->R): Array3[\R,b0,s0,b1,s1,b2,s2\] =
      replica[\R\]().fill(fn (i:ZZ32,j:ZZ32,k:ZZ32):R =>
                              f(get(i-b0,j-b1,k-b2)))
  ivmap[\R\](f:((ZZ32,ZZ32,ZZ32),T)->R): Array3[\R,b0,s0,b1,s1,b2,s2\] =
      replica[\R\]().fill(fn (i:ZZ32,j:ZZ32,k:ZZ32):R =>
                              f((i,j,k),get(i-b0,j-b1,k-b2)))

end

object __DefaultArray3[\T, nat b0, nat s0, nat b1, nat s1, nat b2, nat s2\]() extends
                                        Array3[\T, b0, s0, b1, s1, b2, s2\]
  mem:PrimitiveArray[\T,(s0 (s1 s2))\] = PrimitiveArray[\T,(s0 (s1 s2))\]()

  ofs(i:ZZ32,j:ZZ32,k:ZZ32):ZZ32 = (i s1 + j) s2 + k

  init0(t:(ZZ32,ZZ32,ZZ32), v:T) : () = mem.init0(ofs(t),v)
  put(t:(ZZ32,ZZ32,ZZ32), v:T) : () = mem.put(ofs(t),v)
  get(t:(ZZ32,ZZ32,ZZ32)) : T = mem.get(ofs(t))
end

(** Simple 3-D subarray, used when we have no other knowledge of the
    underlying structure.  If we're on top of a PrimitiveArray we can
    really do much better than this.
    (b0,b1,b2)#(s0,s1,s2) are the bounds of the subarray.
    (bu0,bu1,bu2)#(su0,su1,su2) are the bounds of the underlying array.
    m_i, o_i are multiplier and offset (0-based) of dimension i.
**)
object SubArray3[\T, nat b0, nat s0, nat b1, nat s1, nat b2, nat s2,
                     nat bu0, nat su0, nat bu1, nat su1, nat bu2, nat su2\]
                (mem: Array3[\T,bu0,su0,bu1,su1,bu2,su2\],
                 m0:ZZ32,o0:ZZ32, m1:ZZ32,o1:ZZ32, m2:ZZ32, o2:ZZ32)
        extends Array3[\T,b0,s0,b1,s1,b2,s2\]
    index(a0:ZZ32, a1:ZZ32, a2:ZZ32): (ZZ32,ZZ32,ZZ32) =
        (m0 a0 + o0, m1 a1 + o1, m2 a2 + o2)
    init0(t:(ZZ32,ZZ32,ZZ32), v:T): () = mem.init0(index(t),v)
    put(t:(ZZ32,ZZ32,ZZ32), v:T): () = mem.put(index(t),v)
    get(t:(ZZ32,ZZ32,ZZ32)): T = mem.get(index(t))
end

__builtinFactory3[\T, nat b0, nat s0, nat b1, nat s1, nat b2, nat s2\]():
        Array3[\T,b0,s0,b1,s1,b2,s2\] =
  __DefaultArray3[\T,b0,s0,b1,s1,b2,s2\]()

array3[\T,nat s0, nat s1, nat s2\]():Array3[\T,0,s0,0,s1,0,s2\] =
  __DefaultArray3[\T,0,s0,0,s1,0,s2\]()

(*************

trait Monoid[\ T, opr OPLUS \]
  where { T extends Monoid[\ T, OPLUS \] }
    zero() : T
    opr OPLUS(self, other:T):T
end

*************)

(* Simple mockup of Generators and Reductions. *)

(* The reduction traits allow us to define systematic
recursively-decomposed computations in the absence of a real Generator
hierarchy.  The simplest instance of a reduction defines two functions:
  empty -- What to do if we reach an empty portion of a structure
  join  -- How to combine two pieces of a structure if we don't care which dimension it was split in.
*)

trait Reduction[\ R \]
    getter toString() = "A Reduction without a toString() of its own"
    empty(): R
    join(a: R, b: R): R
end

object VoidReduction extends Reduction[\()\]
    getter toString() = "VoidReduction"
    empty(): () = ()
    join(a: (), b: ()): () = ()
end

object SumReduction[\N extends Number\]() extends Reduction[\N\]
    getter toString() = "SumReduction"
    empty(): N = 0
    join(a: N, b: N): N = a+b
end

object MinReduction[\N extends Number\]() extends Reduction[\N\]
    getter toString() = "MinReduction"
    empty(): N = 0
    join(a: N, b: N): N = a MIN b
end

object MaxReduction[\N extends Number\]() extends Reduction[\N\]
    getter toString() = "MaxReduction"
    empty(): N = 0
    join(a: N, b: N): N = a MAX b
end

(** TODO: AndReduction and OrReduction have natural zeros, and could
 *  take advantage of early exit.
 *
 *  In the absence of full algebraic fanciness, we might still use
 *  label/exit on a thunked domain to achieve the same effect, in
 *  effect pushing the control into the reduction operator itself.
 *)

object AndReduction extends Reduction[\Boolean\]
    getter toString() = "AndReduction"
    empty(): Boolean = true
    join(a: Boolean, b: Boolean): Boolean = a AND b
end

object OrReduction extends Reduction[\Boolean\]
    getter toString() = "OrReduction"
    empty(): Boolean = false
    join(a: Boolean, b: Boolean): Boolean = a OR b
end

object StringReduction extends Reduction[\String\]
    getter toString() = "StringReduction"
    empty(): Boolean = ""
    join(a:String, b:String): String = a b
end

object MapReduceReduction[\R\](j:(R,R)->R, z:R) extends Reduction[\R\]
    getter toString()="mapReduce.Reduction"
    empty() = z
    join(a:R, b:R): R = (j)(a,b)
end

(** Helpers for maps and cross products of generators.  These can be
    quite a bit more sophisticated (for example, we can hoist maps
    outwards if we think that'd be useful), but let's get this much
    working first. *)

trait MappedGenerator[\E,F\] extends Generator[\F\]
    getter g(): Generator[\E\]
    getter f(): E -> F
    getter toString(): String = g() ".map(f)"
    generate[\R\](r: Reduction[\R\], m: F->R): R =
        g().generate[\R\](r, m COMPOSE f())
    reduce(r: Reduction[\F\]): F =
        g().generate[\F\](r, f())
    map[\G\](f': F->G): SimpleMappedGenerator[\E,G\] =
        SimpleMappedGenerator[\E,G\](g(), f' COMPOSE f())
    seq(self) = SimpleMappedSeqGenerator[\E,F\](sequential(g()),f())
end

object SimpleMappedGenerator[\E,F\](g0: Generator[\E\], f0: E->F)
        extends MappedGenerator[\E,F\]
    getter g() = g0
    getter f() = f0
end

object SimpleMappedIndexed[\E,F,I\](g0: Indexed[\E,I\], f0: E->F)
        extends { MappedGenerator[\E,F\], Indexed[\F,I\] }
    getter size(): ZZ32 = g().size()
    getter g() = g0
    getter f() = f0
    getter bounds(): Range[\I\] = g().bounds()
    getter indexValuePairs(): Indexed[\(I,F),I\] =
        g().indexValuePairs().map[\(I,F)\](fn (i:I, e:E): F => (i,(f())(e)))
    getter indices(): Indexed[\I,I\] = g().indices()
    opr[i:I] : F = (f())(g()[i])
    opr[r:Range[\I\]] : Indexed[\F,I\] =
        SimpleMappedIndexed[\E,F,I\](g()[r],f())

    ivmap[\R\](ff:(I,E)->R): SimpleMappedIndexed[\E,R,I\] =
        g0().ivmap[\R\](fn (i:I, e:E) => ff(i, (f())(e)))
    map[\G\](f': F->G): SimpleMappedIndexed[\E,G,I\] =
        SimpleMappedIndexed[\E,G,I\](g(), f' COMPOSE f())
end

object SimpleMappedSeqGenerator[\E,F\](g0: SequentialGenerator[\E\], f0: E->F)
        extends { MappedGenerator[\E,F\], SequentialGenerator[\F\] }
    getter g() = g0
    getter f() = f0
    getter toString() = "seq(" g ".map(f))"
    seq(self): SimpleMappedSeqGenerator[\E,F\] = self
end

trait NestedGenerator[\E,F\] extends Generator[\F\]
    getter g(): Generator[\E\]
    getter f(): E -> Generator[\F\]
    getter toString(): String
    generate[\R\](r: Reduction[\R\], m: F->R): R =
        g().generate[\R\](r,fn (e:E):R => (f())(e).generate[\R\](r,m))
    mapReduce[\R\](body: F->R, join:(R,R)->R, zero:R): R =
        g().mapReduce[\R\](
            fn (e:E): R => (f())(e).mapReduce[\R\](body,join,zero),
            join, zero)
    reduce(r: Reduction[\F\]): F =
        g().generate[\F\](r,fn (e:E):F => (f())(e).reduce(r))
    reduce(j:(F,F)->F, z:F):F =
        g().mapReduce[\F\](fn (e:E): F => (f())(e).reduce(j,z), j, z)
    loop(body:F->()): () =
        g().loop(fn (e:E) => (f())(e).loop(body))
    map[\G\](h:F->G): Generator[\G\] =
        g().nest[\G\](fn (e:E): G => (f())(e).map[\G\](h))
    nest[\G\](h:F->Generator[\G\]): Generator[\G\] =
        g().nest[\G\](fn (e:E):Generator[\G\] => (f())(e).nest[\G\](h))
end

object SimpleNestedGenerator[\E,F\](g0: Generator[\E\], f0: E->Generator[\F\])
        extends { NestedGenerator[\E,F\] }
    getter g() = g0
    getter f() = f0
    getter toString() = g() ".nest(f)"
    seq(self) =
        typecase ff = f() of
            (E -> SequentialGenerator[\F\]) =>
                SimpleNestedSeqGenerator[\E,F\](sequential(g()),ff)
            else =>
                SimpleNestedSeqGenerator[\E,F\](sequential(g()),
                     fn (e:E): SequentialGenerator[\F\] => sequential(f()(e)))
        end
end

object SimpleNestedSeqGenerator[\E,F\]
        (g0: SequentialGenerator[\E\], f0: E->SequentialGenerator[\F\])
        extends { NestedGenerator[\E,F\], SequentialGenerator[\F\] }
    getter g() = g0
    getter f() = f0
    getter toString() = "seq(" g() ".nest(f))"
end

trait PairGenerator[\E,F\] extends Generator[\(E,F)\]
  comprises { SimplePairGenerator[\E,F\], SimplePairSeqGenerator[\E,F\] }
    getter e(): Generator[\E\]
    getter f(): Generator[\F\]
    getter toString(): String
    getter size() = e().size() f().size()
    generate[\R\](r: Reduction[\R\], m:(E,F)->R): R =
        e().generate[\R\](r, fn (a: E): R =>
                              f().generate[\R\](r, fn (b: F): R => m(a,b)))
end

object SimplePairGenerator[\E,F\](e0: Generator[\E\], f0: Generator[\F\])
        extends PairGenerator[\E,F\]
    getter e() = e0
    getter f() = f0
    getter toString()=(e ".cross(" f ")" )
    seq(self) = SimplePairSeqGenerator[\E,F\](sequential(e),sequential(f))
end

object SimplePairSeqGenerator[\E,F\](e0: Generator[\E\], f0: Generator[\F\])
        extends { PairGenerator[\E,F\], SequentialGenerator[\(E,F)\] }
    getter e() = e0
    getter f() = f0
    getter toString()=("seq(" e ".cross(" f "))" )
end

(** Helper for serializing generators naively.  This code should make
 *  obvious that naive seq is *VERY INEFFICIENT*.  It
 *  constructs a function closure whose size is proportional to
 *  g.size(), and then executes that closure.  This trick is old hat
 *  to lambda-calculus wonks, but pretty unfamiliar to the common man.
 *
 *  Basically each element takes in the accumulated value a from the element
 *  to its left.  This is joined with the result of mapping on the
 *  current element value, and that result is returned.  Join simply
 *  reverse-composes the functions for its subtrees, so the output of the left
 *  subtree is fed to the right subtree.
 *
 *  Note that a similar trick can be used to reverse and sequentialize
 *  a generator (use forward function composition rather than reverse
 *  composition, and flipping around the join at the leaves). *)
object NaiveSeqGenerator[\E\](g: Generator[\E\])
        extends SequentialGenerator[\E\]
    size() = g.size()
    toString() = "sequential(" g.toString() ")"
    generate[\R\](r: Reduction[\R\], m:E->R): R = do
      rcompose(f:R->R, g:R->R): R->R = fn (x:R):R => g(f(x))
      id(x:R):R = x
      mp(x:E):R->R = fn (a:R):R => r.join(a,m(x))
      f : R -> R = g.mapReduce[\R->R\](mp,rcompose,id)
      mt : R = r.empty()
      f mt
    end
end

(** Ranges in general represent uses of the # and : operators.
    It's mostly subtypes of Range that are interesting.  **)
trait Range[\T\] extends { Equality }
    comprises { RangeWithLower[\T\], RangeWithUpper[\T\],
                RangeWithExtent[\T\], PartialRange[\T\] }
    excludes { Number }
end

trait PartialRange[\T\] extends Range[\T\]
    comprises { OpenRange[\T\],
                LowerRange[\T\], UpperRange[\T\], ExtentRange[\T\] }
    excludes { FullRange[\T\] }
end

object OpenRange[\T\]() extends { Range[\T\], PartialRange[\T\] }
    toString():String = "#"
    eq[\U\](_:OpenRange[\U\]): Boolean = true
end

trait RangeWithLower[\T\] extends Range[\T\]
        comprises { LowerRange[\T\], FullRange[\T\] }
    getter lower():T
end

object LowerRange[\T\](lo:T) extends { RangeWithLower[\T\], PartialRange[\T\] }
    getter lower():T = lo
    toString():String = lower() "#"
    eq(x:LowerRange[\T\]): Boolean = lower() = x.lower()
end

trait RangeWithUpper[\T\] extends Range[\T\]
        comprises { UpperRange[\T\], FullRange[\T\] }
    getter upper():T
end

object UpperRange[\T\](up:T) extends { RangeWithUpper[\T\], PartialRange[\T\] }
    getter upper():T = up
    toString():String = ":" upper()
    eq(x:UpperRange[\T\]): Boolean = upper() = x.upper()
end

trait RangeWithExtent[\T\] extends Range[\T\]
        comprises { ExtentRange[\T\], FullRange[\T\] }
    getter extent():T
    toString():String = "#" extent()
end

object ExtentRange[\T\](ex:T) extends { RangeWithExtent[\T\], PartialRange[\T\] }
    getter extent():T = ex
    eq(x:ExtentRange[\T\]): Boolean = extent() = x.extent()
end

trait FullRange[\T\]
        extends { RangeWithLower[\T\], RangeWithUpper[\T\],
                  RangeWithExtent[\T\], Indexed[\T,T\] }
        comprises { ScalarRange[\T\], TupleRange[\T\] }
    getter indices(): FullRange[\T\] = bounds()

    map[\G\](f: T->G): Generator[\G\] = SimpleMappedGenerator[\T,G\](self,f)
    opr[r:Range[\T\]]: FullRange[\T\] = fail("Unrecognized Range " r)
    opr[_:OpenRange[\T\]]: FullRange[\T\] = self
    (** Square-bracket indexing on a FullRange restricts that range to
         the range provided.  Restriction should behave as follows:
            - Restriction to an OpenRange is the identity.
            - An UpperRange or ExtentRange restrict the upper bound and
              extent of the range.
          - A LowerRange restricts the lower bound and extent of the range.
        Note that this makes it compatible with the square-bracket
        indexing of the Indexed trait. **)
    opr[r:LowerRange[\T\]]: FullRange[\T\] =
        if r.lower() = lower() then
            (* Important, also handles empty range case. *)
            self
        elif r.lower() IN self then
            r.lower():upper()
        else
            fail(self "[" r "] does not contain lower bound")
        end
    opr[r:UpperRange[\T\]]: FullRange[\T\] =
        if r.upper() = upper() then
            (* Important, also handles empty range case. *)
            self
        elif r.upper() IN self then
            lower():r.upper()
        else
            fail(self "[" r "] does not contain upper bound")
        end
    opr[r:ExtentRange[\T\]]: FullRange[\T\] =
        if r.extent() <= extent() then
            lower()#r.extent()
        else
            fail(self "[" r "] is not sufficiently large in some dimension")
        end
    opr[r:FullRange[\T\]]: FullRange[\T\] =
        if r.lower() < lower() then
            fail(self "[" r "] does not contain lower bound")
        elif r.upper() > upper() then
            fail(self "[" r "] does not contain upper bound")
        else
            r
        end

    toString():String = lower() "#" extent()
end

rangeIndexFailure[\T\](r:FullRange[\T\],i:T): () =
    fail(r "[" i "] out of range.")

(** ParRanges and SeqRanges, the simplest and most basic of all
generators.  They generate size() numbers, incrementing by 1, starting
with lower() (that's the canonical ordering). *)
trait ScalarRange[\N extends Integral\]
        extends { FullRange[\N\] }
    getter bounds():FullRange[\N\] = 0#extent()
    getter upper():N = lower() + extent() - 1
    getter size():ZZ32 = narrow(|\extent()/|)
    opr[i:N]: N =
        if i >= 0 AND i < extent() then
            i + lower()
        else
            rangeIndexFailure[\N\](self,i)
        end
    contains(a:N): Boolean = do
        t = a - lower()
        t >= 0 AND t < size()
      end
end

value object ParRange[\N extends Integral\](lo:N, ex:N)
        extends ScalarRange[\N\]
    getter extent() = ex
    getter lower() = lo
    getter indexValuePairs() =
        ParRange[\N\](0,ex).map[\(N,N)\](fn (n:N):(N,N) => (n,n+lo))

    seq(self) = SeqRange[\N\](lo,ex)
    generate[\R\](r: Reduction[\R\], m: N->R): R =
        if size() < 1 then
            r.empty()
        else
            gen(l,s) = if s>=2 then
                           (s1,s2) = partition(s)
                           r.join(gen(l,s1),gen(l+s1,s2))
                       else
                           m(l)
                       end
            gen(lo,size())
        end

    mapReduce[\R\](m: N->R, j:(R,R)->R, z:R): R =
        if size() < 1 then
            z
        else
            gen(l,s) = if s>=2 then
                           (s1,s2) = partition(s)
                           j(gen(l,s1),gen(l+s1,s2))
                       else
                           m(l)
                       end
            gen(lo,size())
        end
    reduce(j:(N,N)->N, z:N):N =
        if size() < 1 then
            z
        else
            gen(l,s) = if s>=2 then
                           (s1,s2) = partition(s)
                           j(gen(l,s1),gen(l+s1,s2))
                       else
                           l
                       end
            gen(lo,size())
        end
    reduce(r: Reduction[\N\]):N =
        if size() < 1 then
            r.empty()
        else
            gen(l,s) = if s>=2 then
                           (s1,s2) = partition(s)
                           r.join(gen(l,s1),gen(l+s1,s2))
                       else
                           l
                       end
            gen(lo,size())
        end
    loop(f:N->()): () =
        if size() < 1 then
            ()
        else
            gen(l,s) = if s>=2 then
                           (s1,s2) = partition(s)
                           (gen(l,s1),gen(l+s1,s2))
                           ()
                       else
                           f(l)
                       end
            gen(lo,size())
        end
    eq(x:ParRange[\N\]): Boolean = lower()=x.lower() AND size()=x.size()
end
value object SeqRange[\N extends Integral\](lo:N, ex:N)
        extends { ScalarRange[\N\], SequentialGenerator[\N\] }
    getter extent() = ex
    getter lower() = lo
    getter toString() = "seq(" lo "#" ex ")"
    getter indexValuePairs() =
        SeqRange[\N\](0,ex).map[\(N,N)\](fn (n:N):(N,N) => (n,n+lo))
    generate[\R\](r: Reduction[\R\], m: N->R): R = do
        h = lo + ex
        l : N := lo
        acc : R = r.empty()
        (* DO NOT DEFINE THIS USING RECURSION!!! *)
        while l < h do
            acc := r.join(acc, m(l))
            l += 1
        end
        acc
      end
    loop(f: N->()): () = do
        h = lo + ex
        l : N := lo
        (* DO NOT DEFINE THIS USING RECURSION!!! *)
        while l < h do
            f(l)
            l += 1
        end
      end
    eq(x:SeqRange[\N\]): Boolean = lower()=x.lower() AND size()=x.size()
end

trait TupleRange[\T\] extends FullRange[\T\]
end

object Tuple2Range[\N extends Integral, M extends Integral\]
                  (l1:N,l2:M,x1:N,x2:M)
        extends { TupleRange[\(N,M)\], DelegatedIndexed[\(N,M),(N,M)\] }
    getter bounds():(N,M) = (0,0)#(x1,x2)
    getter extent():(N,M) = (x1,x2)
    getter lower():(N,M) = (l1,l2)
    getter upper():(N,M) = ((l1#x1).upper(), (l2#x2).upper())
    getter size():(N,M) = (l1#x1).size() (l2#x2).size()
    getter generator():Generator[\(N,M)\] = (l1#x1).cross[\M\](l2#x2)
    getter toString(): String = "(" l1 "," l2 ")#(" x1 "," x2 ")"
    getter indexValuePairs() =
        Tuple2Range[\N\](0,0,x1,x2).map[\((N,M),(N,M))\](
            fn (n:N,m:M):((N,M),(N,M)) => ((n,m),(n+l1,m+l2)))
    opr[i:(N,M)]: (N,M) = do
        (i1,i2) = i
        if i1 IN (0#x1) AND i2 IN (0#x2) then
            (i1+l1,i2+l2)
        else
            rangeIndexFailure[\(N,M)\](self,i)
        end
      end
    contains(v1:N, v2:M): Boolean =
        v1 IN (l1#x1) AND v2 IN (l2#x2)
    eq(r:Tuple2Range[\N,M\]): Boolean =
        l1.eq(r.l1) AND l2.eq(r.l2) AND x1.eq(r.x1) AND x2.eq(r.x2)
end

object Tuple3Range[\N1 extends Integral, N2 extends Integral, N3 extends Integral\]
                  (l1:N1,l2:N2,l3:N3,x1:N1,x2:N2,x3:N3)
        extends { TupleRange[\(N1,N2,N3)\],
                  DelegatedIndexed[\(N1,N2,N3),(N1,N2,N3)\] }
    getter extent():(N1,N2,N3) = (x1,x2,x3)
    getter lower():(N1,N2,N3) = (l1,l2,l3)
    getter upper():(N1,N2,N3) =
        ((l1#x1).upper(), (l2#x2).upper(), (l3#x3).upper())
    getter size():(N1,N2,N3) = (l1#x1).size() (l2#x2).size() (l3#x3).size()
    getter generator():Generator[\(N1,N2,N3)\] =
        (l1#x1).cross(l2#x2).cross(l3#x3).map[\(N1,N2,N3)\](
            fn (t:(N1,N2),n3:N3):(N1,N2,N3) => do (n1,n2)=t; (n1,n2,n3) end)
    getter toString(): String = "(" l1 "," l2 "," l3 ")#(" x1 "," x2 "," x3 ")"
    getter indexValuePairs() =
        (0#x1).cross(0#x2).cross(0#x3).map[\((N1,N2,N3),(N1,N2,N3))\](
            fn (t:(N1,N2),n3:N3):((N1,N2,N3),(N1,N2,N3)) =>
                do (n1,n2)=t; ((n1,n2,n3),(n1+l1,n2+l2,n3+l3)) end)
    opr[i:(N1,N2,N3)]: (N1,N2,N3) = do
        (i1,i2,i3) = i
        if i1 IN (0#x1) AND i2 IN (0#x2) AND i3 IN (0#x3) then
            (i1+l1,i2+l2, i3+l3)
        else
            rangeIndexFailure[\(N1,N2,N3)\](self,i)
        end
      end
    contains(v1:N1, v2:N2, v3:N3): Boolean =
        v1 IN (l1#x1) AND v2 IN (l2#x2) AND v3 IN (l3#x3)
    eq(r:Tuple3Range[\N1,N2,N3\]): Boolean =
        l1.eq(r.l1) AND l2.eq(r.l2) AND x1.eq(r.x1) AND x2.eq(r.x2) AND
        l3.eq(r.l3) AND x3.eq(r.x3)
end

(** The # and : operators serve as factories for parallel ranges. **)
opr #[\I extends Integral\](lo:I, ex:I): ParRange[\I\] = ParRange[\I\](lo,ex)
opr #(lo:IntLiteral, ex:IntLiteral): ParRange[\ZZ32\] = ParRange[\ZZ32\](lo,ex)
opr #[\I extends Integral, J extends Integral\]
     (lo:(I,J), ex:(I,J)): Tuple2Range[\I,J\] =
    do (l1,l2)=lo; (x1,x2)=ex; Tuple2Range[\I,J\](l1,l2,x1,x2) end
opr #[\I extends Integral, J extends Integral, K extends Integral\]
     (lo:(I,J,K), ex:(I,J,K)): Tuple3Range[\I,J,K\] =
    do (l1,l2,l3)=lo; (x1,x2,x3)=ex; Tuple3Range[\I,J,K\](l1,l2,l3,x1,x2,x3) end

opr :[\I extends Integral\](lo:I, hi:I): ParRange[\I\] =
        ParRange[\I\](lo,hi-lo+1)
opr :(lo:IntLiteral, ex:IntLiteral): ParRange[\ZZ32\] =
        ParRange[\ZZ32\](lo,hi-lo+1)
opr :[\I extends Integral, J extends Integral\]
     (lo:(I,J), hi:(I,J)): Tuple2Range[\I,J\] =
    do (l1,l2)=lo; (h1,h2)=hi; Tuple2Range[\I,J\](l1,l2,h1-l1+1,h2-l2+1) end
opr :[\I extends Integral, J extends Integral, K extends Integral\]
     (lo:(I,J,K), hi:(I,J,K)): Tuple3Range[\I,J,K\] = do
    (l1,l2,l3)=lo; (h1,h2,h3)=hi
    Tuple3Range[\I,J,K\](l1,l2,l3,h1-l1+1,h2-l2+1,h3-l3+1)
  end

(** Factories for incomplete ranges **)
(* BUG: we can't define both a prefix and a suffix version of a single
   operator right now.  They get thrown into the same overloading
   bucket.  Meanwhile, if we define a prefix operator and use it in
   suffix form it'll work and vice versa. *)
(*
opr [\T\](x:T)# : LowerRange[\T\] = LowerRange[\T\](x)
*)
opr [\T\](x:T): : LowerRange[\T\] = LowerRange[\T\](x)
opr #[\T\](x:T) : ExtentRange[\T\] = ExtentRange[\T\](x)

(*
opr :[\T\](x:T) : UpperRange[\T\] = UpperRange[\T\](x)
*)

opr #(): OpenRange[\Any\] = OpenRange[\Any\]()
opr :(): OpenRange[\Any\] = OpenRange[\Any\]()

(***********************************************************
 * NUMERIC primitives, down here to avoid ordering hosure. *)

opr [\ N extends Integral \]|x:N| = if x>=0 then x else -x end

opr -(a:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Negate")
opr +(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Add")
opr -(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Sub")
opr DOT(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Mul")
opr juxtaposition
     (a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Mul")
opr DIV(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Div")
opr REM(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Rem")
opr MOD(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Mod")
opr GCD(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Gcd")
opr LCM(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Lcm")
opr CHOOSE(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Choose")
opr BITAND(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$BitAnd")
opr BITOR(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$BitOr")
opr BITXOR(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$BitXor")
opr LSHIFT(a:ZZ32,b:Integral):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$LShift")
opr RSHIFT(a:ZZ32,b:Integral):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$RShift")
opr BITNOT(a:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$BitNot")
opr =(a:ZZ32, b:ZZ32):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Eq")
opr <=(a:ZZ32, b:ZZ32):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$LessEq")
opr MIN(a:ZZ32, b:ZZ32):ZZ32 = if a <= b then a else b end
opr MAX(a:ZZ32, b:ZZ32):ZZ32 = if b <= a then a else b end
opr ^(a:ZZ32, b:Integral):Number = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Pow")
widen(a:ZZ32):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$ToLong")
partitionL(a:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Partition")

nanoTime():ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$NanoTime")
printTaskTrace():() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$PrintTaskTrace")

__globalTimeInformation: ZZ64 := 0
recordTime(dummy: Any): () = do __globalTimeInformation := nanoTime() end
printTime(dummy: Any): () = do
    r = nanoTime()
    e = r - __globalTimeInformation
    __globalTimeInformation := r
    secs: ZZ64 = (e+500000) DIV 1000000
    println("Operation took " secs "ms")
  end

opr -(a: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Negate")
opr +(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Add")
opr -(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Sub")
opr DOT(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Mul")
opr juxtaposition
     (a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Mul")
opr DIV(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Div")
opr REM(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Rem")
opr MOD(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Mod")
opr GCD(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Gcd")
opr LCM(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Lcm")
opr CHOOSE(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Choose")
opr BITAND(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$BitAnd")
opr BITOR(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$BitOr")
opr BITXOR(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$BitXor")
opr LSHIFT(a: IntLiteral,b:Integral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$LShift")
opr RSHIFT(a: IntLiteral,b:Integral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$RShift")
opr BITNOT(a: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$BitNot")
opr =(a: IntLiteral, b: IntLiteral):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Eq")
opr <=(a: IntLiteral, b: IntLiteral):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$LessEq")
opr MIN(a: IntLiteral, b: IntLiteral): IntLiteral = if a <= b then a else b end
opr MAX(a: IntLiteral, b: IntLiteral): IntLiteral = if b <= a then a else b end
opr ^(a: IntLiteral, b:Integral):Number = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Pow")

opr -[\ T extends Number, nat n, nat m \]
     (a:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Negate")
opr +[\ T extends Number, nat n, nat m \]
     (a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Add")
opr -[\ T extends Number, nat n, nat m \]
     (a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Sub")
opr DOT[\ T extends Number, nat n, nat m, nat p \]
     (a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Mul")
opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Mul")
opr DIV(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Div")
opr REM(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Rem")
opr MOD(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Mod")
opr GCD(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Gcd")
opr LCM(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Lcm")
opr CHOOSE(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Choose")
opr BITAND(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$BitAnd")
opr BITOR(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$BitOr")
opr BITXOR(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$BitXor")
opr LSHIFT(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$LShift")
opr RSHIFT(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$RShift")
opr BITNOT(a:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$BitNot")
opr =(a:Integral, b:Integral):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Eq")
opr <=(a:Integral, b:Integral):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$LessEq")
opr MIN(a:Integral, b:Integral):ZZ64 = if a <= b then a else b end
opr MAX(a:Integral, b:Integral):ZZ64 = if b <= a then a else b end
opr ^(a:ZZ64, b:Integral):Number = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Pow")
narrow(a:ZZ64):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$FromLong")

opr   <(a:Integral, b:Integral):Boolean = NOT (b <= a)
opr   >(a:Integral, b:Integral):Boolean = NOT (a <= b)
opr  >=(a:Integral, b:Integral):Boolean = b <= a

opr -(a:RR64):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Negate")
opr +(a:Number,b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Add")
opr -(a:Number,b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Sub")
opr DOT(a:Number,b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Mul")
opr juxtaposition
     (a:Number,b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Mul")
opr /(a:Number,b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Div")
opr =(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Eq")
opr =/=(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$NEq")
opr <(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Less")
opr <=(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$LessEq")
opr >(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Greater")
opr >=(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$GreaterEq")
opr MIN(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Min")
opr MAX(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Max")
opr |a:RR64|:RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Abs")
opr ^(a:Number, b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Pow")
opr SQRT(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Sqrt")
sin(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Sin")
cos(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Cos")
tan(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Tan")
asin(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$ASin")
acos(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$ACos")
atan(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$ATan")
atan2(y:Number,x:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$ATan2")
log(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Log")
exp(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Exp")
floor(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Floor")
opr |\a:Number/|:ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$IFloor")
ceiling(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Ceiling")
opr |/a:Number\|:ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$ICeiling")
truncate(a:Number):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Truncate")
random(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Random")

opr =(a:Char, b:Char):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Char$Eq")

opr DOT(a:String, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:String, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(a:Number, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:Number, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(a:String, b:Number):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:String, b:Number):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(a:Boolean, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:Boolean, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(a:String, b:Boolean):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:String, b:Boolean):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
oprDOT(a:String, c:Char):String =builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:String, c:Char):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
oprDOT(c:Char, a:String):String =builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (c:Char, a:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(a:String, b:()):String = a "()"
opr juxtaposition(a:String, b:()):String = a "()"
opr DOT(a:String, b:(Any,Any)):String = do (i,j) = b; a "(" i "," j ")" end
opr juxtaposition(a:String, b:(Any,Any)):String =
    do (i,j) = b; a "(" i "," j ")" end
opr DOT(a:(), b:String):String = "()" b
opr juxtaposition(a:(), b:String):String = "()" b
opr DOT(a:Any, b:String):String = a.toString() b
opr juxtaposition(a:Any, b:String):String = a.toString() b
opr DOT(a:String, b:Any):String = a b.toString()
opr juxtaposition(a:String, b:Any):String = a b.toString()

opr =(a:String, b:String):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Eq")
opr <(a:String, b:String):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Less")
opr <=(a:String, b:String):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$LessEq")
opr >(a:String, b:String):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Greater")
opr >=(a:String, b:String):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$GreaterEq")

outFileOpen(name:String):BufferedWriter = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.File$OutFileOpen")
outFileWrite(file: BufferedWriter, str: String):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.File$OutFileWrite")
outFileClose(file: BufferedWriter):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.File$OutFileClose")

substring(str: String, beginIndex: ZZ32, endIndex: ZZ32):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Substring")
length(str: String):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Length")

print(a:String):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Print")
println(a:String):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Println")
print(a:Number):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Print")
println(a:Number):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Println")
print(a:Boolean):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Print")
println(a:Boolean):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Println")
println(a:Char):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Println")
print(a:Any):() = print("" a)
println(a:Any):() = println("" a)
(* 0-argument versions handle passing of () to single-argument versions. *)
print():() = print("()")
println():() = println("")

(* These are useful temporary hacks for debugging multi-threaded programs *)
printThreadInfo(a:String):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$PrintThreadInfo")
printThreadInfo(a:Number):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$PrintThreadInfo")
throwError(a:String):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$ThrowError")

opr  OR(a:Boolean, b:Boolean):Boolean = if a then true else b end
opr AND(a:Boolean, b:Boolean):Boolean = if a then b else false end
opr NOT(a:Boolean):Boolean = if a then false else true end
opr =(a:Boolean, b:Boolean):Boolean = if a then b else NOT b end
opr ->(a: Boolean, b:Boolean):Boolean = if a then b else true end
opr <->(a: Boolean, b:Boolean):Boolean = a=b
opr +[\T extends Number\](x:T):T = x

end
