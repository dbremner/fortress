// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, Version 1.10.0, (C) 2004-2006 Robert Grimm
// on Wednesday, October 24, 2007 at 11:37:16 AM.
// Edit at your own risk.
// ===========================================================================

package com.sun.fortress.parser.preparser;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Pair;


import xtc.parser.FullParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import com.sun.fortress.interpreter.evaluator.ProgramError;
import com.sun.fortress.parser_util.precedence_opexpr.PrecedenceOpExpr;
import com.sun.fortress.parser_util.precedence_opexpr.Left;
import com.sun.fortress.parser_util.precedence_opexpr.Right;
import com.sun.fortress.parser_util.precedence_opexpr.RealExpr;
import com.sun.fortress.parser_util.precedence_opexpr.TightInfix;
import com.sun.fortress.parser_util.precedence_opexpr.LooseInfix;
import com.sun.fortress.parser_util.precedence_opexpr.Prefix;
import com.sun.fortress.parser_util.precedence_opexpr.Postfix;
import com.sun.fortress.parser_util.precedence_resolver.*;
import com.sun.fortress.nodes.*;
import com.sun.fortress.nodes_util.*;
import com.sun.fortress.parser_util.*;
import com.sun.fortress.useful.PureList;
import com.sun.fortress.useful.Empty;
import com.sun.fortress.useful.Cons;
import edu.rice.cs.plt.tuple.Option;
import edu.rice.cs.plt.iter.IterUtil;
import xtc.util.Action;
import java.util.Collections;
import java.util.ArrayList;
import java.util.List;

import static com.sun.fortress.interpreter.evaluator.ProgramError.errorMsg;
import static com.sun.fortress.interpreter.evaluator.ProgramError.error;
import static com.sun.fortress.interpreter.evaluator.InterpreterBug.bug;

/**
 * Packrat parser for grammar <code>PreFortress</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.10.0, (C) 2004-2006 Robert Grimm.
 */
public final class PreFortress extends FullParserBase {

  /** The FORTRESS_KEYWORDS set. */
  public static final Set<String> FORTRESS_KEYWORDS = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fImports;
    Result fImports$$Star1;
    Result fImport;
    Result fAliasedName;
    Result fEncloserPair;
    Result fAliasedDottedName;
    Result fCoercions;
    Result fCoercions$$Star1;
    Result fGoesFrontInAnObject;
    Result fGoBackInAnObject;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fGoBackInAnObject$$Star1;
    Result fGoesBackInAnObject;
    Result fParameter$ValParam;
    Result fParameter$Params;
    Result fParameter$Params$$Star1;
    Result fParameter$Params$$Star2;
    Result fParameter$Params$$Star3;
    Result f$$Shared15;
    Result fParameter$Keyword;
    Result f$$Shared2;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fParameter$Param;
    Result fMdHeaderFront;
    Result fCoercion;
    Result fCoercionWhereClause;
    Result fMethodParam$ValParam;
    Result fMethodParam$Params;
    Result fMethodParam$Params$$Star1;
    Result fMethodParam$Params$$Star2;
    Result fMethodParam$Params$$Star3;
    Result fMethodParam$Keyword;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fMethodParam$Param;
    Result fField$VarWType;
    Result f$$Shared3;
    Result fTraitTypeWhere;
    Result fExtends;
    Result fTraitTypes;
    Result fWhere;
    Result fWhereClause;
    Result fIntVal;
    Result fIntExpr;
  }

  /** Chunk 5 of memoized results. */
  static final class Chunk5 {
    Result fIntExpr$$Star1;
    Result fBoolVal;
    Result fBoolExpr;
    Result fBoolExpr$$Star1;
    Result fFnHeaderClause;
    Result fThrows;
    Result fEnsures;
    Result fEnsuresClause;
    Result fInvariant;
    Result fFnMod;
  }

  /** Chunk 6 of memoized results. */
  static final class Chunk6 {
    Result fLocalFnMod;
    Result fStaticParams;
    Result fStaticParam;
    Result fPropertyDecl;
    Result fIsType;
    Result fTypeFrontNonArrow;
    Result fArrowTypeTail;
    Result fNonArrowType;
    Result fTraitType;
    Result fTraitType$$Star1;
  }

  /** Chunk 7 of memoized results. */
  static final class Chunk7 {
    Result fTupleType;
    Result fTupleType$$Star1;
    Result fTupleType$$Star2;
    Result fKeywordType;
    Result fSimpleTupleType;
    Result fTypeList;
    Result fTypeList$$Star1;
    Result fDimExpr;
    Result fDimExpr$$Star1;
    Result fStaticArgList;
  }

  /** Chunk 8 of memoized results. */
  static final class Chunk8 {
    Result fStaticArgList$$Star1;
    Result fStaticArg;
    Result fDUPreOp;
    Result fDUPostOp;
    Result fArraySize;
    Result fArraySize$$Star1;
    Result fExtentRange;
    Result fNumber;
    Result fExpression$Expr;
    Result fExpression$Expr$$Star1;
  }

  /** Chunk 9 of memoized results. */
  static final class Chunk9 {
    Result f$$Shared19;
    Result f$$Shared19$$Star1;
    Result f$$Shared18;
    Result f$$Shared18$$Plus1;
    Result fExpression$OpExpr;
    Result fExpression$OpExprNoEnc;
    Result fExpression$LeftLooseInfix;
    Result fExpression$OpExprLeftEncloser;
    Result fExpression$OpExprPrimary;
    Result fExpression$OpExprPrefix;
  }

  /** Chunk 10 of memoized results. */
  static final class Chunk10 {
    Result fExpression$LooseInfix;
    Result fExpression$Primary;
    Result fExpression$Primary$$Star1;
    Result f$$Shared8;
    Result fExpression$UnitExpr;
    Result fExpression$UnitExpr$$Star1;
    Result fExpression$AtomicBack;
    Result fExpression$GeneratorList;
    Result fExpression$GeneratorList$$Star1;
    Result fExpression$Generator;
  }

  /** Chunk 11 of memoized results. */
  static final class Chunk11 {
    Result fDelimitedExpr;
    Result fDo;
    Result fDo$$Star1;
    Result fDoFront;
    Result fTupleExpr;
    Result fTupleExpr$$Star1;
    Result fTupleExpr$$Star2;
    Result fNoKeyTuple;
    Result fNoKeyTuple$$Star1;
    Result fNoKeyTuple$$Plus1;
  }

  /** Chunk 12 of memoized results. */
  static final class Chunk12 {
    Result fParenthesized;
    Result fElifs;
    Result fElifs$$Star1;
    Result fElif;
    Result fElse;
    Result fCaseClauses;
    Result fCaseClauses$$Star1;
    Result fCaseElse;
    Result fBinding;
    Result fTypecaseClause;
  }

  /** Chunk 13 of memoized results. */
  static final class Chunk13 {
    Result fTypecaseTypes;
    Result fCatch;
    Result fCatchClause;
    Result fEntry;
    Result fIdOrInt;
    Result fBaseExpr;
    Result fExprList;
    Result fExprList$$Star1;
    Result fNoNewlineExpr$Expr;
    Result fNoNewlineExpr$Expr$$Star1;
  }

  /** Chunk 14 of memoized results. */
  static final class Chunk14 {
    Result fNoNewlineExpr$OpExpr;
    Result fNoNewlineExpr$OpExprNoEnc;
    Result fNoNewlineExpr$LeftLooseInfix;
    Result fNoNewlineExpr$OpExprLeftEncloser;
    Result fNoNewlineExpr$OpExprPrimary;
    Result fNoNewlineExpr$OpExprPrefix;
    Result fNoNewlineExpr$LooseInfix;
    Result fNoNewlineExpr$Primary;
    Result fNoNewlineExpr$Primary$$Star1;
    Result fNoNewlineExpr$UnitExpr;
  }

  /** Chunk 15 of memoized results. */
  static final class Chunk15 {
    Result fNoNewlineExpr$UnitExpr$$Star1;
    Result fNoNewlineExpr$AtomicBack;
    Result fNoNewlineExpr$GeneratorList;
    Result fNoNewlineExpr$GeneratorList$$Star1;
    Result fNoNewlineExpr$Generator;
    Result fNoNewlineExpr;
    Result fNoSpaceExpr$ExprFront;
    Result fNoSpaceExpr$OpExprNoEnc;
    Result fNoSpaceExpr$OpExprLeftEncloser;
    Result fNoSpaceExpr$OpExprPrimary;
  }

  /** Chunk 16 of memoized results. */
  static final class Chunk16 {
    Result fNoSpaceExpr$OpExprPrefix;
    Result fNoSpaceExpr$Primary;
    Result fNoSpaceExpr$Primary$$Star1;
    Result fNoSpaceExpr$UnitExpr;
    Result fNoSpaceExpr$UnitExpr$$Star1;
    Result fNoSpaceExpr;
    Result fLocalDecl$VarWType;
    Result fBlockElems;
    Result fLocalFnDecl;
    Result fVarWoType;
  }

  /** Chunk 17 of memoized results. */
  static final class Chunk17 {
    Result fUnpasting;
    Result fUnpastingElems;
    Result fUnpastingElem;
    Result fCaseClause;
    Result fid;
    Result fid$$Star1;
    Result fidrest;
    Result fId;
    Result fBindId;
    Result fBindIdOrBindIdTuple;
  }

  /** Chunk 18 of memoized results. */
  static final class Chunk18 {
    Result fName;
    Result fDottedName;
    Result f$$Shared27;
    Result fQualifiedName;
    Result fEncloser;
    Result fLeftEncloser;
    Result fRightEncloser;
    Result fExponentOp;
    Result fbars;
    Result fbars$$Star1;
  }

  /** Chunk 19 of memoized results. */
  static final class Chunk19 {
    Result fslashes;
    Result fslashes$$Star1;
    Result fslashes$$Star2;
    Result fgreaters;
    Result fgreaters$$Star1;
    Result fencloser;
    Result fleftEncloser;
    Result frightEncloser;
    Result frightEncloserMulti;
    Result frightEncloserMulti$$Plus1;
  }

  /** Chunk 20 of memoized results. */
  static final class Chunk20 {
    Result frightEncloserMulti$$Plus2;
    Result fOpName;
    Result fOp;
    Result fcompOp;
    Result fmultiOp;
    Result fsingleOp;
    Result fop;
    Result fleftarrow;
    Result fcaret;
    Result fcolonequals;
  }

  /** Chunk 21 of memoized results. */
  static final class Chunk21 {
    Result fequals;
    Result fequalsOp;
    Result fsemicolon;
    Result fone;
    Result fcolon;
    Result fclosesquare;
    Result fopensquare;
    Result fAssignOp;
    Result fAccumulator;
    Result fArrayComprehensionClause;
  }

  /** Chunk 22 of memoized results. */
  static final class Chunk22 {
    Result fWhitespace;
    Result fSpace;
    Result fNewline;
    Result fComment;
    Result fComment$$Star1;
    Result fwValue;
    Result fwValue$$Star1;
    Result fRectSeparator;
    Result fRectSeparator$$Plus1;
    Result fBIG;
  }

  /** Chunk 23 of memoized results. */
  static final class Chunk23 {
    Result fatomic;
    Result fend;
    Result fprivate;
    Result fself;
    Result ftest;
    Result funit;
    Result fvar;
    Result fwidens;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class PreFortressColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
    Chunk5 chunk5;
    Chunk6 chunk6;
    Chunk7 chunk7;
    Chunk8 chunk8;
    Chunk9 chunk9;
    Chunk10 chunk10;
    Chunk11 chunk11;
    Chunk12 chunk12;
    Chunk13 chunk13;
    Chunk14 chunk14;
    Chunk15 chunk15;
    Chunk16 chunk16;
    Chunk17 chunk17;
    Chunk18 chunk18;
    Chunk19 chunk19;
    Chunk20 chunk20;
    Chunk21 chunk21;
    Chunk22 chunk22;
    Chunk23 chunk23;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public PreFortress(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public PreFortress(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new PreFortressColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal PreFortress.File.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pFile(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    List<Import>    yyOpValue1;
    CompilationUnit yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pComponent(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pImports(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Import> v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
    }
    { // Start scope for a1.
      List<Import> a1 = yyOpValue1;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        if (a1 == null) a1 = Collections.<Import>emptyList();
        Span span = createSpan(yyStart,yyCount);
        String file = span.begin.getFileName();
        DottedName name = NodeFactory.makeDottedName(span, file, "\\.");
        List<Export> a3 = Collections.<Export>emptyList();
        List<Decl> a4 = Collections.<Decl>emptyList();
        yyValue = new Component(span, name, a1, a3, a4);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreFortress.Component.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComponent(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    int          yyRepetition1;
    int          yyOption1;
    List<Import> yyOpValue1;
    Component    yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcomponent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pDottedName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          DottedName a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pImports(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Import> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<Import> a2 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              while (true) {

                yyC = character(yyRepetition1);
                if (-1 != yyC) {
                  yyIndex = yyRepetition1 + 1;

                  yyRepetition1 = yyIndex;
                  continue;
                }
                break;
              }

              if (a2 == null) a2 = Collections.<Import>emptyList();
              List<Export> a3 = Collections.<Export>emptyList();
              List<Decl> a4 = Collections.<Decl>emptyList();
              yyValue = new Component(createSpan(yyStart,yyCount), a1, a2, a3, a4);

              return new SemanticValue(yyValue, yyRepetition1, yyError);
            }
          } // End scope for a2.
        }
      }
    }

    // Done.
    yyError = yyError.select("component expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreFortress.Imports.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImports(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fImports) 
      yyColumn.chunk1.fImports = pImports$1(yyStart);
    return yyColumn.chunk1.fImports;
  }

  /** Actually parse PreFortress.Imports. */
  private Result pImports$1(final int yyStart) throws IOException {
    Result       yyResult;
    List<Import> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pImport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Import a1 = yyResult.semanticValue();

      yyResult = pImports$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Import> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.Imports$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImports$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fImports$$Star1) 
      yyColumn.chunk1.fImports$$Star1 = pImports$$Star1$1(yyStart);
    return yyColumn.chunk1.fImports$$Star1;
  }

  /** Actually parse PreFortress.Imports$$Star1. */
  private Result pImports$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<Import> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pImport(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Import v$el$1 = yyResult.semanticValue();

        yyResult = pImports$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Import> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Import>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal PreFortress.Import.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImport(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fImport) 
      yyColumn.chunk1.fImport = pImport$1(yyStart);
    return yyColumn.chunk1.fImport;
  }

  /** Actually parse PreFortress.Import. */
  private Result pImport$1(final int yyStart) throws IOException {
    Result     yyResult;
    Import     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pimport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pImportFrom(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pAliasedDottedNames(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<AliasedDottedName> a1 = yyResult.semanticValue();

          yyValue = new ImportApi(createSpan(yyStart, yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreFortress.ImportFrom.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImportFrom(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyOption1;
    List<SimpleName> yyOpValue1;
    ImportFrom       yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pstar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pexcept(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNames(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<SimpleName> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a1.
        List<SimpleName> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pfrom(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pDottedName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                DottedName a2 = yyResult.semanticValue();

                if (a1 == null) a1 = Collections.<SimpleName>emptyList();
                yyValue = new ImportStar(createSpan(yyStart,yyCount), a2, a1);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pAliasedNames(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<AliasedName> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pfrom(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDottedName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              DottedName a2 = yyResult.semanticValue();

              yyValue = new ImportNames(createSpan(yyStart,yyCount), a2, a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreFortress.Names.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNames(final int yyStart) throws IOException {
    Result           yyResult;
    List<SimpleName> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SimpleName a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNameList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreFortress.NameList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNameList(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyRepetition1;
    Pair<SimpleName> yyRepValue1;
    List<SimpleName> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SimpleName a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                SimpleName v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<SimpleName>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<SimpleName> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreFortress.AliasedNames.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedNames(final int yyStart) throws IOException {
    Result            yyResult;
    List<AliasedName> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAliasedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AliasedName a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAliasedNameList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreFortress.AliasedName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedName(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAliasedName) 
      yyColumn.chunk1.fAliasedName = pAliasedName$1(yyStart);
    return yyColumn.chunk1.fAliasedName;
  }

  /** Actually parse PreFortress.AliasedName. */
  private Result pAliasedName$1(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    Object      yyOpValue1;
    AliasedName yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pas(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        Id a2 = cast(yyOpValue1);

        if (a2 == null)
        yyValue = NodeFactory.makeAliasedName(createSpan(yyStart,yyCount), a1);
        else
        yyValue = NodeFactory.makeAliasedName(createSpan(yyStart,yyCount), a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pOp(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pas(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pOp(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Op v$el$2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
              }
            }
          }
          { // Start scope for a2.
            Op a2 = cast(yyOpValue1);

            if (a2 == null)
            yyValue = NodeFactory.makeAliasedName(createSpan(yyStart,yyCount),
            new Opr(a1.getSpan(), a1));
            else
            yyValue = NodeFactory.makeAliasedName(createSpan(yyStart,yyCount),
            new Opr(a1.getSpan(), a1),
            new Opr(a2.getSpan(), a2));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a2.
        }

        // Nested alternative 2.

        yyResult = pEncloserPair(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Bracketing a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pas(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pEncloserPair(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Bracketing v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
            }
          }
          { // Start scope for a2.
            Bracketing a2 = cast(yyOpValue1);

            Span span = createSpan(yyStart,yyCount);
            if (a2 == null)
            yyValue = NodeFactory.makeAliasedName(span, a1);
            else
            yyValue = NodeFactory.makeAliasedName(span, a1, a2);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreFortress.EncloserPair.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEncloserPair(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fEncloserPair) 
      yyColumn.chunk1.fEncloserPair = pEncloserPair$1(yyStart);
    return yyColumn.chunk1.fEncloserPair;
  }

  /** Actually parse PreFortress.EncloserPair. */
  private Result pEncloserPair$1(final int yyStart) throws IOException {
    Result     yyResult;
    Bracketing yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloserPair$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pEncloserPair$$Choice2(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          if (PrecedenceMap.ONLY.matchedBrackets(a1.getText(), a2.getText()))
          yyValue = new Bracketing(createSpan(yyStart,yyCount), a1, a2);
          else
          yyValue = error(a2, "Mismatched Enclosers.");

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.EncloserPair$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEncloserPair$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.EncloserPair$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEncloserPair$$Choice2(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreFortress.AliasedNameList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedNameList(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<AliasedName> yyRepValue1;
    List<AliasedName> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAliasedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AliasedName a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pAliasedName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                AliasedName v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<AliasedName>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<AliasedName> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreFortress.AliasedDottedNames.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedDottedNames(final int yyStart) throws IOException {
    Result                  yyResult;
    List<AliasedDottedName> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAliasedDottedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AliasedDottedName a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAliasedDottedNameList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreFortress.AliasedDottedName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedDottedName(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAliasedDottedName) 
      yyColumn.chunk1.fAliasedDottedName = pAliasedDottedName$1(yyStart);
    return yyColumn.chunk1.fAliasedDottedName;
  }

  /** Actually parse PreFortress.AliasedDottedName. */
  private Result pAliasedDottedName$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    DottedName        yyOpValue1;
    AliasedDottedName yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDottedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      DottedName a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pas(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDottedName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              DottedName v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        DottedName a2 = yyOpValue1;

        if (a2 == null)
        yyValue = new AliasedDottedName(createSpan(yyStart,yyCount), a1,
        Option.<DottedName>none());
        else
        yyValue = new AliasedDottedName(createSpan(yyStart,yyCount), a1,
        Option.some(a2));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreFortress.AliasedDottedNameList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedDottedNameList(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    int                     yyRepetition1;
    Pair<AliasedDottedName> yyRepValue1;
    List<AliasedDottedName> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAliasedDottedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AliasedDottedName a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pAliasedDottedName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                AliasedDottedName v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = 
                  new Pair<AliasedDottedName>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<AliasedDottedName> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.Coercions.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCoercions(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fCoercions) 
      yyColumn.chunk1.fCoercions = pCoercions$1(yyStart);
    return yyColumn.chunk1.fCoercions;
  }

  /** Actually parse TraitObject.Coercions. */
  private Result pCoercions$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCoercion(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Decl a1 = yyResult.semanticValue();

      yyResult = pCoercions$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Decl> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.Coercions$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCoercions$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fCoercions$$Star1) 
      yyColumn.chunk1.fCoercions$$Star1 = pCoercions$$Star1$1(yyStart);
    return yyColumn.chunk1.fCoercions$$Star1;
  }

  /** Actually parse PreFortress.Coercions$$Star1. */
  private Result pCoercions$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pCoercion(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Decl v$el$1 = yyResult.semanticValue();

        yyResult = pCoercions$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Decl> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Decl>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoInAnObject(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Decl> yyOpValue1;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pCoercions(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Decl> v$el$1 = yyResult.semanticValue();

      yyResult = pbr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      List<Decl> a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = pGoFrontInAnObject(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Decl> a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pbr(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pGoBackInAnObject(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Decl> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a3.
          List<Decl> a3 = yyOpValue1;

          yyValue = new ArrayList<Decl>();
          if (a1 != null) yyValue.addAll(a1);
          yyValue.addAll(a2);
          if (a3 != null) yyValue.addAll(a3);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      }

      // Nested alternative 2.

      yyResult = pGoBackInAnObject(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Decl> a2 = yyResult.semanticValue();

        yyValue = new ArrayList<Decl>();
        if (a1 != null) yyValue.addAll(a1);
        yyValue.addAll(a2);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pCoercions(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Decl> a1 = yyResult.semanticValue();

      yyValue = new ArrayList<Decl>();
      yyValue.addAll(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoFrontInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoFrontInAnObject(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Decl> yyRepValue1;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pGoesFrontInAnObject(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Decl a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pbr(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pGoesFrontInAnObject(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Decl v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Decl>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Decl> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoesFrontInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoesFrontInAnObject(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fGoesFrontInAnObject) 
      yyColumn.chunk1.fGoesFrontInAnObject = pGoesFrontInAnObject$1(yyStart);
    return yyColumn.chunk1.fGoesFrontInAnObject;
  }

  /** Actually parse TraitObject.GoesFrontInAnObject. */
  private Result pGoesFrontInAnObject$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Decl       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pField$VarDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pGetterSetterDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pPropertyDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoBackInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoBackInAnObject(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fGoBackInAnObject) 
      yyColumn.chunk1.fGoBackInAnObject = pGoBackInAnObject$1(yyStart);
    return yyColumn.chunk1.fGoBackInAnObject;
  }

  /** Actually parse TraitObject.GoBackInAnObject. */
  private Result pGoBackInAnObject$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pGoesBackInAnObject(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Decl a1 = yyResult.semanticValue();

      yyResult = pGoBackInAnObject$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Decl> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.GoBackInAnObject$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoBackInAnObject$$Star1(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fGoBackInAnObject$$Star1) 
      yyColumn.chunk2.fGoBackInAnObject$$Star1 = pGoBackInAnObject$$Star1$1(yyStart);
    return yyColumn.chunk2.fGoBackInAnObject$$Star1;
  }

  /** Actually parse PreFortress.GoBackInAnObject$$Star1. */
  private Result pGoBackInAnObject$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pGoesBackInAnObject(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Decl v$el$1 = yyResult.semanticValue();

        yyResult = pGoBackInAnObject$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Decl> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Decl>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoesBackInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoesBackInAnObject(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fGoesBackInAnObject) 
      yyColumn.chunk2.fGoesBackInAnObject = pGoesBackInAnObject$1(yyStart);
    return yyColumn.chunk2.fGoesBackInAnObject;
  }

  /** Actually parse TraitObject.GoesBackInAnObject. */
  private Result pGoesBackInAnObject$1(final int yyStart) throws IOException {
    Result     yyResult;
    Decl       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMdDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pPropertyDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Function.FnHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnHeaderFront(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<StaticParam> yyOpValue1;
    FnHeaderFront     yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticParam> v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a2.
        List<StaticParam> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pParameter$ValParam(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Param> a3 = yyResult.semanticValue();

            if (a2 == null) a2 = FortressUtil.emptyStaticParams();
            yyValue = new FnHeaderFront(NodeFactory.makeIdName(a1),a2,a3);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pParameter$OpHeaderFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.ValParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$ValParam(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fParameter$ValParam) 
      yyColumn.chunk2.fParameter$ValParam = pParameter$ValParam$1(yyStart);
    return yyColumn.chunk2.fParameter$ValParam;
  }

  /** Actually parse Parameter.ValParam. */
  private Result pParameter$ValParam$1(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    List<Param> yyOpValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = FortressUtil.<Param, NormalParam>mkList(NodeFactory.makeParam(a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pParameter$Params(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<Param> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (a1 == null) yyValue = FortressUtil.emptyParams();
            else            yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.Params.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$Params(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fParameter$Params) 
      yyColumn.chunk2.fParameter$Params = pParameter$Params$1(yyStart);
    return yyColumn.chunk2.fParameter$Params;
  }

  /** Actually parse Parameter.Params. */
  private Result pParameter$Params$1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    VarargsParam yyOpValue1;
    List<Param>  yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParameter$Params$$Star1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<NormalParam> a1s = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = p$$Shared15(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        VarargsParam v$el$3 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
          }
        }
      }
      { // Start scope for a2.
        VarargsParam a2 = yyOpValue1;

        yyResult = pParameter$Keyword(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Param a3 = yyResult.semanticValue();

          yyResult = pParameter$Params$$Star2(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<Param> a4s = yyResult.semanticValue();

            yyValue = FortressUtil.<Param, NormalParam>mkList(a1s.list());
            if (a2 != null) yyValue.add(a2);
            yyValue.add(a3);
            yyValue.addAll(a4s.list());

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.

      // Nested alternative 2.

      yyResult = p$$Shared15(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        VarargsParam a2 = yyResult.semanticValue();

        yyValue = FortressUtil.<Param, NormalParam>mkList(a1s.list(), a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pParameter$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NormalParam a1 = yyResult.semanticValue();

      yyResult = pParameter$Params$$Star3(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<NormalParam> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.<Param, NormalParam>mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Parameter.Params$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$Params$$Star1(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fParameter$Params$$Star1) 
      yyColumn.chunk2.fParameter$Params$$Star1 = pParameter$Params$$Star1$1(yyStart);
    return yyColumn.chunk2.fParameter$Params$$Star1;
  }

  /** Actually parse Parameter.Params$$Star1. */
  private Result pParameter$Params$$Star1$1(final int yyStart) 
    throws IOException {

    Result            yyResult;
    Pair<NormalParam> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParameter$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NormalParam v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pParameter$Params$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<NormalParam> v$2 = yyResult.semanticValue();

              yyValue = new Pair<NormalParam>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Parameter.Params$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$Params$$Star2(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fParameter$Params$$Star2) 
      yyColumn.chunk2.fParameter$Params$$Star2 = pParameter$Params$$Star2$1(yyStart);
    return yyColumn.chunk2.fParameter$Params$$Star2;
  }

  /** Actually parse Parameter.Params$$Star2. */
  private Result pParameter$Params$$Star2$1(final int yyStart) 
    throws IOException {

    Result      yyResult;
    Pair<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pParameter$Keyword(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Param v$el$4 = yyResult.semanticValue();

            yyResult = pParameter$Params$$Star2(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Param> v$5 = yyResult.semanticValue();

              yyValue = new Pair<Param>(v$el$4, v$5);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Parameter.Params$$Star3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$Params$$Star3(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fParameter$Params$$Star3) 
      yyColumn.chunk2.fParameter$Params$$Star3 = pParameter$Params$$Star3$1(yyStart);
    return yyColumn.chunk2.fParameter$Params$$Star3;
  }

  /** Actually parse Parameter.Params$$Star3. */
  private Result pParameter$Params$$Star3$1(final int yyStart) 
    throws IOException {

    Result            yyResult;
    Pair<NormalParam> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pParameter$Param(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            NormalParam v$el$6 = yyResult.semanticValue();

            yyResult = pParameter$Params$$Star3(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<NormalParam> v$7 = yyResult.semanticValue();

              yyValue = new Pair<NormalParam>(v$el$6, v$7);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared1.
   * This nonterminal represents the duplicate productions 
   * Parameter.VarargsParam and MethodParam.VarargsParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared1(final int yyStart) throws IOException {
    Result       yyResult;
    VarargsParam yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pellipses(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  VarargsType ty = new VarargsType(a2.getSpan(), a2);
                  yyValue = NodeFactory.makeVarargsParam(NodeFactory.makeIdName(a1), ty);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared15.
   * This nonterminal represents the duplicate productions Parameter.Varargs 
   * and MethodParam.Varargs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared15(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.f$$Shared15) 
      yyColumn.chunk2.f$$Shared15 = p$$Shared15$1(yyStart);
    return yyColumn.chunk2.f$$Shared15;
  }

  /** Actually parse PreFortress.$$Shared15. */
  private Result p$$Shared15$1(final int yyStart) throws IOException {
    Result       yyResult;
    VarargsParam yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.Keyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$Keyword(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fParameter$Keyword) 
      yyColumn.chunk2.fParameter$Keyword = pParameter$Keyword$1(yyStart);
    return yyColumn.chunk2.fParameter$Keyword;
  }

  /** Actually parse Parameter.Keyword. */
  private Result pParameter$Keyword$1(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParameter$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NormalParam a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeParam(a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared2.
   * This nonterminal represents the duplicate productions 
   * Parameter.PlainParam and MethodParam.PlainParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared2(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.f$$Shared2) 
      yyColumn.chunk2.f$$Shared2 = p$$Shared2$1(yyStart);
    return yyColumn.chunk2.f$$Shared2;
  }

  /** Actually parse PreFortress.$$Shared2. */
  private Result p$$Shared2$1(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    Type        yyOpValue1;
    NormalParam yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIsType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        Type a2 = yyOpValue1;

        if (a2 == null) yyValue = NodeFactory.makeParam(a1);
        else            yyValue = NodeFactory.makeParam(a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeParam(new Id(createSpan(yyStart,yyCount), "_"),
      a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.Param.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$Param(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fParameter$Param) 
      yyColumn.chunk3.fParameter$Param = pParameter$Param$1(yyStart);
    return yyColumn.chunk3.fParameter$Param;
  }

  /** Actually parse Parameter.Param. */
  private Result pParameter$Param$1(final int yyStart) throws IOException {
    Result      yyResult;
    NormalParam yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.OpHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$OpHeaderFront(final int yyStart) 
    throws IOException {

    Result        yyResult;
    int           yyOption1;
    Object        yyOpValue1;
    FnHeaderFront yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticParam> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for opa1.
        List<StaticParam> opa1 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBIG(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for big.
          String big = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared20(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Op opa2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pParameter$Params(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Param> opa3 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = p$$Shared21(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Op opa4 = yyResult.semanticValue();

                      SimpleName name;
                      Span span = createSpan(yyStart,yyCount);
                      String left  = opa2.getText();
                      String right = opa4.getText();
                      if (PrecedenceMap.ONLY.matchedBrackets(left, right)) {
                        if (big != null) {
                          opa2 = NodeFactory.makeOp(opa2.getSpan(), "BIG " + left);
                          opa4 = NodeFactory.makeOp(opa4.getSpan(), "BIG " + right);
                        }
                        name = new Bracketing(span, opa2, opa4);
                      } else
                      name = error(opa2, "Mismatched enclosing operator definition: "
                      + left + " and " + right);
                      if (opa1 == null) opa1 = FortressUtil.emptyStaticParams();
                      yyValue = new FnHeaderFront(name, opa1, opa3);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        } // End scope for big.
      } // End scope for opa1.

      // Nested alternative 2.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticParam> v$el$7 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$7;
        }
      }
      { // Start scope for a1.
        List<StaticParam> a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pParameter$ValParam(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Param> a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = p$$Shared22(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Op a3 = yyResult.semanticValue();

                Span span = createSpan(yyStart,yyCount);
                if (a1 == null) yyValue = new FnHeaderFront(new PostFix(span,a3), a2);
                else            yyValue = new FnHeaderFront(new PostFix(span,a3), a1, a2);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      } // End scope for a1.

      // Nested alternative 3.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBIG(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$10 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$10;
        }
      }
      { // Start scope for big.
        String big = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared23(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Object a1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticParams(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<StaticParam> v$el$13 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$13;
              }
            }
            { // Start scope for a2.
              List<StaticParam> a2 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pParameter$ValParam(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Param> a3 = yyResult.semanticValue();

                  Span span = createSpan(yyStart,yyCount);
                  Op op = (Op)a1;
                  if (big != null)
                  op = NodeFactory.makeOp(op.getSpan(), "BIG " + op.getText());
                  if (a2 == null) yyValue = new FnHeaderFront(new Opr(span,op), a3);
                  else            yyValue = new FnHeaderFront(new Opr(span,op), a2, a3);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for a2.
          }
        }
      } // End scope for big.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared20.
   * This nonterminal represents the duplicate productions 
   * Parameter.OpHeaderFront$$Choice1 and MethodParam.OpHeaderFront$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared20(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared21.
   * This nonterminal represents the duplicate productions 
   * Parameter.OpHeaderFront$$Choice2 and MethodParam.OpHeaderFront$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared21(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared22.
   * This nonterminal represents the duplicate productions 
   * Parameter.OpHeaderFront$$Choice3 and MethodParam.OpHeaderFront$$Choice3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared22(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExponentOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared23.
   * This nonterminal represents the duplicate productions 
   * Parameter.OpHeaderFront$$Choice4 and MethodParam.OpHeaderFront$$Choice4.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared23(final int yyStart) throws IOException {
    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=NodeFactory.makeOp(createSpan(yyStart,yyCount),"^");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.MdDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMdDef(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    List<Modifier> yyOpValue1;
    FnDecl         yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMdMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<Modifier> a1 = yyOpValue1;

      yyResult = pMdHeaderFront(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        FnHeaderFront a2 = yyResult.semanticValue();

        yyResult = pFnHeaderClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FnHeaderClause a3 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pequals(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineExpr(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Expr a4 = yyResult.semanticValue();

                  if (a1 == null) a1 = FortressUtil.emptyModifiers();
                  yyValue = FortressUtil.mkFnDecl(createSpan(yyStart,yyCount), a1,
                  a2.getReceiver(), a2, a3, a4);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.MdHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMdHeaderFront(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMdHeaderFront) 
      yyColumn.chunk3.fMdHeaderFront = pMdHeaderFront$1(yyStart);
    return yyColumn.chunk3.fMdHeaderFront;
  }

  /** Actually parse Method.MdHeaderFront. */
  private Result pMdHeaderFront$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<StaticParam> yyOpValue1;
    FnHeaderFront     yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticParam> v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a2.
        List<StaticParam> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pMethodParam$ValParam(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Param> a3 = yyResult.semanticValue();

            if (a2 == null) a2 = FortressUtil.emptyStaticParams();
            yyValue = new FnHeaderFront(NodeFactory.makeIdName(a1), a2, a3);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pMethodParam$OpHeaderFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.GetterSetterDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGetterSetterDef(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    List<Modifier>  yyOpValue1;
    FnAbsDeclOrDecl yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pFnMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<Modifier> a1 = yyOpValue1;

      yyResult = pGetterSetterMod(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Modifier a2 = yyResult.semanticValue();

        yyResult = pMdHeaderFront(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FnHeaderFront a3 = yyResult.semanticValue();

          yyResult = pFnHeaderClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            FnHeaderClause a4 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pequals(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pNoNewlineExpr(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Expr a5 = yyResult.semanticValue();

                    if (a1 == null) a1 = new ArrayList<Modifier>();
                    a1.add(a2);
                    yyValue = FortressUtil.mkFnDecl(createSpan(yyStart,yyCount), a1,
                    a3.getReceiver(), a3, a4, a5);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.GetterSetterMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGetterSetterMod(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pgetter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new ModifierGetter(createSpan(yyStart,yyCount));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = psetter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new ModifierSetter(createSpan(yyStart,yyCount));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.Coercion.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCoercion(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fCoercion) 
      yyColumn.chunk3.fCoercion = pCoercion$1(yyStart);
    return yyColumn.chunk3.fCoercion;
  }

  /** Actually parse Method.Coercion. */
  private Result pCoercion$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Decl       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcoerce(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticParam> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<StaticParam> a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = popenparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pBindId(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Id a2 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pIsType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Type a3 = yyResult.semanticValue();

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pcloseparen(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pCoercionClauses(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          FnHeaderClause a4 = yyResult.semanticValue();

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyOption1  = yyResult.index;
                            yyOpValue1 = null;

                            yyResult = pwidens(yyOption1);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              String v$el$2 = yyResult.semanticValue();

                              yyResult = pw(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyOption1  = yyResult.index;
                                yyOpValue1 = v$el$2;
                              }
                            }
                            { // Start scope for a5.
                              String a5 = cast(yyOpValue1);

                              yyResult = pequals(yyOption1);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pw(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyResult = pNoNewlineExpr(yyResult.index);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {
                                    Expr a6 = yyResult.semanticValue();

                                    if (a1 == null) a1 = FortressUtil.emptyStaticParams();
                                    List<Param> params = FortressUtil.<Param, NormalParam>mkList(NodeFactory.makeParam(a2, a3));
                                    List<Modifier> mods = new ArrayList<Modifier>();
                                    if (a5 != null) mods.add(new ModifierWidens(createSpan(yyStart,8)));
                                    Span span = createSpan(yyStart+9,8);
                                    yyValue = FortressUtil.mkFnDecl(createSpan(yyStart,yyCount), mods,
                                    NodeFactory.makeIdName(span, "coerce"), a1,
                                    params, a4, a6);

                                    return yyResult.createValue(yyValue, yyError);
                                  }
                                }
                              }
                            } // End scope for a5.
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.CoercionClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCoercionClauses(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    Object         yyOpValue1;
    FnHeaderClause yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pCoercionWhere(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<WhereClause> v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      List<WhereClause> a1 = cast(yyOpValue1);

      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pEnsures(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<EnsuresClause> v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a2.
        List<EnsuresClause> a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pInvariant(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Expr> v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
        }
        { // Start scope for a3.
          List<Expr> a3 = cast(yyOpValue1);

          Option<List<WhereClause>> whereClause = Option.wrap(a1);
          Option<Contract> contractClause;
          if (a2 == null && a3 == null) contractClause = Option.<Contract>none();
          else contractClause = Option.<Contract>some(
          new Contract(createSpan(yyStart,yyCount),
          Option.<List<Expr>>none(),
          Option.wrap(a2),
          Option.wrap(a3)));
          yyValue = new FnHeaderClause(Option.<List<TraitType>>none(), whereClause,
          contractClause, Option.<Type>none());

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      } // End scope for a2.
    } // End scope for a1.
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.CoercionWhere.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCoercionWhere(final int yyStart) throws IOException {
    Result            yyResult;
    List<WhereClause> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pwhere(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popencurly(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pCoercionWhereClauseList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              yyValue = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pclosecurly(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.CoercionWhereClauseList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCoercionWhereClauseList(final int yyStart) 
    throws IOException {

    Result            yyResult;
    int               yyRepetition1;
    Pair<WhereClause> yyRepValue1;
    List<WhereClause> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCoercionWhereClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WhereClause a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pCoercionWhereClause(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                WhereClause v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<WhereClause>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<WhereClause> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.CoercionWhereClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCoercionWhereClause(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fCoercionWhereClause) 
      yyColumn.chunk3.fCoercionWhereClause = pCoercionWhereClause$1(yyStart);
    return yyColumn.chunk3.fCoercionWhereClause;
  }

  /** Actually parse Method.CoercionWhereClause. */
  private Result pCoercionWhereClause$1(final int yyStart) 
    throws IOException {

    Result      yyResult;
    WhereClause yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWhereClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pwidens(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = por(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcoerces(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pType(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Type a2 = yyResult.semanticValue();

                      yyValue = new WhereWidensCoerces(createSpan(yyStart,yyCount), a1, a2);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.ValParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$ValParam(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMethodParam$ValParam) 
      yyColumn.chunk3.fMethodParam$ValParam = pMethodParam$ValParam$1(yyStart);
    return yyColumn.chunk3.fMethodParam$ValParam;
  }

  /** Actually parse MethodParam.ValParam. */
  private Result pMethodParam$ValParam$1(final int yyStart) 
    throws IOException {

    Result      yyResult;
    int         yyOption1;
    List<Param> yyOpValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMethodParam$Params(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<Param> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (a1 == null) yyValue = FortressUtil.emptyParams();
            else            yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.Params.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$Params(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMethodParam$Params) 
      yyColumn.chunk3.fMethodParam$Params = pMethodParam$Params$1(yyStart);
    return yyColumn.chunk3.fMethodParam$Params;
  }

  /** Actually parse MethodParam.Params. */
  private Result pMethodParam$Params$1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    VarargsParam yyOpValue1;
    List<Param>  yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMethodParam$Params$$Star1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<NormalParam> a1s = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = p$$Shared15(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        VarargsParam v$el$3 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
          }
        }
      }
      { // Start scope for a2.
        VarargsParam a2 = yyOpValue1;

        yyResult = pMethodParam$Keyword(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Param a3 = yyResult.semanticValue();

          yyResult = pMethodParam$Params$$Star2(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<Param> a4s = yyResult.semanticValue();

            yyValue = FortressUtil.<Param, NormalParam>mkList(a1s.list());
            if (a2 != null) yyValue.add(a2);
            yyValue.add(a3);
            yyValue.addAll(a4s.list());

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.

      // Nested alternative 2.

      yyResult = p$$Shared15(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        VarargsParam a2 = yyResult.semanticValue();

        yyValue = FortressUtil.<Param, NormalParam>mkList(a1s.list(), a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pMethodParam$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NormalParam a1 = yyResult.semanticValue();

      yyResult = pMethodParam$Params$$Star3(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<NormalParam> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.<Param, NormalParam>mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal MethodParam.Params$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$Params$$Star1(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMethodParam$Params$$Star1) 
      yyColumn.chunk3.fMethodParam$Params$$Star1 = pMethodParam$Params$$Star1$1(yyStart);
    return yyColumn.chunk3.fMethodParam$Params$$Star1;
  }

  /** Actually parse MethodParam.Params$$Star1. */
  private Result pMethodParam$Params$$Star1$1(final int yyStart) 
    throws IOException {

    Result            yyResult;
    Pair<NormalParam> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMethodParam$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NormalParam v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pMethodParam$Params$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<NormalParam> v$2 = yyResult.semanticValue();

              yyValue = new Pair<NormalParam>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal MethodParam.Params$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$Params$$Star2(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMethodParam$Params$$Star2) 
      yyColumn.chunk3.fMethodParam$Params$$Star2 = pMethodParam$Params$$Star2$1(yyStart);
    return yyColumn.chunk3.fMethodParam$Params$$Star2;
  }

  /** Actually parse MethodParam.Params$$Star2. */
  private Result pMethodParam$Params$$Star2$1(final int yyStart) 
    throws IOException {

    Result      yyResult;
    Pair<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pMethodParam$Keyword(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Param v$el$4 = yyResult.semanticValue();

            yyResult = pMethodParam$Params$$Star2(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Param> v$5 = yyResult.semanticValue();

              yyValue = new Pair<Param>(v$el$4, v$5);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal MethodParam.Params$$Star3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$Params$$Star3(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMethodParam$Params$$Star3) 
      yyColumn.chunk3.fMethodParam$Params$$Star3 = pMethodParam$Params$$Star3$1(yyStart);
    return yyColumn.chunk3.fMethodParam$Params$$Star3;
  }

  /** Actually parse MethodParam.Params$$Star3. */
  private Result pMethodParam$Params$$Star3$1(final int yyStart) 
    throws IOException {

    Result            yyResult;
    Pair<NormalParam> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pMethodParam$Param(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            NormalParam v$el$6 = yyResult.semanticValue();

            yyResult = pMethodParam$Params$$Star3(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<NormalParam> v$7 = yyResult.semanticValue();

              yyValue = new Pair<NormalParam>(v$el$6, v$7);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.Keyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$Keyword(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMethodParam$Keyword) 
      yyColumn.chunk3.fMethodParam$Keyword = pMethodParam$Keyword$1(yyStart);
    return yyColumn.chunk3.fMethodParam$Keyword;
  }

  /** Actually parse MethodParam.Keyword. */
  private Result pMethodParam$Keyword$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMethodParam$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NormalParam a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeParam(a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.Param.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$Param(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fMethodParam$Param) 
      yyColumn.chunk4.fMethodParam$Param = pMethodParam$Param$1(yyStart);
    return yyColumn.chunk4.fMethodParam$Param;
  }

  /** Actually parse MethodParam.Param. */
  private Result pMethodParam$Param$1(final int yyStart) throws IOException {
    Result      yyResult;
    NormalParam yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pself(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeParam(new Id(createSpan(yyStart,yyCount),
      "self"));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.OpHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$OpHeaderFront(final int yyStart) 
    throws IOException {

    Result        yyResult;
    int           yyOption1;
    Object        yyOpValue1;
    FnHeaderFront yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticParam> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for opa1.
        List<StaticParam> opa1 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBIG(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for big.
          String big = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared20(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Op opa2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pMethodParam$Params(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Param> opa3 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = p$$Shared21(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Op opa4 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pcolonequals(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = popenparen(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pw(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = 
                                  pSubscriptAssignParam(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {
                                  Param v$el$7 = yyResult.semanticValue();

                                  yyResult = pw(yyResult.index);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pcloseparen(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {

                                      yyOption1  = yyResult.index;
                                      yyOpValue1 = v$el$7;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      { // Start scope for opa5.
                        Param opa5 = cast(yyOpValue1);

                        SimpleName name;
                        Span span = createSpan(yyStart,yyCount);
                        String left  = opa2.getText();
                        String right = opa4.getText();
                        if (PrecedenceMap.ONLY.matchedBrackets(left, right)) {
                          if (big != null) {
                            opa2 = NodeFactory.makeOp(opa2.getSpan(), "BIG " + left);
                            opa4 = NodeFactory.makeOp(opa4.getSpan(), "BIG " + right);
                          }
                          if (FortressUtil.isFunctionalMethod(opa3)) {
                            name = new Bracketing(span, opa2, opa4);
                          } else {
                            if (opa5 == null) name = new SubscriptOp(span, opa2, opa4);
                            else              name = new SubscriptAssign(span, opa2, opa4);
                          }
                        } else
                        name = error(opa2, "Mismatched enclosing operator definition: "
                        + left + " and " + right);
                        if (opa1 == null) opa1 = FortressUtil.emptyStaticParams();
                        Option<Param> opparam = Option.wrap(opa5);
                        yyValue = new FnHeaderFront(name, opa1, opa3, opparam);

                        return new SemanticValue(yyValue, yyOption1, yyError);
                      } // End scope for opa5.
                    }
                  }
                }
              }
            }
          }
        } // End scope for big.
      } // End scope for opa1.

      // Nested alternative 2.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticParam> v$el$8 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$8;
        }
      }
      { // Start scope for a1.
        List<StaticParam> a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pMethodParam$ValParam(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Param> a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = p$$Shared22(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Op a3 = yyResult.semanticValue();

                Span span = createSpan(yyStart,yyCount);
                if (a1 == null) yyValue = new FnHeaderFront(new PostFix(span,a3), a2);
                else            yyValue = new FnHeaderFront(new PostFix(span,a3), a1, a2);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      } // End scope for a1.

      // Nested alternative 3.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBIG(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$11 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$11;
        }
      }
      { // Start scope for big.
        String big = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared23(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Object a1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticParams(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<StaticParam> v$el$14 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$14;
              }
            }
            { // Start scope for a2.
              List<StaticParam> a2 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pMethodParam$ValParam(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Param> a3 = yyResult.semanticValue();

                  Span span = createSpan(yyStart,yyCount);
                  Op op = (Op)a1;
                  if (big != null)
                  op = NodeFactory.makeOp(op.getSpan(), "BIG " + op.getText());
                  if (a2 == null) yyValue = new FnHeaderFront(new Opr(span,op), a3);
                  else            yyValue = new FnHeaderFront(new Opr(span,op), a2, a3);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for a2.
          }
        }
      } // End scope for big.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.SubscriptAssignParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSubscriptAssignParam(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared15(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMethodParam$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Field.VarDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pField$VarDecl(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    List<Modifier> yyOpValue1;
    VarDecl        yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pFldMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<Modifier> a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = pField$VarWTypes(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<LValueBind> a2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared3(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            com.sun.fortress.useful.Pair<Expr,Boolean> a3 = yyResult.semanticValue();

            if (a1 != null) {
              if (a3.getB()) a2 = FortressUtil.setModsAndMutable(a2, a1);
              else a2 = FortressUtil.setMods(a2, a1);
            } else {
              if (a3.getB()) a2 = FortressUtil.setMutable(a2);
            }
            yyValue = new VarDecl(createSpan(yyStart,yyCount), a2, a3.getA());

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pBindIdOrBindIdTuple(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Id> a2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice2 = yyResult.index;

          // Nested alternative 1.

          yyResult = pequals(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineExpr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr a3 = yyResult.semanticValue();

                List<LValueBind> lvs;
                if (a1 != null) lvs = FortressUtil.ids2Lvs(a2, a1);
                else lvs = FortressUtil.ids2Lvs(a2);
                yyValue = new VarDecl(createSpan(yyStart,yyCount), lvs, a3);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 2.

          yyResult = pcolon(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              final int yyChoice3 = yyResult.index;

              // Nested alternative 1.

              yyResult = pType(yyChoice3);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Type a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pellipses(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = p$$Shared3(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        com.sun.fortress.useful.Pair<Expr,Boolean> a4 = yyResult.semanticValue();

                        List<LValueBind> lvs;
                        if (a1 != null) {
                          if (a4.getB()) lvs = FortressUtil.ids2Lvs(a2, a1, a3, true);
                          else           lvs = FortressUtil.ids2Lvs(a2, a1, a3, false);
                        } else {
                          if (a4.getB()) lvs = FortressUtil.ids2Lvs(a2, a3, true);
                          else           lvs = FortressUtil.ids2Lvs(a2, a3, false);
                        }
                        yyValue = new VarDecl(createSpan(yyStart,yyCount), lvs, a4.getA());

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              }

              // Nested alternative 2.

              yyResult = pSimpleTupleType(yyChoice3);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TupleType a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = p$$Shared3(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    com.sun.fortress.useful.Pair<Expr,Boolean> a4 = yyResult.semanticValue();

                    Span span = createSpan(yyStart,yyCount);
                    List<Type> tys = a3.getElements();
                    if (a2.size() != tys.size())
                    error(new Id(span,"_"), "Mismatched numbers of variables and types.");
                    List<LValueBind> lvs;
                    if (a1 != null) {
                      if (a4.getB()) lvs = FortressUtil.ids2Lvs(a2, a1, tys, true);
                      else           lvs = FortressUtil.ids2Lvs(a2, a1, tys, false);
                    } else {
                      if (a4.getB()) lvs = FortressUtil.ids2Lvs(a2, tys, true);
                      else           lvs = FortressUtil.ids2Lvs(a2, tys, false);
                    }
                    yyValue = new VarDecl(span, lvs, a4.getA());

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Field.VarWTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pField$VarWTypes(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyRepetition1;
    boolean          yyRepeated1;
    Pair<LValueBind> yyRepValue1;
    List<LValueBind> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pField$VarWType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LValueBind a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pField$VarWType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          LValueBind a1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pField$VarWType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    LValueBind v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = new Pair<LValueBind>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<LValueBind> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = FortressUtil.mkList(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Field.VarWType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pField$VarWType(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fField$VarWType) 
      yyColumn.chunk4.fField$VarWType = pField$VarWType$1(yyStart);
    return yyColumn.chunk4.fField$VarWType;
  }

  /** Actually parse Field.VarWType. */
  private Result pField$VarWType$1(final int yyStart) throws IOException {
    Result     yyResult;
    LValueBind yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIsType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a2 = yyResult.semanticValue();

          yyValue = FortressUtil.mkLValueBind(createSpan(yyStart,yyCount),a1,a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared3.
   * This nonterminal represents the duplicate productions Field.InitVal 
   * and LocalDecl.InitVal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared3(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.f$$Shared3) 
      yyColumn.chunk4.f$$Shared3 = p$$Shared3$1(yyStart);
    return yyColumn.chunk4.f$$Shared3;
  }

  /** Actually parse PreFortress.$$Shared3. */
  private Result p$$Shared3$1(final int yyStart) throws IOException {
    Result                                     yyResult;
    com.sun.fortress.useful.Pair<Expr,Boolean> yyValue;
    ParseError                                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared3$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a2 = yyResult.semanticValue();

          yyValue = new com.sun.fortress.useful.Pair<Expr,Boolean>(a2, a1.equals(":="));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared3$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared3$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pequals(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pcolonequals(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.ExtendsWhere.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExtendsWhere(final int yyStart) throws IOException {
    Result               yyResult;
    List<TraitTypeWhere> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pextends(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitTypeWheres(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.TraitTypeWheres.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitTypeWheres(final int yyStart) throws IOException {
    Result               yyResult;
    List<TraitTypeWhere> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitTypeWhere(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitTypeWhere a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitTypeWhereList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.TraitTypeWhereList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitTypeWhereList(final int yyStart) throws IOException {
    Result               yyResult;
    int                  yyRepetition1;
    Pair<TraitTypeWhere> yyRepValue1;
    List<TraitTypeWhere> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitTypeWhere(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitTypeWhere a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pTraitTypeWhere(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TraitTypeWhere v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<TraitTypeWhere>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<TraitTypeWhere> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.TraitTypeWhere.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitTypeWhere(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fTraitTypeWhere) 
      yyColumn.chunk4.fTraitTypeWhere = pTraitTypeWhere$1(yyStart);
    return yyColumn.chunk4.fTraitTypeWhere;
  }

  /** Actually parse Header.TraitTypeWhere. */
  private Result pTraitTypeWhere$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<WhereClause> yyOpValue1;
    TraitTypeWhere    yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitType a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pWhere(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WhereClause> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        List<WhereClause> a2 = yyOpValue1;

        if (a2 == null) a2 = Collections.<WhereClause>emptyList();
        yyValue = new TraitTypeWhere(a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.Extends.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExtends(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fExtends) 
      yyColumn.chunk4.fExtends = pExtends$1(yyStart);
    return yyColumn.chunk4.fExtends;
  }

  /** Actually parse Header.Extends. */
  private Result pExtends$1(final int yyStart) throws IOException {
    Result          yyResult;
    List<TraitType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pextends(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitTypes(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.TraitTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitTypes(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fTraitTypes) 
      yyColumn.chunk4.fTraitTypes = pTraitTypes$1(yyStart);
    return yyColumn.chunk4.fTraitTypes;
  }

  /** Actually parse Header.TraitTypes. */
  private Result pTraitTypes$1(final int yyStart) throws IOException {
    Result          yyResult;
    List<TraitType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitType a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitTypeList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.TraitTypeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitTypeList(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyRepetition1;
    Pair<TraitType> yyRepValue1;
    List<TraitType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitType a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pTraitType(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TraitType v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<TraitType>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<TraitType> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.Where.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhere(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fWhere) 
      yyColumn.chunk4.fWhere = pWhere$1(yyStart);
    return yyColumn.chunk4.fWhere;
  }

  /** Actually parse Header.Where. */
  private Result pWhere$1(final int yyStart) throws IOException {
    Result            yyResult;
    List<WhereClause> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pwhere(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popencurly(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pWhereClauseList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              yyValue = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pclosecurly(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.WhereClauseList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhereClauseList(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<WhereClause> yyRepValue1;
    List<WhereClause> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWhereClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WhereClause a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pWhereClause(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                WhereClause v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<WhereClause>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<WhereClause> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.WhereClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhereClause(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fWhereClause) 
      yyColumn.chunk4.fWhereClause = pWhereClause$1(yyStart);
    return yyColumn.chunk4.fWhereClause;
  }

  /** Actually parse Header.WhereClause. */
  private Result pWhereClause$1(final int yyStart) throws IOException {
    int         yyC;
    int         yyIndex;
    Result      yyResult;
    int         yyBase;
    WhereClause yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtends(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<TraitType> a2 = yyResult.semanticValue();

          yyValue = new WhereExtends(createSpan(yyStart,yyCount),
          NodeFactory.makeIdName(a1), a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pTypeAlias(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pnat(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyValue = new WhereNat(createSpan(yyStart,yyCount),
          NodeFactory.makeIdName(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyResult = pint(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyValue = new WhereInt(createSpan(yyStart,yyCount),
          NodeFactory.makeIdName(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = pbool(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyValue = new WhereBool(createSpan(yyStart,yyCount),
          NodeFactory.makeIdName(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 6.

    yyResult = punit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyValue = new WhereUnit(createSpan(yyStart,yyCount),
          NodeFactory.makeIdName(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 7.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pcoerces(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyValue = new WhereCoerces(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = pwidens(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyValue = new WhereWidens(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 8.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('o' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('n' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('l' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('e' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('s' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('s' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyResult = pw(yyIndex);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pequals(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyResult = pw(yyResult.index);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pId(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Id a1 = yyResult.semanticValue();

                                      yyValue = new UnitConstraint(createSpan(yyStart,yyCount),
                                      NodeFactory.makeIdName(a1));

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 9.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if ('d' == yyC) {
              yyIndex = yyResult.index + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('m' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('n' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('s' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('i' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('o' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('n' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyC = character(yyIndex);
                              if ('l' == yyC) {
                                yyIndex = yyIndex + 1;

                                yyC = character(yyIndex);
                                if ('e' == yyC) {
                                  yyIndex = yyIndex + 1;

                                  yyC = character(yyIndex);
                                  if ('s' == yyC) {
                                    yyIndex = yyIndex + 1;

                                    yyC = character(yyIndex);
                                    if ('s' == yyC) {
                                      yyIndex = yyIndex + 1;

                                      yyValue = new UnitConstraint(createSpan(yyStart,yyCount),
                                      NodeFactory.makeIdName(a1));

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("\"dimensionless\" expected", yyBase);
                                    }
                                  } else {
                                    yyError = yyError.select("\"dimensionless\" expected", yyBase);
                                  }
                                } else {
                                  yyError = yyError.select("\"dimensionless\" expected", yyBase);
                                }
                              } else {
                                yyError = yyError.select("\"dimensionless\" expected", yyBase);
                              }
                            } else {
                              yyError = yyError.select("\"dimensionless\" expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("\"dimensionless\" expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("\"dimensionless\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"dimensionless\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"dimensionless\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"dimensionless\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"dimensionless\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"dimensionless\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"dimensionless\" expected", yyBase);
            }
          }
        }
      }
    }

    // Alternative 10.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pQualifiedName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              QualifiedIdName a2 = yyResult.semanticValue();

              yyValue = new WhereEquals(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 11.

    yyResult = pIntConstraint(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 12.

    yyResult = pBoolConstraint(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BoolConstraint a1 = yyResult.semanticValue();

      yyValue = new BoolConstraintExpr(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("where clause expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.IntConstraint.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntConstraint(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyBase;
    IntConstraint yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IntExpr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyBase   = yyChoice1;
        yyResult = pop(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue("<=")) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIntExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              IntExpr a2 = yyResult.semanticValue();

              yyValue = new LEConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } else {
          yyError = yyError.select("\"<=\" expected", yyBase);
        }

        // Nested alternative 2.

        yyBase   = yyChoice1;
        yyResult = pop(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue("<")) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIntExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              IntExpr a2 = yyResult.semanticValue();

              yyValue = new LTConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } else {
          yyError = yyError.select("\"<\" expected", yyBase);
        }

        // Nested alternative 3.

        yyBase   = yyChoice1;
        yyResult = pop(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue(">=")) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIntExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              IntExpr a2 = yyResult.semanticValue();

              yyValue = new GEConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } else {
          yyError = yyError.select("\">=\" expected", yyBase);
        }

        // Nested alternative 4.

        yyBase   = yyChoice1;
        yyResult = pop(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue(">")) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIntExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              IntExpr a2 = yyResult.semanticValue();

              yyValue = new GTConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } else {
          yyError = yyError.select("\">\" expected", yyBase);
        }

        // Nested alternative 5.

        yyResult = pequals(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIntExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              IntExpr a2 = yyResult.semanticValue();

              yyValue = new IEConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.IntVal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntVal(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fIntVal) 
      yyColumn.chunk4.fIntVal = pIntVal$1(yyStart);
    return yyColumn.chunk4.fIntVal;
  }

  /** Actually parse Header.IntVal. */
  private Result pIntVal$1(final int yyStart) throws IOException {
    Result     yyResult;
    IntVal     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNumber(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IntLiteral a1 = yyResult.semanticValue();

      yyValue = new NumberConstraint(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyValue = new IntRef(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.IntExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntExpr(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fIntExpr) 
      yyColumn.chunk4.fIntExpr = pIntExpr$1(yyStart);
    return yyColumn.chunk4.fIntExpr;
  }

  /** Actually parse Header.IntExpr. */
  private Result pIntExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    IntExpr    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IntExpr seed = yyResult.semanticValue();

      yyResult = pIntExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<IntExpr>> list = yyResult.semanticValue();

        yyValue = (IntExpr)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.IntExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntExpr$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fIntExpr$$Star1) 
      yyColumn.chunk5.fIntExpr$$Star1 = pIntExpr$$Star1$1(yyStart);
    return yyColumn.chunk5.fIntExpr$$Star1;
  }

  /** Actually parse PreFortress.IntExpr$$Star1. */
  private Result pIntExpr$$Star1$1(final int yyStart) throws IOException {
    Result                yyResult;
    Pair<Action<IntExpr>> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<IntExpr> v$el$1 = yyResult.semanticValue();

      yyResult = pIntExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<IntExpr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<IntExpr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.IntExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntExprFront(final int yyStart) throws IOException {
    Result     yyResult;
    IntExpr    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntVal(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIntExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IntExpr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.IntExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntExprTail(final int yyStart) throws IOException {
    Result          yyResult;
    Action<IntExpr> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pplus(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pIntExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final IntExpr a1 = yyResult.semanticValue();

            yyValue = new Action<IntExpr>() {
              public IntExpr run(IntExpr base) {
                return new SumConstraint(createSpan(yyStart,yyCount),
                (IntExpr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pminus(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pIntExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final IntExpr a1 = yyResult.semanticValue();

            yyValue = new Action<IntExpr>() {
              public IntExpr run(IntExpr base) {
                return new MinusConstraint(createSpan(yyStart,yyCount),
                (IntExpr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyResult = p$$Shared24(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pIntExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final IntExpr a1 = yyResult.semanticValue();

        yyValue = new Action<IntExpr>() {
          public IntExpr run(IntExpr base) {
            return new ProductConstraint(createSpan(yyStart,yyCount),
            (IntExpr)base, a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pIntVal(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final IntVal a1 = yyResult.semanticValue();

        yyValue = new Action<IntExpr>() {
          public IntExpr run(IntExpr base) {
            return new ExponentConstraint(createSpan(yyStart,yyCount),
            (IntExpr)base, a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared24.
   * This nonterminal represents the duplicate productions 
   * PreFortress.ProductIntExpr$$Choice1, PreFortress.ProductDim$$Choice1, 
   * Expression.ProductUnit$$Choice1, NoNewlineExpr.ProductUnit$$Choice1, 
   * and NoSpaceExpr.ProductUnit$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared24(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDOT(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyResult = pSpace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        continue;
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.BoolConstraint.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolConstraint(final int yyStart) throws IOException {
    Result                       yyResult;
    int                          yyRepetition1;
    Pair<Action<BoolConstraint>> yyRepValue1;
    BoolConstraint               yyValue;
    ParseError                   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBoolConstraintFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BoolConstraint seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBoolConstraintTail(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Action<BoolConstraint> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<Action<BoolConstraint>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for list.
        Pair<Action<BoolConstraint>> list = yyRepValue1.reverse();

        yyValue = (BoolConstraint)apply(list, seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for list.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.BoolConstraintFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolConstraintFront(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyBase;
    BoolConstraint yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("NOT")) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBoolExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          BoolExpr a1 = yyResult.semanticValue();

          yyValue = new NotConstraint(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pBoolConstraintHead(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BoolExpr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyBase   = yyChoice1;
        yyResult = pop(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue("OR")) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBoolExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              BoolExpr a2 = yyResult.semanticValue();

              yyValue = new OrConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } else {
          yyError = yyError.select("\"OR\" expected", yyBase);
        }

        // Nested alternative 2.

        yyBase   = yyChoice1;
        yyResult = pop(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue("AND")) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBoolExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              BoolExpr a2 = yyResult.semanticValue();

              yyValue = new AndConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } else {
          yyError = yyError.select("\"AND\" expected", yyBase);
        }

        // Nested alternative 3.

        yyBase   = yyChoice1;
        yyResult = pop(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue("IMPLIES")) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBoolExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              BoolExpr a2 = yyResult.semanticValue();

              yyValue = new ImpliesConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } else {
          yyError = yyError.select("\"IMPLIES\" expected", yyBase);
        }

        // Nested alternative 4.

        yyResult = pequals(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBoolExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              BoolExpr a2 = yyResult.semanticValue();

              yyValue = new BEConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("bool constraint front expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.BoolConstraintHead.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolConstraintHead(final int yyStart) throws IOException {
    Result     yyResult;
    BoolExpr   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBoolVal(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBoolExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          BoolExpr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.BoolConstraintTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolConstraintTail(final int yyStart) throws IOException {
    Result                 yyResult;
    int                    yyBase;
    Action<BoolConstraint> yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pop(yyBase);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue("OR")) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBoolExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final BoolExpr a1 = yyResult.semanticValue();

            yyValue = new Action<BoolConstraint>() {
              public BoolConstraint run(BoolConstraint base) {
                return new OrConstraint(createSpan(yyStart,yyCount),
                (BoolConstraint)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } else {
        yyError = yyError.select("\"OR\" expected", yyBase);
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pop(yyBase);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue("AND")) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBoolExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final BoolExpr a1 = yyResult.semanticValue();

            yyValue = new Action<BoolConstraint>() {
              public BoolConstraint run(BoolConstraint base) {
                return new AndConstraint(createSpan(yyStart,yyCount),
                (BoolConstraint)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } else {
        yyError = yyError.select("\"AND\" expected", yyBase);
      }

      // Nested alternative 3.

      yyBase   = yyChoice1;
      yyResult = pop(yyBase);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue("IMPLIES")) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBoolExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final BoolExpr a1 = yyResult.semanticValue();

            yyValue = new Action<BoolConstraint>() {
              public BoolConstraint run(BoolConstraint base) {
                return new ImpliesConstraint(createSpan(yyStart,yyCount),
                (BoolConstraint)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } else {
        yyError = yyError.select("\"IMPLIES\" expected", yyBase);
      }

      // Nested alternative 4.

      yyResult = pequals(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBoolExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final BoolExpr a1 = yyResult.semanticValue();

            yyValue = new Action<BoolConstraint>() {
              public BoolConstraint run(BoolConstraint base) {
                return new BEConstraint(createSpan(yyStart,yyCount),
                (BoolConstraint)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.BoolVal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolVal(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fBoolVal) 
      yyColumn.chunk5.fBoolVal = pBoolVal$1(yyStart);
    return yyColumn.chunk5.fBoolVal;
  }

  /** Actually parse Header.BoolVal. */
  private Result pBoolVal$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    BoolVal    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;
            String a1 = "true";

            yyValue = new BoolConstant(createSpan(yyStart,yyCount), true);

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;
              String a1 = "false";

              yyValue = new BoolConstant(createSpan(yyStart,yyCount), false);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
      }
    }

    // Alternative 3.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyValue = new BoolRef(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("bool val expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.BoolExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolExpr(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fBoolExpr) 
      yyColumn.chunk5.fBoolExpr = pBoolExpr$1(yyStart);
    return yyColumn.chunk5.fBoolExpr;
  }

  /** Actually parse Header.BoolExpr. */
  private Result pBoolExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    BoolExpr   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBoolExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BoolExpr seed = yyResult.semanticValue();

      yyResult = pBoolExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<BoolExpr>> list = yyResult.semanticValue();

        yyValue = (BoolExpr)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.BoolExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolExpr$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fBoolExpr$$Star1) 
      yyColumn.chunk5.fBoolExpr$$Star1 = pBoolExpr$$Star1$1(yyStart);
    return yyColumn.chunk5.fBoolExpr$$Star1;
  }

  /** Actually parse PreFortress.BoolExpr$$Star1. */
  private Result pBoolExpr$$Star1$1(final int yyStart) throws IOException {
    Result                 yyResult;
    Pair<Action<BoolExpr>> yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBoolExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<BoolExpr> v$el$1 = yyResult.semanticValue();

      yyResult = pBoolExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<BoolExpr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<BoolExpr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.BoolExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolExprFront(final int yyStart) throws IOException {
    Result     yyResult;
    BoolExpr   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBoolVal(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBoolExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          BoolExpr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 3.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("NOT")) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBoolExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          BoolExpr a1 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = new NotConstraint(span, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("bool expr front expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.BoolExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolExprTail(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyBase;
    Action<BoolExpr> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pop(yyBase);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue("OR")) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBoolExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final BoolExpr a1 = yyResult.semanticValue();

            yyValue = new Action<BoolExpr>() {
              public BoolExpr run(BoolExpr base) {
                Span span = createSpan(yyStart,yyCount);
                return new OrConstraint(span, (BoolExpr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } else {
        yyError = yyError.select("\"OR\" expected", yyBase);
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pop(yyBase);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue("AND")) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBoolExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final BoolExpr a1 = yyResult.semanticValue();

            yyValue = new Action<BoolExpr>() {
              public BoolExpr run(BoolExpr base) {
                Span span = createSpan(yyStart,yyCount);
                return new AndConstraint(span, (BoolExpr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } else {
        yyError = yyError.select("\"AND\" expected", yyBase);
      }

      // Nested alternative 3.

      yyBase   = yyChoice1;
      yyResult = pop(yyBase);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue("IMPLIES")) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBoolExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final BoolExpr a1 = yyResult.semanticValue();

            yyValue = new Action<BoolExpr>() {
              public BoolExpr run(BoolExpr base) {
                Span span = createSpan(yyStart,yyCount);
                return new ImpliesConstraint(span, (BoolExpr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } else {
        yyError = yyError.select("\"IMPLIES\" expected", yyBase);
      }

      // Nested alternative 4.

      yyResult = pequals(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBoolExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final BoolExpr a1 = yyResult.semanticValue();

            yyValue = new Action<BoolExpr>() {
              public BoolExpr run(BoolExpr base) {
                Span span = createSpan(yyStart,yyCount);
                return new BEConstraint(span, (BoolExpr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.FnHeaderClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnHeaderClause(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fFnHeaderClause) 
      yyColumn.chunk5.fFnHeaderClause = pFnHeaderClause$1(yyStart);
    return yyColumn.chunk5.fFnHeaderClause;
  }

  /** Actually parse Header.FnHeaderClause. */
  private Result pFnHeaderClause$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    Type           yyOpValue1;
    FnHeaderClause yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pIsType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Type v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      Type a1 = yyOpValue1;

      yyResult = pFnClauses(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        FnHeaderClause a2 = yyResult.semanticValue();

        Option<Type> returnType = Option.wrap(a1);
        yyValue = new FnHeaderClause(a2.getThrowsClause(), a2.getWhereClause(),
        a2.getContractClause(), returnType);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.FnClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnClauses(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    Object         yyOpValue1;
    FnHeaderClause yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pThrows(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<TraitType> v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      List<TraitType> a1 = cast(yyOpValue1);

      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pWhere(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WhereClause> v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a2.
        List<WhereClause> a2 = cast(yyOpValue1);

        yyResult = pContract(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Contract a3 = yyResult.semanticValue();

          Option<List<TraitType>>   throwsClause = Option.wrap(a1);
          Option<List<WhereClause>> whereClause = Option.wrap(a2);
          Option<Contract>          contractClause = Option.wrap(a3);
          yyValue = new FnHeaderClause(throwsClause, whereClause, contractClause,
          Option.<Type>none());

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for a2.
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.Throws.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pThrows(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fThrows) 
      yyColumn.chunk5.fThrows = pThrows$1(yyStart);
    return yyColumn.chunk5.fThrows;
  }

  /** Actually parse Header.Throws. */
  private Result pThrows$1(final int yyStart) throws IOException {
    Result          yyResult;
    List<TraitType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pthrows(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMayTraitTypes(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.MayTraitTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMayTraitTypes(final int yyStart) throws IOException {
    Result          yyResult;
    List<TraitType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pclosecurly(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = FortressUtil.emptyTraitTypes();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pTraitTypes(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.Contract.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pContract(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Contract   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pRequires(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Expr> v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      List<Expr> a1 = cast(yyOpValue1);

      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pEnsures(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<EnsuresClause> v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a2.
        List<EnsuresClause> a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pInvariant(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Expr> v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
        }
        { // Start scope for a3.
          List<Expr> a3 = cast(yyOpValue1);

          Option<List<Expr>> requires = Option.wrap(a1);
          Option<List<EnsuresClause>> ensures = Option.wrap(a2);
          Option<List<Expr>> invariant = Option.wrap(a3);
          if (a1 == null && a2 == null && a3 == null) yyValue = null;
          else yyValue = new Contract(createSpan(yyStart,yyCount), requires,
          ensures, invariant);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      } // End scope for a2.
    } // End scope for a1.
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.Requires.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRequires(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Expr> yyOpValue1;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = prequires(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popencurly(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExprList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Expr> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a1.
            List<Expr> a1 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                if (a1 == null) yyValue = FortressUtil.emptyExprs();
                else            yyValue = a1;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a1.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.Ensures.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnsures(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fEnsures) 
      yyColumn.chunk5.fEnsures = pEnsures$1(yyStart);
    return yyColumn.chunk5.fEnsures;
  }

  /** Actually parse Header.Ensures. */
  private Result pEnsures$1(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyOption1;
    List<EnsuresClause> yyOpValue1;
    List<EnsuresClause> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pensures(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popencurly(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pEnsuresClauseList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<EnsuresClause> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a1.
            List<EnsuresClause> a1 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                if (a1 == null) yyValue = FortressUtil.emptyEnsuresClauses();
                else            yyValue = a1;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a1.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.EnsuresClauseList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnsuresClauseList(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyRepetition1;
    Pair<EnsuresClause> yyRepValue1;
    List<EnsuresClause> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEnsuresClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      EnsuresClause a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pEnsuresClause(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                EnsuresClause v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<EnsuresClause>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<EnsuresClause> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.EnsuresClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnsuresClause(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fEnsuresClause) 
      yyColumn.chunk5.fEnsuresClause = pEnsuresClause$1(yyStart);
    return yyColumn.chunk5.fEnsuresClause;
  }

  /** Actually parse Header.EnsuresClause. */
  private Result pEnsuresClause$1(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyOption1;
    Expr          yyOpValue1;
    EnsuresClause yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pprovided(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        Expr a2 = yyOpValue1;

        Option<Expr> ensures = Option.wrap(a2);
        yyValue = new EnsuresClause(createSpan(yyStart,yyCount), a1, ensures);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.Invariant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInvariant(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fInvariant) 
      yyColumn.chunk5.fInvariant = pInvariant$1(yyStart);
    return yyColumn.chunk5.fInvariant;
  }

  /** Actually parse Header.Invariant. */
  private Result pInvariant$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Expr> yyOpValue1;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pinvariant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popencurly(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExprList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Expr> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a1.
            List<Expr> a1 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                if (a1 == null) yyValue = FortressUtil.emptyExprs();
                else            yyValue = a1;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a1.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.MdMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMdMods(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyRepetition1;
    boolean        yyRepeated1;
    Pair<Modifier> yyRepValue1;
    List<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pMdMod(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Modifier v$el$1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Modifier>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Modifier> a1s = yyRepValue1.reverse();

      yyValue = FortressUtil.mkList(a1s.list());
      FortressUtil.noDuplicate(yyValue);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.MdMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMdMod(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFnMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = poverride(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierOverride(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.FnMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnMods(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyRepetition1;
    boolean        yyRepeated1;
    Pair<Modifier> yyRepValue1;
    List<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pFnMod(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Modifier v$el$1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Modifier>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Modifier> a1s = yyRepValue1.reverse();

      yyValue = FortressUtil.mkList(a1s.list());
      FortressUtil.noDuplicate(yyValue);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.FnMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnMod(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fFnMod) 
      yyColumn.chunk5.fFnMod = pFnMod$1(yyStart);
    return yyColumn.chunk5.fFnMod;
  }

  /** Actually parse Header.FnMod. */
  private Result pFnMod$1(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAbsFnMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pprivate(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierPrivate(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.AbsFnMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsFnMod(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLocalFnMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ptest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierTest(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.LocalFnMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalFnMods(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyRepetition1;
    boolean        yyRepeated1;
    Pair<Modifier> yyRepValue1;
    List<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pLocalFnMod(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Modifier v$el$1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Modifier>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Modifier> a1s = yyRepValue1.reverse();

      yyValue = FortressUtil.mkList(a1s.list());
      FortressUtil.noDuplicate(yyValue);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.LocalFnMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalFnMod(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fLocalFnMod) 
      yyColumn.chunk6.fLocalFnMod = pLocalFnMod$1(yyStart);
    return yyColumn.chunk6.fLocalFnMod;
  }

  /** Actually parse Header.LocalFnMod. */
  private Result pLocalFnMod$1(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = patomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierAtomic(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pio(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierIO(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.FldMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFldMods(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyRepetition1;
    boolean        yyRepeated1;
    Pair<Modifier> yyRepValue1;
    List<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pFldMod(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Modifier v$el$1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Modifier>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Modifier> a1s = yyRepValue1.reverse();

      yyValue = FortressUtil.mkList(a1s.list());
      FortressUtil.noDuplicate(yyValue);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.FldMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFldMod(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pvar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierVar(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAbsFldMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.AbsFldMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsFldMod(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pApiFldMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pwrapped(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierWrapped(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pprivate(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierPrivate(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.ApiFldMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pApiFldMod(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = phidden(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierHidden(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = psettable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierSettable(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = ptest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierTest(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.StaticParams.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticParams(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fStaticParams) 
      yyColumn.chunk6.fStaticParams = pStaticParams$1(yyStart);
    return yyColumn.chunk6.fStaticParams;
  }

  /** Actually parse Header.StaticParams. */
  private Result pStaticParams$1(final int yyStart) throws IOException {
    Result            yyResult;
    List<StaticParam> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popendoublesquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParamList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosedoublesquare(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.StaticParamList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticParamList(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<StaticParam> yyRepValue1;
    List<StaticParam> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStaticParam(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StaticParam a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticParam(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                StaticParam v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<StaticParam>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<StaticParam> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Header.StaticParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticParam(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fStaticParam) 
      yyColumn.chunk6.fStaticParam = pStaticParam$1(yyStart);
    return yyColumn.chunk6.fStaticParam;
  }

  /** Actually parse Header.StaticParam. */
  private Result pStaticParam$1(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    Object      yyOpValue1;
    StaticParam yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtends(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<TraitType> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        List<TraitType> a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pabsorbs(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = punit(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                String v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
          }
        }
        { // Start scope for a3.
          String a3 = cast(yyOpValue1);

          if (a2 == null) a2 = Collections.<TraitType>emptyList();
          boolean absorbs;
          if (a3 == null) absorbs = false;
          else            absorbs = true;
          yyValue = new SimpleTypeParam(createSpan(yyStart,yyCount),
          NodeFactory.makeIdName(a1),a2,absorbs);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pnat(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyValue = new NatParam(createSpan(yyStart,yyCount), NodeFactory.makeIdName(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = pint(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyValue = new IntParam(createSpan(yyStart,yyCount), NodeFactory.makeIdName(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyResult = pbool(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyValue = new BoolParam(createSpan(yyStart,yyCount), NodeFactory.makeIdName(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = pdim(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyValue = new DimensionParam(createSpan(yyStart,yyCount),NodeFactory.makeIdName(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 6.

    yyResult = punit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcolon(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pDimExpr(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  DimExpr v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
            }
          }
          { // Start scope for a2.
            DimExpr a2 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pabsorbs(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = punit(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    String v$el$4 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$4;
                  }
                }
              }
            }
            { // Start scope for a3.
              String a3 = cast(yyOpValue1);

              Option<DimExpr> derived = Option.wrap(a2);
              boolean absorbs = (a3 == null) ? false : true;
              yyValue = new UnitParam(createSpan(yyStart,yyCount),NodeFactory.makeIdName(a1),
              derived,absorbs);

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a3.
          } // End scope for a2.
        }
      }
    }

    // Alternative 7.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a1 = yyResult.semanticValue();

          yyValue = new OperatorParam(createSpan(yyStart,yyCount),NodeFactory.makeOpr(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal OtherDecl.TypeAlias.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeAlias(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<StaticParam> yyOpValue1;
    TypeAlias         yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ptype(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticParams(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<StaticParam> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<StaticParam> a2 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pequals(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Type a3 = yyResult.semanticValue();

                    if (a2 == null) a2 = FortressUtil.emptyStaticParams();
                    yyValue = new TypeAlias(createSpan(yyStart,yyCount), NodeFactory.makeIdName(a1),
                    a2, a3);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal OtherDecl.PropertyDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPropertyDecl(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fPropertyDecl) 
      yyColumn.chunk6.fPropertyDecl = pPropertyDecl$1(yyStart);
    return yyColumn.chunk6.fPropertyDecl;
  }

  /** Actually parse OtherDecl.PropertyDecl. */
  private Result pPropertyDecl$1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Object       yyOpValue1;
    PropertyDecl yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pproperty(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id v$el$1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pequals(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a1.
        Id a1 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pFORALL(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pParameter$ValParam(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<Param> v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
          }
        }
        { // Start scope for a2.
          List<Param> a2 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              Option<IdName> id = (a1 == null) ? Option.<IdName>none() :
              Option.some(NodeFactory.makeIdName(a1));
              if (a2 == null) a2 = FortressUtil.emptyParams();
              yyValue = new PropertyDecl(createSpan(yyStart,yyCount), id, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a2.
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.IsType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIsType(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fIsType) 
      yyColumn.chunk6.fIsType = pIsType$1(yyStart);
    return yyColumn.chunk6.fIsType;
  }

  /** Actually parse Type.IsType. */
  private Result pIsType$1(final int yyStart) throws IOException {
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcolon(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Type>> yyRepValue1;
    Type               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypeFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Type seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pTypeTail(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Action<Type> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Type>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for list.
        final Pair<Action<Type>> list = yyRepValue1.reverse();

        yyValue = (Type)apply(list, seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for list.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TypeFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeFront(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    List<TraitType> yyOpValue1;
    Type            yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pTypeFrontNonArrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NonArrowType a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = prightarrow(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNonArrowType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              NonArrowType a2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pThrows(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<TraitType> v$el$2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
              }
              { // Start scope for a3.
                List<TraitType> a3 = yyOpValue1;

                Option<List<TraitType>> throws_ = Option.wrap(a3);
                yyValue = NodeFactory.makeArrowType(createSpan(yyStart,yyCount), a1, a2,
                throws_);

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for a3.
            }
          }
        }
      }
    }

    // Alternative 3.

    yyResult = pTypeFrontNonArrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TypeFrontNonArrow.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeFrontNonArrow(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fTypeFrontNonArrow) 
      yyColumn.chunk6.fTypeFrontNonArrow = pTypeFrontNonArrow$1(yyStart);
    return yyColumn.chunk6.fTypeFrontNonArrow;
  }

  /** Actually parse Type.TypeFrontNonArrow. */
  private Result pTypeFrontNonArrow$1(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    List<StaticArg> yyOpValue1;
    NonArrowType    yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popendoublesquare(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticArgList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<StaticArg> v$el$2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pclosedoublesquare(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
              }
            }
          }
        }
      }
      { // Start scope for a2.
        List<StaticArg> a2 = yyOpValue1;

        if (a2 == null) yyValue = new IdType(createSpan(yyStart,yyCount), a1);
        else yyValue = new InstantiatedType(createSpan(yyStart,yyCount), a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pTupleType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcloseparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = new VoidType(createSpan(yyStart,yyCount));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TypeTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeTail(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<ExtentRange> yyRepValue1;
    int               yyOption1;
    Object            yyOpValue1;
    Action<Type>      yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = popensquare(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pArraySize(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final FixedDim v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        }
        { // Start scope for a1.
          final FixedDim a1 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosesquare(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pArrowTypeTail(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final ArrowTypeTail v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
              { // Start scope for a2.
                final ArrowTypeTail a2 = cast(yyOpValue1);

                yyValue = new Action<Type>() {
                  public Type run(Type base) {
                    Option<FixedDim> indices = Option.wrap(a1);
                    NonArrowType ty =
                    NodeFactory.makeArrayType(createSpan(yyStart,yyCount),
                    (Type)base, indices);
                    if (a2 == null) return ty;
                    else return NodeFactory.makeArrowType(createSpan(yyStart,yyCount),
                    ty, a2.getRange(),
                    a2.getThrows());
                }};

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for a2.
            }
          }
        } // End scope for a1.
      }
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pIntExpr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final IntExpr a1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pArrowTypeTail(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final ArrowTypeTail v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
        { // Start scope for a2.
          final ArrowTypeTail a2 = cast(yyOpValue1);

          yyValue = new Action<Type>() {
            public Type run(Type base) {
              StaticArg arg = new IntArg(a1.getSpan(),a1);
              ExtentRange er = new ExtentRange(Option.<StaticArg>none(),
              Option.some(arg));
              NonArrowType ty =
              NodeFactory.makeMatrixType(createSpan(yyStart,yyCount),
              (Type)base, er);
              if (a2 == null) return ty;
              else return NodeFactory.makeArrowType(createSpan(yyStart,yyCount),
              ty, a2.getRange(),
              a2.getThrows());
          }};

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }

      // Nested alternative 2.

      yyResult = popenparen(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExtentRange(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final ExtentRange a1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = pw(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcross(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pExtentRange(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      final ExtentRange v$el$4 = yyResult.semanticValue();

                      yyRepetition1 = yyResult.index;
                      yyRepValue1   = 
                        new Pair<ExtentRange>(v$el$4, yyRepValue1);
                      continue;
                    }
                  }
                }
              }
              break;
            }
            { // Start scope for a2s.
              final Pair<ExtentRange> a2s = yyRepValue1.reverse();

              yyResult = pw(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pArrowTypeTail(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    final ArrowTypeTail v$el$5 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$5;
                  }
                  { // Start scope for a3.
                    final ArrowTypeTail a3 = cast(yyOpValue1);

                    yyValue = new Action<Type>() {
                      public Type run(Type base) {
                        NonArrowType ty =
                        NodeFactory.makeMatrixType(createSpan(yyStart,yyCount),
                        (Type)base,a1,a2s.list());
                        
                        if (a3 == null) return ty;
                        else return NodeFactory.makeArrowType(createSpan(yyStart,yyCount),
                        ty, a3.getRange(),
                        a3.getThrows());
                    }};

                    return new SemanticValue(yyValue, yyOption1, yyError);
                  } // End scope for a3.
                }
              }
            } // End scope for a2s.
          }
        }
      }
    }

    // Alternative 3.

    yyResult = psr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pDimExpr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final DimExpr a1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pin(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExpression$UnitExpr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final UnitExpr v$el$6 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$6;
              }
            }
          }
        }
        { // Start scope for a2.
          final UnitExpr a2 = cast(yyOpValue1);

          yyValue = new Action<Type>() {
            public Type run(Type base) {
              Option<UnitExpr> unit;
              if (a2 == null) unit = Option.<UnitExpr>none();
              else            unit = Option.<UnitExpr>some(a2);
              return new TaggedDimType(createSpan(yyStart,yyCount),
              (Type)base, a1, unit);
          }};

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }

      // Nested alternative 2.

      yyResult = pExpression$UnitExpr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final UnitExpr a1 = yyResult.semanticValue();

        yyValue = new Action<Type>() {
          public Type run(Type base) {
            return new TaggedUnitType(createSpan(yyStart,yyCount),
            (Type)base, a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.ArrowTypeTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrowTypeTail(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fArrowTypeTail) 
      yyColumn.chunk6.fArrowTypeTail = pArrowTypeTail$1(yyStart);
    return yyColumn.chunk6.fArrowTypeTail;
  }

  /** Actually parse Type.ArrowTypeTail. */
  private Result pArrowTypeTail$1(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    List<TraitType> yyOpValue1;
    ArrowTypeTail   yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = prightarrow(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNonArrowType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            NonArrowType a1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pThrows(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<TraitType> v$el$1 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$1;
              }
            }
            { // Start scope for a2.
              List<TraitType> a2 = yyOpValue1;

              Option<List<TraitType>> throws_ = Option.wrap(a2);
              yyValue = new ArrowTypeTail(a1, throws_);

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a2.
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.NonArrowType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonArrowType(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fNonArrowType) 
      yyColumn.chunk6.fNonArrowType = pNonArrowType$1(yyStart);
    return yyColumn.chunk6.fNonArrowType;
  }

  /** Actually parse Type.NonArrowType. */
  private Result pNonArrowType$1(final int yyStart) throws IOException {
    Result       yyResult;
    NonArrowType yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pTupleType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcloseparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = new VoidType(createSpan(yyStart,yyCount));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyResult = pDimType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TraitType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitType(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fTraitType) 
      yyColumn.chunk6.fTraitType = pTraitType$1(yyStart);
    return yyColumn.chunk6.fTraitType;
  }

  /** Actually parse Type.TraitType. */
  private Result pTraitType$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    TraitType  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popensquare(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pArraySize(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              FixedDim v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            FixedDim a2 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosesquare(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                Option<FixedDim> indices = Option.wrap(a2);
                yyValue = NodeFactory.makeArrayType(createSpan(yyStart,yyCount), a1,
                indices);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a2.
        }
      }

      // Nested alternative 2.

      yyResult = pcaret(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pIntExpr(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IntExpr a2 = yyResult.semanticValue();

          StaticArg arg = new IntArg(a2.getSpan(),a2);
          ExtentRange er = new ExtentRange(Option.<StaticArg>none(),
          Option.some(arg));
          yyValue = NodeFactory.makeMatrixType(createSpan(yyStart,yyCount),a1,er);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = popenparen(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExtentRange(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              ExtentRange a2 = yyResult.semanticValue();

              yyResult = pTraitType$$Star1(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Pair<ExtentRange> a3s = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = NodeFactory.makeMatrixType(createSpan(yyStart,yyCount), a1, a2,
                    a3s.list());

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popendoublesquare(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticArgList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<StaticArg> v$el$4 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pclosedoublesquare(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$4;
                }
              }
            }
          }
        }
      }
      { // Start scope for a2.
        List<StaticArg> a2 = cast(yyOpValue1);

        if (a2 == null) yyValue = new IdType(createSpan(yyStart,yyCount), a1);
        else yyValue = new InstantiatedType(createSpan(yyStart,yyCount), a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.TraitType$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitType$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fTraitType$$Star1) 
      yyColumn.chunk6.fTraitType$$Star1 = pTraitType$$Star1$1(yyStart);
    return yyColumn.chunk6.fTraitType$$Star1;
  }

  /** Actually parse PreFortress.TraitType$$Star1. */
  private Result pTraitType$$Star1$1(final int yyStart) throws IOException {
    Result            yyResult;
    Pair<ExtentRange> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcross(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExtentRange(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            ExtentRange v$el$2 = yyResult.semanticValue();

            yyResult = pTraitType$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<ExtentRange> v$3 = yyResult.semanticValue();

              yyValue = new Pair<ExtentRange>(v$el$2, v$3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TupleType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTupleType(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fTupleType) 
      yyColumn.chunk7.fTupleType = pTupleType$1(yyStart);
    return yyColumn.chunk7.fTupleType;
  }

  /** Actually parse Type.TupleType. */
  private Result pTupleType$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Type       yyOpValue1;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTupleType$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Type> a1s = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyOption1  = yyChoice1;
          yyOpValue1 = null;

          yyResult = pType(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Type v$el$4 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcomma(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$4;
                    }
                  }
                }
              }
            }
          }
          { // Start scope for a2.
            Type a2 = yyOpValue1;

            yyResult = pKeywordType(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              KeywordType a3 = yyResult.semanticValue();

              yyResult = pTupleType$$Star2(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Pair<KeywordType> a4s = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    List<Type>   ts1 = a1s.list();
                    Option<VarargsType> ts2 = ((a2 != null)?
                    Option.some(new VarargsType(createSpan(yyStart,yyCount), a2)) :
                    Option.<VarargsType>none());
                    List<KeywordType> ts3 = a4s.list();
                    ts3.add(0, a3);
                    yyValue = new TupleType(createSpan(yyStart,yyCount), ts1, ts2, ts3);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          } // End scope for a2.

          // Nested alternative 2.

          yyResult = pType(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Type a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    List<Type> ts1 = FortressUtil.mkList(a1s.list());
                    Option<VarargsType> ts2 =
                    Option.some(new VarargsType(createSpan(yyStart,yyCount),a2));
                    yyValue = NodeFactory.makeTupleType(createSpan(yyStart,yyCount),ts1,ts2);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pSimpleTupleType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.TupleType$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTupleType$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fTupleType$$Star1) 
      yyColumn.chunk7.fTupleType$$Star1 = pTupleType$$Star1$1(yyStart);
    return yyColumn.chunk7.fTupleType$$Star1;
  }

  /** Actually parse PreFortress.TupleType$$Star1. */
  private Result pTupleType$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type v$el$2 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pTupleType$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Type> v$3 = yyResult.semanticValue();

              yyValue = new Pair<Type>(v$el$2, v$3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.TupleType$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTupleType$$Star2(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fTupleType$$Star2) 
      yyColumn.chunk7.fTupleType$$Star2 = pTupleType$$Star2$1(yyStart);
    return yyColumn.chunk7.fTupleType$$Star2;
  }

  /** Actually parse PreFortress.TupleType$$Star2. */
  private Result pTupleType$$Star2$1(final int yyStart) throws IOException {
    Result            yyResult;
    Pair<KeywordType> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pKeywordType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            KeywordType v$el$5 = yyResult.semanticValue();

            yyResult = pTupleType$$Star2(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<KeywordType> v$6 = yyResult.semanticValue();

              yyValue = new Pair<KeywordType>(v$el$5, v$6);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.KeywordType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pKeywordType(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fKeywordType) 
      yyColumn.chunk7.fKeywordType = pKeywordType$1(yyStart);
    return yyColumn.chunk7.fKeywordType;
  }

  /** Actually parse Type.KeywordType. */
  private Result pKeywordType$1(final int yyStart) throws IOException {
    Result      yyResult;
    KeywordType yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyValue = new KeywordType(createSpan(yyStart,yyCount),
              NodeFactory.makeIdName(a1), a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.SimpleTupleType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleTupleType(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fSimpleTupleType) 
      yyColumn.chunk7.fSimpleTupleType = pSimpleTupleType$1(yyStart);
    return yyColumn.chunk7.fSimpleTupleType;
  }

  /** Actually parse Type.SimpleTupleType. */
  private Result pSimpleTupleType$1(final int yyStart) throws IOException {
    Result     yyResult;
    TupleType  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcomma(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pTypeList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Type> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      List<Type> ts = FortressUtil.mkList(a1, a2);
                      yyValue = NodeFactory.makeTupleType(createSpan(yyStart,yyCount), ts,
                      Option.<VarargsType>none());

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TypeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeList(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fTypeList) 
      yyColumn.chunk7.fTypeList = pTypeList$1(yyStart);
    return yyColumn.chunk7.fTypeList;
  }

  /** Actually parse Type.TypeList. */
  private Result pTypeList$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyResult = pTypeList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Type> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.TypeList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeList$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fTypeList$$Star1) 
      yyColumn.chunk7.fTypeList$$Star1 = pTypeList$$Star1$1(yyStart);
    return yyColumn.chunk7.fTypeList$$Star1;
  }

  /** Actually parse PreFortress.TypeList$$Star1. */
  private Result pTypeList$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Type v$el$1 = yyResult.semanticValue();

            yyResult = pTypeList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Type> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Type>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.DimType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDimType(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    UnitExpr   yyOpValue1;
    DimType    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyResult = psr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pDimExpr(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          DimExpr a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pin(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExpression$UnitExpr(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  UnitExpr v$el$1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
            }
          }
          { // Start scope for a3.
            UnitExpr a3 = yyOpValue1;

            Option<UnitExpr> unit;
            if (a3 == null) unit = Option.<UnitExpr>none();
            else            unit = Option.<UnitExpr>some(a3);
            yyValue = new TaggedDimType(createSpan(yyStart,yyCount), a1, a2, unit);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }

        // Nested alternative 2.

        yyResult = pExpression$UnitExpr(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          UnitExpr a2 = yyResult.semanticValue();

          yyValue = new TaggedUnitType(createSpan(yyStart,yyCount), a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.DimExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDimExpr(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fDimExpr) 
      yyColumn.chunk7.fDimExpr = pDimExpr$1(yyStart);
    return yyColumn.chunk7.fDimExpr;
  }

  /** Actually parse Type.DimExpr. */
  private Result pDimExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    DimExpr    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDimExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      DimExpr seed = yyResult.semanticValue();

      yyResult = pDimExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<DimExpr>> list = yyResult.semanticValue();

        yyValue = (DimExpr)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.DimExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDimExpr$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fDimExpr$$Star1) 
      yyColumn.chunk7.fDimExpr$$Star1 = pDimExpr$$Star1$1(yyStart);
    return yyColumn.chunk7.fDimExpr$$Star1;
  }

  /** Actually parse PreFortress.DimExpr$$Star1. */
  private Result pDimExpr$$Star1$1(final int yyStart) throws IOException {
    Result                yyResult;
    Pair<Action<DimExpr>> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDimExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<DimExpr> v$el$1 = yyResult.semanticValue();

      yyResult = pDimExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<DimExpr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<DimExpr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.DimExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDimExprFront(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    DimExpr    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('U' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('y' == yyC) {
              yyIndex = yyIndex + 1;

              yyValue = new BaseDim(createSpan(yyStart,yyCount));

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyValue = new DimRef(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pone(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pslash(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDimExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              DimExpr a1 = yyResult.semanticValue();

              yyValue = new QuotientDim(createSpan(yyStart,yyCount),
              new BaseDim(createSpan(yyStart,1)), a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pDimExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          DimExpr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 5.

    yyResult = pDUPreOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      DimUnitOp a1 = yyResult.semanticValue();

      yyResult = psr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pDimExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          DimExpr a2 = yyResult.semanticValue();

          yyValue = new OpDim(createSpan(yyStart,yyCount), a2, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("dim expr front expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.DimExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDimExprTail(final int yyStart) throws IOException {
    Result          yyResult;
    Action<DimExpr> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared24(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDimExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final DimExpr a1 = yyResult.semanticValue();

        yyValue = new Action<DimExpr>() {
          public DimExpr run(DimExpr base) {
            return new ProductDim(createSpan(yyStart,yyCount), (DimExpr)base,
            a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = p$$Shared25(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pDimExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final DimExpr a1 = yyResult.semanticValue();

            yyValue = new Action<DimExpr>() {
              public DimExpr run(DimExpr base) {
                return new QuotientDim(createSpan(yyStart,yyCount), (DimExpr)base,
                a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 3.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNumber(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final IntLiteral a1 = yyResult.semanticValue();

        yyValue = new Action<DimExpr>() {
          public DimExpr run(DimExpr base) {
            return new ExponentDim(createSpan(yyStart,yyCount), (DimExpr)base,
            a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDUPostOp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final DimUnitOp a1 = yyResult.semanticValue();

        yyValue = new Action<DimExpr>() {
          public DimExpr run(DimExpr base) {
            return new OpDim(createSpan(yyStart,yyCount), (DimExpr)base, a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared25.
   * This nonterminal represents the duplicate productions 
   * PreFortress.QuotientDim$$Choice1, Expression.QuotientUnit$$Choice1, 
   * NoNewlineExpr.QuotientUnit$$Choice1, 
   * and NoSpaceExpr.QuotientUnit$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared25(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("/")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select(" expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.StaticArgList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArgList(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fStaticArgList) 
      yyColumn.chunk7.fStaticArgList = pStaticArgList$1(yyStart);
    return yyColumn.chunk7.fStaticArgList;
  }

  /** Actually parse Type.StaticArgList. */
  private Result pStaticArgList$1(final int yyStart) throws IOException {
    Result          yyResult;
    List<StaticArg> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStaticArg(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StaticArg a1 = yyResult.semanticValue();

      yyResult = pStaticArgList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<StaticArg> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.StaticArgList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArgList$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fStaticArgList$$Star1) 
      yyColumn.chunk8.fStaticArgList$$Star1 = pStaticArgList$$Star1$1(yyStart);
    return yyColumn.chunk8.fStaticArgList$$Star1;
  }

  /** Actually parse PreFortress.StaticArgList$$Star1. */
  private Result pStaticArgList$$Star1$1(final int yyStart) 
    throws IOException {

    Result          yyResult;
    Pair<StaticArg> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStaticArg(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            StaticArg v$el$1 = yyResult.semanticValue();

            yyResult = pStaticArgList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<StaticArg> v$2 = yyResult.semanticValue();

              yyValue = new Pair<StaticArg>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.StaticArg.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArg(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fStaticArg) 
      yyColumn.chunk8.fStaticArg = pStaticArg$1(yyStart);
    return yyColumn.chunk8.fStaticArg;
  }

  /** Actually parse Type.StaticArg. */
  private Result pStaticArg$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    StaticArg  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOprArg(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'U':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('n' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('i' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('t' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('y' == yyC) {

                          Span span = createSpan(yyStart,yyCount);
                          yyValue = new DimArg(span, new BaseDim(span));

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'd':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('i' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('m' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('n' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('s' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('i' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('o' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('n' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('l' == yyC) {

                                              yyC = character(yyIndex);
                                              if (-1 != yyC) {
                                                yyIndex = yyIndex + 1;
                                                if ('e' == yyC) {

                                                  yyC = character(yyIndex);
                                                  if (-1 != yyC) {
                                                    yyIndex = yyIndex + 1;
                                                    if ('s' == yyC) {

                                                      yyC = 
                                                        character(yyIndex);
                                                      if (-1 != yyC) {
                                                        yyIndex = yyIndex + 1;
                                                        if ('s' == yyC) {

                                                          Span span = createSpan(yyStart,yyCount);
                                                          yyValue = new UnitArg(span, new BaseUnit(span));

                                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyResult = pone(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pslash(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDimExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              DimExpr a1 = yyResult.semanticValue();

              Span span = createSpan(yyStart,1);
              yyValue = new DimArg(span, new QuotientDim(span, new BaseDim(createSpan(yyStart,1)), a1));

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pDUPreOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      DimUnitOp a1 = yyResult.semanticValue();

      yyResult = psr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pDimExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          DimExpr a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = new DimArg(span, new OpDim(span, a2, a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArg(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          StaticArg a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 6.

    yyPredMatched = false;

    yyPredResult = pStaticArg$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pIntExpr(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        IntExpr a1 = yyResult.semanticValue();

        yyValue = new IntArg(createSpan(yyStart,yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("static arg expected", yyStart);
    }

    // Alternative 7.

    yyPredMatched = false;

    yyPredResult = pStaticArg$$Choice2(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pBoolExpr(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        BoolExpr a1 = yyResult.semanticValue();

        yyValue = new BoolArg(createSpan(yyStart,yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("static arg expected", yyStart);
    }

    // Alternative 8.

    yyPredMatched = false;

    yyPredResult = pStaticArg$$Choice3(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pType(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Type a1 = yyResult.semanticValue();

        yyValue = new TypeArg(createSpan(yyStart,yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("static arg expected", yyStart);
    }

    // Alternative 9.

    yyResult = pDimExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      DimExpr a1 = yyResult.semanticValue();

      yyValue = new DimArg(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyResult = pExpression$UnitExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      UnitExpr a1 = yyResult.semanticValue();

      yyValue = new UnitArg(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("static arg expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.StaticArg$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArg$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pclosedoublesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pclosesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pcomma(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 4.

        yyResult = popendoublesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 5.

        yyResult = popensquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 6.

        yyResult = prightarrow(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 7.

        yyBase   = yyChoice2;
        yyResult = pop(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue("OR")) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("\"OR\" expected", yyBase);
        }

        // Nested alternative 8.

        yyBase   = yyChoice2;
        yyResult = pop(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue("AND")) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("\"AND\" expected", yyBase);
        }

        // Nested alternative 9.

        yyBase   = yyChoice2;
        yyResult = pop(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue("IMPLIES")) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("\"IMPLIES\" expected", yyBase);
        }

        // Nested alternative 10.

        yyResult = pequals(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.StaticArg$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArg$$Choice2(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pclosedoublesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pclosesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pcomma(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 4.

        yyResult = popendoublesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 5.

        yyResult = popensquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 6.

        yyResult = prightarrow(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.StaticArg$$Choice3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArg$$Choice3(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pDOT(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pslash(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pper(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 4.

        yyResult = pDUPostOp(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.DUPreOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDUPreOp(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fDUPreOp) 
      yyColumn.chunk8.fDUPreOp = pDUPreOp$1(yyStart);
    return yyColumn.chunk8.fDUPreOp;
  }

  /** Actually parse Type.DUPreOp. */
  private Result pDUPreOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    DimUnitOp  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new SquareDimUnit(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pcubic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new CubicDimUnit(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pinverse(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new InverseDimUnit(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.DUPostOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDUPostOp(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fDUPostOp) 
      yyColumn.chunk8.fDUPostOp = pDUPostOp$1(yyStart);
    return yyColumn.chunk8.fDUPostOp;
  }

  /** Actually parse Type.DUPostOp. */
  private Result pDUPostOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    DimUnitOp  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psquared(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new SquareDimUnit(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pcubed(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new CubicDimUnit(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.ArraySize.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArraySize(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fArraySize) 
      yyColumn.chunk8.fArraySize = pArraySize$1(yyStart);
    return yyColumn.chunk8.fArraySize;
  }

  /** Actually parse Type.ArraySize. */
  private Result pArraySize$1(final int yyStart) throws IOException {
    Result     yyResult;
    FixedDim   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExtentRange(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExtentRange a1 = yyResult.semanticValue();

      yyResult = pArraySize$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<ExtentRange> a2s = yyResult.semanticValue();

        List<ExtentRange> es = FortressUtil.mkList(a1, a2s.list());
        yyValue = new FixedDim(createSpan(yyStart,yyCount), es);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.ArraySize$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArraySize$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fArraySize$$Star1) 
      yyColumn.chunk8.fArraySize$$Star1 = pArraySize$$Star1$1(yyStart);
    return yyColumn.chunk8.fArraySize$$Star1;
  }

  /** Actually parse PreFortress.ArraySize$$Star1. */
  private Result pArraySize$$Star1$1(final int yyStart) throws IOException {
    Result            yyResult;
    Pair<ExtentRange> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExtentRange(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            ExtentRange v$el$1 = yyResult.semanticValue();

            yyResult = pArraySize$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<ExtentRange> v$2 = yyResult.semanticValue();

              yyValue = new Pair<ExtentRange>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.ExtentRange.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExtentRange(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fExtentRange) 
      yyColumn.chunk8.fExtentRange = pExtentRange$1(yyStart);
    return yyColumn.chunk8.fExtentRange;
  }

  /** Actually parse Type.ExtentRange. */
  private Result pExtentRange$1(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    StaticArg   yyOpValue1;
    ExtentRange yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pStaticArg(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StaticArg v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      StaticArg a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = ppound(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStaticArg(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            StaticArg v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a2.
          StaticArg a2 = yyOpValue1;

          Option<StaticArg> base = Option.wrap(a1);
          Option<StaticArg> size = Option.wrap(a2);
          yyValue = new ExtentRange(createSpan(yyStart,yyCount), base, size);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }

      // Nested alternative 2.

      yyResult = pcolon(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStaticArg(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            StaticArg v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
        }
        { // Start scope for a2.
          StaticArg a2 = yyOpValue1;

          Option<StaticArg> base = Option.wrap(a1);
          Option<StaticArg> size = Option.wrap(a2);
          yyValue = new ExtentRange(createSpan(yyStart,yyCount), base, size);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pStaticArg(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StaticArg a1 = yyResult.semanticValue();

      yyValue = new ExtentRange(createSpan(yyStart,yyCount),
      Option.<StaticArg>none(),
      Option.some(a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.Number.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumber(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fNumber) 
      yyColumn.chunk8.fNumber = pNumber$1(yyStart);
    return yyColumn.chunk8.fNumber;
  }

  /** Actually parse Type.Number. */
  private Result pNumber$1(final int yyStart) throws IOException {
    Result     yyResult;
    IntLiteral yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Expr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$Expr(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fExpression$Expr) 
      yyColumn.chunk8.fExpression$Expr = pExpression$Expr$1(yyStart);
    return yyColumn.chunk8.fExpression$Expr;
  }

  /** Actually parse Expression.Expr. */
  private Result pExpression$Expr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$ExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr seed = yyResult.semanticValue();

      yyResult = pExpression$Expr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> list = yyResult.semanticValue();

        yyValue = (Expr)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Expression.Expr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$Expr$$Star1(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fExpression$Expr$$Star1) 
      yyColumn.chunk8.fExpression$Expr$$Star1 = pExpression$Expr$$Star1$1(yyStart);
    return yyColumn.chunk8.fExpression$Expr$$Star1;
  }

  /** Actually parse Expression.Expr$$Star1. */
  private Result pExpression$Expr$$Star1$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    Pair<Action<Expr>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared16(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Expr> v$el$1 = yyResult.semanticValue();

      yyResult = pExpression$Expr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.ExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$ExprFront(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Assign>.

    yyResult = p$$Shared19(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<LHS> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAssignOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Option<Opr> a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              yyValue = new Assignment(createSpan(yyStart,yyCount),false, a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pExpression$OpExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDelimitedExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Flow>.

    yyResult = pExpression$FlowExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Fn>.

    yyResult = pfn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pParameter$ValParam(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIsType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type v$el$4 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$4;
            }
          }
          { // Start scope for a2.
            Type a2 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pThrows(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<TraitType> v$el$5 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$5;
              }
            }
            { // Start scope for a3.
              List<TraitType> a3 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pmatch(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pExpression$Expr(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Expr a4 = yyResult.semanticValue();

                      Option<Type> ty_opt = Option.wrap(a2);
                      Option<List<TraitType>> tys = Option.wrap(a3);
                      yyValue = ExprFactory.makeFnExpr(createSpan(yyStart,yyCount), a1, ty_opt,
                      tys, a4);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            } // End scope for a3.
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared16.
   * This nonterminal represents the duplicate productions 
   * Expression.ExprTail and NoSpaceExpr.ExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared16(final int yyStart) throws IOException {
    Result       yyResult;
    Action<Expr> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pas(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Type a1 = yyResult.semanticValue();

            yyValue = new Action<Expr>() {
              public Expr run(Expr base) {
                return new AsExpr(createSpan(yyStart,yyCount), false, (Expr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pasif(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Type a1 = yyResult.semanticValue();

            yyValue = new Action<Expr>() {
              public Expr run(Expr base) {
                return new AsIfExpr(createSpan(yyStart,yyCount), false, (Expr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared19.
   * This nonterminal represents the duplicate productions 
   * Expression.AssignLefts, NoNewlineExpr.AssignLefts, 
   * and NoSpaceExpr.AssignLefts.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared19(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.f$$Shared19) 
      yyColumn.chunk9.f$$Shared19 = p$$Shared19$1(yyStart);
    return yyColumn.chunk9.f$$Shared19;
  }

  /** Actually parse PreFortress.$$Shared19. */
  private Result p$$Shared19$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<LHS>  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared18(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          LHS a1 = yyResult.semanticValue();

          yyResult = p$$Shared19$$Star1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<LHS> a2s = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = FortressUtil.mkList(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = p$$Shared18(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LHS a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared19$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared19$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.f$$Shared19$$Star1) 
      yyColumn.chunk9.f$$Shared19$$Star1 = p$$Shared19$$Star1$1(yyStart);
    return yyColumn.chunk9.f$$Shared19$$Star1;
  }

  /** Actually parse PreFortress.$$Shared19$$Star1. */
  private Result p$$Shared19$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<LHS>  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared18(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            LHS v$el$1 = yyResult.semanticValue();

            yyResult = p$$Shared19$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<LHS> v$2 = yyResult.semanticValue();

              yyValue = new Pair<LHS>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared18.
   * This nonterminal represents the duplicate productions 
   * Expression.AssignLeft, NoNewlineExpr.AssignLeft, 
   * and NoSpaceExpr.AssignLeft.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared18(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.f$$Shared18) 
      yyColumn.chunk9.f$$Shared18 = p$$Shared18$1(yyStart);
    return yyColumn.chunk9.f$$Shared18;
  }

  /** Actually parse PreFortress.$$Shared18. */
  private Result p$$Shared18$1(final int yyStart) throws IOException {
    Result     yyResult;
    LHS        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr seed = yyResult.semanticValue();

      yyResult = p$$Shared18$$Plus1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> list = yyResult.semanticValue();

        Expr left = (Expr)apply(list, seed);
        if (left instanceof LHS) yyValue = (LHS)left;
        else yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyValue = new VarRef(createSpan(yyStart,yyCount), false, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared18$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared18$$Plus1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.f$$Shared18$$Plus1) 
      yyColumn.chunk9.f$$Shared18$$Plus1 = p$$Shared18$$Plus1$1(yyStart);
    return yyColumn.chunk9.f$$Shared18$$Plus1;
  }

  /** Actually parse PreFortress.$$Shared18$$Plus1. */
  private Result p$$Shared18$$Plus1$1(final int yyStart) throws IOException {
    Result             yyResult;
    Pair<Action<Expr>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared17(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Expr> v$el$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = p$$Shared18$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Action<Expr>>(v$el$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared17.
   * This nonterminal represents the duplicate productions 
   * Expression.AssignLeftTail, NoNewlineExpr.AssignLeftTail, 
   * and NoSpaceExpr.AssignLeftTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared17(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    List<Expr>   yyOpValue1;
    Action<Expr> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExprList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<Expr> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        final List<Expr> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pclosesquare(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final String a3 = yyResult.semanticValue();

            yyValue = new Action<Expr>() {
              public Expr run(Expr base) {
                List<Expr> es;
                if (a2 == null) es = FortressUtil.emptyExprs();
                else            es = a2;
                Span span = createSpan(yyStart,yyCount);
                Op open  = NodeFactory.makeOp(createSpan(yyStart, yyStart+1), a1);
                Op close = NodeFactory.makeOp(createSpan(yyCount-1,1),a3);
                SubscriptOp op = new SubscriptOp(span, open, close);
                return ExprFactory.makeSubscriptExpr(span,base,es,Option.some(op));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pdot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Id a1 = yyResult.semanticValue();

        yyValue = new Action<Expr>() {
          public Expr run(Expr base) {
            return new FieldRef(createSpan(yyStart,yyCount), false, base,
            NodeFactory.makeIdName(a1));
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.OpExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$OpExpr(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fExpression$OpExpr) 
      yyColumn.chunk9.fExpression$OpExpr = pExpression$OpExpr$1(yyStart);
    return yyColumn.chunk9.fExpression$OpExpr;
  }

  /** Actually parse Expression.OpExpr. */
  private Result pExpression$OpExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$OpExprNoEnc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      yyValue = Resolver.resolveOps(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExpression$OpExprLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      yyValue = Resolver.resolveOps(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      PrecedenceOpExpr e =
      new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
      yyValue = Resolver.resolveOps(PureList.make(e));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.OpExprNoEnc.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$OpExprNoEnc(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fExpression$OpExprNoEnc) 
      yyColumn.chunk9.fExpression$OpExprNoEnc = pExpression$OpExprNoEnc$1(yyStart);
    return yyColumn.chunk9.fExpression$OpExprNoEnc;
  }

  /** Actually parse Expression.OpExprNoEnc. */
  private Result pExpression$OpExprNoEnc$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$OpExprPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExpression$OpExprPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
      yyValue = PureList.make(e);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.TightInfixRight.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$TightInfixRight(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExpression$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pExpression$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$LooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$LeftLooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 4.

      yyValue = PureList.make((PrecedenceOpExpr)new Right(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.LeftLooseInfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$LeftLooseInfix(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fExpression$LeftLooseInfix) 
      yyColumn.chunk9.fExpression$LeftLooseInfix = pExpression$LeftLooseInfix$1(yyStart);
    return yyColumn.chunk9.fExpression$LeftLooseInfix;
  }

  /** Actually parse Expression.LeftLooseInfix. */
  private Result pExpression$LeftLooseInfix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$OpExprLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pwr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$OpExprPrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$OpExprLeftEncloser(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.OpExprLeftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$OpExprLeftEncloser(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fExpression$OpExprLeftEncloser) 
      yyColumn.chunk9.fExpression$OpExprLeftEncloser = pExpression$OpExprLeftEncloser$1(yyStart);
    return yyColumn.chunk9.fExpression$OpExprLeftEncloser;
  }

  /** Actually parse Expression.OpExprLeftEncloser. */
  private Result pExpression$OpExprLeftEncloser$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pExpression$OpExprNoEnc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new Left(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.OpExprPrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$OpExprPrimary(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fExpression$OpExprPrimary) 
      yyColumn.chunk9.fExpression$OpExprPrimary = pExpression$OpExprPrimary$1(yyStart);
    return yyColumn.chunk9.fExpression$OpExprPrimary;
  }

  /** Actually parse Expression.OpExprPrimary. */
  private Result pExpression$OpExprPrimary$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$Primary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<Expr> a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExpression$TightInfixPostfix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pExpression$TightInfixRight(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$LooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$LeftLooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 4.

      yyValue =
      PureList.make((PrecedenceOpExpr)new RealExpr(FortressUtil.buildPrimary(a1)));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.OpExprPrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$OpExprPrefix(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fExpression$OpExprPrefix) 
      yyColumn.chunk9.fExpression$OpExprPrefix = pExpression$OpExprPrefix$1(yyStart);
    return yyColumn.chunk9.fExpression$OpExprPrefix;
  }

  /** Actually parse Expression.OpExprPrefix. */
  private Result pExpression$OpExprPrefix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExpression$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new Prefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pExpression$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new Prefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pExpression$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new Prefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Prefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Prefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$OpExprLeftEncloser(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Prefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.TightInfixPostfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$TightInfixPostfix(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExpression$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pExpression$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pExpression$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$OpExprLeftEncloser(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 5.

      yyValue = PureList.make((PrecedenceOpExpr)new Postfix(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.LooseInfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$LooseInfix(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fExpression$LooseInfix) 
      yyColumn.chunk10.fExpression$LooseInfix = pExpression$LooseInfix$1(yyStart);
    return yyColumn.chunk10.fExpression$LooseInfix;
  }

  /** Actually parse Expression.LooseInfix. */
  private Result pExpression$LooseInfix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pwr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$OpExprPrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$OpExprLeftEncloser(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Primary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$Primary(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fExpression$Primary) 
      yyColumn.chunk10.fExpression$Primary = pExpression$Primary$1(yyStart);
    return yyColumn.chunk10.fExpression$Primary;
  }

  /** Actually parse Expression.Primary. */
  private Result pExpression$Primary$1(final int yyStart) throws IOException {
    Result         yyResult;
    PureList<Expr> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expr seed = yyResult.semanticValue();

      yyResult = pExpression$Primary$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<PureList<Expr>>> list = yyResult.semanticValue();

        yyValue = (PureList<Expr>)apply(list, PureList.make(seed));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Expression.Primary$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$Primary$$Star1(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fExpression$Primary$$Star1) 
      yyColumn.chunk10.fExpression$Primary$$Star1 = pExpression$Primary$$Star1$1(yyStart);
    return yyColumn.chunk10.fExpression$Primary$$Star1;
  }

  /** Actually parse Expression.Primary$$Star1. */
  private Result pExpression$Primary$$Star1$1(final int yyStart) 
    throws IOException {

    Result                       yyResult;
    Pair<Action<PureList<Expr>>> yyValue;
    ParseError                   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$PrimaryTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Action<PureList<Expr>> v$el$1 = yyResult.semanticValue();

      yyResult = pExpression$Primary$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<PureList<Expr>>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<PureList<Expr>>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared8.
   * This nonterminal represents the duplicate productions 
   * Expression.PrimaryFront, NoNewlineExpr.PrimaryFront, 
   * and NoSpaceExpr.PrimaryFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared8(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.f$$Shared8) 
      yyColumn.chunk10.f$$Shared8 = p$$Shared8$1(yyStart);
    return yyColumn.chunk10.f$$Shared8;
  }

  /** Actually parse PreFortress.$$Shared8. */
  private Result p$$Shared8$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Expr> yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComprehension(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyResult = popendoublesquare(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStaticArgList(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<StaticArg> a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosedoublesquare(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = ExprFactory.makeFnRef(createSpan(yyStart,yyCount), a1, a2);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Alternative 3.

    yyResult = pBaseExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExprList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Expr> v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
      }
      { // Start scope for a2.
        List<Expr> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pRightEncloser(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Op a3 = yyResult.semanticValue();

            if (a2 == null) a2 = FortressUtil.emptyExprs();
            yyValue = ASTUtil.enclosing(FortressUtil.spanTwo(a1, a3), a1, a2, a3);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.PrimaryTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$PrimaryTail(final int yyStart) 
    throws IOException {

    int                    yyC;
    int                    yyIndex;
    Result                 yyResult;
    int                    yyBase;
    int                    yyOption1;
    Object                 yyOpValue1;
    Action<PureList<Expr>> yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExprList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<Expr> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        final List<Expr> a2 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pclosesquare(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final String a3 = yyResult.semanticValue();

            yyValue = new Action<PureList<Expr>>() {
              public PureList<Expr> run(PureList<Expr> base) {
                Span span = createSpan(yyStart,yyCount);
                Expr arr = FortressUtil.buildPrimary((PureList<Expr>)base);
                List<Expr> es;
                if (a2 == null) es = FortressUtil.emptyExprs();
                else            es = a2;
                Op open  = NodeFactory.makeOp(createSpan(yyStart, yyStart+1), a1);
                Op close = NodeFactory.makeOp(createSpan(yyCount-1,1),a3);
                SubscriptOp op = new SubscriptOp(span, open, close);
                return PureList.make((Expr)ExprFactory.makeSubscriptExpr(span, arr, es, Option.some(op)));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExprList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<Expr> v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a2.
        final List<Expr> a2 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pRightEncloser(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Op a3 = yyResult.semanticValue();

            yyValue = new Action<PureList<Expr>>() {
              public PureList<Expr> run(PureList<Expr> base) {
                Span span = createSpan(yyStart,yyCount);
                Expr arr = FortressUtil.buildPrimary((PureList<Expr>)base);
                List<Expr> es;
                if (a2 == null) es = FortressUtil.emptyExprs();
                else            es = a2;
                SubscriptOp op = new SubscriptOp(FortressUtil.spanTwo(a1,a3), a1, a3);
                return PureList.make((Expr)new SubscriptExpr(span, false, arr, es,
                Option.some(op)));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Alternative 3.

    yyResult = pdot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Id a1 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = popendoublesquare(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticArgList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final List<StaticArg> v$el$1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pclosedoublesquare(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
            }
          }
        }
        { // Start scope for a2.
          final List<StaticArg> a2 = cast(yyOpValue1);

          final int yyChoice2 = yyOption1;

          // Nested alternative 1.

          yyResult = p$$Shared26(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expr a3 = yyResult.semanticValue();

            yyValue = new Action<PureList<Expr>>() {
              public PureList<Expr> run(PureList<Expr> base) {
                Expr rcv = FortressUtil.buildPrimary((PureList<Expr>)base);
                List<StaticArg> sargs;
                if (a2 == null) sargs = Collections.<StaticArg>emptyList();
                else            sargs = a2;
                Expr inv = new MethodInvocation(FortressUtil.spanTwo(rcv,a3),
                false, rcv, NodeFactory.makeIdName(a1),
                sargs, a3);
                return PureList.make(inv);
            }};

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyResult = popenparen(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = new Action<PureList<Expr>>() {
                  public PureList<Expr> run(PureList<Expr> base) {
                    Expr arg = ExprFactory.makeVoidLiteral(a1.getSpan());
                    Expr rcv = FortressUtil.buildPrimary((PureList<Expr>)base);
                    List<StaticArg> sargs;
                    if (a2 == null) sargs = Collections.<StaticArg>emptyList();
                    else            sargs = a2;
                    Expr inv = new MethodInvocation(createSpan(yyStart,yyCount),
                    false, rcv, NodeFactory.makeIdName(a1),
                    sargs, arg);
                    return PureList.make(inv);
                }};

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        } // End scope for a2.

        // Nested alternative 2.

        yyValue = new Action<PureList<Expr>>() {
          public PureList<Expr> run(PureList<Expr> base) {
            Span span = createSpan(yyStart,yyCount);
            Expr rcv = FortressUtil.buildPrimary((PureList<Expr>)base);
            return PureList.make((Expr)new FieldRef(span,false,rcv,
            NodeFactory.makeIdName(a1)));
        }};

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Alternative 4.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String a1 = yyResult.semanticValue();

      yyResult = pBaseExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expr a2 = yyResult.semanticValue();

        yyValue = new Action<PureList<Expr>>() {
          public PureList<Expr> run(PureList<Expr> base) {
            PureList<Expr> primary = (PureList<Expr>)base;
            if (primary.isEmpty()) {
              return error(a2, "Exponentiation on an empty primary.");
            } else { // !primary.isEmpty()
              Expr last = ((Cons<Expr>)primary).getFirst();
              PureList<Expr> rest = ((Cons<Expr>)primary).getRest();
              Span span = FortressUtil.spanTwo(last, a2);
              Op op = NodeFactory.makeOp(createSpan(yyStart,yyCount), a1);
              return rest.cons(ASTUtil.infix(span, last, op, a2));
            }
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 5.

    yyResult = pExponentOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Op a1 = yyResult.semanticValue();

      yyValue = new Action<PureList<Expr>>() {
        public PureList<Expr> run(PureList<Expr> base) {
          PureList<Expr> primary = (PureList<Expr>)base;
          if (primary.isEmpty()) {
            return error(a1, "Exponentiation on an empty primary.");
          } else { // !primary.isEmpty()
            Expr last = ((Cons<Expr>)primary).getFirst();
            PureList<Expr> rest = ((Cons<Expr>)primary).getRest();
            Span span = FortressUtil.spanTwo(last, a1);
            return rest.cons(ASTUtil.postfix(span, last, a1));
          }
      }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('d' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('i' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('o' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('n' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('l' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('e' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('s' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyC = character(yyIndex);
                              if ('s' == yyC) {
                                yyIndex = yyIndex + 1;

                                yyValue = new Action<PureList<Expr>>() {
                                  public PureList<Expr> run(PureList<Expr> base) {
                                    Span span = createSpan(yyStart,yyCount);
                                    Expr val = FortressUtil.buildPrimary((PureList<Expr>)base);
                                    return PureList.make((Expr)new ProductUnitExpr(span,false,val,
                                    new BaseUnit(span)));
                                }};

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select("\"dimensionless\" expected", yyBase);
                              }
                            } else {
                              yyError = yyError.select("\"dimensionless\" expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("\"dimensionless\" expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("\"dimensionless\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"dimensionless\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"dimensionless\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"dimensionless\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"dimensionless\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"dimensionless\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"dimensionless\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"dimensionless\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"dimensionless\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"dimensionless\" expected", yyBase);
      }

      // Nested alternative 2.

      yyResult = pper(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression$UnitExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final UnitExpr a1 = yyResult.semanticValue();

            yyValue = new Action<PureList<Expr>>() {
              public PureList<Expr> run(PureList<Expr> base) {
                Span span = createSpan(yyStart,yyCount);
                Expr val = FortressUtil.buildPrimary((PureList<Expr>)base);
                return PureList.make((Expr)new QuotientUnitExpr(span,false,val,a1));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 3.

      yyResult = pin(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression$UnitExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final UnitExpr a1 = yyResult.semanticValue();

            yyValue = new Action<PureList<Expr>>() {
              public PureList<Expr> run(PureList<Expr> base) {
                Span span = createSpan(yyStart,yyCount);
                Expr val = FortressUtil.buildPrimary((PureList<Expr>)base);
                return PureList.make((Expr)new ChangeUnitExpr(span,false,val,a1));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 7.

    yyResult = p$$Shared26(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expr a1 = yyResult.semanticValue();

      yyValue = new Action<PureList<Expr>>() {
        public PureList<Expr> run(PureList<Expr> base) {
          return base.cons(a1);
      }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcloseparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = new Action<PureList<Expr>>() {
            public PureList<Expr> run(PureList<Expr> base) {
              return base.cons(ExprFactory.makeVoidLiteral(createSpan(yyStart,yyCount)));
          }};

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 9.

    yyResult = pExpression$Primary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final PureList<Expr> a1 = yyResult.semanticValue();

      yyValue = new Action<PureList<Expr>>() {
        public PureList<Expr> run(PureList<Expr> base) {
          return a1.append(base);
      }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared26.
   * This nonterminal represents the duplicate productions 
   * PreFortress.$$Shared10$$Choice1, Expression.TightJuxtaposition$$Choice1, 
   * NoNewlineExpr.TightJuxtaposition$$Choice1, 
   * and NoSpaceExpr.TightJuxtaposition$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared26(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTupleExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pParenthesized(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.UnitExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$UnitExpr(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fExpression$UnitExpr) 
      yyColumn.chunk10.fExpression$UnitExpr = pExpression$UnitExpr$1(yyStart);
    return yyColumn.chunk10.fExpression$UnitExpr;
  }

  /** Actually parse Expression.UnitExpr. */
  private Result pExpression$UnitExpr$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    UnitExpr   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$UnitExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      UnitExpr seed = yyResult.semanticValue();

      yyResult = pExpression$UnitExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<UnitExpr>> list = yyResult.semanticValue();

        yyValue = (UnitExpr)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Expression.UnitExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$UnitExpr$$Star1(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fExpression$UnitExpr$$Star1) 
      yyColumn.chunk10.fExpression$UnitExpr$$Star1 = pExpression$UnitExpr$$Star1$1(yyStart);
    return yyColumn.chunk10.fExpression$UnitExpr$$Star1;
  }

  /** Actually parse Expression.UnitExpr$$Star1. */
  private Result pExpression$UnitExpr$$Star1$1(final int yyStart) 
    throws IOException {

    Result                 yyResult;
    Pair<Action<UnitExpr>> yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$UnitExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<UnitExpr> v$el$1 = yyResult.semanticValue();

      yyResult = pExpression$UnitExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<UnitExpr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<UnitExpr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.UnitExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$UnitExprFront(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    UnitExpr   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('o' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('n' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('l' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('e' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('s' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('s' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyValue = new BaseUnit(createSpan(yyStart,yyCount));

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyValue = new UnitRef(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pone(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pslash(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$UnitExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              UnitExpr a1 = yyResult.semanticValue();

              yyValue = new QuotientUnit(createSpan(yyStart,yyCount),
              new BaseUnit(createSpan(yyStart,1)), a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$UnitExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          UnitExpr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 5.

    yyResult = pDUPreOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      DimUnitOp a1 = yyResult.semanticValue();

      yyResult = psr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$UnitExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          UnitExpr a2 = yyResult.semanticValue();

          yyValue = new OpUnit(createSpan(yyStart,yyCount), a2, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("unit expr front expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.UnitExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$UnitExprTail(final int yyStart) 
    throws IOException {

    Result           yyResult;
    Action<UnitExpr> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared24(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pExpression$UnitExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final UnitExpr a1 = yyResult.semanticValue();

        yyValue = new Action<UnitExpr>() {
          public UnitExpr run(UnitExpr base) {
            return new ProductUnit(createSpan(yyStart,yyCount),
            (UnitExpr)base, a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = p$$Shared25(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression$UnitExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final UnitExpr a1 = yyResult.semanticValue();

            yyValue = new Action<UnitExpr>() {
              public UnitExpr run(UnitExpr base) {
                return new QuotientUnit(createSpan(yyStart,yyCount),
                (UnitExpr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 3.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNumber(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final IntLiteral a1 = yyResult.semanticValue();

        yyValue = new Action<UnitExpr>() {
          public UnitExpr run(UnitExpr base) {
            return new ExponentUnit(createSpan(yyStart,yyCount),
            (UnitExpr)base, a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDUPostOp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final DimUnitOp a1 = yyResult.semanticValue();

        yyValue = new Action<UnitExpr>() {
          public UnitExpr run(UnitExpr base) {
            return new OpUnit(createSpan(yyStart,yyCount),(UnitExpr)base,a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.FlowExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$FlowExpr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        Id a1 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pwith(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExpression$Expr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
          }
        }
        { // Start scope for a2.
          Expr a2 = cast(yyOpValue1);

          Option<IdName> name = (a1 == null) ? Option.<IdName>none() :
          Option.some(NodeFactory.makeIdName(a1));
          Option<Expr> expr = Option.wrap(a2);
          yyValue = new Exit(createSpan(yyStart,yyCount), false, name, expr);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pAccumulator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popensquare(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$GeneratorList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Generator> v$el$3 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pclosesquare(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
            }
          }
        }
      }
      { // Start scope for a2.
        List<Generator> a2 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression$Expr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a3 = yyResult.semanticValue();

            if (a2 == null) a2 = Collections.<Generator>emptyList();
            yyValue = new Accumulator(createSpan(yyStart,yyCount), false,
            NodeFactory.makeOpr(a1), a2, a3);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Alternative 3.

    yyResult = patomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$AtomicBack(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = new AtomicExpr(createSpan(yyStart,yyCount), false, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyResult = ptryatomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$AtomicBack(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = new TryAtomicExpr(createSpan(yyStart,yyCount), false, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = pspawn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = new Spawn(createSpan(yyStart,yyCount), false, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 6.

    yyResult = pthrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = new Throw(createSpan(yyStart,yyCount), false, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.AtomicBack.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$AtomicBack(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fExpression$AtomicBack) 
      yyColumn.chunk10.fExpression$AtomicBack = pExpression$AtomicBack$1(yyStart);
    return yyColumn.chunk10.fExpression$AtomicBack;
  }

  /** Actually parse Expression.AtomicBack. */
  private Result pExpression$AtomicBack$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared19(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<LHS> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAssignOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Option<Opr> a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              yyValue = new Assignment(createSpan(yyStart,yyCount), false, a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pExpression$OpExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDelimitedExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.GeneratorList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$GeneratorList(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fExpression$GeneratorList) 
      yyColumn.chunk10.fExpression$GeneratorList = pExpression$GeneratorList$1(yyStart);
    return yyColumn.chunk10.fExpression$GeneratorList;
  }

  /** Actually parse Expression.GeneratorList. */
  private Result pExpression$GeneratorList$1(final int yyStart) 
    throws IOException {

    Result          yyResult;
    List<Generator> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$Generator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Generator a1 = yyResult.semanticValue();

      yyResult = pExpression$GeneratorList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Generator> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Expression.GeneratorList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$GeneratorList$$Star1(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fExpression$GeneratorList$$Star1) 
      yyColumn.chunk10.fExpression$GeneratorList$$Star1 = pExpression$GeneratorList$$Star1$1(yyStart);
    return yyColumn.chunk10.fExpression$GeneratorList$$Star1;
  }

  /** Actually parse Expression.GeneratorList$$Star1. */
  private Result pExpression$GeneratorList$$Star1$1(final int yyStart) 
    throws IOException {

    Result          yyResult;
    Pair<Generator> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression$Generator(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Generator v$el$1 = yyResult.semanticValue();

            yyResult = pExpression$GeneratorList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Generator> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Generator>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Generator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$Generator(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fExpression$Generator) 
      yyColumn.chunk10.fExpression$Generator = pExpression$Generator$1(yyStart);
    return yyColumn.chunk10.fExpression$Generator;
  }

  /** Actually parse Expression.Generator. */
  private Result pExpression$Generator$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Generator  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindIdOrBindIdTuple(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Id> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pleftarrow(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = ExprFactory.makeGenerator(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyValue = new Generator(createSpan(yyStart,yyCount),
      Collections.<IdName>emptyList(), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.DelimitedExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDelimitedExpr(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fDelimitedExpr) 
      yyColumn.chunk11.fDelimitedExpr = pDelimitedExpr$1(yyStart);
    return yyColumn.chunk11.fDelimitedExpr;
  }

  /** Actually parse DelimitedExpr.DelimitedExpr. */
  private Result pDelimitedExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTupleExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pParenthesized(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pobject(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendsWhere(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<TraitTypeWhere> v$el$4 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$4;
        }
      }
      { // Start scope for a1.
        List<TraitTypeWhere> a1 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pGoInAnObject(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Decl> v$el$5 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$5;
          }
        }
        { // Start scope for a2.
          List<Decl> a2 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pend(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              if (a1 == null) a1 = FortressUtil.emptyTraitTypeWheres();
              if (a2 == null) a2 = Collections.<Decl>emptyList();
              yyValue = new ObjectExpr(createSpan(yyStart,yyCount), false, a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a2.
      } // End scope for a1.
    }

    // Alternative <DO>.

    yyResult = pDo(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pfoo(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pbarrr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = a1;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 6.

    yyResult = plabel(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Block a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pend(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pId(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Id a3 = yyResult.semanticValue();

                      if (!a1.getText().equals(a3.getText()))
                      error(a1, "Mismatched identifiers for label expressions.");
                      yyValue = new Label(createSpan(yyStart,yyCount), false,
                      NodeFactory.makeIdName(a1), a2);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 7.

    yyResult = pwhile(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDo(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Do a2 = yyResult.semanticValue();

              yyValue = new While(createSpan(yyStart,yyCount), false, a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 8.

    yyResult = pfor(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$GeneratorList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Generator> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDoFront(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              DoFront a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pend(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = new For(createSpan(yyStart,yyCount), false, a1, a2);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Alternative 9.

    yyResult = pif(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pthen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pBlockElems(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Block a2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pElifs(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<IfClause> v$el$6 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$6;
                    }
                  }
                  { // Start scope for a3.
                    List<IfClause> a3 = cast(yyOpValue1);

                    yyOpValue1 = null;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pElse(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Block v$el$7 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = v$el$7;
                      }
                    }
                    { // Start scope for a4.
                      Block a4 = cast(yyOpValue1);

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pend(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          IfClause ic = new IfClause(FortressUtil.spanTwo(a1,a2), a1, a2);
                          List<IfClause> clauses = FortressUtil.mkList(ic);
                          if (a3 != null) clauses.addAll(a3);
                          Option<Block> elseC = Option.wrap(a4);
                          yyValue = new If(createSpan(yyStart,yyCount), false, clauses, elseC);

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    } // End scope for a4.
                  } // End scope for a3.
                }
              }
            }
          }
        }
      }
    }

    // Alternative 10.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pif(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pthen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pBlockElems(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Block a2 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pElifs(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          List<IfClause> v$el$8 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$8;
                        }
                      }
                      { // Start scope for a3.
                        List<IfClause> a3 = cast(yyOpValue1);

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pElse(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            Block a4 = yyResult.semanticValue();

                            yyOption1  = yyResult.index;

                            yyResult = pw(yyOption1);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pend(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyOption1  = yyResult.index;
                              }
                            }

                            yyResult = pw(yyOption1);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pcloseparen(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                IfClause ic = new IfClause(FortressUtil.spanTwo(a1,a2), a1, a2);
                                List<IfClause> clauses = FortressUtil.mkList(ic);
                                if (a3 != null) clauses.addAll(a3);
                                yyValue = new If(createSpan(yyStart,yyCount),false,clauses,
                                Option.some(a4));

                                return yyResult.createValue(yyValue, yyError);
                              }
                            }
                          }
                        }
                      } // End scope for a3.
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 11.

    yyResult = pcase(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$Expr(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pOp(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Op v$el$9 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$9;
            }
          }
          { // Start scope for a2.
            Op a2 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pof(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pCaseClauses(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<CaseClause> a3 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = null;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pCaseElse(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Block v$el$10 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = v$el$10;
                      }
                    }
                    { // Start scope for a4.
                      Block a4 = cast(yyOpValue1);

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pend(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          CaseParam e1 = new CaseParamExpr(a1.getSpan(), a1);
                          Option<Opr> compare;
                          if (a2 == null) compare = Option.none();
                          else            compare = Option.some(NodeFactory.makeOpr(a2));
                          if (a4 == null) a4 = FortressUtil.doBlock(FortressUtil.emptyExprs());
                          yyValue = new CaseExpr(createSpan(yyStart,yyCount), false, e1, compare,
                          a3, Option.some(a4));

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    } // End scope for a4.
                  }
                }
              }
            }
          } // End scope for a2.
        }

        // Nested alternative 2.

        yyResult = pDelimitedExpr$$Choice1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pOp(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Op v$el$13 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$13;
            }
          }
          { // Start scope for a2.
            Op a2 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pof(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pCaseClauses(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<CaseClause> a3 = yyResult.semanticValue();

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pend(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        CaseParam e1;
                        if (a1.equals("largest"))
                        e1 = new CaseParamLargest(createSpan(yyStart+5,7));
                        else // a1.equals("smallest")
                        e1 = new CaseParamSmallest(createSpan(yyStart+5,8));
                        Option<Opr> compare;
                        if (a2 == null) compare = Option.none();
                        else            compare = Option.some(NodeFactory.makeOpr(a2));
                        yyValue = new CaseExpr(createSpan(yyStart,yyCount), false, e1, compare,
                        a3, Option.some(FortressUtil.doBlock(FortressUtil.emptyExprs())));

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              }
            }
          } // End scope for a2.
        }
      }
    }

    // Alternative 12.

    yyResult = ptypecase(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTypecaseBindings(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Binding> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pof(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pTypecaseClauses(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<TypecaseClause> a2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pbr(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pCaseElse(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Block v$el$14 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$14;
                    }
                  }
                  { // Start scope for a3.
                    Block a3 = cast(yyOpValue1);

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pend(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        Option<Block> caseElse = Option.wrap(a3);
                        yyValue = new Typecase(createSpan(yyStart,yyCount), false, a1, a2, caseElse);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  } // End scope for a3.
                }
              }
            }
          }
        }
      }
    }

    // Alternative 13.

    yyResult = ptry(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBlockElems(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Block a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pCatch(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Catch v$el$15 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$15;
            }
          }
          { // Start scope for a2.
            Catch a2 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pforbid(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pTraitTypes(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<TraitType> v$el$16 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$16;
                  }
                }
              }
            }
            { // Start scope for a3.
              List<TraitType> a3 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pfinally(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pBlockElems(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Block v$el$17 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$17;
                    }
                  }
                }
              }
              { // Start scope for a4.
                Block a4 = cast(yyOpValue1);

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pend(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    Option<Catch> catch_ = Option.wrap(a2);
                    if (a3 == null) a3 = FortressUtil.emptyTraitTypes();
                    Option<Block> finally_ = Option.wrap(a4);
                    yyValue = new Try(createSpan(yyStart,yyCount), false, a1, catch_, a3,
                    finally_);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for a4.
            } // End scope for a3.
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.DelimitedExpr$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDelimitedExpr$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'l':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('r' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('g' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('e' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('s' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('t' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "largest";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("delimited expr expected", yyStart);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 's':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('m' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('a' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('l' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('l' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('e' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('s' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('t' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "smallest";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("delimited expr expected", yyStart);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("delimited expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Do.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDo(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fDo) yyColumn.chunk11.fDo = pDo$1(yyStart);
    return yyColumn.chunk11.fDo;
  }

  /** Actually parse DelimitedExpr.Do. */
  private Result pDo$1(final int yyStart) throws IOException {
    Result     yyResult;
    Do         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDo$$Star1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<DoFront> a1s = yyResult.semanticValue();

      yyResult = pDoFront(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        DoFront a2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pend(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Do(createSpan(yyStart, yyCount), false,
            FortressUtil.mkList(a1s.list(), a2));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.Do$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDo$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fDo$$Star1) 
      yyColumn.chunk11.fDo$$Star1 = pDo$$Star1$1(yyStart);
    return yyColumn.chunk11.fDo$$Star1;
  }

  /** Actually parse PreFortress.Do$$Star1. */
  private Result pDo$$Star1$1(final int yyStart) throws IOException {
    Result        yyResult;
    Pair<DoFront> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDoFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      DoFront v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = palso(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDo$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<DoFront> v$2 = yyResult.semanticValue();

              yyValue = new Pair<DoFront>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.DoFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDoFront(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fDoFront) 
      yyColumn.chunk11.fDoFront = pDoFront$1(yyStart);
    return yyColumn.chunk11.fDoFront;
  }

  /** Actually parse DelimitedExpr.DoFront. */
  private Result pDoFront$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    DoFront    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pat(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr v$el$1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        }
      }
    }
    { // Start scope for a1.
      Expr a1 = cast(yyOpValue1);

      yyOpValue1 = null;

      yyResult = patomic(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a2.
        String a2 = cast(yyOpValue1);

        yyResult = pdo(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Block v$el$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
          }
          { // Start scope for a3.
            Block a3 = cast(yyOpValue1);

            Option<Expr> at = Option.wrap(a1);
            boolean atomic = (a2 == null) ? false : true;
            if (a3 == null) a3 = FortressUtil.doBlock(FortressUtil.emptyExprs());
            yyValue = new DoFront(createSpan(yyStart,yyCount), at, atomic, a3);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }
      } // End scope for a2.
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.TupleExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTupleExpr(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fTupleExpr) 
      yyColumn.chunk11.fTupleExpr = pTupleExpr$1(yyStart);
    return yyColumn.chunk11.fTupleExpr;
  }

  /** Actually parse DelimitedExpr.TupleExpr. */
  private Result pTupleExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Expr       yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTupleExpr$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Expr> a1s = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pExpression$Expr(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr v$el$4 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcomma(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$4;
                    }
                  }
                }
              }
            }
          }
          { // Start scope for a2.
            Expr a2 = yyOpValue1;

            yyResult = pBinding(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Binding a3 = yyResult.semanticValue();

              yyResult = pTupleExpr$$Star2(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Pair<Binding> a4s = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    List<Expr> es = a1s.list();
                    Option<VarargsExpr> vs = ((a2 != null) ?
                    Option.some(new VarargsExpr(a2.getSpan(), a2)) :
                    Option.<VarargsExpr>none());
                    List<Binding> ks = new ArrayList<Binding>();
                    ks.add(a3);
                    for (Binding b : (List<Binding>)a4s.list()) {
                      ks.add(b);
                    }
                    yyValue = new TupleExpr(createSpan(yyStart,yyCount), false, es, vs, ks);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          } // End scope for a2.
        }
      }
    }

    // Alternative 2.

    yyResult = pNoKeyTuple(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.TupleExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTupleExpr$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fTupleExpr$$Star1) 
      yyColumn.chunk11.fTupleExpr$$Star1 = pTupleExpr$$Star1$1(yyStart);
    return yyColumn.chunk11.fTupleExpr$$Star1;
  }

  /** Actually parse PreFortress.TupleExpr$$Star1. */
  private Result pTupleExpr$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr v$el$2 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pTupleExpr$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Expr> v$3 = yyResult.semanticValue();

              yyValue = new Pair<Expr>(v$el$2, v$3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.TupleExpr$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTupleExpr$$Star2(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fTupleExpr$$Star2) 
      yyColumn.chunk11.fTupleExpr$$Star2 = pTupleExpr$$Star2$1(yyStart);
    return yyColumn.chunk11.fTupleExpr$$Star2;
  }

  /** Actually parse PreFortress.TupleExpr$$Star2. */
  private Result pTupleExpr$$Star2$1(final int yyStart) throws IOException {
    Result        yyResult;
    Pair<Binding> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBinding(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Binding v$el$5 = yyResult.semanticValue();

            yyResult = pTupleExpr$$Star2(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Binding> v$6 = yyResult.semanticValue();

              yyValue = new Pair<Binding>(v$el$5, v$6);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.NoKeyTuple.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoKeyTuple(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fNoKeyTuple) 
      yyColumn.chunk11.fNoKeyTuple = pNoKeyTuple$1(yyStart);
    return yyColumn.chunk11.fNoKeyTuple;
  }

  /** Actually parse DelimitedExpr.NoKeyTuple. */
  private Result pNoKeyTuple$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoKeyTuple$$Star1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Expr> a1s = yyResult.semanticValue();

          yyResult = pExpression$Expr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    Option<VarargsExpr> vs = Option.some(new VarargsExpr(a2.getSpan(), a2));
                    yyValue = new TupleExpr(createSpan(yyStart,yyCount), false, a1s.list(), vs);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }

        // Nested alternative 2.

        yyResult = pNoKeyTuple$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Expr> a1s = yyResult.semanticValue();

          yyResult = pExpression$Expr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                List<Expr> es = FortressUtil.mkList(a1s.list(), a2);
                yyValue = new TupleExpr(createSpan(yyStart,yyCount), false, es);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.NoKeyTuple$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoKeyTuple$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fNoKeyTuple$$Star1) 
      yyColumn.chunk11.fNoKeyTuple$$Star1 = pNoKeyTuple$$Star1$1(yyStart);
    return yyColumn.chunk11.fNoKeyTuple$$Star1;
  }

  /** Actually parse PreFortress.NoKeyTuple$$Star1. */
  private Result pNoKeyTuple$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoKeyTuple$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Expr> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Expr>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.NoKeyTuple$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoKeyTuple$$Plus1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fNoKeyTuple$$Plus1) 
      yyColumn.chunk11.fNoKeyTuple$$Plus1 = pNoKeyTuple$$Plus1$1(yyStart);
    return yyColumn.chunk11.fNoKeyTuple$$Plus1;
  }

  /** Actually parse PreFortress.NoKeyTuple$$Plus1. */
  private Result pNoKeyTuple$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr v$el$3 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pNoKeyTuple$$Plus1(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Expr> v$4 = yyResult.semanticValue();

              yyValue = new Pair<Expr>(v$el$3, v$4);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyValue = new Pair<Expr>(v$el$3);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Parenthesized.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParenthesized(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fParenthesized) 
      yyColumn.chunk12.fParenthesized = pParenthesized$1(yyStart);
    return yyColumn.chunk12.fParenthesized;
  }

  /** Actually parse DelimitedExpr.Parenthesized. */
  private Result pParenthesized$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = ExprFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Elifs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElifs(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fElifs) 
      yyColumn.chunk12.fElifs = pElifs$1(yyStart);
    return yyColumn.chunk12.fElifs;
  }

  /** Actually parse DelimitedExpr.Elifs. */
  private Result pElifs$1(final int yyStart) throws IOException {
    Result         yyResult;
    List<IfClause> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pElif(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IfClause a1 = yyResult.semanticValue();

      yyResult = pElifs$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<IfClause> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.Elifs$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElifs$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fElifs$$Star1) 
      yyColumn.chunk12.fElifs$$Star1 = pElifs$$Star1$1(yyStart);
    return yyColumn.chunk12.fElifs$$Star1;
  }

  /** Actually parse PreFortress.Elifs$$Star1. */
  private Result pElifs$$Star1$1(final int yyStart) throws IOException {
    Result         yyResult;
    Pair<IfClause> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pElif(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        IfClause v$el$1 = yyResult.semanticValue();

        yyResult = pElifs$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<IfClause> v$2 = yyResult.semanticValue();

          yyValue = new Pair<IfClause>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Elif.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElif(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fElif) 
      yyColumn.chunk12.fElif = pElif$1(yyStart);
    return yyColumn.chunk12.fElif;
  }

  /** Actually parse DelimitedExpr.Elif. */
  private Result pElif$1(final int yyStart) throws IOException {
    Result     yyResult;
    IfClause   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pelif(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pthen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pBlockElems(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Block a2 = yyResult.semanticValue();

                  yyValue = new IfClause(createSpan(yyStart,yyCount), a1, a2);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Else.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElse(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fElse) 
      yyColumn.chunk12.fElse = pElse$1(yyStart);
    return yyColumn.chunk12.fElse;
  }

  /** Actually parse DelimitedExpr.Else. */
  private Result pElse$1(final int yyStart) throws IOException {
    Result     yyResult;
    Block      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pelse(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBlockElems(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.CaseClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseClauses(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fCaseClauses) 
      yyColumn.chunk12.fCaseClauses = pCaseClauses$1(yyStart);
    return yyColumn.chunk12.fCaseClauses;
  }

  /** Actually parse DelimitedExpr.CaseClauses. */
  private Result pCaseClauses$1(final int yyStart) throws IOException {
    Result           yyResult;
    List<CaseClause> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCaseClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      CaseClause a1 = yyResult.semanticValue();

      yyResult = pCaseClauses$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<CaseClause> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.CaseClauses$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseClauses$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fCaseClauses$$Star1) 
      yyColumn.chunk12.fCaseClauses$$Star1 = pCaseClauses$$Star1$1(yyStart);
    return yyColumn.chunk12.fCaseClauses$$Star1;
  }

  /** Actually parse PreFortress.CaseClauses$$Star1. */
  private Result pCaseClauses$$Star1$1(final int yyStart) throws IOException {
    Result           yyResult;
    Pair<CaseClause> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pCaseClause(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        CaseClause v$el$1 = yyResult.semanticValue();

        yyResult = pCaseClauses$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<CaseClause> v$2 = yyResult.semanticValue();

          yyValue = new Pair<CaseClause>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.CaseElse.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseElse(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fCaseElse) 
      yyColumn.chunk12.fCaseElse = pCaseElse$1(yyStart);
    return yyColumn.chunk12.fCaseElse;
  }

  /** Actually parse DelimitedExpr.CaseElse. */
  private Result pCaseElse$1(final int yyStart) throws IOException {
    Result     yyResult;
    Block      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pelse(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmatch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              yyValue = yyResult.semanticValue();

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.TypecaseBindings.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypecaseBindings(final int yyStart) throws IOException {
    Result        yyResult;
    List<Binding> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBindingList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pBinding(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Binding a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(new Binding(createSpan(yyStart,yyCount),
      NodeFactory.makeIdName(a1),
      ExprFactory.makeVarRef(a1)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.BindingList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBindingList(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyRepetition1;
    Pair<Binding> yyRepValue1;
    List<Binding> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBinding(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Binding a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pBinding(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Binding v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Binding>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Binding> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Binding.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBinding(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fBinding) 
      yyColumn.chunk12.fBinding = pBinding$1(yyStart);
    return yyColumn.chunk12.fBinding;
  }

  /** Actually parse DelimitedExpr.Binding. */
  private Result pBinding$1(final int yyStart) throws IOException {
    Result     yyResult;
    Binding    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = new Binding(createSpan(yyStart,yyCount),
              NodeFactory.makeIdName(a1), a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.TypecaseClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypecaseClauses(final int yyStart) throws IOException {
    Result               yyResult;
    int                  yyRepetition1;
    Pair<TypecaseClause> yyRepValue1;
    List<TypecaseClause> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypecaseClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypecaseClause a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pbr(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pTypecaseClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            TypecaseClause v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<TypecaseClause>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<TypecaseClause> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.TypecaseClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypecaseClause(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fTypecaseClause) 
      yyColumn.chunk12.fTypecaseClause = pTypecaseClause$1(yyStart);
    return yyColumn.chunk12.fTypecaseClause;
  }

  /** Actually parse DelimitedExpr.TypecaseClause. */
  private Result pTypecaseClause$1(final int yyStart) throws IOException {
    Result         yyResult;
    TypecaseClause yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypecaseTypes(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Type> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmatch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Block a2 = yyResult.semanticValue();

              yyValue = new TypecaseClause(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.TypecaseTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypecaseTypes(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fTypecaseTypes) 
      yyColumn.chunk13.fTypecaseTypes = pTypecaseTypes$1(yyStart);
    return yyColumn.chunk13.fTypecaseTypes;
  }

  /** Actually parse DelimitedExpr.TypecaseTypes. */
  private Result pTypecaseTypes$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTypeList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Catch.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCatch(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fCatch) 
      yyColumn.chunk13.fCatch = pCatch$1(yyStart);
    return yyColumn.chunk13.fCatch;
  }

  /** Actually parse DelimitedExpr.Catch. */
  private Result pCatch$1(final int yyStart) throws IOException {
    Result     yyResult;
    Catch      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcatch(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBindId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pCatchClauses(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<CatchClause> a2 = yyResult.semanticValue();

              yyValue = new Catch(createSpan(yyStart,yyCount), NodeFactory.makeIdName(a1), a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.CatchClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCatchClauses(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<CatchClause> yyRepValue1;
    List<CatchClause> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCatchClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      CatchClause a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pbr(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pCatchClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            CatchClause v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<CatchClause>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<CatchClause> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.CatchClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCatchClause(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fCatchClause) 
      yyColumn.chunk13.fCatchClause = pCatchClause$1(yyStart);
    return yyColumn.chunk13.fCatchClause;
  }

  /** Actually parse DelimitedExpr.CatchClause. */
  private Result pCatchClause$1(final int yyStart) throws IOException {
    Result      yyResult;
    CatchClause yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitType a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmatch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Block a2 = yyResult.semanticValue();

              yyValue = new CatchClause(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Comprehension.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComprehension(final int yyStart) throws IOException {
    Result                         yyResult;
    int                            yyRepetition1;
    Pair<ArrayComprehensionClause> yyRepValue1;
    Comprehension                  yyValue;
    ParseError                     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$Expr(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pwr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pbar(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pwr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExpression$GeneratorList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Generator> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pclosecurly(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyValue = new SetComprehension(createSpan(yyStart,yyCount),false,a2,a1);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }

        // Nested alternative 2.

        yyResult = pEntry(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Entry a1 = yyResult.semanticValue();

          yyResult = pwr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pbar(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pwr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExpression$GeneratorList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Generator> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pclosecurly(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyValue = new MapComprehension(createSpan(yyStart,yyCount),false,a2,a1);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = popenangle(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pwr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pbar(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pwr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExpression$GeneratorList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Generator> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseangle(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyValue = new ListComprehension(createSpan(yyStart,yyCount),false,a2,a1);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 3.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pArrayComprehensionClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          ArrayComprehensionClause a1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pbr(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pArrayComprehensionClause(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                ArrayComprehensionClause v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = 
                  new Pair<ArrayComprehensionClause>(v$el$1, yyRepValue1);
                continue;
              }
            }
            break;
          }
          { // Start scope for a2s.
            Pair<ArrayComprehensionClause> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosesquare(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                List<ArrayComprehensionClause> clauses = FortressUtil.mkList(a1, a2s.list());
                yyValue = new ArrayComprehension(createSpan(yyStart,yyCount), false, clauses);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a2s.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.mapstoOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmapstoOp(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pmapstoOp$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if ('|' == yyC) {
        yyIndex = yyStart + 1;

        yyC = character(yyIndex);
        if ('-' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('>' == yyC) {
            yyIndex = yyIndex + 1;
            yyValue = "|->";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    } else {
      yyError = yyError.select("mapsto op expected", yyStart);
    }

    // Done.
    yyError = yyError.select("mapsto op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.mapstoOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmapstoOp$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pw(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              final int yyChoice1 = yyResult.index;

              // Nested alternative 1.

              yyResult = pw(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pmapsto(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }

              // Nested alternative 2.

              yyResult = pwr(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pbar(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }

              // Nested alternative 3.

              yyResult = pw(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                final int yyChoice2 = yyResult.index;

                // Nested alternative 1.

                yyResult = pclosecurly(yyChoice2);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }

                // Nested alternative 2.

                yyResult = pcomma(yyChoice2);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("mapsto op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Entry.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEntry(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fEntry) 
      yyColumn.chunk13.fEntry = pEntry$1(yyStart);
    return yyColumn.chunk13.fEntry;
  }

  /** Actually parse DelimitedExpr.Entry. */
  private Result pEntry$1(final int yyStart) throws IOException {
    Result     yyResult;
    Entry      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmapsto(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = new Entry(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.ArrayComprehensionLeft.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayComprehensionLeft(final int yyStart) 
    throws IOException {

    Result                                        yyResult;
    com.sun.fortress.useful.Pair<List<Expr>,Expr> yyValue;
    ParseError                                    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdOrInt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmapsto(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              List<Expr> exprs = FortressUtil.mkList(a1);
              yyValue = new com.sun.fortress.useful.Pair<List<Expr>,Expr>(exprs, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdOrInt(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcomma(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pIdOrIntList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Expr> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pmapsto(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pExpression$Expr(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              Expr a3 = yyResult.semanticValue();

                              List<Expr> exprs = FortressUtil.mkList(a1);
                              for (Expr i : a2) {
                                exprs.add(i);
                              }
                              yyValue = new com.sun.fortress.useful.Pair<List<Expr>,Expr>(exprs, a3);

                              return yyResult.createValue(yyValue, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.IdOrInt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdOrInt(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fIdOrInt) 
      yyColumn.chunk13.fIdOrInt = pIdOrInt$1(yyStart);
    return yyColumn.chunk13.fIdOrInt;
  }

  /** Actually parse DelimitedExpr.IdOrInt. */
  private Result pIdOrInt$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeVarRef(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIntLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.IdOrIntList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdOrIntList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Expr> yyRepValue1;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdOrInt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pIdOrInt(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Expr>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Expr> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.BaseExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBaseExpr(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fBaseExpr) 
      yyColumn.chunk13.fBaseExpr = pBaseExpr$1(yyStart);
    return yyColumn.chunk13.fBaseExpr;
  }

  /** Actually parse DelimitedExpr.BaseExpr. */
  private Result pBaseExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoKeyTuple(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pParenthesized(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pAggregate(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyValue = new VarRef(createSpan(yyStart,yyCount), false, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pself(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeVarRef(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.ExprList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprList(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fExprList) 
      yyColumn.chunk13.fExprList = pExprList$1(yyStart);
    return yyColumn.chunk13.fExprList;
  }

  /** Actually parse DelimitedExpr.ExprList. */
  private Result pExprList$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pExprList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Expr> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.ExprList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprList$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fExprList$$Star1) 
      yyColumn.chunk13.fExprList$$Star1 = pExprList$$Star1$1(yyStart);
    return yyColumn.chunk13.fExprList$$Star1;
  }

  /** Actually parse PreFortress.ExprList$$Star1. */
  private Result pExprList$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression$Expr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr v$el$1 = yyResult.semanticValue();

            yyResult = pExprList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Expr> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Expr>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.Expr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$Expr(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fNoNewlineExpr$Expr) 
      yyColumn.chunk13.fNoNewlineExpr$Expr = pNoNewlineExpr$Expr$1(yyStart);
    return yyColumn.chunk13.fNoNewlineExpr$Expr;
  }

  /** Actually parse NoNewlineExpr.Expr. */
  private Result pNoNewlineExpr$Expr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$ExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr seed = yyResult.semanticValue();

      yyResult = pNoNewlineExpr$Expr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> list = yyResult.semanticValue();

        yyValue = (Expr)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal NoNewlineExpr.Expr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$Expr$$Star1(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fNoNewlineExpr$Expr$$Star1) 
      yyColumn.chunk13.fNoNewlineExpr$Expr$$Star1 = pNoNewlineExpr$Expr$$Star1$1(yyStart);
    return yyColumn.chunk13.fNoNewlineExpr$Expr$$Star1;
  }

  /** Actually parse NoNewlineExpr.Expr$$Star1. */
  private Result pNoNewlineExpr$Expr$$Star1$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    Pair<Action<Expr>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$ExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Expr> v$el$1 = yyResult.semanticValue();

      yyResult = pNoNewlineExpr$Expr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.ExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$ExprFront(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Assign>.

    yyResult = p$$Shared19(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<LHS> a1 = yyResult.semanticValue();

      yyResult = ps(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAssignOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Option<Opr> a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              yyValue = new Assignment(createSpan(yyStart,yyCount), false, a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr$OpExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDelimitedExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Flow>.

    yyResult = pNoNewlineExpr$FlowExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Fn>.

    yyResult = pfn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pParameter$ValParam(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIsType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type v$el$4 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$4;
            }
          }
          { // Start scope for a2.
            Type a2 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pThrows(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<TraitType> v$el$5 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$5;
              }
            }
            { // Start scope for a3.
              List<TraitType> a3 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pmatch(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pNoNewlineExpr$Expr(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Expr a4 = yyResult.semanticValue();

                      Option<Type> ty_opt = Option.wrap(a2);
                      Option<List<TraitType>> tys = Option.wrap(a3);
                      yyValue = ExprFactory.makeFnExpr(createSpan(yyStart,yyCount), a1, ty_opt,
                      tys, a4);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            } // End scope for a3.
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.ExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$ExprTail(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Expr> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pas(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Type a1 = yyResult.semanticValue();

            yyValue = new Action<Expr>() {
              public Expr run(Expr base) {
                return new AsExpr(createSpan(yyStart,yyCount), false, (Expr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pasif(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Type a1 = yyResult.semanticValue();

            yyValue = new Action<Expr>() {
              public Expr run(Expr base) {
                return new AsIfExpr(createSpan(yyStart,yyCount), false, (Expr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.OpExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$OpExpr(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fNoNewlineExpr$OpExpr) 
      yyColumn.chunk14.fNoNewlineExpr$OpExpr = pNoNewlineExpr$OpExpr$1(yyStart);
    return yyColumn.chunk14.fNoNewlineExpr$OpExpr;
  }

  /** Actually parse NoNewlineExpr.OpExpr. */
  private Result pNoNewlineExpr$OpExpr$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$OpExprNoEnc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      yyValue = Resolver.resolveOps(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      yyValue = Resolver.resolveOps(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      PrecedenceOpExpr e =
      new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
      yyValue = Resolver.resolveOps(PureList.make(e));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.OpExprNoEnc.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$OpExprNoEnc(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fNoNewlineExpr$OpExprNoEnc) 
      yyColumn.chunk14.fNoNewlineExpr$OpExprNoEnc = pNoNewlineExpr$OpExprNoEnc$1(yyStart);
    return yyColumn.chunk14.fNoNewlineExpr$OpExprNoEnc;
  }

  /** Actually parse NoNewlineExpr.OpExprNoEnc. */
  private Result pNoNewlineExpr$OpExprNoEnc$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$OpExprPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr$OpExprPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
      yyValue = PureList.make(e);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.TightInfixRight.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$TightInfixRight(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = psr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$LooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$LeftLooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 4.

      yyValue = PureList.make((PrecedenceOpExpr)new Right(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.LeftLooseInfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$LeftLooseInfix(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fNoNewlineExpr$LeftLooseInfix) 
      yyColumn.chunk14.fNoNewlineExpr$LeftLooseInfix = pNoNewlineExpr$LeftLooseInfix$1(yyStart);
    return yyColumn.chunk14.fNoNewlineExpr$LeftLooseInfix;
  }

  /** Actually parse NoNewlineExpr.LeftLooseInfix. */
  private Result pNoNewlineExpr$LeftLooseInfix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = psr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.OpExprLeftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$OpExprLeftEncloser(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fNoNewlineExpr$OpExprLeftEncloser) 
      yyColumn.chunk14.fNoNewlineExpr$OpExprLeftEncloser = pNoNewlineExpr$OpExprLeftEncloser$1(yyStart);
    return yyColumn.chunk14.fNoNewlineExpr$OpExprLeftEncloser;
  }

  /** Actually parse NoNewlineExpr.OpExprLeftEncloser. */
  private Result pNoNewlineExpr$OpExprLeftEncloser$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pNoNewlineExpr$OpExprNoEnc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new Left(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.OpExprPrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$OpExprPrimary(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fNoNewlineExpr$OpExprPrimary) 
      yyColumn.chunk14.fNoNewlineExpr$OpExprPrimary = pNoNewlineExpr$OpExprPrimary$1(yyStart);
    return yyColumn.chunk14.fNoNewlineExpr$OpExprPrimary;
  }

  /** Actually parse NoNewlineExpr.OpExprPrimary. */
  private Result pNoNewlineExpr$OpExprPrimary$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$Primary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<Expr> a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineExpr$TightInfixPostfix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoNewlineExpr$TightInfixRight(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = psr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$LooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$LeftLooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 4.

      yyValue =
      PureList.make((PrecedenceOpExpr)new RealExpr(FortressUtil.buildPrimary(a1)));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.OpExprPrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$OpExprPrefix(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fNoNewlineExpr$OpExprPrefix) 
      yyColumn.chunk14.fNoNewlineExpr$OpExprPrefix = pNoNewlineExpr$OpExprPrefix$1(yyStart);
    return yyColumn.chunk14.fNoNewlineExpr$OpExprPrefix;
  }

  /** Actually parse NoNewlineExpr.OpExprPrefix. */
  private Result pNoNewlineExpr$OpExprPrefix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new Prefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new Prefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new Prefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = psr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Prefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Prefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Prefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.TightInfixPostfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$TightInfixPostfix(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = psr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 5.

      yyValue = PureList.make((PrecedenceOpExpr)new Postfix(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.LooseInfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$LooseInfix(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fNoNewlineExpr$LooseInfix) 
      yyColumn.chunk14.fNoNewlineExpr$LooseInfix = pNoNewlineExpr$LooseInfix$1(yyStart);
    return yyColumn.chunk14.fNoNewlineExpr$LooseInfix;
  }

  /** Actually parse NoNewlineExpr.LooseInfix. */
  private Result pNoNewlineExpr$LooseInfix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyResult = psr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.Primary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$Primary(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fNoNewlineExpr$Primary) 
      yyColumn.chunk14.fNoNewlineExpr$Primary = pNoNewlineExpr$Primary$1(yyStart);
    return yyColumn.chunk14.fNoNewlineExpr$Primary;
  }

  /** Actually parse NoNewlineExpr.Primary. */
  private Result pNoNewlineExpr$Primary$1(final int yyStart) 
    throws IOException {

    Result         yyResult;
    PureList<Expr> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expr seed = yyResult.semanticValue();

      yyResult = pNoNewlineExpr$Primary$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<PureList<Expr>>> list = yyResult.semanticValue();

        yyValue = (PureList<Expr>)apply(list, PureList.make(seed));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal NoNewlineExpr.Primary$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$Primary$$Star1(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fNoNewlineExpr$Primary$$Star1) 
      yyColumn.chunk14.fNoNewlineExpr$Primary$$Star1 = pNoNewlineExpr$Primary$$Star1$1(yyStart);
    return yyColumn.chunk14.fNoNewlineExpr$Primary$$Star1;
  }

  /** Actually parse NoNewlineExpr.Primary$$Star1. */
  private Result pNoNewlineExpr$Primary$$Star1$1(final int yyStart) 
    throws IOException {

    Result                       yyResult;
    Pair<Action<PureList<Expr>>> yyValue;
    ParseError                   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$PrimaryTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Action<PureList<Expr>> v$el$1 = yyResult.semanticValue();

      yyResult = pNoNewlineExpr$Primary$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<PureList<Expr>>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<PureList<Expr>>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.PrimaryTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$PrimaryTail(final int yyStart) 
    throws IOException {

    int                    yyC;
    int                    yyIndex;
    Result                 yyResult;
    int                    yyBase;
    int                    yyOption1;
    Object                 yyOpValue1;
    Action<PureList<Expr>> yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExprList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<Expr> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        final List<Expr> a2 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pclosesquare(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final String a3 = yyResult.semanticValue();

            yyValue = new Action<PureList<Expr>>() {
              public PureList<Expr> run(PureList<Expr> base) {
                Span span = createSpan(yyStart,yyCount);
                Expr arr = FortressUtil.buildPrimary((PureList<Expr>)base);
                List<Expr> es;
                if (a2 == null) es = FortressUtil.emptyExprs();
                else            es = a2;
                Op open  = NodeFactory.makeOp(createSpan(yyStart, yyStart+1), a1);
                Op close = NodeFactory.makeOp(createSpan(yyCount-1,1),a3);
                SubscriptOp op = new SubscriptOp(span, open, close);
                return PureList.make((Expr)ExprFactory.makeSubscriptExpr(span, arr, es, Option.some(op)));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExprList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<Expr> v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a2.
        final List<Expr> a2 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pRightEncloser(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Op a3 = yyResult.semanticValue();

            yyValue = new Action<PureList<Expr>>() {
              public PureList<Expr> run(PureList<Expr> base) {
                Span span = createSpan(yyStart,yyCount);
                Expr arr = FortressUtil.buildPrimary((PureList<Expr>)base);
                List<Expr> es;
                if (a2 == null) es = FortressUtil.emptyExprs();
                else            es = a2;
                SubscriptOp op = new SubscriptOp(FortressUtil.spanTwo(a1,a3), a1, a3);
                return PureList.make((Expr)new SubscriptExpr(span, false, arr, es,
                Option.some(op)));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Alternative 3.

    yyResult = pdot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Id a1 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = popendoublesquare(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticArgList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final List<StaticArg> v$el$1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pclosedoublesquare(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
            }
          }
        }
        { // Start scope for a2.
          final List<StaticArg> a2 = cast(yyOpValue1);

          final int yyChoice2 = yyOption1;

          // Nested alternative 1.

          yyResult = p$$Shared26(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expr a3 = yyResult.semanticValue();

            yyValue = new Action<PureList<Expr>>() {
              public PureList<Expr> run(PureList<Expr> base) {
                Expr rcv = FortressUtil.buildPrimary((PureList<Expr>)base);
                List<StaticArg> sargs;
                if (a2 == null) sargs = Collections.<StaticArg>emptyList();
                else            sargs = a2;
                Expr inv = new MethodInvocation(FortressUtil.spanTwo(rcv,a3),
                false, rcv, NodeFactory.makeIdName(a1),
                sargs, a3);
                return PureList.make(inv);
            }};

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyResult = popenparen(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = new Action<PureList<Expr>>() {
                  public PureList<Expr> run(PureList<Expr> base) {
                    Expr arg = ExprFactory.makeVoidLiteral(a1.getSpan());
                    Expr rcv = FortressUtil.buildPrimary((PureList<Expr>)base);
                    List<StaticArg> sargs;
                    if (a2 == null) sargs = Collections.<StaticArg>emptyList();
                    else            sargs = a2;
                    Expr inv = new MethodInvocation(createSpan(yyStart,yyCount),
                    false, rcv, NodeFactory.makeIdName(a1),
                    sargs, arg);
                    return PureList.make(inv);
                }};

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        } // End scope for a2.

        // Nested alternative 2.

        yyValue = new Action<PureList<Expr>>() {
          public PureList<Expr> run(PureList<Expr> base) {
            Span span = createSpan(yyStart,yyCount);
            Expr rcv = FortressUtil.buildPrimary((PureList<Expr>)base);
            return PureList.make((Expr)new FieldRef(span,false,rcv,
            NodeFactory.makeIdName(a1)));
        }};

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Alternative 4.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String a1 = yyResult.semanticValue();

      yyResult = pBaseExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expr a2 = yyResult.semanticValue();

        yyValue = new Action<PureList<Expr>>() {
          public PureList<Expr> run(PureList<Expr> base) {
            PureList<Expr> primary = (PureList<Expr>)base;
            if (primary.isEmpty()) {
              return error(a2, "Exponentiation on an empty primary.");
            } else { // !primary.isEmpty()
              Expr last = ((Cons<Expr>)primary).getFirst();
              PureList<Expr> rest = ((Cons<Expr>)primary).getRest();
              Span span = FortressUtil.spanTwo(last, a2);
              Op op = NodeFactory.makeOp(createSpan(yyStart,yyCount), a1);
              return rest.cons(ASTUtil.infix(span, last, op, a2));
            }
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 5.

    yyResult = pExponentOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Op a1 = yyResult.semanticValue();

      yyValue = new Action<PureList<Expr>>() {
        public PureList<Expr> run(PureList<Expr> base) {
          PureList<Expr> primary = (PureList<Expr>)base;
          if (primary.isEmpty()) {
            return error(a1, "Exponentiation on an empty primary.");
          } else { // !primary.isEmpty()
            Expr last = ((Cons<Expr>)primary).getFirst();
            PureList<Expr> rest = ((Cons<Expr>)primary).getRest();
            Span span = FortressUtil.spanTwo(last, a1);
            return rest.cons(ASTUtil.postfix(span, last, a1));
          }
      }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('d' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('i' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('o' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('n' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('l' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('e' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('s' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyC = character(yyIndex);
                              if ('s' == yyC) {
                                yyIndex = yyIndex + 1;

                                yyValue = new Action<PureList<Expr>>() {
                                  public PureList<Expr> run(PureList<Expr> base) {
                                    Span span = createSpan(yyStart,yyCount);
                                    Expr val = FortressUtil.buildPrimary((PureList<Expr>)base);
                                    return PureList.make((Expr)new ProductUnitExpr(span,false,val,
                                    new BaseUnit(span)));
                                }};

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select("\"dimensionless\" expected", yyBase);
                              }
                            } else {
                              yyError = yyError.select("\"dimensionless\" expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("\"dimensionless\" expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("\"dimensionless\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"dimensionless\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"dimensionless\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"dimensionless\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"dimensionless\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"dimensionless\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"dimensionless\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"dimensionless\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"dimensionless\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"dimensionless\" expected", yyBase);
      }

      // Nested alternative 2.

      yyResult = pper(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineExpr$UnitExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final UnitExpr a1 = yyResult.semanticValue();

            yyValue = new Action<PureList<Expr>>() {
              public PureList<Expr> run(PureList<Expr> base) {
                Span span = createSpan(yyStart,yyCount);
                Expr val = FortressUtil.buildPrimary((PureList<Expr>)base);
                return PureList.make((Expr)new QuotientUnitExpr(span,false,val,a1));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 3.

      yyResult = pin(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineExpr$UnitExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final UnitExpr a1 = yyResult.semanticValue();

            yyValue = new Action<PureList<Expr>>() {
              public PureList<Expr> run(PureList<Expr> base) {
                Span span = createSpan(yyStart,yyCount);
                Expr val = FortressUtil.buildPrimary((PureList<Expr>)base);
                return PureList.make((Expr)new ChangeUnitExpr(span,false,val,a1));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 7.

    yyResult = p$$Shared26(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expr a1 = yyResult.semanticValue();

      yyValue = new Action<PureList<Expr>>() {
        public PureList<Expr> run(PureList<Expr> base) {
          return base.cons(a1);
      }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcloseparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = new Action<PureList<Expr>>() {
            public PureList<Expr> run(PureList<Expr> base) {
              return base.cons(ExprFactory.makeVoidLiteral(createSpan(yyStart,yyCount)));
          }};

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 9.

    yyResult = pNoNewlineExpr$Primary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final PureList<Expr> a1 = yyResult.semanticValue();

      yyValue = new Action<PureList<Expr>>() {
        public PureList<Expr> run(PureList<Expr> base) {
          return a1.append(base);
      }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.UnitExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$UnitExpr(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fNoNewlineExpr$UnitExpr) 
      yyColumn.chunk14.fNoNewlineExpr$UnitExpr = pNoNewlineExpr$UnitExpr$1(yyStart);
    return yyColumn.chunk14.fNoNewlineExpr$UnitExpr;
  }

  /** Actually parse NoNewlineExpr.UnitExpr. */
  private Result pNoNewlineExpr$UnitExpr$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    UnitExpr   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$UnitExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      UnitExpr seed = yyResult.semanticValue();

      yyResult = pNoNewlineExpr$UnitExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<UnitExpr>> list = yyResult.semanticValue();

        yyValue = (UnitExpr)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal NoNewlineExpr.UnitExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$UnitExpr$$Star1(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fNoNewlineExpr$UnitExpr$$Star1) 
      yyColumn.chunk15.fNoNewlineExpr$UnitExpr$$Star1 = pNoNewlineExpr$UnitExpr$$Star1$1(yyStart);
    return yyColumn.chunk15.fNoNewlineExpr$UnitExpr$$Star1;
  }

  /** Actually parse NoNewlineExpr.UnitExpr$$Star1. */
  private Result pNoNewlineExpr$UnitExpr$$Star1$1(final int yyStart) 
    throws IOException {

    Result                 yyResult;
    Pair<Action<UnitExpr>> yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$UnitExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<UnitExpr> v$el$1 = yyResult.semanticValue();

      yyResult = pNoNewlineExpr$UnitExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<UnitExpr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<UnitExpr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.UnitExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$UnitExprFront(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    UnitExpr   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('o' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('n' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('l' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('e' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('s' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('s' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyValue = new BaseUnit(createSpan(yyStart,yyCount));

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyValue = new UnitRef(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pone(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pslash(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr$UnitExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              UnitExpr a1 = yyResult.semanticValue();

              yyValue = new QuotientUnit(createSpan(yyStart,yyCount),
              new BaseUnit(createSpan(yyStart,1)), a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$UnitExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          UnitExpr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 5.

    yyResult = pDUPreOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      DimUnitOp a1 = yyResult.semanticValue();

      yyResult = psr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$UnitExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          UnitExpr a2 = yyResult.semanticValue();

          yyValue = new OpUnit(createSpan(yyStart,yyCount), a2, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("unit expr front expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.UnitExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$UnitExprTail(final int yyStart) 
    throws IOException {

    Result           yyResult;
    Action<UnitExpr> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared24(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNoNewlineExpr$UnitExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final UnitExpr a1 = yyResult.semanticValue();

        yyValue = new Action<UnitExpr>() {
          public UnitExpr run(UnitExpr base) {
            return new ProductUnit(createSpan(yyStart,yyCount),
            (UnitExpr)base, a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = p$$Shared25(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineExpr$UnitExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final UnitExpr a1 = yyResult.semanticValue();

            yyValue = new Action<UnitExpr>() {
              public UnitExpr run(UnitExpr base) {
                return new QuotientUnit(createSpan(yyStart,yyCount),
                (UnitExpr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 3.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNumber(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final IntLiteral a1 = yyResult.semanticValue();

        yyValue = new Action<UnitExpr>() {
          public UnitExpr run(UnitExpr base) {
            return new ExponentUnit(createSpan(yyStart,yyCount),
            (UnitExpr)base, a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDUPostOp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final DimUnitOp a1 = yyResult.semanticValue();

        yyValue = new Action<UnitExpr>() {
          public UnitExpr run(UnitExpr base) {
            return new OpUnit(createSpan(yyStart,yyCount),(UnitExpr)base,a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.FlowExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$FlowExpr(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        Id a1 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pwith(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineExpr$Expr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
          }
        }
        { // Start scope for a2.
          Expr a2 = cast(yyOpValue1);

          Option<IdName> name = (a1 == null) ? Option.<IdName>none() :
          Option.some(NodeFactory.makeIdName(a1));
          Option<Expr> expr = Option.wrap(a2);
          yyValue = new Exit(createSpan(yyStart,yyCount), false, name, expr);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pAccumulator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popensquare(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr$GeneratorList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Generator> v$el$3 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pclosesquare(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
            }
          }
        }
      }
      { // Start scope for a2.
        List<Generator> a2 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineExpr$Expr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a3 = yyResult.semanticValue();

            if (a2 == null) a2 = Collections.<Generator>emptyList();
            yyValue = new Accumulator(createSpan(yyStart,yyCount), false,
            NodeFactory.makeOpr(a1), a2, a3);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Alternative 3.

    yyResult = patomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$AtomicBack(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = new AtomicExpr(createSpan(yyStart,yyCount), false, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyResult = ptryatomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$AtomicBack(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = new TryAtomicExpr(createSpan(yyStart,yyCount), false, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = pspawn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = new Spawn(createSpan(yyStart,yyCount), false, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 6.

    yyResult = pthrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = new Throw(createSpan(yyStart,yyCount), false, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.AtomicBack.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$AtomicBack(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fNoNewlineExpr$AtomicBack) 
      yyColumn.chunk15.fNoNewlineExpr$AtomicBack = pNoNewlineExpr$AtomicBack$1(yyStart);
    return yyColumn.chunk15.fNoNewlineExpr$AtomicBack;
  }

  /** Actually parse NoNewlineExpr.AtomicBack. */
  private Result pNoNewlineExpr$AtomicBack$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared19(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<LHS> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAssignOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Option<Opr> a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              yyValue = new Assignment(createSpan(yyStart,yyCount), false, a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr$OpExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDelimitedExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.GeneratorList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$GeneratorList(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fNoNewlineExpr$GeneratorList) 
      yyColumn.chunk15.fNoNewlineExpr$GeneratorList = pNoNewlineExpr$GeneratorList$1(yyStart);
    return yyColumn.chunk15.fNoNewlineExpr$GeneratorList;
  }

  /** Actually parse NoNewlineExpr.GeneratorList. */
  private Result pNoNewlineExpr$GeneratorList$1(final int yyStart) 
    throws IOException {

    Result          yyResult;
    List<Generator> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$Generator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Generator a1 = yyResult.semanticValue();

      yyResult = pNoNewlineExpr$GeneratorList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Generator> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal NoNewlineExpr.GeneratorList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$GeneratorList$$Star1(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fNoNewlineExpr$GeneratorList$$Star1) 
      yyColumn.chunk15.fNoNewlineExpr$GeneratorList$$Star1 = pNoNewlineExpr$GeneratorList$$Star1$1(yyStart);
    return yyColumn.chunk15.fNoNewlineExpr$GeneratorList$$Star1;
  }

  /** Actually parse NoNewlineExpr.GeneratorList$$Star1. */
  private Result pNoNewlineExpr$GeneratorList$$Star1$1(final int yyStart) 
    throws IOException {

    Result          yyResult;
    Pair<Generator> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineExpr$Generator(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Generator v$el$1 = yyResult.semanticValue();

            yyResult = pNoNewlineExpr$GeneratorList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Generator> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Generator>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.Generator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$Generator(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fNoNewlineExpr$Generator) 
      yyColumn.chunk15.fNoNewlineExpr$Generator = pNoNewlineExpr$Generator$1(yyStart);
    return yyColumn.chunk15.fNoNewlineExpr$Generator;
  }

  /** Actually parse NoNewlineExpr.Generator. */
  private Result pNoNewlineExpr$Generator$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Generator  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindIdOrBindIdTuple(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Id> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pleftarrow(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = ExprFactory.makeGenerator(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyValue = new Generator(createSpan(yyStart,yyCount),
      Collections.<IdName>emptyList(), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.NoNewlineExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fNoNewlineExpr) 
      yyColumn.chunk15.fNoNewlineExpr = pNoNewlineExpr$1(yyStart);
    return yyColumn.chunk15.fNoNewlineExpr;
  }

  /** Actually parse NoNewlineExpr.NoNewlineExpr. */
  private Result pNoNewlineExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.Expr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$Expr(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Expr>> yyRepValue1;
    Expr               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr$ExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = p$$Shared16(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Action<Expr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Expr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for list.
        Pair<Action<Expr>> list = yyRepValue1.reverse();

        yyValue = (Expr)apply(list, seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for list.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.ExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$ExprFront(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fNoSpaceExpr$ExprFront) 
      yyColumn.chunk15.fNoSpaceExpr$ExprFront = pNoSpaceExpr$ExprFront$1(yyStart);
    return yyColumn.chunk15.fNoSpaceExpr$ExprFront;
  }

  /** Actually parse NoSpaceExpr.ExprFront. */
  private Result pNoSpaceExpr$ExprFront$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Assign>.

    yyResult = p$$Shared19(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<LHS> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAssignOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Option<Opr> a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoSpaceExpr$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              yyValue = new Assignment(createSpan(yyStart,yyCount),false, a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pNoSpaceExpr$OpExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDelimitedExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.OpExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$OpExpr(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr$OpExprNoEnc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      yyValue = Resolver.resolveOps(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoSpaceExpr$OpExprLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      yyValue = Resolver.resolveOps(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      PrecedenceOpExpr e =
      new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
      yyValue = Resolver.resolveOps(PureList.make(e));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.OpExprNoEnc.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$OpExprNoEnc(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fNoSpaceExpr$OpExprNoEnc) 
      yyColumn.chunk15.fNoSpaceExpr$OpExprNoEnc = pNoSpaceExpr$OpExprNoEnc$1(yyStart);
    return yyColumn.chunk15.fNoSpaceExpr$OpExprNoEnc;
  }

  /** Actually parse NoSpaceExpr.OpExprNoEnc. */
  private Result pNoSpaceExpr$OpExprNoEnc$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr$OpExprPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoSpaceExpr$OpExprPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
      yyValue = PureList.make(e);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.TightInfixRight.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$TightInfixRight(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoSpaceExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoSpaceExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyValue = PureList.make((PrecedenceOpExpr)new Right(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.OpExprLeftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$OpExprLeftEncloser(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fNoSpaceExpr$OpExprLeftEncloser) 
      yyColumn.chunk15.fNoSpaceExpr$OpExprLeftEncloser = pNoSpaceExpr$OpExprLeftEncloser$1(yyStart);
    return yyColumn.chunk15.fNoSpaceExpr$OpExprLeftEncloser;
  }

  /** Actually parse NoSpaceExpr.OpExprLeftEncloser. */
  private Result pNoSpaceExpr$OpExprLeftEncloser$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pNoSpaceExpr$OpExprNoEnc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new Left(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.OpExprPrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$OpExprPrimary(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fNoSpaceExpr$OpExprPrimary) 
      yyColumn.chunk15.fNoSpaceExpr$OpExprPrimary = pNoSpaceExpr$OpExprPrimary$1(yyStart);
    return yyColumn.chunk15.fNoSpaceExpr$OpExprPrimary;
  }

  /** Actually parse NoSpaceExpr.OpExprPrimary. */
  private Result pNoSpaceExpr$OpExprPrimary$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr$Primary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<Expr> a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoSpaceExpr$TightInfixPostfix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoSpaceExpr$TightInfixRight(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyValue =
      PureList.make((PrecedenceOpExpr)new RealExpr(FortressUtil.buildPrimary(a1)));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.OpExprPrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$OpExprPrefix(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fNoSpaceExpr$OpExprPrefix) 
      yyColumn.chunk16.fNoSpaceExpr$OpExprPrefix = pNoSpaceExpr$OpExprPrefix$1(yyStart);
    return yyColumn.chunk16.fNoSpaceExpr$OpExprPrefix;
  }

  /** Actually parse NoSpaceExpr.OpExprPrefix. */
  private Result pNoSpaceExpr$OpExprPrefix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoSpaceExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new Prefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoSpaceExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new Prefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pNoSpaceExpr$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new Prefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.TightInfixPostfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$TightInfixPostfix(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoSpaceExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoSpaceExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pNoSpaceExpr$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyValue = PureList.make((PrecedenceOpExpr)new Postfix(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.Primary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$Primary(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fNoSpaceExpr$Primary) 
      yyColumn.chunk16.fNoSpaceExpr$Primary = pNoSpaceExpr$Primary$1(yyStart);
    return yyColumn.chunk16.fNoSpaceExpr$Primary;
  }

  /** Actually parse NoSpaceExpr.Primary. */
  private Result pNoSpaceExpr$Primary$1(final int yyStart) 
    throws IOException {

    Result         yyResult;
    PureList<Expr> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expr seed = yyResult.semanticValue();

      yyResult = pNoSpaceExpr$Primary$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<PureList<Expr>>> list = yyResult.semanticValue();

        yyValue = (PureList<Expr>)apply(list, PureList.make(seed));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal NoSpaceExpr.Primary$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$Primary$$Star1(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fNoSpaceExpr$Primary$$Star1) 
      yyColumn.chunk16.fNoSpaceExpr$Primary$$Star1 = pNoSpaceExpr$Primary$$Star1$1(yyStart);
    return yyColumn.chunk16.fNoSpaceExpr$Primary$$Star1;
  }

  /** Actually parse NoSpaceExpr.Primary$$Star1. */
  private Result pNoSpaceExpr$Primary$$Star1$1(final int yyStart) 
    throws IOException {

    Result                       yyResult;
    Pair<Action<PureList<Expr>>> yyValue;
    ParseError                   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr$PrimaryTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Action<PureList<Expr>> v$el$1 = yyResult.semanticValue();

      yyResult = pNoSpaceExpr$Primary$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Action<PureList<Expr>>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<PureList<Expr>>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.PrimaryTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$PrimaryTail(final int yyStart) 
    throws IOException {

    int                    yyC;
    int                    yyIndex;
    Result                 yyResult;
    int                    yyBase;
    int                    yyOption1;
    Object                 yyOpValue1;
    Action<PureList<Expr>> yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExprList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<Expr> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        final List<Expr> a2 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pclosesquare(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final String a3 = yyResult.semanticValue();

            yyValue = new Action<PureList<Expr>>() {
              public PureList<Expr> run(PureList<Expr> base) {
                Span span = createSpan(yyStart,yyCount);
                Expr arr = FortressUtil.buildPrimary((PureList<Expr>)base);
                List<Expr> es;
                if (a2 == null) es = FortressUtil.emptyExprs();
                else            es = a2;
                Op open  = NodeFactory.makeOp(createSpan(yyStart, yyStart+1), a1);
                Op close = NodeFactory.makeOp(createSpan(yyCount-1,1),a3);
                SubscriptOp op = new SubscriptOp(span, open, close);
                return PureList.make((Expr)ExprFactory.makeSubscriptExpr(span, arr, es, Option.some(op)));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExprList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<Expr> v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a2.
        final List<Expr> a2 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pRightEncloser(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Op a3 = yyResult.semanticValue();

            yyValue = new Action<PureList<Expr>>() {
              public PureList<Expr> run(PureList<Expr> base) {
                Span span = createSpan(yyStart,yyCount);
                Expr arr = FortressUtil.buildPrimary((PureList<Expr>)base);
                List<Expr> es;
                if (a2 == null) es = FortressUtil.emptyExprs();
                else            es = a2;
                SubscriptOp op = new SubscriptOp(FortressUtil.spanTwo(a1,a3), a1, a3);
                return PureList.make((Expr)new SubscriptExpr(span, false, arr, es,
                Option.some(op)));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Alternative 3.

    yyResult = pdot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Id a1 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = popendoublesquare(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticArgList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final List<StaticArg> v$el$1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pclosedoublesquare(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
            }
          }
        }
        { // Start scope for a2.
          final List<StaticArg> a2 = cast(yyOpValue1);

          final int yyChoice2 = yyOption1;

          // Nested alternative 1.

          yyResult = p$$Shared26(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expr a3 = yyResult.semanticValue();

            yyValue = new Action<PureList<Expr>>() {
              public PureList<Expr> run(PureList<Expr> base) {
                Expr rcv = FortressUtil.buildPrimary((PureList<Expr>)base);
                List<StaticArg> sargs;
                if (a2 == null) sargs = Collections.<StaticArg>emptyList();
                else            sargs = a2;
                Expr inv = new MethodInvocation(FortressUtil.spanTwo(rcv,a3),
                false, rcv, NodeFactory.makeIdName(a1),
                sargs, a3);
                return PureList.make(inv);
            }};

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyResult = popenparen(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = new Action<PureList<Expr>>() {
                  public PureList<Expr> run(PureList<Expr> base) {
                    Expr arg = ExprFactory.makeVoidLiteral(a1.getSpan());
                    Expr rcv = FortressUtil.buildPrimary((PureList<Expr>)base);
                    List<StaticArg> sargs;
                    if (a2 == null) sargs = Collections.<StaticArg>emptyList();
                    else            sargs = a2;
                    Expr inv = new MethodInvocation(createSpan(yyStart,yyCount),
                    false, rcv, NodeFactory.makeIdName(a1),
                    sargs, arg);
                    return PureList.make(inv);
                }};

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        } // End scope for a2.

        // Nested alternative 2.

        yyValue = new Action<PureList<Expr>>() {
          public PureList<Expr> run(PureList<Expr> base) {
            Span span = createSpan(yyStart,yyCount);
            Expr rcv = FortressUtil.buildPrimary((PureList<Expr>)base);
            return PureList.make((Expr)new FieldRef(span,false,rcv,
            NodeFactory.makeIdName(a1)));
        }};

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Alternative 4.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String a1 = yyResult.semanticValue();

      yyResult = pBaseExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expr a2 = yyResult.semanticValue();

        yyValue = new Action<PureList<Expr>>() {
          public PureList<Expr> run(PureList<Expr> base) {
            PureList<Expr> primary = (PureList<Expr>)base;
            if (primary.isEmpty()) {
              return error(a2, "Exponentiation on an empty primary.");
            } else { // !primary.isEmpty()
              Expr last = ((Cons<Expr>)primary).getFirst();
              PureList<Expr> rest = ((Cons<Expr>)primary).getRest();
              Span span = FortressUtil.spanTwo(last, a2);
              Op op = NodeFactory.makeOp(createSpan(yyStart,yyCount), a1);
              return rest.cons(ASTUtil.infix(span, last, op, a2));
            }
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 5.

    yyResult = pExponentOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Op a1 = yyResult.semanticValue();

      yyValue = new Action<PureList<Expr>>() {
        public PureList<Expr> run(PureList<Expr> base) {
          PureList<Expr> primary = (PureList<Expr>)base;
          if (primary.isEmpty()) {
            return error(a1, "Exponentiation on an empty primary.");
          } else { // !primary.isEmpty()
            Expr last = ((Cons<Expr>)primary).getFirst();
            PureList<Expr> rest = ((Cons<Expr>)primary).getRest();
            Span span = FortressUtil.spanTwo(last, a1);
            return rest.cons(ASTUtil.postfix(span, last, a1));
          }
      }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('d' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('i' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('o' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('n' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('l' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('e' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('s' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyC = character(yyIndex);
                              if ('s' == yyC) {
                                yyIndex = yyIndex + 1;

                                yyValue = new Action<PureList<Expr>>() {
                                  public PureList<Expr> run(PureList<Expr> base) {
                                    Span span = createSpan(yyStart,yyCount);
                                    Expr val = FortressUtil.buildPrimary((PureList<Expr>)base);
                                    return PureList.make((Expr)new ProductUnitExpr(span,false,val,
                                    new BaseUnit(span)));
                                }};

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select("\"dimensionless\" expected", yyBase);
                              }
                            } else {
                              yyError = yyError.select("\"dimensionless\" expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("\"dimensionless\" expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("\"dimensionless\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"dimensionless\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"dimensionless\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"dimensionless\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"dimensionless\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"dimensionless\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"dimensionless\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"dimensionless\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"dimensionless\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"dimensionless\" expected", yyBase);
      }

      // Nested alternative 2.

      yyResult = pper(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoSpaceExpr$UnitExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final UnitExpr a1 = yyResult.semanticValue();

            yyValue = new Action<PureList<Expr>>() {
              public PureList<Expr> run(PureList<Expr> base) {
                Span span = createSpan(yyStart,yyCount);
                Expr val = FortressUtil.buildPrimary((PureList<Expr>)base);
                return PureList.make((Expr)new QuotientUnitExpr(span,false,val,a1));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 3.

      yyResult = pin(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoSpaceExpr$UnitExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final UnitExpr a1 = yyResult.semanticValue();

            yyValue = new Action<PureList<Expr>>() {
              public PureList<Expr> run(PureList<Expr> base) {
                Span span = createSpan(yyStart,yyCount);
                Expr val = FortressUtil.buildPrimary((PureList<Expr>)base);
                return PureList.make((Expr)new ChangeUnitExpr(span,false,val,a1));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 7.

    yyResult = p$$Shared26(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expr a1 = yyResult.semanticValue();

      yyValue = new Action<PureList<Expr>>() {
        public PureList<Expr> run(PureList<Expr> base) {
          return base.cons(a1);
      }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcloseparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = new Action<PureList<Expr>>() {
            public PureList<Expr> run(PureList<Expr> base) {
              return base.cons(ExprFactory.makeVoidLiteral(createSpan(yyStart,yyCount)));
          }};

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 9.

    yyResult = pNoSpaceExpr$Primary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final PureList<Expr> a1 = yyResult.semanticValue();

      yyValue = new Action<PureList<Expr>>() {
        public PureList<Expr> run(PureList<Expr> base) {
          return a1.append(base);
      }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.UnitExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$UnitExpr(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fNoSpaceExpr$UnitExpr) 
      yyColumn.chunk16.fNoSpaceExpr$UnitExpr = pNoSpaceExpr$UnitExpr$1(yyStart);
    return yyColumn.chunk16.fNoSpaceExpr$UnitExpr;
  }

  /** Actually parse NoSpaceExpr.UnitExpr. */
  private Result pNoSpaceExpr$UnitExpr$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    UnitExpr   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr$UnitExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      UnitExpr seed = yyResult.semanticValue();

      yyResult = pNoSpaceExpr$UnitExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<UnitExpr>> list = yyResult.semanticValue();

        yyValue = (UnitExpr)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal NoSpaceExpr.UnitExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$UnitExpr$$Star1(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fNoSpaceExpr$UnitExpr$$Star1) 
      yyColumn.chunk16.fNoSpaceExpr$UnitExpr$$Star1 = pNoSpaceExpr$UnitExpr$$Star1$1(yyStart);
    return yyColumn.chunk16.fNoSpaceExpr$UnitExpr$$Star1;
  }

  /** Actually parse NoSpaceExpr.UnitExpr$$Star1. */
  private Result pNoSpaceExpr$UnitExpr$$Star1$1(final int yyStart) 
    throws IOException {

    Result                 yyResult;
    Pair<Action<UnitExpr>> yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr$UnitExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<UnitExpr> v$el$1 = yyResult.semanticValue();

      yyResult = pNoSpaceExpr$UnitExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<UnitExpr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<UnitExpr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.UnitExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$UnitExprFront(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    UnitExpr   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('o' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('n' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('l' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('e' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('s' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('s' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyValue = new BaseUnit(createSpan(yyStart,yyCount));

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyValue = new UnitRef(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pone(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pslash(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoSpaceExpr$UnitExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              UnitExpr a1 = yyResult.semanticValue();

              yyValue = new QuotientUnit(createSpan(yyStart,yyCount),
              new BaseUnit(createSpan(yyStart,1)), a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoSpaceExpr$UnitExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          UnitExpr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 5.

    yyResult = pDUPreOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      DimUnitOp a1 = yyResult.semanticValue();

      yyResult = psr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoSpaceExpr$UnitExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          UnitExpr a2 = yyResult.semanticValue();

          yyValue = new OpUnit(createSpan(yyStart,yyCount), a2, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("unit expr front expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.UnitExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$UnitExprTail(final int yyStart) 
    throws IOException {

    Result           yyResult;
    Action<UnitExpr> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared24(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNoSpaceExpr$UnitExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final UnitExpr a1 = yyResult.semanticValue();

        yyValue = new Action<UnitExpr>() {
          public UnitExpr run(UnitExpr base) {
            return new ProductUnit(createSpan(yyStart,yyCount),
            (UnitExpr)base, a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = p$$Shared25(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoSpaceExpr$UnitExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final UnitExpr a1 = yyResult.semanticValue();

            yyValue = new Action<UnitExpr>() {
              public UnitExpr run(UnitExpr base) {
                return new QuotientUnit(createSpan(yyStart,yyCount),
                (UnitExpr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 3.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNumber(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final IntLiteral a1 = yyResult.semanticValue();

        yyValue = new Action<UnitExpr>() {
          public UnitExpr run(UnitExpr base) {
            return new ExponentUnit(createSpan(yyStart,yyCount),
            (UnitExpr)base, a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDUPostOp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final DimUnitOp a1 = yyResult.semanticValue();

        yyValue = new Action<UnitExpr>() {
          public UnitExpr run(UnitExpr base) {
            return new OpUnit(createSpan(yyStart,yyCount),(UnitExpr)base,a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.NoSpaceExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fNoSpaceExpr) 
      yyColumn.chunk16.fNoSpaceExpr = pNoSpaceExpr$1(yyStart);
    return yyColumn.chunk16.fNoSpaceExpr;
  }

  /** Actually parse NoSpaceExpr.NoSpaceExpr. */
  private Result pNoSpaceExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr$ExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.Literal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcloseparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = ExprFactory.makeVoidLiteral(createSpan(yyStart,yyCount));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pNumericLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pCharLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.Aggregate.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAggregate(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyRepetition1;
    Pair<Entry> yyRepValue1;
    Expr        yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pEntry(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Entry a1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pEntry(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Entry v$el$2 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepValue1   = new Pair<Entry>(v$el$2, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }
          { // Start scope for a2s.
            Pair<Entry> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                List<Entry> elements = new ArrayList<Entry>();
                elements.add(a1);
                elements.addAll(a2s.list());
                yyValue = new MapExpr(createSpan(yyStart,yyCount), false, elements);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a2s.
        }
      }
    }

    // Alternative 2.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pRectElements(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosesquare(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.RectElements.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRectElements(final int yyStart) throws IOException {
    Result                                           yyResult;
    int                                              yyRepetition1;
    Pair<com.sun.fortress.useful.Pair<Integer,Expr>> yyRepValue1;
    ArrayExpr                                        yyValue;
    ParseError                                       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pMultiDimCons(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          com.sun.fortress.useful.Pair<Integer,Expr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<com.sun.fortress.useful.Pair<Integer,Expr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<com.sun.fortress.useful.Pair<Integer,Expr>> a2s = yyRepValue1.reverse();

        if (a2s == null || a2s.isEmpty())
        yyValue = new ArrayElement(a1.getSpan(), false, a1);
        else
        yyValue = FortressUtil.multiDimCons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.MultiDimCons.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiDimCons(final int yyStart) throws IOException {
    Result                                     yyResult;
    com.sun.fortress.useful.Pair<Integer,Expr> yyValue;
    ParseError                                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRectSeparator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Integer a1 = yyResult.semanticValue();

      yyResult = pNoSpaceExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expr a2 = yyResult.semanticValue();

        yyValue = new com.sun.fortress.useful.Pair<Integer,Expr>(a1,a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NumericLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumericLiteral(final int yyStart) throws IOException {
    Result        yyResult;
    NumberLiteral yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFloatLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIntLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.FloatLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatLiteral(final int yyStart) throws IOException {
    Result       yyResult;
    FloatLiteral yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDigitString(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pdot(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pDigitString(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a2 = yyResult.semanticValue();

          yyValue = ExprFactory.makeFloatLiteral(createSpan(yyStart,yyCount), a1 + "." + a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.IntLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    IntLiteral yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDigitString(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeIntLiteral(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.DigitString.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDigitString(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("digit string expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.CharLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharLiteral(final int yyStart) throws IOException {
    int         yyC;
    int         yyIndex;
    Result      yyResult;
    int         yyBase;
    CharLiteral yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\'' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pCharLiteralContent(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a1 = yyResult.semanticValue();

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('\'' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = ExprFactory.makeCharLiteral(createSpan(yyStart,yyCount), a1);

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"\\\'\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("char literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.StringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteral(final int yyStart) throws IOException {
    int           yyC;
    int           yyIndex;
    Result        yyResult;
    int           yyRepetition1;
    Pair<String>  yyRepValue1;
    StringLiteral yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pStringLiteralContent(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a1.
        Pair<String> a1 = yyRepValue1.reverse();

        yyC = character(yyRepetition1);
        if ('\"' == yyC) {
          yyIndex = yyRepetition1 + 1;

          String str = "";
          for (String s : (List<String>)a1.list()) {
            str = str.concat(s);
          }
          yyValue = new StringLiteral(createSpan(yyStart,yyCount), false, str);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      } // End scope for a1.
    }

    // Done.
    yyError = yyError.select("string literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.StringLiteralContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteralContent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEscapeSequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if (('\"' != a1) &&
          ('\\' != a1)) {

        yyValue = String.valueOf(a1);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("string literal content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.EscapeSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEscapeSequence(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (-1 != yyC) {
        yyIndex = yyIndex + 1;
        char a1 = (char)yyC;

        if (('\"' == a1) ||
            ('\\' == a1) ||
            ('b' == a1) ||
            ('f' == a1) ||
            ('n' == a1) ||
            ('r' == a1) ||
            ('t' == a1)) {

          switch (a1) {
            case 'b': { yyValue = "\b"; break; }
            case 't': { yyValue = "\t"; break; }
            case 'n': { yyValue = "\n"; break; }
            case 'f': { yyValue = "\f"; break; }
            case 'r': { yyValue = "\r"; break; }
            case '"': { yyValue = "\""; break; }
            case '\\': { yyValue = "\\"; break; }
            default:   { yyValue = ""; }
          }

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("escape sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.CharLiteralContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharLiteralContent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (-1 != yyC) {
        yyIndex = yyIndex + 1;

        switch (yyC) {
        case '\"':
        case '\\':
        case 'b':
        case 'f':
        case 'n':
        case 'r':
        case 't':
          {
            yyValue = difference(yyStart, yyIndex);

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        default:
          /* No match. */
        }
      }
    }

    // Alternative 2.

    yyPredMatched = false;

    yyC = character(yyStart);
    if ('\'' == yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("char literal content expected", yyStart);
    }

    // Done.
    yyError = yyError.select("char literal content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.VarWTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalDecl$VarWTypes(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyRepetition1;
    boolean          yyRepeated1;
    Pair<LValueBind> yyRepValue1;
    List<LValueBind> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLocalDecl$VarWType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LValueBind a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pLocalDecl$VarWType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          LValueBind a1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pLocalDecl$VarWType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    LValueBind v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = new Pair<LValueBind>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<LValueBind> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = FortressUtil.mkList(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.VarWType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalDecl$VarWType(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fLocalDecl$VarWType) 
      yyColumn.chunk16.fLocalDecl$VarWType = pLocalDecl$VarWType$1(yyStart);
    return yyColumn.chunk16.fLocalDecl$VarWType;
  }

  /** Actually parse LocalDecl.VarWType. */
  private Result pLocalDecl$VarWType$1(final int yyStart) throws IOException {
    Result     yyResult;
    LValueBind yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = ps(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = ps(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyValue = FortressUtil.mkLValueBind(createSpan(yyStart,yyCount),a1,a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.BlockElems.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockElems(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fBlockElems) 
      yyColumn.chunk16.fBlockElems = pBlockElems$1(yyStart);
    return yyColumn.chunk16.fBlockElems;
  }

  /** Actually parse LocalDecl.BlockElems. */
  private Result pBlockElems$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    Block      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBlockElem(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pbr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBlockElems(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Block a2 = yyResult.semanticValue();

          yyValue = FortressUtil.doBlock(FortressUtil.mkList(a1, a2));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyPredResult = pBlockElems$$Choice1(yyChoice1);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyValue = FortressUtil.doBlock(FortressUtil.mkList(a1));

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }

      // Nested alternative 3.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = psemicolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyPredResult = pBlockElems$$Choice2(yyResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyValue = FortressUtil.doBlock(FortressUtil.mkList(a1));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.BlockElems$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockElems$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pElifs(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pElse(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pCaseClause(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pTypecaseTypes(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pCaseElse(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pend(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pCatch(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pforbid(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = pfinally(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 5.

      yyResult = pcloseparen(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.BlockElems$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockElems$$Choice2(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pElifs(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pElse(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pCaseClause(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = pTypecaseTypes(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 5.

      yyResult = pCaseElse(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 6.

      yyResult = pend(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 7.

      yyResult = pCatch(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 8.

      yyResult = pforbid(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 9.

      yyResult = pfinally(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 10.

      yyResult = pcloseparen(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.BlockElem.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockElem(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    List<Generator> yyOpValue1;
    Expr            yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLocalVarFnDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = ps(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr$GeneratorList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Generator> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
        }
      }
      { // Start scope for a2.
        List<Generator> a2 = yyOpValue1;

        if (a2 == null) yyValue = a1;
        else yyValue = new GeneratedExpr(createSpan(yyStart,yyCount), false,
        a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.LocalVarFnDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalVarFnDecl(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyRepetition1;
    Pair<FnDef> yyRepValue1;
    LetExpr     yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLocalFnDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      FnDef a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pbr(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pLocalFnDecl(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            FnDef v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<FnDef>(v$el$2, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<FnDef> a2s = yyRepValue1.reverse();

        List<FnDef> fns = FortressUtil.mkList(a1, a2s.list());
        yyValue = new LetFn(createSpan(yyStart,yyCount), false,
        FortressUtil.emptyExprs(), fns);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Alternative 2.

    yyResult = pLocalVarDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.LocalFnDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalFnDecl(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fLocalFnDecl) 
      yyColumn.chunk16.fLocalFnDecl = pLocalFnDecl$1(yyStart);
    return yyColumn.chunk16.fLocalFnDecl;
  }

  /** Actually parse LocalDecl.LocalFnDecl. */
  private Result pLocalFnDecl$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    List<Modifier> yyOpValue1;
    FnDef          yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pLocalFnMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<Modifier> a1 = yyOpValue1;

      yyResult = pFnHeaderFront(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        FnHeaderFront a2 = yyResult.semanticValue();

        yyResult = pFnHeaderClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FnHeaderClause a3 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pequals(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineExpr(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Expr a4 = yyResult.semanticValue();

                  if (a1 == null) a1 = FortressUtil.emptyModifiers();
                  yyValue = FortressUtil.mkFnDecl(createSpan(yyStart,yyCount),a1,a2,a3,a4);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.LocalVarDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalVarDecl(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Object       yyOpValue1;
    LocalVarDecl yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pvar(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      String a1 = cast(yyOpValue1);

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = pLocalDecl$VarWTypes(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<LValueBind> a2 = yyResult.semanticValue();

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = ps(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared3(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            com.sun.fortress.useful.Pair<Expr,Boolean> a3 = yyResult.semanticValue();

            if (a1 != null) a2 = FortressUtil.setMutable(a2, createSpan(yyStart,3));
            else if (a3.getB()) a2 = FortressUtil.setMutable(a2);
            yyValue = FortressUtil.mkLocalVarDecl(createSpan(yyStart,yyCount),
            FortressUtil.toLValueList(a2),
            a3.getA());

            return yyResult.createValue(yyValue, yyError);
          }
        }

        // Nested alternative 2.

        if (a1 != null) a2 = FortressUtil.setMutable(a2, createSpan(yyStart,3));
        yyValue = FortressUtil.mkLocalVarDecl(createSpan(yyStart,yyCount),
        FortressUtil.toLValueList(a2));

        return new SemanticValue(yyValue, yyChoice2, yyError);
      }

      // Nested alternative 2.

      yyResult = pVarWoTypes(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<LValue> a2 = yyResult.semanticValue();

        yyResult = ps(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice2 = yyResult.index;

          // Nested alternative 1.

          yyResult = pequals(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = ps(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineExpr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr a3 = yyResult.semanticValue();

                if (a1 != null) a2 = FortressUtil.setMutableLValue(a2,
                createSpan(yyStart,3));
                yyValue = FortressUtil.mkLocalVarDecl(createSpan(yyStart,yyCount),a2,a3);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 2.

          yyResult = pcolon(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = ps(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              final int yyChoice3 = yyResult.index;

              // Nested alternative 1.

              yyResult = pType(yyChoice3);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Type a3 = yyResult.semanticValue();

                yyResult = ps(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pellipses(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption1  = yyResult.index;
                    yyOpValue1 = null;

                    yyResult = ps(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = p$$Shared3(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        com.sun.fortress.useful.Pair<Expr,Boolean> v$el$2 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = v$el$2;
                      }
                    }
                    { // Start scope for a4.
                      com.sun.fortress.useful.Pair<Expr,Boolean> a4 = cast(yyOpValue1);

                      Option<Expr> init;
                      if (a1 != null) {
                        a2 = FortressUtil.setMutableAndType(a2, createSpan(yyStart,3), a3);
                        if (a4 == null) init = Option.none();
                        else            init = Option.some(a4.getA());
                      } else {
                        if (a4 == null) {
                          init = Option.none();
                          a2 = FortressUtil.setType(a2, a3);
                        } else {
                          init = Option.some(a4.getA());
                          if (a4.getB()) a2 = FortressUtil.setMutableAndType(a2, a3);
                          else a2 = FortressUtil.setType(a2, a3);
                        }
                      }
                      yyValue = FortressUtil.mkLocalVarDecl(createSpan(yyStart,yyCount), a2,
                      init);

                      return new SemanticValue(yyValue, yyOption1, yyError);
                    } // End scope for a4.
                  }
                }
              }

              // Nested alternative 2.

              yyResult = pSimpleTupleType(yyChoice3);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TupleType a3 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = ps(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = p$$Shared3(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    com.sun.fortress.useful.Pair<Expr,Boolean> v$el$3 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$3;
                  }
                }
                { // Start scope for a4.
                  com.sun.fortress.useful.Pair<Expr,Boolean> a4 = cast(yyOpValue1);

                  Span span = createSpan(yyStart,yyCount);
                  List<Type> tys = a3.getElements();
                  Option<Expr> init;
                  if (a2.size() != tys.size())
                  error(new Id(span,"_"),"Mismatched numbers of variables and types.");
                  if (a1 != null) {
                    a2 = FortressUtil.setMutableAndType(a2, createSpan(yyStart,3), tys);
                    if (a4 == null) init = Option.none();
                    else            init = Option.some(a4.getA());
                  } else {
                    if (a4 == null) {
                      init = Option.none();
                      a2 = FortressUtil.setType(a2, tys);
                    } else {
                      init = Option.some(a4.getA());
                      if (a4.getB()) a2 = FortressUtil.setMutableAndType(a2, tys);
                      else a2 = FortressUtil.setType(a2, tys);
                    }
                  }
                  yyValue = FortressUtil.mkLocalVarDecl(span, a2, init);

                  return new SemanticValue(yyValue, yyOption1, yyError);
                } // End scope for a4.
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.VarWoTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVarWoTypes(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    boolean      yyRepeated1;
    Pair<LValue> yyRepValue1;
    List<LValue> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pVarWoType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LValue a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pVarWoType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          LValue a1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pVarWoType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    LValue v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = new Pair<LValue>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<LValue> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = FortressUtil.mkList(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.VarWoType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVarWoType(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fVarWoType) 
      yyColumn.chunk16.fVarWoType = pVarWoType$1(yyStart);
    return yyColumn.chunk16.fVarWoType;
  }

  /** Actually parse LocalDecl.VarWoType. */
  private Result pVarWoType$1(final int yyStart) throws IOException {
    Result     yyResult;
    LValue     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkLValueBind(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pUnpasting(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.Unpasting.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnpasting(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fUnpasting) 
      yyColumn.chunk17.fUnpasting = pUnpasting$1(yyStart);
    return yyColumn.chunk17.fUnpasting;
  }

  /** Actually parse LocalDecl.Unpasting. */
  private Result pUnpasting$1(final int yyStart) throws IOException {
    Result     yyResult;
    Unpasting  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnpastingElems(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosesquare(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.UnpastingElems.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnpastingElems(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fUnpastingElems) 
      yyColumn.chunk17.fUnpastingElems = pUnpastingElems$1(yyStart);
    return yyColumn.chunk17.fUnpastingElems;
  }

  /** Actually parse LocalDecl.UnpastingElems. */
  private Result pUnpastingElems$1(final int yyStart) throws IOException {
    Result     yyResult;
    Unpasting  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUnpastingElem(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Unpasting a1 = yyResult.semanticValue();

      yyResult = pRectSeparator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Integer a2 = yyResult.semanticValue();

        yyResult = pUnpastingElems(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Unpasting a3 = yyResult.semanticValue();

          yyValue = FortressUtil.unpastingCons(createSpan(yyStart,yyCount),a1,a2,a3);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pUnpastingElem(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.UnpastingElem.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnpastingElem(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fUnpastingElem) 
      yyColumn.chunk17.fUnpastingElem = pUnpastingElem$1(yyStart);
    return yyColumn.chunk17.fUnpastingElem;
  }

  /** Actually parse LocalDecl.UnpastingElem. */
  private Result pUnpastingElem$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<ExtentRange> yyOpValue1;
    Unpasting         yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = popensquare(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pUnpastingDim(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<ExtentRange> v$el$2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosesquare(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
          }
        }
      }
      { // Start scope for a2.
        List<ExtentRange> a2 = yyOpValue1;

        if (a2 == null)
        yyValue = new UnpastingBind(createSpan(yyStart,yyCount),
        NodeFactory.makeIdName(a1),
        Collections.<ExtentRange>emptyList());
        else
        yyValue = new UnpastingBind(createSpan(yyStart,yyCount),
        NodeFactory.makeIdName(a1), a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pUnpasting(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.UnpastingDim.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnpastingDim(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    boolean           yyRepeated1;
    Pair<ExtentRange> yyRepValue1;
    List<ExtentRange> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExtentRange(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExtentRange a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcross(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExtentRange(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                ExtentRange v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = new Pair<ExtentRange>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<ExtentRange> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.CaseClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseClause(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fCaseClause) 
      yyColumn.chunk17.fCaseClause = pCaseClause$1(yyStart);
    return yyColumn.chunk17.fCaseClause;
  }

  /** Actually parse LocalDecl.CaseClause. */
  private Result pCaseClause$1(final int yyStart) throws IOException {
    Result     yyResult;
    CaseClause yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmatch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Block a2 = yyResult.semanticValue();

              yyValue = new CaseClause(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pid(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fid) yyColumn.chunk17.fid = pid$1(yyStart);
    return yyColumn.chunk17.fid;
  }

  /** Actually parse Identifier.id. */
  private Result pid$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pid$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String s = yyResult.semanticValue();

      if (!FORTRESS_KEYWORDS.contains(s)) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("id expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.id$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pid$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fid$$Star1) 
      yyColumn.chunk17.fid$$Star1 = pid$$Star1$1(yyStart);
    return yyColumn.chunk17.fid$$Star1;
  }

  /** Actually parse PreFortress.id$$Star1. */
  private Result pid$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pidrest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pid$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.id$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pid$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pidstart(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pid$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.idstart.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidstart(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z')) ||
          ('\u00aa' == yyC) ||
          ('\u00b5' == yyC) ||
          ('\u00ba' == yyC) ||
          (('\u00c0' <= yyC) && (yyC <= '\u00d6')) ||
          (('\u00d8' <= yyC) && (yyC <= '\u00f6')) ||
          (('\u00f8' <= yyC) && (yyC <= '\u02c1')) ||
          (('\u02c6' <= yyC) && (yyC <= '\u02d1')) ||
          (('\u02e0' <= yyC) && (yyC <= '\u02e4')) ||
          ('\u02ee' == yyC) ||
          (('\u037a' <= yyC) && (yyC <= '\u037d')) ||
          ('\u0386' == yyC) ||
          (('\u0388' <= yyC) && (yyC <= '\u038a')) ||
          ('\u038c' == yyC) ||
          (('\u038e' <= yyC) && (yyC <= '\u03a1')) ||
          (('\u03a3' <= yyC) && (yyC <= '\u03ce')) ||
          (('\u03d0' <= yyC) && (yyC <= '\u03f5')) ||
          (('\u03f7' <= yyC) && (yyC <= '\u0481')) ||
          (('\u048a' <= yyC) && (yyC <= '\u0513')) ||
          (('\u0531' <= yyC) && (yyC <= '\u0556')) ||
          ('\u0559' == yyC) ||
          (('\u0561' <= yyC) && (yyC <= '\u0587')) ||
          (('\u05d0' <= yyC) && (yyC <= '\u05ea')) ||
          (('\u05f0' <= yyC) && (yyC <= '\u05f2')) ||
          (('\u0621' <= yyC) && (yyC <= '\u063a')) ||
          (('\u0640' <= yyC) && (yyC <= '\u064a')) ||
          (('\u066e' <= yyC) && (yyC <= '\u066f')) ||
          (('\u0671' <= yyC) && (yyC <= '\u06d3')) ||
          ('\u06d5' == yyC) ||
          (('\u06e5' <= yyC) && (yyC <= '\u06e6')) ||
          (('\u06ee' <= yyC) && (yyC <= '\u06ef')) ||
          (('\u06fa' <= yyC) && (yyC <= '\u06fc')) ||
          ('\u06ff' == yyC) ||
          ('\u0710' == yyC) ||
          (('\u0712' <= yyC) && (yyC <= '\u072f')) ||
          (('\u074d' <= yyC) && (yyC <= '\u076d')) ||
          (('\u0780' <= yyC) && (yyC <= '\u07a5')) ||
          ('\u07b1' == yyC) ||
          (('\u07ca' <= yyC) && (yyC <= '\u07ea')) ||
          (('\u07f4' <= yyC) && (yyC <= '\u07f5')) ||
          ('\u07fa' == yyC) ||
          (('\u0904' <= yyC) && (yyC <= '\u0939')) ||
          ('\u093d' == yyC) ||
          ('\u0950' == yyC) ||
          (('\u0958' <= yyC) && (yyC <= '\u0961')) ||
          (('\u097b' <= yyC) && (yyC <= '\u097f')) ||
          (('\u0985' <= yyC) && (yyC <= '\u098c')) ||
          (('\u098f' <= yyC) && (yyC <= '\u0990')) ||
          (('\u0993' <= yyC) && (yyC <= '\u09a8')) ||
          (('\u09aa' <= yyC) && (yyC <= '\u09b0')) ||
          ('\u09b2' == yyC) ||
          (('\u09b6' <= yyC) && (yyC <= '\u09b9')) ||
          ('\u09bd' == yyC) ||
          ('\u09ce' == yyC) ||
          (('\u09dc' <= yyC) && (yyC <= '\u09dd')) ||
          (('\u09df' <= yyC) && (yyC <= '\u09e1')) ||
          (('\u09f0' <= yyC) && (yyC <= '\u09f1')) ||
          (('\u0a05' <= yyC) && (yyC <= '\u0a0a')) ||
          (('\u0a0f' <= yyC) && (yyC <= '\u0a10')) ||
          (('\u0a13' <= yyC) && (yyC <= '\u0a28')) ||
          (('\u0a2a' <= yyC) && (yyC <= '\u0a30')) ||
          (('\u0a32' <= yyC) && (yyC <= '\u0a33')) ||
          (('\u0a35' <= yyC) && (yyC <= '\u0a36')) ||
          (('\u0a38' <= yyC) && (yyC <= '\u0a39')) ||
          (('\u0a59' <= yyC) && (yyC <= '\u0a5c')) ||
          ('\u0a5e' == yyC) ||
          (('\u0a72' <= yyC) && (yyC <= '\u0a74')) ||
          (('\u0a85' <= yyC) && (yyC <= '\u0a8d')) ||
          (('\u0a8f' <= yyC) && (yyC <= '\u0a91')) ||
          (('\u0a93' <= yyC) && (yyC <= '\u0aa8')) ||
          (('\u0aaa' <= yyC) && (yyC <= '\u0ab0')) ||
          (('\u0ab2' <= yyC) && (yyC <= '\u0ab3')) ||
          (('\u0ab5' <= yyC) && (yyC <= '\u0ab9')) ||
          ('\u0abd' == yyC) ||
          ('\u0ad0' == yyC) ||
          (('\u0ae0' <= yyC) && (yyC <= '\u0ae1')) ||
          (('\u0b05' <= yyC) && (yyC <= '\u0b0c')) ||
          (('\u0b0f' <= yyC) && (yyC <= '\u0b10')) ||
          (('\u0b13' <= yyC) && (yyC <= '\u0b28')) ||
          (('\u0b2a' <= yyC) && (yyC <= '\u0b30')) ||
          (('\u0b32' <= yyC) && (yyC <= '\u0b33')) ||
          (('\u0b35' <= yyC) && (yyC <= '\u0b39')) ||
          ('\u0b3d' == yyC) ||
          (('\u0b5c' <= yyC) && (yyC <= '\u0b5d')) ||
          (('\u0b5f' <= yyC) && (yyC <= '\u0b61')) ||
          ('\u0b71' == yyC) ||
          ('\u0b83' == yyC) ||
          (('\u0b85' <= yyC) && (yyC <= '\u0b8a')) ||
          (('\u0b8e' <= yyC) && (yyC <= '\u0b90')) ||
          (('\u0b92' <= yyC) && (yyC <= '\u0b95')) ||
          (('\u0b99' <= yyC) && (yyC <= '\u0b9a')) ||
          ('\u0b9c' == yyC) ||
          (('\u0b9e' <= yyC) && (yyC <= '\u0b9f')) ||
          (('\u0ba3' <= yyC) && (yyC <= '\u0ba4')) ||
          (('\u0ba8' <= yyC) && (yyC <= '\u0baa')) ||
          (('\u0bae' <= yyC) && (yyC <= '\u0bb9')) ||
          (('\u0c05' <= yyC) && (yyC <= '\u0c0c')) ||
          (('\u0c0e' <= yyC) && (yyC <= '\u0c10')) ||
          (('\u0c12' <= yyC) && (yyC <= '\u0c28')) ||
          (('\u0c2a' <= yyC) && (yyC <= '\u0c33')) ||
          (('\u0c35' <= yyC) && (yyC <= '\u0c39')) ||
          (('\u0c60' <= yyC) && (yyC <= '\u0c61')) ||
          (('\u0c85' <= yyC) && (yyC <= '\u0c8c')) ||
          (('\u0c8e' <= yyC) && (yyC <= '\u0c90')) ||
          (('\u0c92' <= yyC) && (yyC <= '\u0ca8')) ||
          (('\u0caa' <= yyC) && (yyC <= '\u0cb3')) ||
          (('\u0cb5' <= yyC) && (yyC <= '\u0cb9')) ||
          ('\u0cbd' == yyC) ||
          ('\u0cde' == yyC) ||
          (('\u0ce0' <= yyC) && (yyC <= '\u0ce1')) ||
          (('\u0d05' <= yyC) && (yyC <= '\u0d0c')) ||
          (('\u0d0e' <= yyC) && (yyC <= '\u0d10')) ||
          (('\u0d12' <= yyC) && (yyC <= '\u0d28')) ||
          (('\u0d2a' <= yyC) && (yyC <= '\u0d39')) ||
          (('\u0d60' <= yyC) && (yyC <= '\u0d61')) ||
          (('\u0d85' <= yyC) && (yyC <= '\u0d96')) ||
          (('\u0d9a' <= yyC) && (yyC <= '\u0db1')) ||
          (('\u0db3' <= yyC) && (yyC <= '\u0dbb')) ||
          ('\u0dbd' == yyC) ||
          (('\u0dc0' <= yyC) && (yyC <= '\u0dc6')) ||
          (('\u0e01' <= yyC) && (yyC <= '\u0e30')) ||
          (('\u0e32' <= yyC) && (yyC <= '\u0e33')) ||
          (('\u0e40' <= yyC) && (yyC <= '\u0e46')) ||
          (('\u0e81' <= yyC) && (yyC <= '\u0e82')) ||
          ('\u0e84' == yyC) ||
          (('\u0e87' <= yyC) && (yyC <= '\u0e88')) ||
          ('\u0e8a' == yyC) ||
          ('\u0e8d' == yyC) ||
          (('\u0e94' <= yyC) && (yyC <= '\u0e97')) ||
          (('\u0e99' <= yyC) && (yyC <= '\u0e9f')) ||
          (('\u0ea1' <= yyC) && (yyC <= '\u0ea3')) ||
          ('\u0ea5' == yyC) ||
          ('\u0ea7' == yyC) ||
          (('\u0eaa' <= yyC) && (yyC <= '\u0eab')) ||
          (('\u0ead' <= yyC) && (yyC <= '\u0eb0')) ||
          (('\u0eb2' <= yyC) && (yyC <= '\u0eb3')) ||
          ('\u0ebd' == yyC) ||
          (('\u0ec0' <= yyC) && (yyC <= '\u0ec4')) ||
          ('\u0ec6' == yyC) ||
          (('\u0edc' <= yyC) && (yyC <= '\u0edd')) ||
          ('\u0f00' == yyC) ||
          (('\u0f40' <= yyC) && (yyC <= '\u0f47')) ||
          (('\u0f49' <= yyC) && (yyC <= '\u0f6a')) ||
          (('\u0f88' <= yyC) && (yyC <= '\u0f8b')) ||
          (('\u1000' <= yyC) && (yyC <= '\u1021')) ||
          (('\u1023' <= yyC) && (yyC <= '\u1027')) ||
          (('\u1029' <= yyC) && (yyC <= '\u102a')) ||
          (('\u1050' <= yyC) && (yyC <= '\u1055')) ||
          (('\u10a0' <= yyC) && (yyC <= '\u10c5')) ||
          (('\u10d0' <= yyC) && (yyC <= '\u10fa')) ||
          ('\u10fc' == yyC) ||
          (('\u1100' <= yyC) && (yyC <= '\u1159')) ||
          (('\u115f' <= yyC) && (yyC <= '\u11a2')) ||
          (('\u11a8' <= yyC) && (yyC <= '\u11f9')) ||
          (('\u1200' <= yyC) && (yyC <= '\u1248')) ||
          (('\u124a' <= yyC) && (yyC <= '\u124d')) ||
          (('\u1250' <= yyC) && (yyC <= '\u1256')) ||
          ('\u1258' == yyC) ||
          (('\u125a' <= yyC) && (yyC <= '\u125d')) ||
          (('\u1260' <= yyC) && (yyC <= '\u1288')) ||
          (('\u128a' <= yyC) && (yyC <= '\u128d')) ||
          (('\u1290' <= yyC) && (yyC <= '\u12b0')) ||
          (('\u12b2' <= yyC) && (yyC <= '\u12b5')) ||
          (('\u12b8' <= yyC) && (yyC <= '\u12be')) ||
          ('\u12c0' == yyC) ||
          (('\u12c2' <= yyC) && (yyC <= '\u12c5')) ||
          (('\u12c8' <= yyC) && (yyC <= '\u12d6')) ||
          (('\u12d8' <= yyC) && (yyC <= '\u1310')) ||
          (('\u1312' <= yyC) && (yyC <= '\u1315')) ||
          (('\u1318' <= yyC) && (yyC <= '\u135a')) ||
          (('\u1380' <= yyC) && (yyC <= '\u138f')) ||
          (('\u13a0' <= yyC) && (yyC <= '\u13f4')) ||
          (('\u1401' <= yyC) && (yyC <= '\u166c')) ||
          (('\u166f' <= yyC) && (yyC <= '\u1676')) ||
          (('\u1681' <= yyC) && (yyC <= '\u169a')) ||
          (('\u16a0' <= yyC) && (yyC <= '\u16ea')) ||
          (('\u16ee' <= yyC) && (yyC <= '\u16f0')) ||
          (('\u1700' <= yyC) && (yyC <= '\u170c')) ||
          (('\u170e' <= yyC) && (yyC <= '\u1711')) ||
          (('\u1720' <= yyC) && (yyC <= '\u1731')) ||
          (('\u1740' <= yyC) && (yyC <= '\u1751')) ||
          (('\u1760' <= yyC) && (yyC <= '\u176c')) ||
          (('\u176e' <= yyC) && (yyC <= '\u1770')) ||
          (('\u1780' <= yyC) && (yyC <= '\u17b3')) ||
          ('\u17d7' == yyC) ||
          ('\u17dc' == yyC) ||
          (('\u1820' <= yyC) && (yyC <= '\u1877')) ||
          (('\u1880' <= yyC) && (yyC <= '\u18a8')) ||
          (('\u1900' <= yyC) && (yyC <= '\u191c')) ||
          (('\u1950' <= yyC) && (yyC <= '\u196d')) ||
          (('\u1970' <= yyC) && (yyC <= '\u1974')) ||
          (('\u1980' <= yyC) && (yyC <= '\u19a9')) ||
          (('\u19c1' <= yyC) && (yyC <= '\u19c7')) ||
          (('\u1a00' <= yyC) && (yyC <= '\u1a16')) ||
          (('\u1b05' <= yyC) && (yyC <= '\u1b33')) ||
          (('\u1b45' <= yyC) && (yyC <= '\u1b4b')) ||
          (('\u1d00' <= yyC) && (yyC <= '\u1dbf')) ||
          (('\u1e00' <= yyC) && (yyC <= '\u1e9b')) ||
          (('\u1ea0' <= yyC) && (yyC <= '\u1ef9')) ||
          (('\u1f00' <= yyC) && (yyC <= '\u1f15')) ||
          (('\u1f18' <= yyC) && (yyC <= '\u1f1d')) ||
          (('\u1f20' <= yyC) && (yyC <= '\u1f45')) ||
          (('\u1f48' <= yyC) && (yyC <= '\u1f4d')) ||
          (('\u1f50' <= yyC) && (yyC <= '\u1f57')) ||
          ('\u1f59' == yyC) ||
          ('\u1f5b' == yyC) ||
          ('\u1f5d' == yyC) ||
          (('\u1f5f' <= yyC) && (yyC <= '\u1f7d')) ||
          (('\u1f80' <= yyC) && (yyC <= '\u1fb4')) ||
          (('\u1fb6' <= yyC) && (yyC <= '\u1fbc')) ||
          ('\u1fbe' == yyC) ||
          (('\u1fc2' <= yyC) && (yyC <= '\u1fc4')) ||
          (('\u1fc6' <= yyC) && (yyC <= '\u1fcc')) ||
          (('\u1fd0' <= yyC) && (yyC <= '\u1fd3')) ||
          (('\u1fd6' <= yyC) && (yyC <= '\u1fdb')) ||
          (('\u1fe0' <= yyC) && (yyC <= '\u1fec')) ||
          (('\u1ff2' <= yyC) && (yyC <= '\u1ff4')) ||
          (('\u1ff6' <= yyC) && (yyC <= '\u1ffc')) ||
          ('\u2071' == yyC) ||
          ('\u207f' == yyC) ||
          (('\u2090' <= yyC) && (yyC <= '\u2094')) ||
          ('\u2102' == yyC) ||
          ('\u2107' == yyC) ||
          (('\u210a' <= yyC) && (yyC <= '\u2113')) ||
          ('\u2115' == yyC) ||
          (('\u2119' <= yyC) && (yyC <= '\u211d')) ||
          ('\u2124' == yyC) ||
          ('\u2126' == yyC) ||
          ('\u2128' == yyC) ||
          (('\u212a' <= yyC) && (yyC <= '\u212d')) ||
          (('\u212f' <= yyC) && (yyC <= '\u2139')) ||
          (('\u213c' <= yyC) && (yyC <= '\u213f')) ||
          (('\u2145' <= yyC) && (yyC <= '\u2149')) ||
          ('\u214e' == yyC) ||
          (('\u2160' <= yyC) && (yyC <= '\u2184')) ||
          (('\u2c00' <= yyC) && (yyC <= '\u2c2e')) ||
          (('\u2c30' <= yyC) && (yyC <= '\u2c5e')) ||
          (('\u2c60' <= yyC) && (yyC <= '\u2c6c')) ||
          (('\u2c74' <= yyC) && (yyC <= '\u2c77')) ||
          (('\u2c80' <= yyC) && (yyC <= '\u2ce4')) ||
          (('\u2d00' <= yyC) && (yyC <= '\u2d25')) ||
          (('\u2d30' <= yyC) && (yyC <= '\u2d65')) ||
          ('\u2d6f' == yyC) ||
          (('\u2d80' <= yyC) && (yyC <= '\u2d96')) ||
          (('\u2da0' <= yyC) && (yyC <= '\u2da6')) ||
          (('\u2da8' <= yyC) && (yyC <= '\u2dae')) ||
          (('\u2db0' <= yyC) && (yyC <= '\u2db6')) ||
          (('\u2db8' <= yyC) && (yyC <= '\u2dbe')) ||
          (('\u2dc0' <= yyC) && (yyC <= '\u2dc6')) ||
          (('\u2dc8' <= yyC) && (yyC <= '\u2dce')) ||
          (('\u2dd0' <= yyC) && (yyC <= '\u2dd6')) ||
          (('\u2dd8' <= yyC) && (yyC <= '\u2dde')) ||
          (('\u3005' <= yyC) && (yyC <= '\u3007')) ||
          (('\u3021' <= yyC) && (yyC <= '\u3029')) ||
          (('\u3031' <= yyC) && (yyC <= '\u3035')) ||
          (('\u3038' <= yyC) && (yyC <= '\u303c')) ||
          (('\u3041' <= yyC) && (yyC <= '\u3096')) ||
          (('\u309d' <= yyC) && (yyC <= '\u309f')) ||
          (('\u30a1' <= yyC) && (yyC <= '\u30fa')) ||
          (('\u30fc' <= yyC) && (yyC <= '\u30ff')) ||
          (('\u3105' <= yyC) && (yyC <= '\u312c')) ||
          (('\u3131' <= yyC) && (yyC <= '\u318e')) ||
          (('\u31a0' <= yyC) && (yyC <= '\u31b7')) ||
          (('\u31f0' <= yyC) && (yyC <= '\u31ff')) ||
          ('\u3400' == yyC) ||
          ('\u4db5' == yyC) ||
          ('\u4e00' == yyC) ||
          ('\u9fbb' == yyC) ||
          (('\ua000' <= yyC) && (yyC <= '\ua48c')) ||
          (('\ua717' <= yyC) && (yyC <= '\ua71a')) ||
          (('\ua800' <= yyC) && (yyC <= '\ua801')) ||
          (('\ua803' <= yyC) && (yyC <= '\ua805')) ||
          (('\ua807' <= yyC) && (yyC <= '\ua80a')) ||
          (('\ua80c' <= yyC) && (yyC <= '\ua822')) ||
          (('\ua840' <= yyC) && (yyC <= '\ua873')) ||
          ('\uac00' == yyC) ||
          ('\ud7a3' == yyC) ||
          (('\uf900' <= yyC) && (yyC <= '\ufa2d')) ||
          (('\ufa30' <= yyC) && (yyC <= '\ufa6a')) ||
          (('\ufa70' <= yyC) && (yyC <= '\ufad9')) ||
          (('\ufb00' <= yyC) && (yyC <= '\ufb06')) ||
          (('\ufb13' <= yyC) && (yyC <= '\ufb17')) ||
          ('\ufb1d' == yyC) ||
          (('\ufb1f' <= yyC) && (yyC <= '\ufb28')) ||
          (('\ufb2a' <= yyC) && (yyC <= '\ufb36')) ||
          (('\ufb38' <= yyC) && (yyC <= '\ufb3c')) ||
          ('\ufb3e' == yyC) ||
          (('\ufb40' <= yyC) && (yyC <= '\ufb41')) ||
          (('\ufb43' <= yyC) && (yyC <= '\ufb44')) ||
          (('\ufb46' <= yyC) && (yyC <= '\ufbb1')) ||
          (('\ufbd3' <= yyC) && (yyC <= '\ufd3d')) ||
          (('\ufd50' <= yyC) && (yyC <= '\ufd8f')) ||
          (('\ufd92' <= yyC) && (yyC <= '\ufdc7')) ||
          (('\ufdf0' <= yyC) && (yyC <= '\ufdfb')) ||
          (('\ufe70' <= yyC) && (yyC <= '\ufe74')) ||
          (('\ufe76' <= yyC) && (yyC <= '\ufefc')) ||
          (('\uff21' <= yyC) && (yyC <= '\uff3a')) ||
          (('\uff41' <= yyC) && (yyC <= '\uff5a')) ||
          (('\uff66' <= yyC) && (yyC <= '\uffbe')) ||
          (('\uffc2' <= yyC) && (yyC <= '\uffc7')) ||
          (('\uffca' <= yyC) && (yyC <= '\uffcf')) ||
          (('\uffd2' <= yyC) && (yyC <= '\uffd7')) ||
          (('\uffda' <= yyC) && (yyC <= '\uffdc'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud800':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc0b')) ||
                (('\udc0d' <= yyC) && (yyC <= '\udc26')) ||
                (('\udc28' <= yyC) && (yyC <= '\udc3a')) ||
                (('\udc3c' <= yyC) && (yyC <= '\udc3d')) ||
                (('\udc3f' <= yyC) && (yyC <= '\udc4d')) ||
                (('\udc50' <= yyC) && (yyC <= '\udc5d')) ||
                (('\udc80' <= yyC) && (yyC <= '\udcfa')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd74')) ||
                (('\udf00' <= yyC) && (yyC <= '\udf1e')) ||
                (('\udf30' <= yyC) && (yyC <= '\udf4a')) ||
                (('\udf80' <= yyC) && (yyC <= '\udf9d')) ||
                (('\udfa0' <= yyC) && (yyC <= '\udfc3')) ||
                (('\udfc8' <= yyC) && (yyC <= '\udfcf')) ||
                (('\udfd1' <= yyC) && (yyC <= '\udfd5'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc9d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc05')) ||
                ('\udc08' == yyC) ||
                (('\udc0a' <= yyC) && (yyC <= '\udc35')) ||
                (('\udc37' <= yyC) && (yyC <= '\udc38')) ||
                ('\udc3c' == yyC) ||
                ('\udc3f' == yyC) ||
                (('\udd00' <= yyC) && (yyC <= '\udd15')) ||
                ('\ude00' == yyC) ||
                (('\ude10' <= yyC) && (yyC <= '\ude13')) ||
                (('\ude15' <= yyC) && (yyC <= '\ude17')) ||
                (('\ude19' <= yyC) && (yyC <= '\ude33'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud808':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udf6e')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud809':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc62')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc54')) ||
                (('\udc56' <= yyC) && (yyC <= '\udc9c')) ||
                (('\udc9e' <= yyC) && (yyC <= '\udc9f')) ||
                ('\udca2' == yyC) ||
                (('\udca5' <= yyC) && (yyC <= '\udca6')) ||
                (('\udca9' <= yyC) && (yyC <= '\udcac')) ||
                (('\udcae' <= yyC) && (yyC <= '\udcb9')) ||
                ('\udcbb' == yyC) ||
                (('\udcbd' <= yyC) && (yyC <= '\udcc3')) ||
                (('\udcc5' <= yyC) && (yyC <= '\udd05')) ||
                (('\udd07' <= yyC) && (yyC <= '\udd0a')) ||
                (('\udd0d' <= yyC) && (yyC <= '\udd14')) ||
                (('\udd16' <= yyC) && (yyC <= '\udd1c')) ||
                (('\udd1e' <= yyC) && (yyC <= '\udd39')) ||
                (('\udd3b' <= yyC) && (yyC <= '\udd3e')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd44')) ||
                ('\udd46' == yyC) ||
                (('\udd4a' <= yyC) && (yyC <= '\udd50')) ||
                (('\udd52' <= yyC) && (yyC <= '\udea5')) ||
                (('\udea8' <= yyC) && (yyC <= '\udec0')) ||
                (('\udec2' <= yyC) && (yyC <= '\udeda')) ||
                (('\udedc' <= yyC) && (yyC <= '\udefa')) ||
                (('\udefc' <= yyC) && (yyC <= '\udf14')) ||
                (('\udf16' <= yyC) && (yyC <= '\udf34')) ||
                (('\udf36' <= yyC) && (yyC <= '\udf4e')) ||
                (('\udf50' <= yyC) && (yyC <= '\udf6e')) ||
                (('\udf70' <= yyC) && (yyC <= '\udf88')) ||
                (('\udf8a' <= yyC) && (yyC <= '\udfa8')) ||
                (('\udfaa' <= yyC) && (yyC <= '\udfc2')) ||
                (('\udfc4' <= yyC) && (yyC <= '\udfcb'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud840':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\udc00' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud869':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\uded6' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud87e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\ude1d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '_':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("idstart expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.idrest.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidrest(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fidrest) 
      yyColumn.chunk17.fidrest = pidrest$1(yyStart);
    return yyColumn.chunk17.fidrest;
  }

  /** Actually parse Identifier.idrest. */
  private Result pidrest$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z')) ||
          ('\u00aa' == yyC) ||
          ('\u00b5' == yyC) ||
          ('\u00ba' == yyC) ||
          (('\u00c0' <= yyC) && (yyC <= '\u00d6')) ||
          (('\u00d8' <= yyC) && (yyC <= '\u00f6')) ||
          (('\u00f8' <= yyC) && (yyC <= '\u02c1')) ||
          (('\u02c6' <= yyC) && (yyC <= '\u02d1')) ||
          (('\u02e0' <= yyC) && (yyC <= '\u02e4')) ||
          ('\u02ee' == yyC) ||
          (('\u037a' <= yyC) && (yyC <= '\u037d')) ||
          ('\u0386' == yyC) ||
          (('\u0388' <= yyC) && (yyC <= '\u038a')) ||
          ('\u038c' == yyC) ||
          (('\u038e' <= yyC) && (yyC <= '\u03a1')) ||
          (('\u03a3' <= yyC) && (yyC <= '\u03ce')) ||
          (('\u03d0' <= yyC) && (yyC <= '\u03f5')) ||
          (('\u03f7' <= yyC) && (yyC <= '\u0481')) ||
          (('\u048a' <= yyC) && (yyC <= '\u0513')) ||
          (('\u0531' <= yyC) && (yyC <= '\u0556')) ||
          ('\u0559' == yyC) ||
          (('\u0561' <= yyC) && (yyC <= '\u0587')) ||
          (('\u05d0' <= yyC) && (yyC <= '\u05ea')) ||
          (('\u05f0' <= yyC) && (yyC <= '\u05f2')) ||
          (('\u0621' <= yyC) && (yyC <= '\u063a')) ||
          (('\u0640' <= yyC) && (yyC <= '\u064a')) ||
          (('\u066e' <= yyC) && (yyC <= '\u066f')) ||
          (('\u0671' <= yyC) && (yyC <= '\u06d3')) ||
          ('\u06d5' == yyC) ||
          (('\u06e5' <= yyC) && (yyC <= '\u06e6')) ||
          (('\u06ee' <= yyC) && (yyC <= '\u06ef')) ||
          (('\u06fa' <= yyC) && (yyC <= '\u06fc')) ||
          ('\u06ff' == yyC) ||
          ('\u0710' == yyC) ||
          (('\u0712' <= yyC) && (yyC <= '\u072f')) ||
          (('\u074d' <= yyC) && (yyC <= '\u076d')) ||
          (('\u0780' <= yyC) && (yyC <= '\u07a5')) ||
          ('\u07b1' == yyC) ||
          (('\u07ca' <= yyC) && (yyC <= '\u07ea')) ||
          (('\u07f4' <= yyC) && (yyC <= '\u07f5')) ||
          ('\u07fa' == yyC) ||
          (('\u0904' <= yyC) && (yyC <= '\u0939')) ||
          ('\u093d' == yyC) ||
          ('\u0950' == yyC) ||
          (('\u0958' <= yyC) && (yyC <= '\u0961')) ||
          (('\u097b' <= yyC) && (yyC <= '\u097f')) ||
          (('\u0985' <= yyC) && (yyC <= '\u098c')) ||
          (('\u098f' <= yyC) && (yyC <= '\u0990')) ||
          (('\u0993' <= yyC) && (yyC <= '\u09a8')) ||
          (('\u09aa' <= yyC) && (yyC <= '\u09b0')) ||
          ('\u09b2' == yyC) ||
          (('\u09b6' <= yyC) && (yyC <= '\u09b9')) ||
          ('\u09bd' == yyC) ||
          ('\u09ce' == yyC) ||
          (('\u09dc' <= yyC) && (yyC <= '\u09dd')) ||
          (('\u09df' <= yyC) && (yyC <= '\u09e1')) ||
          (('\u09f0' <= yyC) && (yyC <= '\u09f1')) ||
          (('\u0a05' <= yyC) && (yyC <= '\u0a0a')) ||
          (('\u0a0f' <= yyC) && (yyC <= '\u0a10')) ||
          (('\u0a13' <= yyC) && (yyC <= '\u0a28')) ||
          (('\u0a2a' <= yyC) && (yyC <= '\u0a30')) ||
          (('\u0a32' <= yyC) && (yyC <= '\u0a33')) ||
          (('\u0a35' <= yyC) && (yyC <= '\u0a36')) ||
          (('\u0a38' <= yyC) && (yyC <= '\u0a39')) ||
          (('\u0a59' <= yyC) && (yyC <= '\u0a5c')) ||
          ('\u0a5e' == yyC) ||
          (('\u0a72' <= yyC) && (yyC <= '\u0a74')) ||
          (('\u0a85' <= yyC) && (yyC <= '\u0a8d')) ||
          (('\u0a8f' <= yyC) && (yyC <= '\u0a91')) ||
          (('\u0a93' <= yyC) && (yyC <= '\u0aa8')) ||
          (('\u0aaa' <= yyC) && (yyC <= '\u0ab0')) ||
          (('\u0ab2' <= yyC) && (yyC <= '\u0ab3')) ||
          (('\u0ab5' <= yyC) && (yyC <= '\u0ab9')) ||
          ('\u0abd' == yyC) ||
          ('\u0ad0' == yyC) ||
          (('\u0ae0' <= yyC) && (yyC <= '\u0ae1')) ||
          (('\u0b05' <= yyC) && (yyC <= '\u0b0c')) ||
          (('\u0b0f' <= yyC) && (yyC <= '\u0b10')) ||
          (('\u0b13' <= yyC) && (yyC <= '\u0b28')) ||
          (('\u0b2a' <= yyC) && (yyC <= '\u0b30')) ||
          (('\u0b32' <= yyC) && (yyC <= '\u0b33')) ||
          (('\u0b35' <= yyC) && (yyC <= '\u0b39')) ||
          ('\u0b3d' == yyC) ||
          (('\u0b5c' <= yyC) && (yyC <= '\u0b5d')) ||
          (('\u0b5f' <= yyC) && (yyC <= '\u0b61')) ||
          ('\u0b71' == yyC) ||
          ('\u0b83' == yyC) ||
          (('\u0b85' <= yyC) && (yyC <= '\u0b8a')) ||
          (('\u0b8e' <= yyC) && (yyC <= '\u0b90')) ||
          (('\u0b92' <= yyC) && (yyC <= '\u0b95')) ||
          (('\u0b99' <= yyC) && (yyC <= '\u0b9a')) ||
          ('\u0b9c' == yyC) ||
          (('\u0b9e' <= yyC) && (yyC <= '\u0b9f')) ||
          (('\u0ba3' <= yyC) && (yyC <= '\u0ba4')) ||
          (('\u0ba8' <= yyC) && (yyC <= '\u0baa')) ||
          (('\u0bae' <= yyC) && (yyC <= '\u0bb9')) ||
          (('\u0c05' <= yyC) && (yyC <= '\u0c0c')) ||
          (('\u0c0e' <= yyC) && (yyC <= '\u0c10')) ||
          (('\u0c12' <= yyC) && (yyC <= '\u0c28')) ||
          (('\u0c2a' <= yyC) && (yyC <= '\u0c33')) ||
          (('\u0c35' <= yyC) && (yyC <= '\u0c39')) ||
          (('\u0c60' <= yyC) && (yyC <= '\u0c61')) ||
          (('\u0c85' <= yyC) && (yyC <= '\u0c8c')) ||
          (('\u0c8e' <= yyC) && (yyC <= '\u0c90')) ||
          (('\u0c92' <= yyC) && (yyC <= '\u0ca8')) ||
          (('\u0caa' <= yyC) && (yyC <= '\u0cb3')) ||
          (('\u0cb5' <= yyC) && (yyC <= '\u0cb9')) ||
          ('\u0cbd' == yyC) ||
          ('\u0cde' == yyC) ||
          (('\u0ce0' <= yyC) && (yyC <= '\u0ce1')) ||
          (('\u0d05' <= yyC) && (yyC <= '\u0d0c')) ||
          (('\u0d0e' <= yyC) && (yyC <= '\u0d10')) ||
          (('\u0d12' <= yyC) && (yyC <= '\u0d28')) ||
          (('\u0d2a' <= yyC) && (yyC <= '\u0d39')) ||
          (('\u0d60' <= yyC) && (yyC <= '\u0d61')) ||
          (('\u0d85' <= yyC) && (yyC <= '\u0d96')) ||
          (('\u0d9a' <= yyC) && (yyC <= '\u0db1')) ||
          (('\u0db3' <= yyC) && (yyC <= '\u0dbb')) ||
          ('\u0dbd' == yyC) ||
          (('\u0dc0' <= yyC) && (yyC <= '\u0dc6')) ||
          (('\u0e01' <= yyC) && (yyC <= '\u0e30')) ||
          (('\u0e32' <= yyC) && (yyC <= '\u0e33')) ||
          (('\u0e40' <= yyC) && (yyC <= '\u0e46')) ||
          (('\u0e81' <= yyC) && (yyC <= '\u0e82')) ||
          ('\u0e84' == yyC) ||
          (('\u0e87' <= yyC) && (yyC <= '\u0e88')) ||
          ('\u0e8a' == yyC) ||
          ('\u0e8d' == yyC) ||
          (('\u0e94' <= yyC) && (yyC <= '\u0e97')) ||
          (('\u0e99' <= yyC) && (yyC <= '\u0e9f')) ||
          (('\u0ea1' <= yyC) && (yyC <= '\u0ea3')) ||
          ('\u0ea5' == yyC) ||
          ('\u0ea7' == yyC) ||
          (('\u0eaa' <= yyC) && (yyC <= '\u0eab')) ||
          (('\u0ead' <= yyC) && (yyC <= '\u0eb0')) ||
          (('\u0eb2' <= yyC) && (yyC <= '\u0eb3')) ||
          ('\u0ebd' == yyC) ||
          (('\u0ec0' <= yyC) && (yyC <= '\u0ec4')) ||
          ('\u0ec6' == yyC) ||
          (('\u0edc' <= yyC) && (yyC <= '\u0edd')) ||
          ('\u0f00' == yyC) ||
          (('\u0f40' <= yyC) && (yyC <= '\u0f47')) ||
          (('\u0f49' <= yyC) && (yyC <= '\u0f6a')) ||
          (('\u0f88' <= yyC) && (yyC <= '\u0f8b')) ||
          (('\u1000' <= yyC) && (yyC <= '\u1021')) ||
          (('\u1023' <= yyC) && (yyC <= '\u1027')) ||
          (('\u1029' <= yyC) && (yyC <= '\u102a')) ||
          (('\u1050' <= yyC) && (yyC <= '\u1055')) ||
          (('\u10a0' <= yyC) && (yyC <= '\u10c5')) ||
          (('\u10d0' <= yyC) && (yyC <= '\u10fa')) ||
          ('\u10fc' == yyC) ||
          (('\u1100' <= yyC) && (yyC <= '\u1159')) ||
          (('\u115f' <= yyC) && (yyC <= '\u11a2')) ||
          (('\u11a8' <= yyC) && (yyC <= '\u11f9')) ||
          (('\u1200' <= yyC) && (yyC <= '\u1248')) ||
          (('\u124a' <= yyC) && (yyC <= '\u124d')) ||
          (('\u1250' <= yyC) && (yyC <= '\u1256')) ||
          ('\u1258' == yyC) ||
          (('\u125a' <= yyC) && (yyC <= '\u125d')) ||
          (('\u1260' <= yyC) && (yyC <= '\u1288')) ||
          (('\u128a' <= yyC) && (yyC <= '\u128d')) ||
          (('\u1290' <= yyC) && (yyC <= '\u12b0')) ||
          (('\u12b2' <= yyC) && (yyC <= '\u12b5')) ||
          (('\u12b8' <= yyC) && (yyC <= '\u12be')) ||
          ('\u12c0' == yyC) ||
          (('\u12c2' <= yyC) && (yyC <= '\u12c5')) ||
          (('\u12c8' <= yyC) && (yyC <= '\u12d6')) ||
          (('\u12d8' <= yyC) && (yyC <= '\u1310')) ||
          (('\u1312' <= yyC) && (yyC <= '\u1315')) ||
          (('\u1318' <= yyC) && (yyC <= '\u135a')) ||
          (('\u1380' <= yyC) && (yyC <= '\u138f')) ||
          (('\u13a0' <= yyC) && (yyC <= '\u13f4')) ||
          (('\u1401' <= yyC) && (yyC <= '\u166c')) ||
          (('\u166f' <= yyC) && (yyC <= '\u1676')) ||
          (('\u1681' <= yyC) && (yyC <= '\u169a')) ||
          (('\u16a0' <= yyC) && (yyC <= '\u16ea')) ||
          (('\u16ee' <= yyC) && (yyC <= '\u16f0')) ||
          (('\u1700' <= yyC) && (yyC <= '\u170c')) ||
          (('\u170e' <= yyC) && (yyC <= '\u1711')) ||
          (('\u1720' <= yyC) && (yyC <= '\u1731')) ||
          (('\u1740' <= yyC) && (yyC <= '\u1751')) ||
          (('\u1760' <= yyC) && (yyC <= '\u176c')) ||
          (('\u176e' <= yyC) && (yyC <= '\u1770')) ||
          (('\u1780' <= yyC) && (yyC <= '\u17b3')) ||
          ('\u17d7' == yyC) ||
          ('\u17dc' == yyC) ||
          (('\u1820' <= yyC) && (yyC <= '\u1877')) ||
          (('\u1880' <= yyC) && (yyC <= '\u18a8')) ||
          (('\u1900' <= yyC) && (yyC <= '\u191c')) ||
          (('\u1950' <= yyC) && (yyC <= '\u196d')) ||
          (('\u1970' <= yyC) && (yyC <= '\u1974')) ||
          (('\u1980' <= yyC) && (yyC <= '\u19a9')) ||
          (('\u19c1' <= yyC) && (yyC <= '\u19c7')) ||
          (('\u1a00' <= yyC) && (yyC <= '\u1a16')) ||
          (('\u1b05' <= yyC) && (yyC <= '\u1b33')) ||
          (('\u1b45' <= yyC) && (yyC <= '\u1b4b')) ||
          (('\u1d00' <= yyC) && (yyC <= '\u1dbf')) ||
          (('\u1e00' <= yyC) && (yyC <= '\u1e9b')) ||
          (('\u1ea0' <= yyC) && (yyC <= '\u1ef9')) ||
          (('\u1f00' <= yyC) && (yyC <= '\u1f15')) ||
          (('\u1f18' <= yyC) && (yyC <= '\u1f1d')) ||
          (('\u1f20' <= yyC) && (yyC <= '\u1f45')) ||
          (('\u1f48' <= yyC) && (yyC <= '\u1f4d')) ||
          (('\u1f50' <= yyC) && (yyC <= '\u1f57')) ||
          ('\u1f59' == yyC) ||
          ('\u1f5b' == yyC) ||
          ('\u1f5d' == yyC) ||
          (('\u1f5f' <= yyC) && (yyC <= '\u1f7d')) ||
          (('\u1f80' <= yyC) && (yyC <= '\u1fb4')) ||
          (('\u1fb6' <= yyC) && (yyC <= '\u1fbc')) ||
          ('\u1fbe' == yyC) ||
          (('\u1fc2' <= yyC) && (yyC <= '\u1fc4')) ||
          (('\u1fc6' <= yyC) && (yyC <= '\u1fcc')) ||
          (('\u1fd0' <= yyC) && (yyC <= '\u1fd3')) ||
          (('\u1fd6' <= yyC) && (yyC <= '\u1fdb')) ||
          (('\u1fe0' <= yyC) && (yyC <= '\u1fec')) ||
          (('\u1ff2' <= yyC) && (yyC <= '\u1ff4')) ||
          (('\u1ff6' <= yyC) && (yyC <= '\u1ffc')) ||
          ('\u2071' == yyC) ||
          ('\u207f' == yyC) ||
          (('\u2090' <= yyC) && (yyC <= '\u2094')) ||
          ('\u2102' == yyC) ||
          ('\u2107' == yyC) ||
          (('\u210a' <= yyC) && (yyC <= '\u2113')) ||
          ('\u2115' == yyC) ||
          (('\u2119' <= yyC) && (yyC <= '\u211d')) ||
          ('\u2124' == yyC) ||
          ('\u2126' == yyC) ||
          ('\u2128' == yyC) ||
          (('\u212a' <= yyC) && (yyC <= '\u212d')) ||
          (('\u212f' <= yyC) && (yyC <= '\u2139')) ||
          (('\u213c' <= yyC) && (yyC <= '\u213f')) ||
          (('\u2145' <= yyC) && (yyC <= '\u2149')) ||
          ('\u214e' == yyC) ||
          (('\u2160' <= yyC) && (yyC <= '\u2184')) ||
          (('\u2c00' <= yyC) && (yyC <= '\u2c2e')) ||
          (('\u2c30' <= yyC) && (yyC <= '\u2c5e')) ||
          (('\u2c60' <= yyC) && (yyC <= '\u2c6c')) ||
          (('\u2c74' <= yyC) && (yyC <= '\u2c77')) ||
          (('\u2c80' <= yyC) && (yyC <= '\u2ce4')) ||
          (('\u2d00' <= yyC) && (yyC <= '\u2d25')) ||
          (('\u2d30' <= yyC) && (yyC <= '\u2d65')) ||
          ('\u2d6f' == yyC) ||
          (('\u2d80' <= yyC) && (yyC <= '\u2d96')) ||
          (('\u2da0' <= yyC) && (yyC <= '\u2da6')) ||
          (('\u2da8' <= yyC) && (yyC <= '\u2dae')) ||
          (('\u2db0' <= yyC) && (yyC <= '\u2db6')) ||
          (('\u2db8' <= yyC) && (yyC <= '\u2dbe')) ||
          (('\u2dc0' <= yyC) && (yyC <= '\u2dc6')) ||
          (('\u2dc8' <= yyC) && (yyC <= '\u2dce')) ||
          (('\u2dd0' <= yyC) && (yyC <= '\u2dd6')) ||
          (('\u2dd8' <= yyC) && (yyC <= '\u2dde')) ||
          (('\u3005' <= yyC) && (yyC <= '\u3007')) ||
          (('\u3021' <= yyC) && (yyC <= '\u3029')) ||
          (('\u3031' <= yyC) && (yyC <= '\u3035')) ||
          (('\u3038' <= yyC) && (yyC <= '\u303c')) ||
          (('\u3041' <= yyC) && (yyC <= '\u3096')) ||
          (('\u309d' <= yyC) && (yyC <= '\u309f')) ||
          (('\u30a1' <= yyC) && (yyC <= '\u30fa')) ||
          (('\u30fc' <= yyC) && (yyC <= '\u30ff')) ||
          (('\u3105' <= yyC) && (yyC <= '\u312c')) ||
          (('\u3131' <= yyC) && (yyC <= '\u318e')) ||
          (('\u31a0' <= yyC) && (yyC <= '\u31b7')) ||
          (('\u31f0' <= yyC) && (yyC <= '\u31ff')) ||
          ('\u3400' == yyC) ||
          ('\u4db5' == yyC) ||
          ('\u4e00' == yyC) ||
          ('\u9fbb' == yyC) ||
          (('\ua000' <= yyC) && (yyC <= '\ua48c')) ||
          (('\ua717' <= yyC) && (yyC <= '\ua71a')) ||
          (('\ua800' <= yyC) && (yyC <= '\ua801')) ||
          (('\ua803' <= yyC) && (yyC <= '\ua805')) ||
          (('\ua807' <= yyC) && (yyC <= '\ua80a')) ||
          (('\ua80c' <= yyC) && (yyC <= '\ua822')) ||
          (('\ua840' <= yyC) && (yyC <= '\ua873')) ||
          ('\uac00' == yyC) ||
          ('\ud7a3' == yyC) ||
          (('\uf900' <= yyC) && (yyC <= '\ufa2d')) ||
          (('\ufa30' <= yyC) && (yyC <= '\ufa6a')) ||
          (('\ufa70' <= yyC) && (yyC <= '\ufad9')) ||
          (('\ufb00' <= yyC) && (yyC <= '\ufb06')) ||
          (('\ufb13' <= yyC) && (yyC <= '\ufb17')) ||
          ('\ufb1d' == yyC) ||
          (('\ufb1f' <= yyC) && (yyC <= '\ufb28')) ||
          (('\ufb2a' <= yyC) && (yyC <= '\ufb36')) ||
          (('\ufb38' <= yyC) && (yyC <= '\ufb3c')) ||
          ('\ufb3e' == yyC) ||
          (('\ufb40' <= yyC) && (yyC <= '\ufb41')) ||
          (('\ufb43' <= yyC) && (yyC <= '\ufb44')) ||
          (('\ufb46' <= yyC) && (yyC <= '\ufbb1')) ||
          (('\ufbd3' <= yyC) && (yyC <= '\ufd3d')) ||
          (('\ufd50' <= yyC) && (yyC <= '\ufd8f')) ||
          (('\ufd92' <= yyC) && (yyC <= '\ufdc7')) ||
          (('\ufdf0' <= yyC) && (yyC <= '\ufdfb')) ||
          (('\ufe70' <= yyC) && (yyC <= '\ufe74')) ||
          (('\ufe76' <= yyC) && (yyC <= '\ufefc')) ||
          (('\uff21' <= yyC) && (yyC <= '\uff3a')) ||
          (('\uff41' <= yyC) && (yyC <= '\uff5a')) ||
          (('\uff66' <= yyC) && (yyC <= '\uffbe')) ||
          (('\uffc2' <= yyC) && (yyC <= '\uffc7')) ||
          (('\uffca' <= yyC) && (yyC <= '\uffcf')) ||
          (('\uffd2' <= yyC) && (yyC <= '\uffd7')) ||
          (('\uffda' <= yyC) && (yyC <= '\uffdc'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud800':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc0b')) ||
                (('\udc0d' <= yyC) && (yyC <= '\udc26')) ||
                (('\udc28' <= yyC) && (yyC <= '\udc3a')) ||
                (('\udc3c' <= yyC) && (yyC <= '\udc3d')) ||
                (('\udc3f' <= yyC) && (yyC <= '\udc4d')) ||
                (('\udc50' <= yyC) && (yyC <= '\udc5d')) ||
                (('\udc80' <= yyC) && (yyC <= '\udcfa')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd74')) ||
                (('\udf00' <= yyC) && (yyC <= '\udf1e')) ||
                (('\udf30' <= yyC) && (yyC <= '\udf4a')) ||
                (('\udf80' <= yyC) && (yyC <= '\udf9d')) ||
                (('\udfa0' <= yyC) && (yyC <= '\udfc3')) ||
                (('\udfc8' <= yyC) && (yyC <= '\udfcf')) ||
                (('\udfd1' <= yyC) && (yyC <= '\udfd5'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc9d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc05')) ||
                ('\udc08' == yyC) ||
                (('\udc0a' <= yyC) && (yyC <= '\udc35')) ||
                (('\udc37' <= yyC) && (yyC <= '\udc38')) ||
                ('\udc3c' == yyC) ||
                ('\udc3f' == yyC) ||
                (('\udd00' <= yyC) && (yyC <= '\udd15')) ||
                ('\ude00' == yyC) ||
                (('\ude10' <= yyC) && (yyC <= '\ude13')) ||
                (('\ude15' <= yyC) && (yyC <= '\ude17')) ||
                (('\ude19' <= yyC) && (yyC <= '\ude33'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud808':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udf6e')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud809':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc62')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc54')) ||
                (('\udc56' <= yyC) && (yyC <= '\udc9c')) ||
                (('\udc9e' <= yyC) && (yyC <= '\udc9f')) ||
                ('\udca2' == yyC) ||
                (('\udca5' <= yyC) && (yyC <= '\udca6')) ||
                (('\udca9' <= yyC) && (yyC <= '\udcac')) ||
                (('\udcae' <= yyC) && (yyC <= '\udcb9')) ||
                ('\udcbb' == yyC) ||
                (('\udcbd' <= yyC) && (yyC <= '\udcc3')) ||
                (('\udcc5' <= yyC) && (yyC <= '\udd05')) ||
                (('\udd07' <= yyC) && (yyC <= '\udd0a')) ||
                (('\udd0d' <= yyC) && (yyC <= '\udd14')) ||
                (('\udd16' <= yyC) && (yyC <= '\udd1c')) ||
                (('\udd1e' <= yyC) && (yyC <= '\udd39')) ||
                (('\udd3b' <= yyC) && (yyC <= '\udd3e')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd44')) ||
                ('\udd46' == yyC) ||
                (('\udd4a' <= yyC) && (yyC <= '\udd50')) ||
                (('\udd52' <= yyC) && (yyC <= '\udea5')) ||
                (('\udea8' <= yyC) && (yyC <= '\udec0')) ||
                (('\udec2' <= yyC) && (yyC <= '\udeda')) ||
                (('\udedc' <= yyC) && (yyC <= '\udefa')) ||
                (('\udefc' <= yyC) && (yyC <= '\udf14')) ||
                (('\udf16' <= yyC) && (yyC <= '\udf34')) ||
                (('\udf36' <= yyC) && (yyC <= '\udf4e')) ||
                (('\udf50' <= yyC) && (yyC <= '\udf6e')) ||
                (('\udf70' <= yyC) && (yyC <= '\udf88')) ||
                (('\udf8a' <= yyC) && (yyC <= '\udfa8')) ||
                (('\udfaa' <= yyC) && (yyC <= '\udfc2')) ||
                (('\udfc4' <= yyC) && (yyC <= '\udfcb'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud840':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\udc00' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud869':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\uded6' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud87e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\ude1d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\'':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          ('_' == yyC) ||
          ('\u00ad' == yyC) ||
          (('\u0300' <= yyC) && (yyC <= '\u036f')) ||
          (('\u0483' <= yyC) && (yyC <= '\u0486')) ||
          (('\u0591' <= yyC) && (yyC <= '\u05bd')) ||
          ('\u05bf' == yyC) ||
          (('\u05c1' <= yyC) && (yyC <= '\u05c2')) ||
          (('\u05c4' <= yyC) && (yyC <= '\u05c5')) ||
          ('\u05c7' == yyC) ||
          (('\u0600' <= yyC) && (yyC <= '\u0603')) ||
          (('\u0610' <= yyC) && (yyC <= '\u0615')) ||
          (('\u064b' <= yyC) && (yyC <= '\u065e')) ||
          (('\u0660' <= yyC) && (yyC <= '\u0669')) ||
          ('\u0670' == yyC) ||
          (('\u06d6' <= yyC) && (yyC <= '\u06dd')) ||
          (('\u06df' <= yyC) && (yyC <= '\u06e4')) ||
          (('\u06e7' <= yyC) && (yyC <= '\u06e8')) ||
          (('\u06ea' <= yyC) && (yyC <= '\u06ed')) ||
          (('\u06f0' <= yyC) && (yyC <= '\u06f9')) ||
          ('\u070f' == yyC) ||
          ('\u0711' == yyC) ||
          (('\u0730' <= yyC) && (yyC <= '\u074a')) ||
          (('\u07a6' <= yyC) && (yyC <= '\u07b0')) ||
          (('\u07c0' <= yyC) && (yyC <= '\u07c9')) ||
          (('\u07eb' <= yyC) && (yyC <= '\u07f3')) ||
          (('\u0901' <= yyC) && (yyC <= '\u0903')) ||
          ('\u093c' == yyC) ||
          (('\u093e' <= yyC) && (yyC <= '\u094d')) ||
          (('\u0951' <= yyC) && (yyC <= '\u0954')) ||
          (('\u0962' <= yyC) && (yyC <= '\u0963')) ||
          (('\u0966' <= yyC) && (yyC <= '\u096f')) ||
          (('\u0981' <= yyC) && (yyC <= '\u0983')) ||
          ('\u09bc' == yyC) ||
          (('\u09be' <= yyC) && (yyC <= '\u09c4')) ||
          (('\u09c7' <= yyC) && (yyC <= '\u09c8')) ||
          (('\u09cb' <= yyC) && (yyC <= '\u09cd')) ||
          ('\u09d7' == yyC) ||
          (('\u09e2' <= yyC) && (yyC <= '\u09e3')) ||
          (('\u09e6' <= yyC) && (yyC <= '\u09ef')) ||
          (('\u0a01' <= yyC) && (yyC <= '\u0a03')) ||
          ('\u0a3c' == yyC) ||
          (('\u0a3e' <= yyC) && (yyC <= '\u0a42')) ||
          (('\u0a47' <= yyC) && (yyC <= '\u0a48')) ||
          (('\u0a4b' <= yyC) && (yyC <= '\u0a4d')) ||
          (('\u0a66' <= yyC) && (yyC <= '\u0a71')) ||
          (('\u0a81' <= yyC) && (yyC <= '\u0a83')) ||
          ('\u0abc' == yyC) ||
          (('\u0abe' <= yyC) && (yyC <= '\u0ac5')) ||
          (('\u0ac7' <= yyC) && (yyC <= '\u0ac9')) ||
          (('\u0acb' <= yyC) && (yyC <= '\u0acd')) ||
          (('\u0ae2' <= yyC) && (yyC <= '\u0ae3')) ||
          (('\u0ae6' <= yyC) && (yyC <= '\u0aef')) ||
          (('\u0b01' <= yyC) && (yyC <= '\u0b03')) ||
          ('\u0b3c' == yyC) ||
          (('\u0b3e' <= yyC) && (yyC <= '\u0b43')) ||
          (('\u0b47' <= yyC) && (yyC <= '\u0b48')) ||
          (('\u0b4b' <= yyC) && (yyC <= '\u0b4d')) ||
          (('\u0b56' <= yyC) && (yyC <= '\u0b57')) ||
          (('\u0b66' <= yyC) && (yyC <= '\u0b6f')) ||
          ('\u0b82' == yyC) ||
          (('\u0bbe' <= yyC) && (yyC <= '\u0bc2')) ||
          (('\u0bc6' <= yyC) && (yyC <= '\u0bc8')) ||
          (('\u0bca' <= yyC) && (yyC <= '\u0bcd')) ||
          ('\u0bd7' == yyC) ||
          (('\u0be6' <= yyC) && (yyC <= '\u0bef')) ||
          (('\u0c01' <= yyC) && (yyC <= '\u0c03')) ||
          (('\u0c3e' <= yyC) && (yyC <= '\u0c44')) ||
          (('\u0c46' <= yyC) && (yyC <= '\u0c48')) ||
          (('\u0c4a' <= yyC) && (yyC <= '\u0c4d')) ||
          (('\u0c55' <= yyC) && (yyC <= '\u0c56')) ||
          (('\u0c66' <= yyC) && (yyC <= '\u0c6f')) ||
          (('\u0c82' <= yyC) && (yyC <= '\u0c83')) ||
          ('\u0cbc' == yyC) ||
          (('\u0cbe' <= yyC) && (yyC <= '\u0cc4')) ||
          (('\u0cc6' <= yyC) && (yyC <= '\u0cc8')) ||
          (('\u0cca' <= yyC) && (yyC <= '\u0ccd')) ||
          (('\u0cd5' <= yyC) && (yyC <= '\u0cd6')) ||
          (('\u0ce2' <= yyC) && (yyC <= '\u0ce3')) ||
          (('\u0ce6' <= yyC) && (yyC <= '\u0cef')) ||
          (('\u0d02' <= yyC) && (yyC <= '\u0d03')) ||
          (('\u0d3e' <= yyC) && (yyC <= '\u0d43')) ||
          (('\u0d46' <= yyC) && (yyC <= '\u0d48')) ||
          (('\u0d4a' <= yyC) && (yyC <= '\u0d4d')) ||
          ('\u0d57' == yyC) ||
          (('\u0d66' <= yyC) && (yyC <= '\u0d6f')) ||
          (('\u0d82' <= yyC) && (yyC <= '\u0d83')) ||
          ('\u0dca' == yyC) ||
          (('\u0dcf' <= yyC) && (yyC <= '\u0dd4')) ||
          ('\u0dd6' == yyC) ||
          (('\u0dd8' <= yyC) && (yyC <= '\u0ddf')) ||
          (('\u0df2' <= yyC) && (yyC <= '\u0df3')) ||
          ('\u0e31' == yyC) ||
          (('\u0e34' <= yyC) && (yyC <= '\u0e3a')) ||
          (('\u0e47' <= yyC) && (yyC <= '\u0e4e')) ||
          (('\u0e50' <= yyC) && (yyC <= '\u0e59')) ||
          ('\u0eb1' == yyC) ||
          (('\u0eb4' <= yyC) && (yyC <= '\u0eb9')) ||
          (('\u0ebb' <= yyC) && (yyC <= '\u0ebc')) ||
          (('\u0ec8' <= yyC) && (yyC <= '\u0ecd')) ||
          (('\u0ed0' <= yyC) && (yyC <= '\u0ed9')) ||
          (('\u0f18' <= yyC) && (yyC <= '\u0f19')) ||
          (('\u0f20' <= yyC) && (yyC <= '\u0f29')) ||
          ('\u0f35' == yyC) ||
          ('\u0f37' == yyC) ||
          ('\u0f39' == yyC) ||
          (('\u0f3e' <= yyC) && (yyC <= '\u0f3f')) ||
          (('\u0f71' <= yyC) && (yyC <= '\u0f84')) ||
          (('\u0f86' <= yyC) && (yyC <= '\u0f87')) ||
          (('\u0f90' <= yyC) && (yyC <= '\u0f97')) ||
          (('\u0f99' <= yyC) && (yyC <= '\u0fbc')) ||
          ('\u0fc6' == yyC) ||
          (('\u102c' <= yyC) && (yyC <= '\u1032')) ||
          (('\u1036' <= yyC) && (yyC <= '\u1039')) ||
          (('\u1040' <= yyC) && (yyC <= '\u1049')) ||
          (('\u1056' <= yyC) && (yyC <= '\u1059')) ||
          ('\u135f' == yyC) ||
          (('\u1712' <= yyC) && (yyC <= '\u1714')) ||
          (('\u1732' <= yyC) && (yyC <= '\u1734')) ||
          (('\u1752' <= yyC) && (yyC <= '\u1753')) ||
          (('\u1772' <= yyC) && (yyC <= '\u1773')) ||
          (('\u17b4' <= yyC) && (yyC <= '\u17d3')) ||
          ('\u17dd' == yyC) ||
          (('\u17e0' <= yyC) && (yyC <= '\u17e9')) ||
          (('\u180b' <= yyC) && (yyC <= '\u180d')) ||
          (('\u1810' <= yyC) && (yyC <= '\u1819')) ||
          ('\u18a9' == yyC) ||
          (('\u1920' <= yyC) && (yyC <= '\u192b')) ||
          (('\u1930' <= yyC) && (yyC <= '\u193b')) ||
          (('\u1946' <= yyC) && (yyC <= '\u194f')) ||
          (('\u19b0' <= yyC) && (yyC <= '\u19c0')) ||
          (('\u19c8' <= yyC) && (yyC <= '\u19c9')) ||
          (('\u19d0' <= yyC) && (yyC <= '\u19d9')) ||
          (('\u1a17' <= yyC) && (yyC <= '\u1a1b')) ||
          (('\u1b00' <= yyC) && (yyC <= '\u1b04')) ||
          (('\u1b34' <= yyC) && (yyC <= '\u1b44')) ||
          (('\u1b50' <= yyC) && (yyC <= '\u1b59')) ||
          (('\u1b6b' <= yyC) && (yyC <= '\u1b73')) ||
          (('\u1dc0' <= yyC) && (yyC <= '\u1dca')) ||
          (('\u1dfe' <= yyC) && (yyC <= '\u1dff')) ||
          (('\u200b' <= yyC) && (yyC <= '\u200f')) ||
          (('\u202a' <= yyC) && (yyC <= '\u202e')) ||
          (('\u203f' <= yyC) && (yyC <= '\u2040')) ||
          ('\u2054' == yyC) ||
          (('\u2060' <= yyC) && (yyC <= '\u2063')) ||
          (('\u206a' <= yyC) && (yyC <= '\u206f')) ||
          (('\u20d0' <= yyC) && (yyC <= '\u20dc')) ||
          ('\u20e1' == yyC) ||
          (('\u20e5' <= yyC) && (yyC <= '\u20ef')) ||
          (('\u302a' <= yyC) && (yyC <= '\u302f')) ||
          (('\u3099' <= yyC) && (yyC <= '\u309a')) ||
          ('\ua802' == yyC) ||
          ('\ua806' == yyC) ||
          ('\ua80b' == yyC) ||
          (('\ua823' <= yyC) && (yyC <= '\ua827')) ||
          ('\ufb1e' == yyC) ||
          (('\ufe00' <= yyC) && (yyC <= '\ufe0f')) ||
          (('\ufe20' <= yyC) && (yyC <= '\ufe23')) ||
          (('\ufe33' <= yyC) && (yyC <= '\ufe34')) ||
          (('\ufe4d' <= yyC) && (yyC <= '\ufe4f')) ||
          ('\ufeff' == yyC) ||
          (('\uff10' <= yyC) && (yyC <= '\uff19')) ||
          ('\uff3f' == yyC) ||
          (('\ufff9' <= yyC) && (yyC <= '\ufffb'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '\udca0':
            case '\udca1':
            case '\udca2':
            case '\udca3':
            case '\udca4':
            case '\udca5':
            case '\udca6':
            case '\udca7':
            case '\udca8':
            case '\udca9':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '\ude01':
            case '\ude02':
            case '\ude03':
            case '\ude05':
            case '\ude06':
            case '\ude0c':
            case '\ude0d':
            case '\ude0e':
            case '\ude0f':
            case '\ude38':
            case '\ude39':
            case '\ude3a':
            case '\ude3f':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '\ud834':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udd65' <= yyC) && (yyC <= '\udd69')) ||
                (('\udd6d' <= yyC) && (yyC <= '\udd82')) ||
                (('\udd85' <= yyC) && (yyC <= '\udd8b')) ||
                (('\uddaa' <= yyC) && (yyC <= '\uddad')) ||
                (('\ude42' <= yyC) && (yyC <= '\ude44'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udfce' <= yyC) && (yyC <= '\udfff')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\udb40':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc01' == yyC) ||
                (('\udc20' <= yyC) && (yyC <= '\udc7f')) ||
                (('\udd00' <= yyC) && (yyC <= '\uddef'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("idrest expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.IdText.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdText(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      if (!FortressUtil.validOp(a1) && !a1.equals("_")) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("id text expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.Id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pId(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fId) yyColumn.chunk17.fId = pId$1(yyStart);
    return yyColumn.chunk17.fId;
  }

  /** Actually parse Identifier.Id. */
  private Result pId$1(final int yyStart) throws IOException {
    Result     yyResult;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = new Id(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.BindId.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBindId(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fBindId) 
      yyColumn.chunk17.fBindId = pBindId$1(yyStart);
    return yyColumn.chunk17.fBindId;
  }

  /** Actually parse Identifier.BindId. */
  private Result pBindId$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;
      String a1 = "_";

      yyValue = new Id(createSpan(yyStart,yyCount), a1);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("bind id expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.BindIdList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBindIdList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Id>   yyRepValue1;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pBindId(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Id v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Id>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Id> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.BindIdOrBindIdTuple.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBindIdOrBindIdTuple(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fBindIdOrBindIdTuple) 
      yyColumn.chunk17.fBindIdOrBindIdTuple = pBindIdOrBindIdTuple$1(yyStart);
    return yyColumn.chunk17.fBindIdOrBindIdTuple;
  }

  /** Actually parse Identifier.BindIdOrBindIdTuple. */
  private Result pBindIdOrBindIdTuple$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBindId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcomma(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pBindIdList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Id> a2s = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyValue = FortressUtil.mkList(a1, a2s);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.Name.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pName(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fName) 
      yyColumn.chunk18.fName = pName$1(yyStart);
    return yyColumn.chunk18.fName;
  }

  /** Actually parse Identifier.Name. */
  private Result pName$1(final int yyStart) throws IOException {
    Result     yyResult;
    SimpleName yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeIdName(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a1 = yyResult.semanticValue();

          yyValue = NodeFactory.makeOpr(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.DottedName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDottedName(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fDottedName) 
      yyColumn.chunk18.fDottedName = pDottedName$1(yyStart);
    return yyColumn.chunk18.fDottedName;
  }

  /** Actually parse Identifier.DottedName. */
  private Result pDottedName$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    DottedName yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyPredResult = pw(yyResult.index);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyPredResult = pellipses(yyPredResult.index);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyValue = NodeFactory.makeDottedName(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = p$$Shared27(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Id> a1s = yyResult.semanticValue();

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id a2 = yyResult.semanticValue();

        yyValue = NodeFactory.makeDottedName(createSpan(yyStart,yyCount),
        IterUtil.compose(a1s.list(), a2));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.$$Shared27.
   * This nonterminal represents the duplicate productions 
   * PreFortress.DottedName$$Star1 and PreFortress.QualifiedName$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared27(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.f$$Shared27) 
      yyColumn.chunk18.f$$Shared27 = p$$Shared27$1(yyStart);
    return yyColumn.chunk18.f$$Shared27;
  }

  /** Actually parse PreFortress.$$Shared27. */
  private Result p$$Shared27$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id v$el$1 = yyResult.semanticValue();

      yyResult = pdot(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared27(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Id> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Id>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.QualifiedName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualifiedName(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fQualifiedName) 
      yyColumn.chunk18.fQualifiedName = pQualifiedName$1(yyStart);
    return yyColumn.chunk18.fQualifiedName;
  }

  /** Actually parse Identifier.QualifiedName. */
  private Result pQualifiedName$1(final int yyStart) throws IOException {
    Result          yyResult;
    Result          yyPredResult;
    QualifiedIdName yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyPredResult = pw(yyResult.index);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyPredResult = pellipses(yyPredResult.index);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyValue = NodeFactory.makeQualifiedIdName(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = p$$Shared27(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Id> a1s = yyResult.semanticValue();

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id a2 = yyResult.semanticValue();

        yyValue = NodeFactory.makeQualifiedIdName(createSpan(yyStart,yyCount),
        a1s.list(), a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.Encloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEncloser(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fEncloser) 
      yyColumn.chunk18.fEncloser = pEncloser$1(yyStart);
    return yyColumn.chunk18.fEncloser;
  }

  /** Actually parse Symbol.Encloser. */
  private Result pEncloser$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pencloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOp(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.LeftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLeftEncloser(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fLeftEncloser) 
      yyColumn.chunk18.fLeftEncloser = pLeftEncloser$1(yyStart);
    return yyColumn.chunk18.fLeftEncloser;
  }

  /** Actually parse Symbol.LeftEncloser. */
  private Result pLeftEncloser$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pleftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOp(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.RightEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRightEncloser(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fRightEncloser) 
      yyColumn.chunk18.fRightEncloser = pRightEncloser$1(yyStart);
    return yyColumn.chunk18.fRightEncloser;
  }

  /** Actually parse Symbol.RightEncloser. */
  private Result pRightEncloser$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = prightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOp(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.ExponentOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponentOp(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fExponentOp) 
      yyColumn.chunk18.fExponentOp = pExponentOp$1(yyStart);
    return yyColumn.chunk18.fExponentOp;
  }

  /** Actually parse Symbol.ExponentOp. */
  private Result pExponentOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexponentOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOp(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.bar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyPredIndex;
    Result     yyPredResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyPredIndex = yyStart + 1;

      yyPredResult = pwr(yyPredIndex);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyPredResult = pNoNewlineExpr$GeneratorList(yyPredResult.index);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyPredResult = pclosingComprehension(yyPredResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyC = character(yyStart);
            if ('|' == yyC) {
              yyIndex = yyStart + 1;

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("bar expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closingComprehension.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosingComprehension(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '}':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case '|':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('>' == yyC) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }
    }

    // Alternative 2.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pArrayComprehensionClause(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (']' == yyC) {
        yyIndex = yyResult.index + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("\"]\" expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("closing comprehension expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.sd.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psd(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyC = character(yyOption1);
    if (-1 != yyC) {
      yyIndex = yyOption1 + 1;

      switch (yyC) {
      case '*':
      case '.':
        {
          yyOption1  = yyIndex;
        }

      default:
        /* No match. */
      }
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyOption1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.bars.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbars(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fbars) 
      yyColumn.chunk18.fbars = pbars$1(yyStart);
    return yyColumn.chunk18.fbars;
  }

  /** Actually parse Symbol.bars. */
  private Result pbars$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pbars$$Star1(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bars expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.bars$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbars$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fbars$$Star1) 
      yyColumn.chunk18.fbars$$Star1 = pbars$$Star1$1(yyStart);
    return yyColumn.chunk18.fbars$$Star1;
  }

  /** Actually parse PreFortress.bars$$Star1. */
  private Result pbars$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psd(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('|' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pbars$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\"|\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.slashes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pslashes(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fslashes) 
      yyColumn.chunk19.fslashes = pslashes$1(yyStart);
    return yyColumn.chunk19.fslashes;
  }

  /** Actually parse Symbol.slashes. */
  private Result pslashes$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '/':
        {
          yyResult = pslashes$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      case '\\':
        {
          yyResult = pslashes$$Star2(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("slashes expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.slashes$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pslashes$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fslashes$$Star1) 
      yyColumn.chunk19.fslashes$$Star1 = pslashes$$Star1$1(yyStart);
    return yyColumn.chunk19.fslashes$$Star1;
  }

  /** Actually parse PreFortress.slashes$$Star1. */
  private Result pslashes$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psd(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('/' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pslashes$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\"/\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.slashes$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pslashes$$Star2(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fslashes$$Star2) 
      yyColumn.chunk19.fslashes$$Star2 = pslashes$$Star2$1(yyStart);
    return yyColumn.chunk19.fslashes$$Star2;
  }

  /** Actually parse PreFortress.slashes$$Star2. */
  private Result pslashes$$Star2$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psd(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('\\' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pslashes$$Star2(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\"\\\\\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.lesses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plesses(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        yyResult = psd(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if ('<' == yyC) {
            yyIndex = yyResult.index + 1;

            yyRepetition1 = yyIndex;
            continue;
          } else {
            yyError = yyError.select("\"<\" expected", yyBase);
          }
        }
        break;
      }

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("lesses expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.greaters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgreaters(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fgreaters) 
      yyColumn.chunk19.fgreaters = pgreaters$1(yyStart);
    return yyColumn.chunk19.fgreaters;
  }

  /** Actually parse Symbol.greaters. */
  private Result pgreaters$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pgreaters$$Star1(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("greaters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.greaters$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgreaters$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fgreaters$$Star1) 
      yyColumn.chunk19.fgreaters$$Star1 = pgreaters$$Star1$1(yyStart);
    return yyColumn.chunk19.fgreaters$$Star1;
  }

  /** Actually parse PreFortress.greaters$$Star1. */
  private Result pgreaters$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psd(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('>' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pgreaters$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\">\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.encloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pencloser(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fencloser) 
      yyColumn.chunk19.fencloser = pencloser$1(yyStart);
    return yyColumn.chunk19.fencloser;
  }

  /** Actually parse Symbol.encloser. */
  private Result pencloser$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pbar(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pbars(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyPredMatched = false;

        yyPredResult = pencloser$$Choice1(yyResult.index);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("encloser expected", yyStart);
        }
      }
    } else {
      yyError = yyError.select("encloser expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.encloser$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pencloser$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
      case '.':
      case '/':
      case '>':
      case '\\':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '-':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('>' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("encloser expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.leftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pleftEncloser(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fleftEncloser) 
      yyColumn.chunk19.fleftEncloser = pleftEncloser$1(yyStart);
    return yyColumn.chunk19.fleftEncloser;
  }

  /** Actually parse Symbol.leftEncloser. */
  private Result pleftEncloser$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pleftEncloserMulti(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (PrecedenceMap.ONLY.isLeft(yyValue)) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (c != '|' && PrecedenceMap.ONLY.isLeft(""+c)) {

        yyValue = ""+c;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("left encloser expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.leftEncloserMulti.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pleftEncloserMulti(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '(':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyRepetition1 = yyChoice1;
          yyRepeated1   = false;
          while (true) {

            yyBase = yyRepetition1;
            yyC    = character(yyBase);
            if ('/' == yyC) {
              yyIndex = yyRepetition1 + 1;

              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            } else {
              yyError = yyError.select("\"/\" expected", yyBase);
            }
            break;
          }

          if (yyRepeated1) {

            yyValue = difference(yyStart, yyRepetition1);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          }

          // Nested alternative 2.

          yyRepetition1 = yyChoice1;
          yyRepeated1   = false;
          while (true) {

            yyBase = yyRepetition1;
            yyC    = character(yyBase);
            if ('\\' == yyC) {
              yyIndex = yyRepetition1 + 1;

              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            } else {
              yyError = yyError.select("\"\\\\\" expected", yyBase);
            }
            break;
          }

          if (yyRepeated1) {

            yyValue = difference(yyStart, yyRepetition1);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          }
        }
        break;

      case '[':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('/' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('\\' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('/' == yyC) {

                      final int yyChoice2 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice2);
                      if (-1 != yyC) {
                        yyIndex = yyChoice2 + 1;
                        if ('\\' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('/' == yyC) {

                              yyValue = "[/\\/\\/";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }

                      // Nested alternative 2.

                      yyValue = "[/\\/";

                      return new SemanticValue(yyValue, yyChoice2, yyError);
                    }
                  }
                }
              }
            }
          }

          // Nested alternative 2.

          yyResult = psd(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pslashes(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = difference(yyStart, yyResult.index);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      case '{':
        {
          yyResult = psd(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pslashes(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = difference(yyStart, yyResult.index);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyResult = plesses(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psd(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pslashes(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pbars(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = pbars(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psd(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pslashes(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '{':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('*' == yyC) {

              yyValue = "{*";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '[':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('*' == yyC) {

              yyValue = "[*";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '(':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '(':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('>' == yyC) {

                    yyValue = "((>";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case '<':
              {
                yyValue = "(<";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("left encloser multi expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.rightEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightEncloser(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.frightEncloser) 
      yyColumn.chunk19.frightEncloser = prightEncloser$1(yyStart);
    return yyColumn.chunk19.frightEncloser;
  }

  /** Actually parse Symbol.rightEncloser. */
  private Result prightEncloser$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = prightEncloserMulti(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (PrecedenceMap.ONLY.isRight(yyValue)) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (c != '|' && PrecedenceMap.ONLY.isRight(""+c)) {

        yyValue = ""+c;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("right encloser expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.rightEncloserMulti.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightEncloserMulti(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.frightEncloserMulti) 
      yyColumn.chunk19.frightEncloserMulti = prightEncloserMulti$1(yyStart);
    return yyColumn.chunk19.frightEncloserMulti;
  }

  /** Actually parse Symbol.rightEncloserMulti. */
  private Result prightEncloserMulti$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = prightEncloserMulti$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (')' == yyC) {
        yyIndex = yyResult.index + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("\")\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = prightEncloserMulti$$Plus2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (')' == yyC) {
        yyIndex = yyResult.index + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("\")\" expected", yyBase);
      }
    }

    // Alternative 3.

    yyResult = pslashes(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psd(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pgreaters(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pbars(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case ']':
          case '}':
            {
              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }

          default:
            /* No match. */
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pbars(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psd(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pgreaters(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case ']':
              {
                yyValue = "*]";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '}':
              {
                yyValue = "*}";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case ']':
        {
          yyValue = "]";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = "}";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '>':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (')' == yyC) {

              yyValue = ">)";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '<':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (')' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if (')' == yyC) {

                  yyValue = "<))";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case '/':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\\' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('/' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;

                    switch (yyC) {
                    case '\\':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('/' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if (']' == yyC) {

                                yyValue = "/\\/\\/]";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }
                            }
                          }
                        }
                      }
                      break;

                    case ']':
                      {
                        yyValue = "/\\/]";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }

                    default:
                      /* No match. */
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("right encloser multi expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.rightEncloserMulti$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightEncloserMulti$$Plus1(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.frightEncloserMulti$$Plus1) 
      yyColumn.chunk19.frightEncloserMulti$$Plus1 = prightEncloserMulti$$Plus1$1(yyStart);
    return yyColumn.chunk19.frightEncloserMulti$$Plus1;
  }

  /** Actually parse PreFortress.rightEncloserMulti$$Plus1. */
  private Result prightEncloserMulti$$Plus1$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('/' == yyC) {

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyResult = prightEncloserMulti$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("right encloser multi expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.rightEncloserMulti$$Plus2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightEncloserMulti$$Plus2(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.frightEncloserMulti$$Plus2) 
      yyColumn.chunk20.frightEncloserMulti$$Plus2 = prightEncloserMulti$$Plus2$1(yyStart);
    return yyColumn.chunk20.frightEncloserMulti$$Plus2;
  }

  /** Actually parse PreFortress.rightEncloserMulti$$Plus2. */
  private Result prightEncloserMulti$$Plus2$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('\\' == yyC) {

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyResult = prightEncloserMulti$$Plus2(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("right encloser multi expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.exponentOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexponentOp(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('^' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('T' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "^T";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('^' == yyC) {
      yyIndex = yyStart + 1;
      String a1 = "^";

      yyResult = pop(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = a1+a2;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("exponent op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.OpName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOpName(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fOpName) 
      yyColumn.chunk20.fOpName = pOpName$1(yyStart);
    return yyColumn.chunk20.fOpName;
  }

  /** Actually parse Symbol.OpName. */
  private Result pOpName$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pcross(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pid(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String opn = yyResult.semanticValue();

        if (FortressUtil.validOp(opn)) {

          yyValue = opn;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    } else {
      yyError = yyError.select("op name expected", yyStart);
    }

    // Done.
    yyError = yyError.select("op name expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.Op.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOp(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fOp) yyColumn.chunk20.fOp = pOp$1(yyStart);
    return yyColumn.chunk20.fOp;
  }

  /** Actually parse Symbol.Op. */
  private Result pOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.Op$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOp$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcondOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyPredMatched = false;

      yyPredResult = pequalsOp(yyResult.index);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("op expected", yyStart);
      }
    }

    // Alternative 3.

    yyResult = pcompOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.compOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcompOp(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fcompOp) 
      yyColumn.chunk20.fcompOp = pcompOp$1(yyStart);
    return yyColumn.chunk20.fcompOp;
  }

  /** Actually parse Symbol.compOp. */
  private Result pcompOp$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '=':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '=':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('=' == yyC) {

                    yyValue = "===";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case '/':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('=' == yyC) {

                    yyValue = "=/=";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case '<':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = "<=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '>':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = ">=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("comp op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.condOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcondOp(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;
      String a1 = ":";

      yyResult = pop(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyResult = pcolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a3 = yyResult.semanticValue();

          yyValue = a1+a2+a3;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pcolon(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = a1+a2;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("cond op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.multiOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmultiOp(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fmultiOp) 
      yyColumn.chunk20.fmultiOp = pmultiOp$1(yyStart);
    return yyColumn.chunk20.fmultiOp;
  }

  /** Actually parse Symbol.multiOp. */
  private Result pmultiOp$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('-' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('>' == yyC) {
            yyIndex = yyIndex + 1;
            yyValue = "-/->";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('/' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('-' == yyC) {
            yyIndex = yyIndex + 1;
            yyValue = "<-/-";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "-->";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "==>";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 5.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = ">>>";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 6.

    yyResult = pmapstoOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('<' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('<' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "<<<";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 8.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "<->";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 9.

    yyResult = pleftarrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "<=>";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 11.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "->";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 12.

    yyResult = pdoublerightarrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 13.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = ">>";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 14.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('<' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "<<";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 15.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "**";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 16.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('!' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "!!";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 17.

    yyPredMatched = false;

    yyPredResult = prightEncloserMulti(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      final int yyChoice1 = yyStart;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if ('/' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyC = character(yyIndex);
        if ('/' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('/' == yyC) {
            yyIndex = yyIndex + 1;
            yyValue = "///";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('/' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyC = character(yyIndex);
        if ('/' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "//";

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"//\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"//\" expected", yyBase);
      }
    } else {
      yyError = yyError.select("multi op expected", yyStart);
    }

    // Done.
    yyError = yyError.select("multi op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.singleOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psingleOp(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fsingleOp) 
      yyColumn.chunk20.fsingleOp = psingleOp$1(yyStart);
    return yyColumn.chunk20.fsingleOp;
  }

  /** Actually parse Symbol.singleOp. */
  private Result psingleOp$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = psingleOp$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char a1 = (char)yyC;

        if (PrecedenceMap.ONLY.isOperator("" + a1)) {

          yyValue = "" + a1;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    } else {
      yyError = yyError.select("single op expected", yyStart);
    }

    // Done.
    yyError = yyError.select("single op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.singleOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psingleOp$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pencloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pleftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = prightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pmultiOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pcompOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("single op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.op.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pop(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fop) yyColumn.chunk20.fop = pop$1(yyStart);
    return yyColumn.chunk20.fop;
  }

  /** Actually parse Symbol.op. */
  private Result pop$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOpName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pmultiOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.CompoundOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCompoundOp(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pequalsOp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.doublerightarrow.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdoublerightarrow(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "=>";

        yyPredResult = pw(yyIndex);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyPredResult = pNoNewlineExpr(yyPredResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyPredResult = pw(yyPredResult.index);
            yyError      = yyPredResult.select(yyError);
            if (yyPredResult.hasValue()) {

              yyPredResult = pmatch(yyPredResult.index);
              yyError      = yyPredResult.select(yyError);
              if (yyPredResult.hasValue()) {

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("doublerightarrow expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.leftarrow.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pleftarrow(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fleftarrow) 
      yyColumn.chunk20.fleftarrow = pleftarrow$1(yyStart);
    return yyColumn.chunk20.fleftarrow;
  }

  /** Actually parse Symbol.leftarrow. */
  private Result pleftarrow$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = "<-";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("leftarrow expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.caret.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcaret(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fcaret) 
      yyColumn.chunk20.fcaret = pcaret$1(yyStart);
    return yyColumn.chunk20.fcaret;
  }

  /** Actually parse Symbol.caret. */
  private Result pcaret$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('^' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = "^";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("caret expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.colonequals.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcolonequals(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fcolonequals) 
      yyColumn.chunk20.fcolonequals = pcolonequals$1(yyStart);
    return yyColumn.chunk20.fcolonequals;
  }

  /** Actually parse Symbol.colonequals. */
  private Result pcolonequals$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = ":=";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("colonequals expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.equals.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pequals(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fequals) 
      yyColumn.chunk21.fequals = pequals$1(yyStart);
    return yyColumn.chunk21.fequals;
  }

  /** Actually parse Symbol.equals. */
  private Result pequals$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "=";

      yyPredMatched = false;

      yyPredResult = pop(yyIndex);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("equals expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("equals expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.equalsOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pequalsOp(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fequalsOp) 
      yyColumn.chunk21.fequalsOp = pequalsOp$1(yyStart);
    return yyColumn.chunk21.fequalsOp;
  }

  /** Actually parse Symbol.equalsOp. */
  private Result pequalsOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("=")) {
      yyValue = "=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("equals op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.semicolon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psemicolon(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fsemicolon) 
      yyColumn.chunk21.fsemicolon = psemicolon$1(yyStart);
    return yyColumn.chunk21.fsemicolon;
  }

  /** Actually parse Symbol.semicolon. */
  private Result psemicolon$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (';' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = ";";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("semicolon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.one.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pone(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fone) 
      yyColumn.chunk21.fone = pone$1(yyStart);
    return yyColumn.chunk21.fone;
  }

  /** Actually parse Symbol.one. */
  private Result pone$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('1' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("one expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.colon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcolon(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fcolon) 
      yyColumn.chunk21.fcolon = pcolon$1(yyStart);
    return yyColumn.chunk21.fcolon;
  }

  /** Actually parse Symbol.colon. */
  private Result pcolon$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = ":";

      yyPredMatched = false;

      yyPredResult = pop(yyIndex);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("colon expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("colon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closesquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosesquare(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fclosesquare) 
      yyColumn.chunk21.fclosesquare = pclosesquare$1(yyStart);
    return yyColumn.chunk21.fclosesquare;
  }

  /** Actually parse Symbol.closesquare. */
  private Result pclosesquare$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (']' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = "]";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closesquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.opensquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popensquare(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fopensquare) 
      yyColumn.chunk21.fopensquare = popensquare$1(yyStart);
    return yyColumn.chunk21.fopensquare;
  }

  /** Actually parse Symbol.opensquare. */
  private Result popensquare$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pleftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("[")) {
      yyValue = "[";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("opensquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closecurly.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosecurly(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('}' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closecurly expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closeangle.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcloseangle(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("closeangle expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closedoublesquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosedoublesquare(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (']' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("closedoublesquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closeparen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcloseparen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (')' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closeparen expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.cross.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcross(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('B' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('Y' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("cross expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.DOT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDOT(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOpName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("DOT")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("DOT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.ellipses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pellipses(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('.' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('.' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("ellipses expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.mapsto.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmapsto(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("mapsto expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.match.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmatch(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("match expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.minus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pminus(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("-")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("minus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.opencurly.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popencurly(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pleftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("{")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("opencurly expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.openangle.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popenangle(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pleftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("<|")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("openangle expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.opendoublesquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popendoublesquare(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('\\' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("opendoublesquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.openparen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popenparen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pleftEncloser(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if ('(' == yyC) {
        yyIndex = yyStart + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("openparen expected", yyStart);
    }

    // Done.
    yyError = yyError.select("openparen expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.plus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pplus(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("+")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("plus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.pound.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ppound(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("#")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("pound expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.slash.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pslash(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("/")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("slash expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.star.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pstar(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("*")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("star expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.rightarrow.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightarrow(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("rightarrow expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.comma.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomma(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("comma expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.dot.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdot(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("dot expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.AssignOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignOp(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fAssignOp) 
      yyColumn.chunk21.fAssignOp = pAssignOp$1(yyStart);
    return yyColumn.chunk21.fAssignOp;
  }

  /** Actually parse Symbol.AssignOp. */
  private Result pAssignOp$1(final int yyStart) throws IOException {
    Result      yyResult;
    Option<Opr> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcolonequals(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Option.none();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pCompoundOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyValue = Option.some(NodeFactory.makeOpr(a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.accumulator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result paccumulator(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'S':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('U' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('M' == yyC) {

                  yyValue = "SUM";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case 'P':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('R' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('O' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('D' == yyC) {

                      yyValue = "PROD";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("accumulator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.Accumulator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAccumulator(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fAccumulator) 
      yyColumn.chunk21.fAccumulator = pAccumulator$1(yyStart);
    return yyColumn.chunk21.fAccumulator;
  }

  /** Actually parse Symbol.Accumulator. */
  private Result pAccumulator$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = paccumulator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("SUM")) {

      yyValue = NodeFactory.makeOp(createSpan(yyStart,yyCount), "+");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = paccumulator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("PROD")) {

      yyValue = NodeFactory.makeOp(createSpan(yyStart,yyCount), "DOT");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pBIG(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("accumulator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.ArrayComprehensionClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayComprehensionClause(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fArrayComprehensionClause) 
      yyColumn.chunk21.fArrayComprehensionClause = pArrayComprehensionClause$1(yyStart);
    return yyColumn.chunk21.fArrayComprehensionClause;
  }

  /** Actually parse Symbol.ArrayComprehensionClause. */
  private Result pArrayComprehensionClause$1(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    ArrayComprehensionClause yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArrayComprehensionLeft(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      com.sun.fortress.useful.Pair<List<Expr>,Expr> a1 = yyResult.semanticValue();

      yyResult = pwr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pbar(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pwr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr$GeneratorList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Generator> a2 = yyResult.semanticValue();

              yyValue = new ArrayComprehensionClause(createSpan(yyStart,yyCount),
              a1.getA(), a1.getB(), a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Whitespace.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhitespace(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fWhitespace) 
      yyColumn.chunk22.fWhitespace = pWhitespace$1(yyStart);
    return yyColumn.chunk22.fWhitespace;
  }

  /** Actually parse Spacing.Whitespace. */
  private Result pWhitespace$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpace(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNewline(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpace(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fSpace) 
      yyColumn.chunk22.fSpace = pSpace$1(yyStart);
    return yyColumn.chunk22.fSpace;
  }

  /** Actually parse Spacing.Space. */
  private Result pSpace$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (' ' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = " ";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\f' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "\f";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyResult = pNoNewlineComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Newline.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNewline(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fNewline) 
      yyColumn.chunk22.fNewline = pNewline$1(yyStart);
    return yyColumn.chunk22.fNewline;
  }

  /** Actually parse Spacing.Newline. */
  private Result pNewline$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('\n' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "\r\n";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "\r";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\n' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "\n";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyResult = pComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("newline expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Comment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComment(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fComment) 
      yyColumn.chunk22.fComment = pComment$1(yyStart);
    return yyColumn.chunk22.fComment;
  }

  /** Actually parse Spacing.Comment. */
  private Result pComment$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;
        String a1 = "(*";

        yyResult = pComment$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Object> a2s = yyResult.semanticValue();

          yyResult = pwValue(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a3 = yyResult.semanticValue();

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if ('*' == yyC) {
              yyIndex = yyResult.index + 1;

              yyC = character(yyIndex);
              if (')' == yyC) {
                yyIndex = yyIndex + 1;
                String a4 = "*)";

                yyValue = a1;
                for (Object s : a2s.list()) {
                  yyValue += s;
                }
                yyValue = yyValue + a3 + a4;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("\"*)\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"*)\" expected", yyBase);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.Comment$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComment$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pwValue(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String b1 = yyResult.semanticValue();

      yyResult = pCommentContent(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String b2 = yyResult.semanticValue();

        yyValue = b1+b2;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.Comment$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComment$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fComment$$Star1) 
      yyColumn.chunk22.fComment$$Star1 = pComment$$Star1$1(yyStart);
    return yyColumn.chunk22.fComment$$Star1;
  }

  /** Actually parse PreFortress.Comment$$Star1. */
  private Result pComment$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<Object> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComment$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Object v$el$1 = yyResult.semanticValue();

      yyResult = pComment$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Object> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Object>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.CommentContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommentContent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if (')' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = ""+c;

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("comment content expected", yyStart);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (c != '*') {

        yyValue = ""+c;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("comment content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.NoNewlineComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineComment(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (!(yyValue.contains("\r\n") || yyValue.contains("\r")
          || yyValue.contains("\n"))) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("no newline comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.wValue.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwValue(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fwValue) 
      yyColumn.chunk22.fwValue = pwValue$1(yyStart);
    return yyColumn.chunk22.fwValue;
  }

  /** Actually parse Spacing.wValue. */
  private Result pwValue$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pwValue$$Star1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<String> a1s = yyResult.semanticValue();

      yyValue = "";
      for (String s : (List<String>)a1s.list()) {
        yyValue += s;
      }

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.wValue$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwValue$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fwValue$$Star1) 
      yyColumn.chunk22.fwValue$$Star1 = pwValue$$Star1$1(yyStart);
    return yyColumn.chunk22.fwValue$$Star1;
  }

  /** Actually parse PreFortress.wValue$$Star1. */
  private Result pwValue$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWhitespace(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pwValue$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> v$2 = yyResult.semanticValue();

        yyValue = new Pair<String>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.w.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pw(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pWhitespace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.wr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyResult = pWhitespace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        continue;
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.s.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ps(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pSpace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.sr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyResult = pSpace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        continue;
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.nl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pnl(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNewline(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.br.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbr(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNewline(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if (';' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyResult = pw(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\";\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.RectSeparator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRectSeparator(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fRectSeparator) 
      yyColumn.chunk22.fRectSeparator = pRectSeparator$1(yyStart);
    return yyColumn.chunk22.fRectSeparator;
  }

  /** Actually parse Spacing.RectSeparator. */
  private Result pRectSeparator$1(final int yyStart) throws IOException {
    Result     yyResult;
    Integer    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRectSeparator$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<String> a1s = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = a1s.size() + 1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = psr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = 1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pnl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = 2;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.RectSeparator$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRectSeparator$$Plus1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fRectSeparator$$Plus1) 
      yyColumn.chunk22.fRectSeparator$$Plus1 = pRectSeparator$$Plus1$1(yyStart);
    return yyColumn.chunk22.fRectSeparator$$Plus1;
  }

  /** Actually parse PreFortress.RectSeparator$$Plus1. */
  private Result pRectSeparator$$Plus1$1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psemicolon(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pRectSeparator$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<String> v$2 = yyResult.semanticValue();

          yyValue = new Pair<String>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = new Pair<String>(v$el$1);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.FORALL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFORALL(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('F' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('O' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('R' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('A' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('L' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('L' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("FORALL expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("FORALL expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.cubed.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcubed(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('u' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('b' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('d' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("cubed expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("cubed expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.cubic.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcubic(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('u' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('b' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("cubic expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("cubic expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.inverse.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pinverse(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('v' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("inverse expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("inverse expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.per.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pper(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("per expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("per expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.square.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psquare(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('q' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("square expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("square expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.squared.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psquared(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('q' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('d' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("squared expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("squared expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.absorbs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pabsorbs(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('b' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('b' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("absorbs expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("absorbs expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.also.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result palso(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("also expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("also expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.as.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pas(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('s' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("as expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("as expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.asif.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pasif(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('s' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('f' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("asif expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("asif expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.at.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pat(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('t' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("at expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("at expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.bool.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbool(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('b' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("bool expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("bool expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.case.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcase(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("case expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("case expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.catch.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcatch(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('c' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('h' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("catch expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("catch expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.coerce.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcoerce(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("coerce expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("coerce expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.coerces.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcoerces(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("coerces expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("coerces expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.component.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomponent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('p' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('o' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('t' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("component expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("component expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.dim.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdim(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("dim expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("dim expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.do.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdo(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("do expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("do expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.elif.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pelif(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('f' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("elif expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("elif expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.else.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pelse(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("else expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("else expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.ensures.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pensures(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("ensures expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("ensures expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.except.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexcept(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('c' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('p' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("except expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("except expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.exit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("exit expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("exit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.extends.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pextends(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("extends expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("extends expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.finally.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfinally(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('l' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('l' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('y' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("finally expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("finally expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.fn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfn(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("fn expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("fn expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.for.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfor(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("for expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("for expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.forbid.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pforbid(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('b' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("forbid expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("forbid expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.from.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfrom(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("from expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("from expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.if.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pif(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('f' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("if expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("if expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.import.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pimport(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('m' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("import expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("import expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.in.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pin(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("in expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("in expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.int.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pint(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("int expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("int expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.invariant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pinvariant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('v' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('a' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('t' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("invariant expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("invariant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.label.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plabel(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('l' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('b' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('l' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("label expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("label expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.nat.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pnat(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('n' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("nat expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("nat expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.object.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pobject(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('b' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('j' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("object expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("object expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.of.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pof(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('f' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("of expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("of expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.opr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popr(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('p' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("opr expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("opr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.or.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result por(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("or expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("or expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.property.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pproperty(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('p' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('t' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('y' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("property expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("property expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.provided.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pprovided(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('v' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('d' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("provided expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("provided expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.requires.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prequires(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('q' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('s' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("requires expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("requires expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.spawn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pspawn(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('p' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('w' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("spawn expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("spawn expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.then.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pthen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('n' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("then expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("then expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.throw.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pthrow(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('w' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("throw expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("throw expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.throws.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pthrows(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('w' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("throws expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("throws expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.try.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptry(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('y' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("try expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("try expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.tryatomic.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptryatomic(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('y' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('o' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('m' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('i' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('c' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("tryatomic expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("tryatomic expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptype(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("type expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.typecase.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptypecase(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("typecase expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("typecase expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.where.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwhere(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("where expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("where expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.while.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwhile(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("while expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("while expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.with.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwith(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('h' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("with expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("with expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.foo.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfoo(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("foo expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("foo expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.barrr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbarrr(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('b' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("barrr expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("barrr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.BIG.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBIG(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fBIG) 
      yyColumn.chunk22.fBIG = pBIG$1(yyStart);
    return yyColumn.chunk22.fBIG;
  }

  /** Actually parse Keyword.BIG. */
  private Result pBIG$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('B' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('I' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('G' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = "BIG";

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("BIG expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("BIG expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.atomic.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result patomic(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fatomic) 
      yyColumn.chunk23.fatomic = patomic$1(yyStart);
    return yyColumn.chunk23.fatomic;
  }

  /** Actually parse Keyword.atomic. */
  private Result patomic$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('t' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('c' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "atomic";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("atomic expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("atomic expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.end.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pend(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fend) 
      yyColumn.chunk23.fend = pend$1(yyStart);
    return yyColumn.chunk23.fend;
  }

  /** Actually parse Keyword.end. */
  private Result pend$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('d' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("end expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("end expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.getter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgetter(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('g' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "getter";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("getter expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("getter expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.hidden.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result phidden(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('h' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('d' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('d' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("hidden expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("hidden expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.io.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pio(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("io expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("io expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.override.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result poverride(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('v' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('d' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("override expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("override expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.private.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pprivate(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fprivate) 
      yyColumn.chunk23.fprivate = pprivate$1(yyStart);
    return yyColumn.chunk23.fprivate;
  }

  /** Actually parse Keyword.private. */
  private Result pprivate$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('v' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("private expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("private expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.self.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pself(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fself) 
      yyColumn.chunk23.fself = pself$1(yyStart);
    return yyColumn.chunk23.fself;
  }

  /** Actually parse Keyword.self. */
  private Result pself$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('f' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = "self";

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("self expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("self expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.settable.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psettable(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('b' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('l' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("settable expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("settable expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.setter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psetter(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "setter";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("setter expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("setter expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.test.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptest(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.ftest) 
      yyColumn.chunk23.ftest = ptest$1(yyStart);
    return yyColumn.chunk23.ftest;
  }

  /** Actually parse Keyword.test. */
  private Result ptest$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("test expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("test expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.unit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result punit(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.funit) 
      yyColumn.chunk23.funit = punit$1(yyStart);
    return yyColumn.chunk23.funit;
  }

  /** Actually parse Keyword.unit. */
  private Result punit$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('u' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = "unit";

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("unit expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("unit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.var.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pvar(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fvar) 
      yyColumn.chunk23.fvar = pvar$1(yyStart);
    return yyColumn.chunk23.fvar;
  }

  /** Actually parse Keyword.var. */
  private Result pvar$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = "var";

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("var expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("var expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.widens.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwidens(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fwidens) 
      yyColumn.chunk23.fwidens = pwidens$1(yyStart);
    return yyColumn.chunk23.fwidens;
  }

  /** Actually parse Keyword.widens. */
  private Result pwidens$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('d' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "widens";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("widens expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("widens expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.wrapped.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwrapped(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('p' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('p' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('d' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("wrapped expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("wrapped expected", yyStart);
    return yyError;
  }

  // =========================================================================

  Span createSpan(int start, int end) {
    Column s = column(start);
    Column e = column(end-1);
    SourceLocRats slStart = new SourceLocRats(s.file, s.line, s.column);
    SourceLocRats slEnd   = new SourceLocRats(e.file, e.line, e.column);
    return new Span(slStart, slEnd);
  }
  static {
    add(FORTRESS_KEYWORDS, new String[] {
      "FORALL",
      
      "cubed",        "cubic",        "inverse",      "per",
      "square",       "squared",
      
      "goto",         "idiom",        "public",       "pure",
      "reciprocal",   "static",
      
      "BIG",          "SI_unit",      "absorbs",      "abstract",
      "also",         "api",          "as",           "asif",
      "at",           "atomic",       "bool",         "case",
      "catch",        "coerce",       "coerces",      "component",
      "comprises",    "default",      "dim",          "do",
      "elif",         "else",         "end",          "ensures",
      "except",       "excludes",     "exit",         "export",
      "extends",      "finally",      "fn",           "for",
      "forbid",       "from",         "getter",       "hidden",
      "if",           "import",       "in",           "int",
      "invariant",    "io",           "label",        "largest",
      "nat",          "object",       "of",           "opr",
      "or",           "override",     "private",      "property",
      "provided",     "requires",     "self",         "settable",
      "setter",       "smallest",     "spawn",        "syntax",
      "test",         "then",         "throw",        "throws",
      "trait",        "transient",    "try",          "tryatomic",
      "type",         "typecase",     "unit",         "value",
      "var",          "where",        "while",        "widens",
      "with",         "wrapped",		"macro",		"foo", "barrr"
    });
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

}
