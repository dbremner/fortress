/*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress symbols and operators.
 */
module com.sun.fortress.parser.preparser.PreSymbol(Identifier, Spacing, Keyword);

import Identifier;
import Spacing;
import Keyword;

option setOfString(FORTRESS_KEYWORDS);

Op Encloser = a1:encloser
     { yyValue = NodeFactory.makeOpEnclosing(createSpan(yyStart,yyCount), a1); };

Op LeftEncloser = !(opendoublesquare) a1:leftEncloser
     { yyValue = NodeFactory.makeOpEnclosing(createSpan(yyStart,yyCount), a1); };

Op RightEncloser = a1:rightEncloser
     { yyValue = NodeFactory.makeOpEnclosing(createSpan(yyStart,yyCount), a1); };

/* EncloserPair ::=
     (LeftEncloser | Encloser) (w DOT)? w (RightEncloser | Encloser)
 */
Enclosing EncloserPair =
     a1:(LeftEncloser / Encloser) (w DOT)? w a2:(RightEncloser / Encloser)
     { if (PrecedenceMap.ONLY.matchedBrackets(a1.getText(), a2.getText()))
           yyValue = new Enclosing(createSpan(yyStart,yyCount), a1, a2);
       else
           yyValue = syntaxError(a2.getSpan(), "Mismatched Enclosers.");
     };

transient void bar = "|";
private transient String sd = [*.]? ;
private String bars = "|" (sd "|")* ;
private String slashes = "/" (sd "/")*
                       / "\\" (sd "\\")* ;
private String lesses = "<" (sd "<")*;
private String greaters = ">" (sd ">")*;

private String encloser = !(bar) bars !([*.>/\\] / "->") ;

private String leftEncloser =
      leftEncloserMulti &{ PrecedenceMap.ONLY.isLeft(yyValue) }
   / c:_ &{c != '|' && PrecedenceMap.ONLY.isLeft(""+c)} { yyValue = ""+c; }
   ;

private String leftEncloserMulti =
     "(" ("/"+ / "\\"+)
   / "[/\\/\\/" / "[/\\/"
   / "[" (sd slashes)
   / "{" (sd slashes)
   / lesses sd (slashes / bars)
   / bars sd slashes
   / "{*" /  "[*"
   / "((>" / "(<"
   ;

private String rightEncloser =
      rightEncloserMulti &{ PrecedenceMap.ONLY.isRight(yyValue) }
   / c:_ &{c != '|' && PrecedenceMap.ONLY.isRight(""+c)} { yyValue = ""+c; }
   ;

private String rightEncloserMulti =
     "/"+ ")"
   / "\\"+ ")"
   / slashes sd (greaters / bars / [\]}])
   / bars sd greaters
   / "*]" / "*}"
   / "]" / "}"
   / ">)" / "<))"
   / "/\\/\\/]" / "/\\/]"
   ;

/* Finally, a nonreserved word that is made up of a mixture of uppercase
 * letters and underscores (but no digits), does not begin or end with an
 * underscore, and contains at least two distinct letters is also an
 * operator.  For example: MAX MIN SQRT TIMES
 *
 * Note that FortressUtil.validOp just checks whether the string is
 * all-caps with underscores; it doesn't look it up anywhere, and
 * shouldn't since this set of operators is open-ended.
 */
String OpName =
     opn:id &{FortressUtil.validOp(opn) };

Op Op =
     a1:(condOp / op !(equalsOp) / compOp)
     { yyValue = NodeFactory.makeOpUnknown(createSpan(yyStart, yyCount), a1); };

private String compOp =
     "==="
   / "=/="
   / "<="
   / ">=" ;

private String condOp =
     ":::"                 // Error production
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Three or more colons are not valid operators in Fortress.");
     }
   / a1:":" a2:(encloser / op) a3:colon { yyValue = a1+a2+a3; }
   / a1:(encloser / op) a2:colon        { yyValue = a1+a2; };

private String multiOp =
     "-/->"
   / "<-/-"
   / "-->"
   / "==>"
   / ">>>"
   / mapstoOp
   / "<<<"
   / "<->"
   / leftarrow
   / "<=>"
   / "->"
   / doublerightarrow
   / ">>"
   / "<<"
   / "!!"
   / "::"
   / !(rightEncloserMulti) "///"
   / !(rightEncloserMulti) "//"
   ;

private String singleOp =
     !(encloser / leftEncloser / rightEncloser / multiOp / compOp / match)
     a1:_ &{ PrecedenceMap.ONLY.isOperator("" + a1) }
     { yyValue = "" + a1; } ;

String op =
     OpName
   / multiOp
   / singleOp ;

/* The operator "=>" should not be in the left-hand sides of
   case/typecase expressions. */
String doublerightarrow = "=>"; /* &(w NoNewlineExpr w match); */
String leftarrow = "<-";
String equalsOp = "=":singleOp;
String semicolon = ";";
String closecurly = "}";
String opencurly = "{":leftEncloser;
String colon = ":" (!op);
String ellipses = "...";
String DOT = "DOT":OpName;

transient void closedoublesquare = "\\]";
transient void closeparen = ")";
transient void match = "=>";
transient void opendoublesquare = "[\\";
transient void openparen = !(leftEncloser) "(";
transient void comma = ",";
transient void dot   = ".";

/* from Delimited expr */
String mapstoOp = "|->" ;
