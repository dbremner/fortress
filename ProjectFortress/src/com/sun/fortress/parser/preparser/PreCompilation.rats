/*******************************************************************************
    Copyright 2009 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress components and APIs that are accepted by the preparser.
 */
module com.sun.fortress.parser.preparser.PreCompilation(Identifier, Keyword,
                                                        Symbol, Spacing);

import Identifier;
import Keyword;
import Symbol;
import Spacing;

public void File = initParser void:Program closeParser ;
void initParser  = w { initParser(); };
void closeParser = w EndOfFile
     { try {
           writer.close();
       } catch (IOException error) {
           error("Closing a log file for the parser failed!");
       }
     };

void Program =
     CompilationUnit
   / ImportOrExports (w semicolon)? w DeclsRestWithoutEnd
   / ImportOrExports (w semicolon)? w AbsDeclsRest (w semicolon)?
   / (ImportOrExports (w semicolon)? w)? AbsDeclsRest (w semicolon)?
   ;

private void CompilationUnit =
     (native w)? component w APIName (w ImportOrExports (w semicolon)?)?
     w DeclsRest
   / (native w)? api w APIName (w ImportOrExports (w semicolon)?)? w (_)*
   ;

private void ImportOrExports = ImportOrExport (br ImportOrExport)*;
private void ImportOrExport = Import / Export;
private void Import =
     import (w ForeignLang)? w api w AliasedAPINames
   / import w ImportedNames;
private void ForeignLang = !(Id w dot) Id / StringLiteralExpr;
private void ImportedNames =
     (ForeignLang w)? APIName dot w opencurly w ellipses w closecurly
     (w except w SimpleNames)?
   / ForeignLang w APIName dot w opencurly w AliasedQualifiedNameList
     (w comma w ellipses)? w closecurly
   / (ForeignLang w)? APIName dot w opencurly w AliasedSimpleNameList
     (w comma w ellipses)? w closecurly
   / (ForeignLang w)? Id dot QualifiedName (w as w Id)?
   ;
private void SimpleNames =
     SimpleName / opencurly w SimpleNameList w closecurly ;
private void SimpleNameList = SimpleName (w comma w SimpleName)*;
private void AliasedSimpleName =
     Id (w as w Id)?
   / opr (w BIG)? w (Encloser / Op) (w as w (Encloser / Op))?
   / opr (w BIG)? w EncloserPair (w as w EncloserPair)?
   ;
private void AliasedSimpleNameList =
     AliasedSimpleName (w comma w AliasedSimpleName)*;
private void AliasedQualifiedName =
     QualifiedName (w as w QualifiedName)?;
private void AliasedQualifiedNameList =
     AliasedQualifiedName (w comma w AliasedQualifiedName)*;
private void AliasedAPINames =
     AliasedAPIName
   / opencurly w AliasedAPINameList w closecurly ;
private void AliasedAPIName = APIName (w as w Id)?;
private void AliasedAPINameList = AliasedAPIName (w comma w AliasedAPIName)*;
private void Export = export w APINames ;
private void APINames = APIName / opencurly w APINameList w closecurly ;
private void APINameList = APIName (w comma w APIName)*;

/* Decls ::= Decl (br Decl)* */
transient private Option<String> DeclsRest =
     component (_)*
     { Span span = createSpan(yyStart,yyCount);
       log(span, "Nested component definitions are not allowed.");
       yyValue = Option.<String>none();
     }
   / api (_)*
     { Span span = createSpan(yyStart,yyCount);
       log(span, "Nested API definitions are not allowed.");
       yyValue = Option.<String>none();
     }
   / Mods? (trait/object) (_)*
     { yyValue = Option.<String>none(); }
   / (dim / unit / SI_unit / type / test / property) (_)*
     { yyValue = Option.<String>none(); }
   / FnDeclHeader w NoNewlineExpr (w semicolon)? w end a2:((s component)? s APIName)? &( w EndOfFile )
     { if (a2 == null)
           yyValue = Option.<String>none();
       else
           yyValue = Option.<String>some(NodeUtil.stringName(a2));
     }
   / FnDeclHeader w NoNewlineExpr (w semicolon)? &( w EndOfFile )
     { Span span = createSpan(yyStart,yyCount);
       log(span, "Unmatched delimiter \"component\".");
       yyValue = Option.<String>none();
     }
   / FnDeclHeader (w semicolon)? (w (end / DeclKeywords))? &( w EndOfFile )
     { Span span = createSpan(yyStart,yyCount);
       log(span, "Missing function body.");
       yyValue = Option.<String>none();
     }
   / FnDeclHeader w NoNewlineExpr br a2:DeclsRest
     { yyValue = a2; }
   / Mods? Id (w StaticParams)? w ValParam (w NoNewlineIsType)? !(FnHeaderBack) (_)+
     { Span span = createSpan(yyStart,yyCount);
       log(span, "Missing = in a function declaration.");
       yyValue = Option.<String>none();
     }
   / FnDeclHeader (_)+
     { yyValue = Option.<String>none(); }
   / end w Extra
     { yyValue = Option.<String>none(); }
   / (_)+
     { yyValue = Option.<String>none(); };

/* In between FnDeclHeader and the function body expression */
transient private void FnHeaderBack =
     w equals / w requires / w ensures / w invariant ;

/* Unmatched leftover inputs */
transient private void Extra =
     end (_)*
     { log(createSpan(yyStart,yyCount), "Unmatched delimiter \"end\"."); }
   / a1:(_)+
     { String input = "";
       for ( char c : a1.list() ) {
           input += c;
       }
       log(createSpan(yyStart,yyCount), "Unmatched input \"" + input + "\".");
     };

transient private void DeclsRestWithoutEnd =
     Mods? (trait/object) (_)*
   / (dim / unit / SI_unit / type / test / property) (_)*
   / FnDeclHeader w NoNewlineExpr (w semicolon)? &( w EndOfFile )
   / FnDeclHeader w NoNewlineExpr br DeclsRestWithoutEnd
   / Mods? Id (w StaticParams)? w ValParam (w NoNewlineIsType)? !(FnHeaderBack) (_)+
     { Span span = createSpan(yyStart,yyCount);
       log(span, "Missing = in a function declaration.");
     }
   / FnDeclHeader (_)+
   / Extra
   / (_)+;

transient private void FnDeclHeader =
     Mods? Id (w StaticParams)? w ValParam (w NoNewlineIsType)? w equals w
   / Mods? Id (w StaticParams)? w a1:ExtraOpenparen w ValParam (w NoNewlineIsType)? w equals w
     { log(NodeUtil.getSpan(a1),
           "Unmatched delimiter \"(\".");
     }
   / Mods? Id (w StaticParams)? w a1:ExtraCloseparen w ValParam (w NoNewlineIsType)? w equals w
     { log(NodeUtil.getSpan(a1),
           "Unmatched delimiter \")\".");
     }
   / Mods? Id (w StaticParams)? w ValParam w a1:ExtraOpenparen (w NoNewlineIsType)? w equals w
     { log(NodeUtil.getSpan(a1),
           "Unmatched delimiter \"(\".");
     }
   / Mods? Id (w StaticParams)? w ValParam w a1:ExtraCloseparen (w NoNewlineIsType)? w equals w
     { log(NodeUtil.getSpan(a1),
           "Unmatched delimiter \")\".");
     }
   / Mods? Id (w StaticParams)? w ValParam (w NoNewlineIsType)? w a1:ExtraOpenparen w equals w
     { log(NodeUtil.getSpan(a1),
           "Unmatched delimiter \"(\".");
     }
   / Mods? Id (w StaticParams)? w ValParam (w NoNewlineIsType)? w a1:ExtraCloseparen w equals w
     { log(NodeUtil.getSpan(a1),
           "Unmatched delimiter \")\".");
     };

transient private Expr ExtraOpenparen =
     openparen
     { yyValue = ExprFactory.makeVoidLiteralExpr(createSpan(yyStart,yyCount)); } ;
transient private Expr ExtraCloseparen =
     closeparen
     { yyValue = ExprFactory.makeVoidLiteralExpr(createSpan(yyStart,yyCount)); } ;
transient void AbsDeclsRest = AbsDecl (br AbsDecl)*;
transient void AbsDecl =
     Mods? (trait/object) (_)*
   / (dim / unit / SI_unit / type / test / property / grammar) (_)*
   / (_)*;
transient void Mods = (Mod w)+;
transient void Mod =
     atomic / hidden / io / override / private
   / settable / test / value / var / wrapped
   ;
transient void ValParam =
     BindId
   / openparen w closeparen
   / openparen w Params w closeparen
   ;

/* Params ::=
     (Param w , w)* (Varargs w , w)? Keyword (w , w Keyword)*
   | (Param w , w)*  Varargs
   |  Param (w , w Param)*
 */
transient void Params =
     (Param w comma w)+ (Keyword w comma w)+ Varargs
     { log(createSpan(yyStart,yyCount),
           "Varargs parameters should come before keyword parameters.");
     }
   / Varargs w comma w (Keyword w comma w)+ Param (w comma w Param)*
     { log(createSpan(yyStart,yyCount),
           "Normal parameters should come before varargs parameters and keyword parameters.");
     }
   / Varargs (w comma w Param)+ (w comma w Keyword)*
     { log(createSpan(yyStart,yyCount),
           "Normal parameters should come before varargs parameters.");
     }
   / Keyword (w comma w Keyword)* w comma w Varargs (w comma w Param)*
     { log(createSpan(yyStart,yyCount),
           "Keyword parameters should come after normal parameters and varargs parameters.");
     }
   / Keyword (w comma w Keyword)* (w comma w Param)+ (w comma w Varargs)?
     { log(createSpan(yyStart,yyCount),
           "Keyword parameters should come after normal parameters and varargs parameters.");
     }
   / (Param w comma w)* (Varargs w comma w)? Keyword (w comma w Keyword)*
   / (Param w comma w)* Varargs
   / Param (w comma w Param)* ;

/* Param ::= BindId (w IsType)? */
transient void Param = BindId (w IsType)? ;

/* Varargs ::= BindId w : w Type w ... */
transient void Varargs = BindId w colon w Type w ellipses ;

//transient void Keyword = Param w equals w NoNewlineExpr ;
transient void Keyword = Param w equals w DefaultExpr ;
transient void DefaultExpr = ([0-9]+ / Id) (w Op w DefaultExpr)* ;

/* StaticParams ::= [\ w StaticParamList w \] */
transient void StaticParams =
     a1:opendoublesquare (w StaticParamList)? w a2:closedoublesquare
     { if (! PrecedenceMap.ONLY.matchedBrackets(a1,a2) )
             log(createSpan(yyStart,yyCount),
                 "Unmatched delimiter \"" + a1 + "\" and \"" + a2 + "\".");
     }
   / a1:(a:LeftEncloser {yyValue=a.getText();} / opendoublesquare / opensquare)
     (w StaticParamList)? w
     a2:(a:RightEncloser {yyValue=a.getText();} / closedoublesquare / closesquare)
     { if (! PrecedenceMap.ONLY.matchedBrackets((String)a1,(String)a2) )
           log(createSpan(yyStart,yyCount),
               "Unmatched delimiter \"" + a1 + "\" and \"" + a2 + "\".");
     }
   / opendoublesquare
     { log(createSpan(yyStart,yyCount),
           "Unmatched delimiter \"[\\\".");
     }
   ;

/* StaticParamList ::= StaticParam (w , w StaticParam)* */
transient void StaticParamList = StaticParam (w comma w StaticParam)* ;

/* Do not handle unit parameters and type parameters fully yet. */
/* StaticParam ::=
     nat w Id
   | int w Id
   | bool w Id
   | dim w Id
   | unit w Id (w : w NoNewlineType)? (w absorbs w unit)?
   | opr w Op
   | Id (w Extends)? (w absorbs w unit)?
*/
transient void StaticParam =
     (nat / int / bool / dim / unit) w Id
   / opr w Op
   / Id w extends w Type
   / Id
   ;

/* Do not handle types fully yet. */
transient void Type = TypeFront TypeTail* ;

transient void TypeFront =
     openparen w closeparen
   / openparen w Type (w comma w Type)* w closeparen
   / openparen (w Type)? (w comma w Type)* w
     { log(createSpan(yyStart,yyCount),
           "Unmatched delimiter \"(\".");
     }
   / closeparen
     { log(createSpan(yyStart,yyCount),
           "Unmatched delimiter \")\".");
     }
   / Id a1:opendoublesquare w StaticArg (w comma w StaticArg)* w a2:closedoublesquare
     { if (! PrecedenceMap.ONLY.matchedBrackets(a1,a2) )
             log(createSpan(yyStart,yyCount),
                 "Unmatched delimiter \")\".");
     }
   / Id
   ;

/* Do not handle static arguments fully yet. */
transient void StaticArg =
     Type
   / [0-9]+
   ;
transient void TypeTail =
     w rightarrow w Type
   / opensquare w ExtentRange w closesquare
   / caret openparen w ExtentBase (w cross w ExtentBase)* w closeparen
   ;
transient void ExtentRange = ExtentBase (w comma w ExtentBase)* ;

transient void ExtentBase = [0-9]+ (w (pound/colon) w [0-9]+)? / Id ;

transient void IsType = colon w Type ;
transient void NoNewlineIsType = IsType ;

/* Do not handle expressions fully yet. */
transient void NoNewlineExpr =
     do w BlockElems w end
   / label w Id BlockElems w end w Id
   / exit (w Id)? (w with w NoNewlineExpr)?
   / do w BlockElems
     { log(createSpan(yyStart,yyCount),
           "Unmatched delimiter \"do\".");
     }
   / do w end
   / NoNewlineExprFront NoNewlineExprTail* ;

transient void NoNewlineExprFront =
     openparen (s NoNewlineExpr (w comma w NoNewlineExpr)*)? s closeparen
   / StringLiteralExpr
   / Id
   / Op
   ;

transient void NoNewlineExprTail =
     s NoNewlineExpr
   / s as Id
   ;

transient void BlockElems =
     BlockElem br BlockElems
   / BlockElem w semicolon
     &(w elif / w also / w end / w catch / w forbid / w finally / w closeparen / w EndOfFile)
   / BlockElem
     &(w elif / w also / w end / w catch / w forbid / w finally / w closeparen / w EndOfFile)
   ;

private Expr BlockElem =
     NoNewlineExpr
   ;

private void DeclKeywords =
     trait / object / dim / unit / SI_unit / type / test / property ;

StringLiteralExpr StringLiteralExpr =
     <FIRST> ["] a1:StringLiteralContents? ["]
     { if (a1 == null) a1 = "";
       yyValue = ExprFactory.makeStringLiteralExpr(createSpan(yyStart,yyCount), a1);
     }
   / "\u201c" a1:StringLiteralContents? "\u201d"
     { if (a1 == null) a1 = "";
       yyValue = ExprFactory.makeStringLiteralExpr(createSpan(yyStart,yyCount), a1);
     }
   / <ErrorProduction1> ["] a1:StringLiteralContents? "\u201d"
     { Span span = createSpan(yyStart,yyCount);
       log(span, "The opening and closing marks of a string literal must match.");
       yyValue = ExprFactory.makeStringLiteralExpr(span, "");
     }
   / <ErrorProduction2> "\u201c" a1:StringLiteralContents? ["]
     { Span span = createSpan(yyStart,yyCount);
       log(span, "The opening and closing marks of a string literal must match.");
       yyValue = ExprFactory.makeStringLiteralExpr(span, "");
     }
   / <ErrorProduction3> ["] a1:StringLiteralContents
     { Span span = createSpan(yyStart,yyCount);
       yyValue = ExprFactory.makeStringLiteralExpr(span, "");
     }
   / <ErrorProduction4> "\u201c" a1:StringLiteralContents
     { Span span = createSpan(yyStart,yyCount);
       yyValue = ExprFactory.makeStringLiteralExpr(span, "");
     }
   ;

private String StringLiteralContents =
     StringLiteralContent* a1:[\n\f\r]+ &( w EndOfFile )
     { yyValue = ""; }
   / StringLiteralContent* a1:[\n\f\r]+
     { log(createSpan(yyStart,yyCount), "Unmatched delimiter \"\\\"\".");
       yyValue = "";
     }
   / a1:StringLiteralContent+
     { String str = "";
       for (String c : (List<String>)a1.list()) {
           str = str.concat(c);
       }
       yyValue = str;
     }
   ;

private String StringLiteralContent =
     EscapeSequence
   / a1:(!InvalidStringLiteralContent _) &( w EndOfFile )
     { log(createSpan(yyStart,yyCount), "Unmatched delimiter \"\\\"\".");
       yyValue = String.valueOf(a1);
     }
   / a1:(!InvalidStringLiteralContent _) { yyValue = String.valueOf(a1); }
   ;

private void InvalidStringLiteralContent =
     void:["\u201c\u201d]
   / [\n\f\r]
   / a1:[\\]
     { log(createSpan(yyStart,yyCount), "Invalid string literal content: " + a1); }
   / a1:[\u0009\u000b\u001c\u001d\u001e\u001f\u2028\u2029]
     { log(createSpan(yyStart,yyCount), "Invalid string literal content: " + a1); }
   / c:_ &{ Character.getType(c) == Character.CONTROL }
     { log(createSpan(yyStart,yyCount), "Invalid string literal content: " + c); };

private String EscapeSequence =
     '\\' a1:[btnfr"\\]
     { switch (a1) {
           case 'b': { yyValue = "\b"; break; }
           case 't': { yyValue = "\t"; break; }
           case 'n': { yyValue = "\n"; break; }
           case 'f': { yyValue = "\f"; break; }
           case 'r': { yyValue = "\r"; break; }
           case '"': { yyValue = "\""; break; }
           case '\\': { yyValue = "\\"; break; }
           default: { yyValue = ""; }
       }
     }
   / '\\' a1:[\u201c] { yyValue = "\u201c"; }
   / '\\' a1:[\u201d] { yyValue = "\u201d"; };
/* '*/
