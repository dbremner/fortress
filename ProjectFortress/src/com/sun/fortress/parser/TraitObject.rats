/*******************************************************************************
    Copyright 2009 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress trait and object declarations.
 */
module com.sun.fortress.parser.TraitObject(Method, Variable, Param, Other, Header,
                                           Identifier, Keyword, Symbol, Spacing);

import Method;
import Variable;
modify Param;
import Other;
import Header;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* TraitDecl ::=
     Mods? TraitHeaderFront TraitClauses (w GoInATrait)? w end ((s trait)? s Id)?
 */
TraitDecl TraitDecl =
     a1:Mods? a2:TraitHeaderFront a3:TraitClauses a4:(w GoInATrait)? w end
     a5:((s trait)? s Id)?
     { Span span = createSpan(yyStart,yyCount);
       if (a5 != null && !a2.getName().getText().equals(a5.getText()))
           log(span, "A trait declaration of " + a2.getName() +
                     " has the different name " + a5 + " at the end.");
       if (a1 == null) a1 = Modifiers.None;
       if (a4 == null) a4 = Collections.<Decl>emptyList();
       yyValue = NodeFactory.makeTraitDecl(span, a1, a2.getName(),
                       a2.getStaticParams(), a2.getExtendsClause(), a3.getWhere(),
                       a4, a3.getExcludes(), a3.getComprises());
     };

/* TraitHeaderFront ::= trait w Id (w StaticParams)? (w ExtendsWhere)? */
private TraitHeader TraitHeaderFront =
     <ErrorProduction>
     trait w a1:OpName a2:(w StaticParams)? a3:(w ExtendsWhere)?
      { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid trait name.");
       Id id = NodeFactory.bogusId(span);
       yyValue = new TraitHeader(id, a2, a3);
     }
   / trait w a1:Id a2:(w StaticParams)? a3:(w ExtendsWhere)?
     { if (a2 == null) a2 = FortressUtil.emptyStaticParams();
       if (a3 == null) a3 = FortressUtil.emptyTraitTypeWheres();
       yyValue = new TraitHeader(a1, a2, a3);
     };

/* Each trait clause cannot appear more than once. */
/* TraitClauses ::= (w TraitClause)* */
private TraitClauses TraitClauses = a1s:(w TraitClause)*
     { yyValue = new TraitClauses();
       for (TraitClause t : (List<TraitClause>)a1s.list()) {
           yyValue.set(t);
       }
     };

/* TraitClause ::=
     Excludes
   | Comprises
   | Where
 */
private TraitClause TraitClause =
     a1:Excludes  { yyValue = new Excludes(createSpan(yyStart,yyCount), a1); }
   / a1:Comprises { yyValue = new Comprises(createSpan(yyStart,yyCount), a1); }
   / a1:Where
     { yyValue = new Where(createSpan(yyStart,yyCount),
                           Option.<WhereClause>some(a1));
     }
   / <ErrorProduction>
     ExtendsWhere
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Extends clauses should come before excludes/comprises/where clauses.");
       yyValue = new Where(span, Option.<WhereClause>none());
     };

/* GoInATrait ::=
     (Coercions br)? GoFrontInATrait (br GoBackInATrait)?
   | (Coercions br)? GoBackInATrait
   | Coercions
 */
private List<Decl> GoInATrait =
     a1:Coercions
     { yyValue = new ArrayList<Decl>();
       yyValue.addAll(a1);
     }
   / <ErrorProduction1>
     GoFrontInATrait br Coercions (br GoBackInATrait)?
     { log(createSpan(yyStart,yyCount),
           "Coercion declarations should come first.");
       yyValue = Collections.<Decl>emptyList();
     }
   / <ErrorProduction2>
     GoFrontInATrait br GoBackInATrait br Coercions
     { log(createSpan(yyStart,yyCount),
           "Coercion declarations should come first.");
       yyValue = Collections.<Decl>emptyList();
     }
   / <ErrorProduction3>
     GoBackInATrait br Coercions
     { log(createSpan(yyStart,yyCount),
           "Coercion declarations should come first.");
       yyValue = Collections.<Decl>emptyList();
     }
   / <ErrorProduction4>
     GoBackInATrait br GoFrontInATrait
     { log(createSpan(yyStart,yyCount),
           "Field/getter/setter declarations should come before method declarations.");
       yyValue = Collections.<Decl>emptyList();
     }
   / a1:(Coercions br)? a2:GoFrontInATrait a3:(br GoBackInATrait)?
     { yyValue = new ArrayList<Decl>();
       if (a1 != null) yyValue.addAll(a1);
       yyValue.addAll(a2);
       if (a3 != null) yyValue.addAll(a3);
     }
   / a1:(Coercions br)? a2:GoBackInATrait
     { yyValue = new ArrayList<Decl>();
       if (a1 != null) yyValue.addAll(a1);
       yyValue.addAll(a2);
     };

/* Coercions ::= Coercion (br Coercion)* */
private List<Decl> Coercions = a1:Coercion a2s:(br Coercion)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* GoFrontInATrait ::= GoesFrontInATrait (br GoesFrontInATrait)* */
private List<Decl> GoFrontInATrait =
     a1:GoesFrontInATrait a2s:(br GoesFrontInATrait)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* GoesFrontInATrait ::= AbsVarDecl | GetterSetterDecl | PropertyDecl */
private Decl GoesFrontInATrait =
     AbsVarDecl
   / GetterSetterDecl
   / PropertyDecl ;

/* GoBackInATrait ::= GoesBackInATrait (br GoesBackInATrait)* */
private List<Decl> GoBackInATrait =
     a1:GoesBackInATrait a2s:(br GoesBackInATrait)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* GoesBackInATrait ::= MdDecl | PropertyDecl */
private Decl GoesBackInATrait =
     MdDecl
   / PropertyDecl ;

/* ObjectDecl ::= Mods? ObjectHeader (w GoInAnObject)? w end ((s object)? s Id)?
 */
ObjectDecl ObjectDecl =
     a1:Mods? a2:ObjectHeader a3:(w GoInAnObject)? w end
     a4:((s object)? s Id)?
     { Span span = createSpan(yyStart,yyCount);
       if (a4 != null && !a2.getName().getText().equals(a4.getText()))
           log(span, "An object declaration of " + a2.getName() +
               " has the different name " + a4 + " at the end.");
       if (a1 == null) a1 = Modifiers.None;
       if (a3 == null) a3 = Collections.<Decl>emptyList();
       FnHeaderClause fhc = a2.getFnHeaderClause();
       Option<Contract> contract = fhc.getContractClause();
       yyValue = NodeFactory.makeObjectDecl
           (span, a1, a2.getName(),
            a2.getStaticParams(), a2.getExtendsClause(), fhc.getWhereClause(),
            a3, a2.getParams(), fhc.getThrowsClause(), contract);
     };

/* ObjectHeader ::=
    object w Id (w StaticParams)? (w ObjectValParam)? (w ExtendsWhere)? FnClauses
 */
private ObjectHeader ObjectHeader =
     <ErrorProduction>
     object w a1:OpName a2:(w StaticParams)? a3:(w ObjectValParam)?
     a4:(w ExtendsWhere)? a5:FnClauses
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid object name.\n" +
           "A non-reserved word that is made up of a mixture" +
           " of uppercase letters and underscores (but no " +
           "digits), does not begin or end with an " +
           "underscore, and contains at least two distinct " +
           "letters is an operator name.");
       yyValue = new ObjectHeader(NodeFactory.bogusId(span),
                                  FortressUtil.emptyStaticParams(),
                                  Option.<List<Param>>none(),
                                  FortressUtil.emptyTraitTypeWheres(), a5);
     }
   / object w a1:Id a2:(w StaticParams)? a3:(w ObjectValParam)?
     a4:(w ExtendsWhere)? a5:FnClauses
     { Option<List<Param>> ps = Option.wrap(a3);
       if (a2 == null) a2 = FortressUtil.emptyStaticParams();
       if (a4 == null) a4 = FortressUtil.emptyTraitTypeWheres();
       yyValue = new ObjectHeader(a1, a2, ps, a4, a5);
     };

/* ObjectValParam ::= ( (w ObjectParams)? w ) */
private List<Param> ObjectValParam = openparen a1:(w Params)? w closeparen
     { if (a1 == null) yyValue = FortressUtil.emptyParams();
       else yyValue = a1;
     };

/* ObjectParams  ::=
     (ObjectParam w , w)* ObjectKeyword (w , w ObjectKeyword)*
   |  ObjectParam (w , w ObjectParam)*
   ObjectKeyword ::= ObjectParam w = w Expr
   ObjectParam   ::= ParamFldMods? Param
 */
Param Varargs :=
     <ErrorProduction>
     VarargsParam
     { Span span = createSpan(yyStart,yyCount);
       log(span, "Varargs parameters of objects are not allowed.");
       yyValue = NodeFactory.bogusParam(span);
     };

Param Param :=
     a1:ParamFldMods? a2:PlainParam
     { if (a1 != null) {
           if (a1.isMutable() && a2.getIdType().isNone()) {
               log(NodeUtil.getSpan(a2),
                   "Mutable fields should be declared with their types.");
               yyValue = NodeFactory.makeParam(a2, a1);
           } else yyValue = NodeFactory.makeParam(a2, a1);
       } else yyValue = a2;
     }
   / <ErrorProduction2>
     var w PlainParam
     { Span span = createSpan(yyStart,yyCount);
       log(span, "Mutable variables should be declared with their types.");
       yyValue = NodeFactory.bogusParam(span);
     };

/* ParamWType ::= BindId w IsType */
private Param PlainParamWType =
    a1:BindId w a2:IsType
    { yyValue = NodeFactory.makeParam(a1, a2); };

/* GoInAnObject ::=
     (Coercions br)? GoFrontInAnObject (br GoBackInAnObject)?
   | (Coercions br)? GoBackInAnObject
   | Coercions
 */
List<Decl> GoInAnObject =
     a1:Coercions
     { yyValue = new ArrayList<Decl>();
       yyValue.addAll(a1);
     }
   / <ErrorProduction1>
     GoFrontInAnObject br Coercions (br GoBackInAnObject)?
     { log(createSpan(yyStart,yyCount),
           "Coercion declarations should come first.");
       yyValue = Collections.<Decl>emptyList();
     }
   / <ErrorProduction2>
     GoFrontInAnObject br GoBackInAnObject br Coercions
     { log(createSpan(yyStart,yyCount),
           "Coercion declarations should come first.");
       yyValue = Collections.<Decl>emptyList();
     }
   / <ErrorProduction3>
     GoBackInAnObject br Coercions
     { log(createSpan(yyStart,yyCount),
           "Coercion declarations should come first.");
       yyValue = Collections.<Decl>emptyList();
     }
   / <ErrorProduction4>
     GoBackInAnObject br GoFrontInAnObject
     { log(createSpan(yyStart,yyCount),
           "Field/getter/setter declarations should come before method declarations.");
       yyValue = Collections.<Decl>emptyList();
     }
   / a1:(Coercions br)? a2:GoFrontInAnObject a3:(br GoBackInAnObject)?
     { yyValue = new ArrayList<Decl>();
       if (a1 != null) yyValue.addAll(a1);
       yyValue.addAll(a2);
       if (a3 != null) yyValue.addAll(a3);
     }
   / a1:(Coercions br)? a2:GoBackInAnObject
     { yyValue = new ArrayList<Decl>();
       if (a1 != null) yyValue.addAll(a1);
       yyValue.addAll(a2);
     };

/* GoFrontInAnObject ::= GoesFrontInAnObject (br GoesFrontInAnObject)* */
private List<Decl> GoFrontInAnObject =
     a1:GoesFrontInAnObject a2s:(br GoesFrontInAnObject)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* GoesFrontInAnObject ::= VarDecl | GetterSetterDef | PropertyDecl */
private Decl GoesFrontInAnObject =
     VarDecl
   / GetterSetterDef
   / PropertyDecl ;

/* GoBackInAnObject ::= GoesBackInAnObject (br GoesBackInAnObject)* */
private List<Decl> GoBackInAnObject =
     a1:GoesBackInAnObject a2s:(br GoesBackInAnObject)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* GoesBackInAnObject ::= MdDef | PropertyDecl */
private Decl GoesBackInAnObject =
     MdDef
   / PropertyDecl ;

/* AbsTraitDecl ::=
     Mods? TraitHeaderFront AbsTraitClauses (w AbsGoInATrait)? w end
     ((s trait)? s Id)?
 */
TraitDecl AbsTraitDecl =
     a1:Mods? a2:TraitHeaderFront a3:AbsTraitClauses
     a4:(w AbsGoInATrait)? w end a5:((s trait)? s Id)?
     { Span span = createSpan(yyStart,yyCount);
       if (a5 != null && !a2.getName().getText().equals(a5.getText())) {
           log(span, "A trait declaration of " + a2.getName() +
               " has the different name " + a5 + " at the end.");
       }
       if (a1 == null) a1 = Modifiers.None;
       if (a4 == null) a4 = Collections.<Decl>emptyList();
       yyValue = NodeFactory.makeTraitDecl
           (span, a1, a2.getName(),
            a2.getStaticParams(), a2.getExtendsClause(), a3.getWhere(),
            a4, a3.getExcludes(), a3.getComprises());
     };

/* Each trait clause cannot appear more than once. */
/* AbsTraitClauses ::= (w AbsTraitClause)* */
private TraitClauses AbsTraitClauses = a1s:(w AbsTraitClause)*
     { yyValue = new TraitClauses();
       for (TraitClause t : (List<TraitClause>)a1s.list()) {
         yyValue.set(t);
       }
     };

/* AbsTraitClause ::=
     Excludes
   | AbsComprises
   | Where
 */
private TraitClause AbsTraitClause =
     a1:Excludes
     { yyValue = new Excludes(createSpan(yyStart,yyCount), a1); }
   / a1:AbsComprises
     { yyValue = new Comprises(createSpan(yyStart,yyCount), a1); }
   / a1:Where
     { yyValue = new Where(createSpan(yyStart,yyCount), Option.some(a1)); }
   / <ErrorProduction>
     ExtendsWhere
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Extends clauses should come before excludes/comprises/where clauses.");
       yyValue = new Where(span, Option.<WhereClause>none());
     };

/* AbsGoInATrait ::=
     (AbsCoercions br)? AbsGoFrontInATrait (br AbsGoBackInATrait)?
   | (AbsCoercions br)? AbsGoBackInATrait
   | AbsCoercions
 */
private List<Decl> AbsGoInATrait =
     a1:AbsCoercions
     { yyValue = new ArrayList<Decl>();
       yyValue.addAll(a1);
     }
   / <ErrorProduction1>
     AbsGoFrontInATrait br AbsCoercions (br AbsGoBackInATrait)?
     { log(createSpan(yyStart,yyCount),
           "Coercion declarations should come first.");
       yyValue = Collections.<Decl>emptyList();
     }
   / <ErrorProduction2>
     AbsGoFrontInATrait br AbsGoBackInATrait br AbsCoercions
     { log(createSpan(yyStart,yyCount),
           "Coercion declarations should come first.");
       yyValue = Collections.<Decl>emptyList();
     }
   / <ErrorProduction3>
     AbsGoBackInATrait br AbsCoercions
     { log(createSpan(yyStart,yyCount),
           "Coercion declarations should come first.");
       yyValue = Collections.<Decl>emptyList();
     }
   / <ErrorProduction4>
     AbsGoBackInATrait br AbsGoFrontInATrait
     { log(createSpan(yyStart,yyCount),
           "Field/getter/setter declarations should come before method declarations.");
       yyValue = Collections.<Decl>emptyList();
     }
   / a1:(AbsCoercions br)? a2:AbsGoFrontInATrait a3:(br AbsGoBackInATrait)?
     { yyValue = new ArrayList<Decl>();
       if (a1 != null) yyValue.addAll(a1);
       yyValue.addAll(a2);
       if (a3 != null) yyValue.addAll(a3);
     }
   / a1:(AbsCoercions br)? a2:AbsGoBackInATrait
     { yyValue = new ArrayList<Decl>();
       if (a1 != null) yyValue.addAll(a1);
       yyValue.addAll(a2);
     };

/* AbsCoercions ::= AbsCoercion (br AbsCoercion)* */
private List<Decl> AbsCoercions = a1:AbsCoercion a2s:(br AbsCoercion)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* AbsGoFrontInATrait ::= AbsGoesFrontInATrait (br AbsGoesFrontInATrait)* */
private List<Decl> AbsGoFrontInATrait =
     a1:AbsGoesFrontInATrait a2s:(br AbsGoesFrontInATrait)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* AbsGoesFrontInATrait ::= AbsVarDecl | AbsGetterSetterDecl | PropertyDecl */
private Decl AbsGoesFrontInATrait =
     AbsVarDecl
   / AbsGetterSetterDecl
   / PropertyDecl ;

/* AbsGoBackInATrait ::= AbsGoesBackInATrait (br AbsGoesBackInATrait)* */
private List<Decl> AbsGoBackInATrait =
     a1:AbsGoesBackInATrait a2s:(br AbsGoesBackInATrait)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* AbsGoesBackInATrait ::= AbsMdDecl | PropertyDecl */
private Decl AbsGoesBackInATrait =
     AbsMdDecl
   / PropertyDecl ;

/* AbsObjectDecl ::= Mods? ObjectHeader (w AbsGoInAnObject)? w end
                     ((s object)? s Id)?
 */
ObjectDecl AbsObjectDecl =
     a1:Mods? a2:ObjectHeader a3:(w AbsGoInAnObject)? w end
     a4:((s object)? s Id)?
     { Span span = createSpan(yyStart,yyCount);
       if (a4 != null && !a2.getName().getText().equals(a4.getText())) {
           log(span, "An object declaration of " + a2.getName() +
               " has the different name " + a4 + " at the end.");
       }
       if (a1 == null) a1 = Modifiers.None;
       if (a3 == null) a3 = Collections.<Decl>emptyList();
       FnHeaderClause fhc = a2.getFnHeaderClause();
       Option<Contract> contract = fhc.getContractClause();
       Option<List<Param>> params = a2.getParams();
       FortressUtil.checkNoWrapped(writer, params);
       yyValue = NodeFactory.makeObjectDecl
           (span, a1, a2.getName(),
            a2.getStaticParams(), a2.getExtendsClause(), fhc.getWhereClause(),
            a3, params, fhc.getThrowsClause(), contract);
     };

/* AbsGoInAnObject ::=
     (AbsCoercions br)? AbsGoFrontInAnObject (br AbsGoBackInAnObject)?
   | (AbsCoercions br)? AbsGoBackInAnObject
   | AbsCoercions
 */
List<Decl> AbsGoInAnObject =
     a1:AbsCoercions
     { yyValue = new ArrayList<Decl>();
       yyValue.addAll(a1);
     }
   / <ErrorProduction1>
     AbsGoFrontInAnObject br AbsCoercions (br AbsGoBackInAnObject)?
     { log(createSpan(yyStart,yyCount),
           "Coercion declarations should come first.");
       yyValue = Collections.<Decl>emptyList();
     }
   / <ErrorProduction2>
     AbsGoFrontInAnObject br AbsGoBackInAnObject br AbsCoercions
     { log(createSpan(yyStart,yyCount),
           "Coercion declarations should come first.");
       yyValue = Collections.<Decl>emptyList();
     }
   / <ErrorProduction3>
     AbsGoBackInAnObject br AbsCoercions
     { log(createSpan(yyStart,yyCount),
           "Coercion declarations should come first.");
       yyValue = Collections.<Decl>emptyList();
     }
   / <ErrorProduction4>
     AbsGoBackInAnObject br AbsGoFrontInAnObject
     { log(createSpan(yyStart,yyCount),
           "Field/getter/setter declarations should come before method declarations.");
       yyValue = Collections.<Decl>emptyList();
     }
   / a1:(AbsCoercions br)? a2:AbsGoFrontInAnObject a3:(br AbsGoBackInAnObject)?
     { yyValue = new ArrayList<Decl>();
       if (a1 != null) yyValue.addAll(a1);
       yyValue.addAll(a2);
       if (a3 != null) yyValue.addAll(a3);
     }
   / a1:(AbsCoercions br)? a2:AbsGoBackInAnObject
     { yyValue = new ArrayList<Decl>();
       if (a1 != null) yyValue.addAll(a1);
       yyValue.addAll(a2);
     };

/* AbsGoFrontInAnObject ::=
     AbsGoesFrontInAnObject (br AbsGoesFrontInAnObject)*
 */
private List<Decl> AbsGoFrontInAnObject =
     a1:AbsGoesFrontInAnObject a2s:(br AbsGoesFrontInAnObject)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* AbsGoesFrontInAnObject ::= AbsVarDecl | AbsGetterSetterDecl | PropertyDecl */
private Decl AbsGoesFrontInAnObject =
     AbsVarDecl
   / AbsGetterSetterDecl
   / PropertyDecl ;

/* AbsGoBackInAnObject ::= AbsGoesBackInAnObject (br AbsGoesBackInAnObject)* */
private List<Decl> AbsGoBackInAnObject =
     a1:AbsGoesBackInAnObject a2s:(br AbsGoesBackInAnObject)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* AbsGoesBackInAnObject ::= AbsMdDecl | PropertyDecl */
private Decl AbsGoesBackInAnObject =
     AbsMdDecl
   / PropertyDecl ;
