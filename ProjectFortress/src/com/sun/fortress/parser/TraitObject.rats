/*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress trait and object declarations.
 */
module com.sun.fortress.parser.TraitObject(Method, Field, AbsField, Param, Other,
                                           Header, Identifier, Keyword, Symbol,
                                           Spacing);

import Method;
import Field;
import AbsField;
modify Param;
import Other;
import Header;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* TraitDecl ::=
     TraitMods? TraitHeaderFront TraitClauses (w GoInATrait)? w end ((s trait)? s Id)?
 */
TraitDecl TraitDecl =
     a1:TraitMods? a2:TraitHeaderFront a3:TraitClauses a4:(w GoInATrait)? w end
     a5:((s trait)? s Id)?
     { Span span = createSpan(yyStart,yyCount);
       if (a5 != null && !a2.getName().getText().equals(a5.getText()))
           yyValue = syntaxError(span, "A trait declaration of " + a2.getName() +
                                 " has the different name " + a5 + " at the end.");
       if (a1 == null) a1 = FortressUtil.emptyModifiers();
       if (a4 == null) a4 = Collections.<Decl>emptyList();
       yyValue =
         new TraitDecl(span, a1, a2.getName(),
                       a2.getStaticParams(), a2.getExtendsClause(), a3.getWhere(),
                       a3.getExcludes(), a3.getComprises(), a4);
     };

/* TraitHeaderFront ::= trait w Id (w StaticParams)? (w ExtendsWhere)? */
private TraitHeader TraitHeaderFront =
     <ErrorProduction>
     trait w a1:OpName a2:(w StaticParams)? a3:(w ExtendsWhere)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             a1 + " is not a valid trait name.\n" +
                             "A non-reserved word that is made up of a mixture" +
                             " of uppercase letters and underscores (but no " +
                             "digits), does not begin or end with an " +
                             "underscore, and contains at least two distinct " +
                             "letters is an operator name.");
     }
   / trait w a1:Id a2:(w StaticParams)? a3:(w ExtendsWhere)?
     { if (a2 == null) a2 = FortressUtil.emptyStaticParams();
       if (a3 == null) a3 = FortressUtil.emptyTraitTypeWheres();
       yyValue = new TraitHeader(a1, a2, a3);
     };

/* Each trait clause cannot appear more than once. */
/* TraitClauses ::= (w TraitClause)* */
private TraitClauses TraitClauses = a1s:(w TraitClause)*
     { yyValue = new TraitClauses();
       for (TraitClause t : (List<TraitClause>)a1s.list()) {
           yyValue.set(t);
       }
     };

/* TraitClause ::=
     Excludes
   | Comprises
   | Where
 */
private TraitClause TraitClause =
     a1:Excludes  { yyValue = new Excludes(createSpan(yyStart,yyCount), a1); }
   / a1:Comprises { yyValue = new Comprises(createSpan(yyStart,yyCount), a1); }
   / a1:Where
     { yyValue = new Where(createSpan(yyStart,yyCount),
                           Option.some(a1));
     }
   / <ErrorProduction>
     ExtendsWhere
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before excludes/comprises/where clauses.");
     };

/* GoInATrait ::=
     (Coercions br)? GoFrontInATrait (br GoBackInATrait)?
   | (Coercions br)? GoBackInATrait
   | Coercions
 */
private List<Decl> GoInATrait =
     a1:Coercions
     { yyValue = new ArrayList<Decl>();
       yyValue.addAll(a1);
     }
   / <ErrorProduction1>
     GoFrontInATrait br Coercions (br GoBackInATrait)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Coercion declarations should come first.");
     }
   / <ErrorProduction2>
     GoFrontInATrait br GoBackInATrait br Coercions
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Coercion declarations should come first.");
     }
   / <ErrorProduction3>
     GoBackInATrait br Coercions
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Coercion declarations should come first.");
     }
   / <ErrorProduction4>
     GoBackInATrait br GoFrontInATrait
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Field/getter/setter declarations should come before method declarations.");
     }
   / a1:(Coercions br)? a2:GoFrontInATrait a3:(br GoBackInATrait)?
     { yyValue = new ArrayList<Decl>();
       if (a1 != null) yyValue.addAll(a1);
       yyValue.addAll(a2);
       if (a3 != null) yyValue.addAll(a3);
     }
   / a1:(Coercions br)? a2:GoBackInATrait
     { yyValue = new ArrayList<Decl>();
       if (a1 != null) yyValue.addAll(a1);
       yyValue.addAll(a2);
     };

/* Coercions ::= Coercion (br Coercion)* */
private List<Decl> Coercions = a1:Coercion a2s:(br Coercion)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* GoFrontInATrait ::= GoesFrontInATrait (br GoesFrontInATrait)* */
private List<Decl> GoFrontInATrait =
     a1:GoesFrontInATrait a2s:(br GoesFrontInATrait)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* GoesFrontInATrait ::= AbsFldDecl | GetterSetterDecl | PropertyDecl */
private Decl GoesFrontInATrait =
     AbsFldDecl
   / GetterSetterDecl
   / PropertyDecl ;

/* GoBackInATrait ::= GoesBackInATrait (br GoesBackInATrait)* */
private List<Decl> GoBackInATrait =
     a1:GoesBackInATrait a2s:(br GoesBackInATrait)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* GoesBackInATrait ::= MdDecl | PropertyDecl */
private Decl GoesBackInATrait =
     MdDecl
   / PropertyDecl ;

/* ObjectDecl ::= ObjectMods? ObjectHeader (w GoInAnObject)? w end ((s object)? s Id)?
 */
ObjectDecl ObjectDecl =
     a1:ObjectMods? a2:ObjectHeader a3:(w GoInAnObject)? w end
     a4:((s object)? s Id)?
     { Span span = createSpan(yyStart,yyCount);
       if (a4 != null && !a2.getName().getText().equals(a4.getText()))
           yyValue = syntaxError(span, "An object declaration of " + a2.getName() +
                                 " has the different name " + a4 + " at the end.");
       if (a1 == null) a1 = FortressUtil.emptyModifiers();
       if (a3 == null) a3 = Collections.<Decl>emptyList();
       FnHeaderClause fhc = a2.getFnHeaderClause();
       Option<Contract> contract = fhc.getContractClause();
       yyValue = new ObjectDecl
           (span, a1, a2.getName(),
            a2.getStaticParams(), a2.getExtendsClause(), fhc.getWhereClause(),
            a2.getParams(), fhc.getThrowsClause(), contract, a3);
     };

/* ObjectHeader ::=
    object w Id (w StaticParams)? (w ObjectValParam)? (w ExtendsWhere)? FnClauses
 */
private ObjectHeader ObjectHeader =
     <ErrorProduction>
     object w a1:OpName a2:(w StaticParams)? a3:(w ObjectValParam)?
     a4:(w ExtendsWhere)? a5:FnClauses
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             a1 + " is not a valid object name.\n" +
                             "A non-reserved word that is made up of a mixture" +
                             " of uppercase letters and underscores (but no " +
                             "digits), does not begin or end with an " +
                             "underscore, and contains at least two distinct " +
                             "letters is an operator name.");
     }
   / object w a1:Id a2:(w StaticParams)? a3:(w ObjectValParam)?
     a4:(w ExtendsWhere)? a5:FnClauses
     { Option<List<Param>> ps = Option.wrap(a3);
       if (a2 == null) a2 = FortressUtil.emptyStaticParams();
       if (a4 == null) a4 = FortressUtil.emptyTraitTypeWheres();
       yyValue = new ObjectHeader(a1, a2, ps, a4, a5);
     };

/* ObjectValParam ::= ( (w ObjectParams)? w ) */
private List<Param> ObjectValParam = openparen a1:(w Params)? w closeparen
     { if (a1 == null) yyValue = FortressUtil.emptyParams();
       else yyValue = a1;
     };

/* ObjectParams  ::=
     (ObjectParam w , w)* (ObjectVarargs w , w)? ObjectKeyword (w , w ObjectKeyword)*
   | (ObjectParam w , w)*  ObjectVarargs
   |  ObjectParam (w , w ObjectParam)*
   ObjectVarargs ::= transient w Varargs
   ObjectKeyword ::= ObjectParam w = w Expr
   ObjectParam   ::= ParamFldMods? Param
                 |   var w transient w ParamWType
                 |   (transient w)? var w ParamWType
                 |   transient w Param
 */
VarargsParam Varargs :=
     transient w a1:VarargsParam
     { yyValue = NodeFactory.makeVarargsParam(a1, FortressUtil.mkList(
                    (Modifier)new ModifierTransient(createSpan(yyStart,9))));
     }
   / <ErrorProduction>
     VarargsParam
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Varargs parameters of objects should be transient.");
     };

NormalParam Param :=
     a1:ParamFldMods? a2:PlainParam
     { if (a1 != null) yyValue = NodeFactory.makeParam(a2, a1);
       else yyValue = a2;
     }
   / var w transient w a1:PlainParamWType
     { List<Modifier> mods = new ArrayList<Modifier>(2);
       mods.add(new ModifierVar(createSpan(yyStart,3)));
       mods.add(new ModifierTransient(createSpan(yyStart+3,9)));
       yyValue = NodeFactory.makeParam(a1, mods);
     }
   / a1:(transient w)? var w a2:PlainParamWType
     { List<Modifier> mods;
       if (a1 == null) {
           mods = new ArrayList<Modifier>(1);
           mods.add(new ModifierVar(createSpan(yyStart,3)));
       } else {
           mods = new ArrayList<Modifier>(2);
           mods.add(new ModifierTransient(createSpan(yyStart,9)));
           mods.add(new ModifierVar(createSpan(yyStart+9,3)));
       }
       yyValue = NodeFactory.makeParam(a2, mods);
     }
   / transient w a1:PlainParam
     { List<Modifier> mods = new ArrayList<Modifier>(2);
       mods.add(new ModifierTransient(createSpan(yyStart,9)));
       yyValue = NodeFactory.makeParam(a1, mods);
     }
   / <ErrorProduction1>
     var w transient w PlainParam
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Mutable variables should be declared with their types.");
     }
   / <ErrorProduction2>
     (transient w)? var w PlainParam
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Mutable variables should be declared with their types.");
     };

/* ParamWType ::= BindId w IsType */
private NormalParam PlainParamWType =
    a1:BindId w a2:IsType
    { yyValue = NodeFactory.makeParam(a1, a2); };

/* GoInAnObject ::=
     (Coercions br)? GoFrontInAnObject (br GoBackInAnObject)?
   | (Coercions br)? GoBackInAnObject
   | Coercions
 */
List<Decl> GoInAnObject =
     a1:Coercions
     { yyValue = new ArrayList<Decl>();
       yyValue.addAll(a1);
     }
   / <ErrorProduction1>
     GoFrontInAnObject br Coercions (br GoBackInAnObject)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Coercion declarations should come first.");
     }
   / <ErrorProduction2>
     GoFrontInAnObject br GoBackInAnObject br Coercions
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Coercion declarations should come first.");
     }
   / <ErrorProduction3>
     GoBackInAnObject br Coercions
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Coercion declarations should come first.");
     }
   / <ErrorProduction4>
     GoBackInAnObject br GoFrontInAnObject
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Field/getter/setter declarations should come before method declarations.");
     }
   / a1:(Coercions br)? a2:GoFrontInAnObject a3:(br GoBackInAnObject)?
     { yyValue = new ArrayList<Decl>();
       if (a1 != null) yyValue.addAll(a1);
       yyValue.addAll(a2);
       if (a3 != null) yyValue.addAll(a3);
     }
   / a1:(Coercions br)? a2:GoBackInAnObject
     { yyValue = new ArrayList<Decl>();
       if (a1 != null) yyValue.addAll(a1);
       yyValue.addAll(a2);
     };

/* GoFrontInAnObject ::= GoesFrontInAnObject (br GoesFrontInAnObject)* */
private List<Decl> GoFrontInAnObject =
     a1:GoesFrontInAnObject a2s:(br GoesFrontInAnObject)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* GoesFrontInAnObject ::= FldDecl | GetterSetterDef | PropertyDecl */
private Decl GoesFrontInAnObject =
     FldDecl
   / GetterSetterDef
   / PropertyDecl ;

/* GoBackInAnObject ::= GoesBackInAnObject (br GoesBackInAnObject)* */
private List<Decl> GoBackInAnObject =
     a1:GoesBackInAnObject a2s:(br GoesBackInAnObject)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* GoesBackInAnObject ::= MdDef | PropertyDecl */
private Decl GoesBackInAnObject =
     MdDef
   / PropertyDecl ;

/* AbsTraitDecl ::=
     AbsTraitMods? TraitHeaderFront AbsTraitClauses (w AbsGoInATrait)? w end
     ((s trait)? s Id)?
 */
AbsTraitDecl AbsTraitDecl =
     a1:AbsTraitMods? a2:TraitHeaderFront a3:AbsTraitClauses
     a4:(w AbsGoInATrait)? w end a5:((s trait)? s Id)?
     { Span span = createSpan(yyStart,yyCount);
       if (a5 != null && !a2.getName().getText().equals(a5.getText()))
           yyValue = syntaxError(span, "A trait declaration of " + a2.getName() +
                                 " has the different name " + a5 + " at the end.");
       if (a1 == null) a1 = FortressUtil.emptyModifiers();
       if (a4 == null) a4 = Collections.<AbsDecl>emptyList();
       yyValue = new AbsTraitDecl
           (span, a1, a2.getName(),
            a2.getStaticParams(), a2.getExtendsClause(), a3.getWhere(),
            a3.getExcludes(), a3.getComprises(), a4);
     };

/* Each trait clause cannot appear more than once. */
/* AbsTraitClauses ::= (w AbsTraitClause)* */
private TraitClauses AbsTraitClauses = a1s:(w AbsTraitClause)*
     { yyValue = new TraitClauses();
       for (TraitClause t : (List<TraitClause>)a1s.list()) {
         yyValue.set(t);
       }
     };

/* AbsTraitClause ::=
     Excludes
   | AbsComprises
   | Where
 */
private TraitClause AbsTraitClause =
     a1:Excludes
     { yyValue = new Excludes(createSpan(yyStart,yyCount), a1); }
   / a1:AbsComprises
     { yyValue = new Comprises(createSpan(yyStart,yyCount), a1); }
   / a1:Where
     { yyValue = new Where(createSpan(yyStart,yyCount), Option.some(a1)); }
   / <ErrorProduction>
     ExtendsWhere
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before excludes/comprises/where clauses.");
     };

/* AbsGoInATrait ::=
     (AbsCoercions br)? AbsGoFrontInATrait (br AbsGoBackInATrait)?
   | (AbsCoercions br)? AbsGoBackInATrait
   | AbsCoercions
 */
private List<AbsDecl> AbsGoInATrait =
     a1:AbsCoercions
     { yyValue = new ArrayList<AbsDecl>();
       yyValue.addAll(a1);
     }
   / <ErrorProduction1>
     AbsGoFrontInATrait br AbsCoercions (br AbsGoBackInATrait)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Coercion declarations should come first.");
     }
   / <ErrorProduction2>
     AbsGoFrontInATrait br AbsGoBackInATrait br AbsCoercions
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Coercion declarations should come first.");
     }
   / <ErrorProduction3>
     AbsGoBackInATrait br AbsCoercions
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Coercion declarations should come first.");
     }
   / <ErrorProduction4>
     AbsGoBackInATrait br AbsGoFrontInATrait
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Field/getter/setter declarations should come before method declarations.");
     }
   / a1:(AbsCoercions br)? a2:AbsGoFrontInATrait a3:(br AbsGoBackInATrait)?
     { yyValue = new ArrayList<AbsDecl>();
       if (a1 != null) yyValue.addAll(a1);
       yyValue.addAll(a2);
       if (a3 != null) yyValue.addAll(a3);
     }
   / a1:(AbsCoercions br)? a2:AbsGoBackInATrait
     { yyValue = new ArrayList<AbsDecl>();
       if (a1 != null) yyValue.addAll(a1);
       yyValue.addAll(a2);
     };

/* AbsCoercions ::= AbsCoercion (br AbsCoercion)* */
private List<AbsDecl> AbsCoercions = a1:AbsCoercion a2s:(br AbsCoercion)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* AbsGoFrontInATrait ::= AbsGoesFrontInATrait (br AbsGoesFrontInATrait)* */
private List<AbsDecl> AbsGoFrontInATrait =
     a1:AbsGoesFrontInATrait a2s:(br AbsGoesFrontInATrait)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* AbsGoesFrontInATrait ::= ApiFldDecl | AbsGetterSetterDecl | PropertyDecl */
private AbsDecl AbsGoesFrontInATrait =
     ApiFldDecl
   / AbsGetterSetterDecl
   / PropertyDecl ;

/* AbsGoBackInATrait ::= AbsGoesBackInATrait (br AbsGoesBackInATrait)* */
private List<AbsDecl> AbsGoBackInATrait =
     a1:AbsGoesBackInATrait a2s:(br AbsGoesBackInATrait)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* AbsGoesBackInATrait ::= AbsMdDecl | PropertyDecl */
private AbsDecl AbsGoesBackInATrait =
     AbsMdDecl
   / PropertyDecl ;

/* AbsObjectDecl ::= AbsObjectMods? ObjectHeader (w AbsGoInAnObject)? w end
                     ((s object)? s Id)?
 */
AbsObjectDecl AbsObjectDecl =
     a1:AbsObjectMods? a2:ObjectHeader a3:(w AbsGoInAnObject)? w end
     a4:((s object)? s Id)?
     { Span span = createSpan(yyStart,yyCount);
       if (a4 != null && !a2.getName().getText().equals(a4.getText()))
           yyValue = syntaxError(span, "An object declaration of " + a2.getName() +
                                 " has the different name " + a4 + " at the end.");
       if (a1 == null) a1 = FortressUtil.emptyModifiers();
       if (a3 == null) a3 = Collections.<AbsDecl>emptyList();
       FnHeaderClause fhc = a2.getFnHeaderClause();
       Option<Contract> contract = fhc.getContractClause();
       yyValue = new AbsObjectDecl
           (span, a1, a2.getName(),
            a2.getStaticParams(), a2.getExtendsClause(), fhc.getWhereClause(),
            a2.getParams(), fhc.getThrowsClause(), contract, a3);
     };

/* AbsGoInAnObject ::=
     (AbsCoercions br)? AbsGoFrontInAnObject (br AbsGoBackInAnObject)?
   | (AbsCoercions br)? AbsGoBackInAnObject
   | AbsCoercions
 */
List<AbsDecl> AbsGoInAnObject =
     a1:AbsCoercions
     { yyValue = new ArrayList<AbsDecl>();
       yyValue.addAll(a1);
     }
   / <ErrorProduction1>
     AbsGoFrontInAnObject br AbsCoercions (br AbsGoBackInAnObject)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Coercion declarations should come first.");
     }
   / <ErrorProduction2>
     AbsGoFrontInAnObject br AbsGoBackInAnObject br AbsCoercions
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Coercion declarations should come first.");
     }
   / <ErrorProduction3>
     AbsGoBackInAnObject br AbsCoercions
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Coercion declarations should come first.");
     }
   / <ErrorProduction4>
     AbsGoBackInAnObject br AbsGoFrontInAnObject
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Field/getter/setter declarations should come before method declarations.");
     }
   / a1:(AbsCoercions br)? a2:AbsGoFrontInAnObject a3:(br AbsGoBackInAnObject)?
     { yyValue = new ArrayList<AbsDecl>();
       if (a1 != null) yyValue.addAll(a1);
       yyValue.addAll(a2);
       if (a3 != null) yyValue.addAll(a3);
     }
   / a1:(AbsCoercions br)? a2:AbsGoBackInAnObject
     { yyValue = new ArrayList<AbsDecl>();
       if (a1 != null) yyValue.addAll(a1);
       yyValue.addAll(a2);
     };

/* AbsGoFrontInAnObject ::=
     AbsGoesFrontInAnObject (br AbsGoesFrontInAnObject)*
 */
private List<AbsDecl> AbsGoFrontInAnObject =
     a1:AbsGoesFrontInAnObject a2s:(br AbsGoesFrontInAnObject)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* AbsGoesFrontInAnObject ::= ApiFldDecl | AbsGetterSetterDecl | PropertyDecl */
private AbsDecl AbsGoesFrontInAnObject =
     ApiFldDecl
   / AbsGetterSetterDecl
   / PropertyDecl ;

/* AbsGoBackInAnObject ::= AbsGoesBackInAnObject (br AbsGoesBackInAnObject)* */
private List<AbsDecl> AbsGoBackInAnObject =
     a1:AbsGoesBackInAnObject a2s:(br AbsGoesBackInAnObject)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* AbsGoesBackInAnObject ::= AbsMdDecl | PropertyDecl */
private AbsDecl AbsGoesBackInAnObject =
     AbsMdDecl
   / PropertyDecl ;
