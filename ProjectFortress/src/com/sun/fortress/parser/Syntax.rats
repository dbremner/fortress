/*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress macro language.
 */
module com.sun.fortress.parser.Syntax(Identifier, Keyword, Spacing, Symbol, Expr,
                                      DelimitedExpr, LocalDecl, Unicode, Header,
                                      Type);

import Identifier;
import Keyword;
import Spacing;
import Symbol;
import Expr;
import DelimitedExpr;
import LocalDecl;
import Unicode;
import Header;
import Type;

header {
  import java.util.LinkedList;
}

body {
  static {
    add(FORTRESS_SYNTAX_SPECIAL_SYMBOLS, new String[] {
        "AND",    "BACKSPACE",    "FORMFEED",    "NEWLINE",
        "NOT",    "RETURN",    "TAB",    "SPACE",    "<\\["
    });

    add(FORTRESS_SYNTAX_SPECIAL_CHARS, new String[] {
        "#",    ":",    "`",    "\\+",    "\\?",    "\\*",    "\\[",    "\\]",    "\\|",    "\\_", "\\{", "\\}"
    });
  }
}

option setOfString(FORTRESS_SYNTAX_SPECIAL_SYMBOLS), setOfString(FORTRESS_SYNTAX_SPECIAL_CHARS);

/* GrammarDef ::= grammar w id w GrammarExtends? (br NonterminalDef)* w end */
public GrammarDecl GrammarDef =
     native w grammar w a1:Id a3s:(br NonterminalDecl)* w end
     { List<Id> extendedGrammars = Collections.<Id>emptyList();
       yyValue = new GrammarDef(createSpan(yyStart,yyCount), a1, extendedGrammars,
                                a3s.list(),
                                new LinkedList<TransformerDecl>(),
                                /*native*/ true); }
   / grammar w a1:Id a2:(w GrammarExtends)? a3s:(br NonterminalDef)* w end 
     { List<Id> ids = new ArrayList<Id>();
       if ( a2 == null) ids = Collections.<Id>emptyList();
       else { ids.addAll(a2); } 
       yyValue = new GrammarDef(createSpan(yyStart,yyCount), a1, ids, a3s.list(), new LinkedList<TransformerDecl>(), false); };

/* GrammarExtends ::= extends w QualifiedNames */
List<Id> GrammarExtends = extends w QualifiedNames ;

/* QualifiedNames ::= QualifiedName | { w QualifiedNameList w } */
List<Id> QualifiedNames =
     a1:QualifiedName { yyValue = FortressUtil.mkList(a1); }
   / void:opencurly w QualifiedNameList w void:closecurly ;

/* QualifiedNameList ::= QualifiedName (w , w QualifiedName)* */
private List<Id> QualifiedNameList = a1:QualifiedName a2s:(w comma w QualifiedName)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* Extends ::= extends w IdName */
Option<Id> Extends = extends w a1:QualifiedName { yyValue = Option.some(a1); };

private GrammarMemberDecl NonterminalDef =
      header:NonterminalHeader w void:bar astType:(w TraitType)? w void:colonequals w a4:SyntaxDef a4s:(w SyntaxDefOr)*
      { Option<BaseType> astType1 = Option.none();
        if (astType != null) astType1 = Option.some(astType);
        List<SyntaxDef> syntaxDefs = a4s.list();
        syntaxDefs.add(0, a4);
        yyValue = new NonterminalExtensionDef(createSpan(yyStart,yyCount), header, astType1, syntaxDefs); }
    /  header:NonterminalHeader w void:colon astType:(w TraitType)? w void:colonequals w a4:SyntaxDef a4s:(w SyntaxDefOr)*
      { Option<BaseType> astType1 = Option.none();
        if (astType != null) astType1 = Option.some(astType);
        List<SyntaxDef> syntaxDefs = a4s.list();
        syntaxDefs.add(0, a4); 
        yyValue = new NonterminalDef(createSpan(yyStart,yyCount), header, astType1, syntaxDefs); }
    /  yyValue:NonterminalDecl
    /  header:NonterminalHeader w void:bar w astType:TraitType
      { Option<BaseType> astType1 = Option.none();
        if (astType != null) astType1 = Option.some(astType);
	List<SyntaxDef> syntaxDefs = Collections.<SyntaxDef>emptyList();
        yyValue = new NonterminalExtensionDef(createSpan(yyStart,yyCount), header, astType1, syntaxDefs); };

/* Only nonterminal decls are allowed within native grammars */
private GrammarMemberDecl NonterminalDecl =
       header:NonterminalHeader w void:colon w astType:TraitType
      { Option<BaseType> astType1 = Option.none();
        if (astType != null) astType1 = Option.some(astType);
        List<SyntaxDef> syntaxDefs = Collections.<SyntaxDef>emptyList();
        yyValue = new NonterminalDef(createSpan(yyStart,yyCount), header, astType1, syntaxDefs); };

private NonterminalHeader NonterminalHeader =
        mod:(NonTermMod w)? name:Id params:(w NonterminalArguments)? staticParams:(w StaticParams)? type:(void:colon Type)? whereClauses:(w Where)?
        { if (mod == null) mod = Option.none();
          if (params == null) params = new LinkedList<NonterminalParameter>();
          if (staticParams == null) staticParams = FortressUtil.emptyStaticParams();
          Option<Type> type1 = Option.<Type>none();
          if (type != null) type1 = Option.some(type);
          if (whereClauses == null) whereClauses = FortressUtil.emptyWhereClause();
          yyValue = new NonterminalHeader(createSpan(yyStart, yyCount), mod, name, params, staticParams, type1, whereClauses);
        };

private Option<ModifierPrivate> NonTermMod =
        private {yyValue = Option.some(new ModifierPrivate(createSpan(yyStart,yyCount)));};

private List<NonterminalParameter> NonterminalArguments =
        void:openparen w DeclList w void:closeparen;

private List<NonterminalParameter> DeclList =
        a1:Decl w comma w a2s:DeclList
        { yyValue = FortressUtil.mkList(a1, a2s); }
     /  a1:Decl
        { yyValue = FortressUtil.mkList(a1); };

private NonterminalParameter Decl =
        a1:Id colon a2:TraitType
        { yyValue = new NonterminalParameter(createSpan(yyStart,yyCount),
                                             a1,a2); };

/* SyntaxDef ::= SyntaxSymbol*  w BlockExpr **/
SyntaxDef SyntaxDef =
     a1s:SyntaxSymbols w a2:PreTransformer
     { yyValue = NodeFactory.makeSyntaxDef(createSpan(yyStart,yyCount), a1s, a2); };
/*
       a1s:SyntaxSymbols w a2:TransformerExpr
       { yyValue = NodeFactory.makeSyntaxDef(createSpan(yyStart,yyCount), a1s, a2); }
     / a1s:SyntaxSymbols w a2:PreTransformer
       { yyValue = NodeFactory.makeSyntaxDef(createSpan(yyStart,yyCount), a1s, a2); };
       */

SyntaxDef SyntaxDefOr =
     void:bar w a1s:SyntaxSymbols w a2:PreTransformer
     { yyValue = NodeFactory.makeSyntaxDef(createSpan(yyStart,yyCount), a1s, a2); };
/*
       void:bar w a1s:SyntaxSymbols w a2:TransformerExpr
       { yyValue = NodeFactory.makeSyntaxDef(createSpan(yyStart,yyCount), a1s, a2); }
     / void:bar w a1s:SyntaxSymbols w a2:PreTransformer
       { yyValue = NodeFactory.makeSyntaxDef(createSpan(yyStart,yyCount), a1s, a2); };
*/

/* TransformationExpr ::= do BlockElems end */
/*
TransformerExpressionDef TransformerExpr =
     do a3:(w BlockElems) w end
     { Span span = createSpan(yyStart, yyCount);
       if (a3 == null) a3 = FortressUtil.doBlock(span);
       Do d = new Do(span, false,
                        FortressUtil.mkList(new DoFront(span, Option.<Expr>none(), false, a3)));
       yyValue = new TransformerExpressionDef(createSpan(yyStart,yyCount), d);
     };
*/

/* TransformationTemplate ::= <[ Expr ]> */
PreTransformerDef PreTransformer =
     leftDelimiter w a1:AnythingButRightDelimiter w rightDelimiter
     { yyValue = new PreTransformerDef(createSpan(yyStart,yyCount), "Expr", a1); };

String AnythingButRightDelimiter = (']' !'>' / !']' _)*;

List<SyntaxSymbol> SyntaxSymbols =
      a1:SyntaxSymbol a1s:Symbs* &(w (leftDelimiter))
      { List<SyntaxSymbol> ls = FortressUtil.mkList(a1);
        for(List<SyntaxSymbol> sl: a1s.list()) {
          ls.addAll(sl);
        }
        yyValue = ls; };

List<SyntaxSymbol> SyntaxSymbolsX =
      a1:SyntaxSymbol a1s:Symbs*
      { List<SyntaxSymbol> ls = FortressUtil.mkList(a1);
        for(List<SyntaxSymbol> sl: a1s.list()) {
          ls.addAll(sl);
        }
        yyValue = ls; };

List<SyntaxSymbol> Symbs = a1:SpaceOrBreakline+ a2:SyntaxSymbol
     { yyValue = FortressUtil.mkList(a1.list(),a2);};

SyntaxSymbol SpaceOrBreakline =
      a1:sr
      { yyValue = new WhitespaceSymbol(createSpan(yyStart,yyCount), a1); }
    /  yyValue:Breakline;

SyntaxSymbol SyntaxSymbol =
      Not w s1:SymbolMod
      {  if (s1 instanceof NoWhitespaceSymbol) {
          SyntaxSymbol tmp = ((NoWhitespaceSymbol) s1).getSymbol();
          yyValue = new NoWhitespaceSymbol(createSpan(yyStart,yyCount), new NotPredicateSymbol(s1.getSpan(), tmp));
        }
        else {
           yyValue = new NotPredicateSymbol(createSpan(yyStart,yyCount), s1);
        }}
    / And w s1:SymbolMod
      {  if (s1 instanceof NoWhitespaceSymbol) {
          SyntaxSymbol tmp = ((NoWhitespaceSymbol) s1).getSymbol();
          yyValue = new NoWhitespaceSymbol(createSpan(yyStart,yyCount), new AndPredicateSymbol(s1.getSpan(), tmp));
        }
        else {
           yyValue = new AndPredicateSymbol(createSpan(yyStart,yyCount), s1);
        }}
    / yyValue:SymbolMod;

SyntaxSymbol SymbolMod =
    s:Single questionmark
      { if ( s instanceof NoWhitespaceSymbol ){
          yyValue = new NoWhitespaceSymbol(createSpan(yyStart,yyCount), new OptionalSymbol(s.getSpan(), ((NoWhitespaceSymbol)s).getSymbol()));
        } else {
	  yyValue = new OptionalSymbol(createSpan(yyStart,yyCount), s);
	}
      }
    / s:Single star
      { if ( s instanceof NoWhitespaceSymbol ){
          yyValue = new NoWhitespaceSymbol(createSpan(yyStart,yyCount), new RepeatSymbol(s.getSpan(), ((NoWhitespaceSymbol)s).getSymbol()));
        } else {
	  yyValue = new RepeatSymbol(createSpan(yyStart,yyCount), s);
	}
      }
    / s:Single plus
      { if ( s instanceof NoWhitespaceSymbol ){
          yyValue = new NoWhitespaceSymbol(createSpan(yyStart,yyCount), new RepeatOneOrMoreSymbol(s.getSpan(), ((NoWhitespaceSymbol)s).getSymbol()));
        } else {
	  yyValue = new RepeatOneOrMoreSymbol(createSpan(yyStart,yyCount), s);
	}
      }
    / yyValue:Single;

SyntaxSymbol Single =
    yyValue:GroupSymbol
    / s:BaseSymbol
    { if ( s instanceof NoWhitespaceSymbol ){
        yyValue = new NoWhitespaceSymbol(createSpan(yyStart,yyCount), new GroupSymbol(createSpan(yyStart, yyCount), FortressUtil.mkList(((NoWhitespaceSymbol) s).getSymbol())) );
      } else {
        yyValue = new GroupSymbol(createSpan(yyStart, yyCount), FortressUtil.mkList(s)); }
      }
    ;

SyntaxSymbol BaseSymbol =
    a1:Id colon s1:Symbol type:(void:colon Type)?
      { Option<Id> prefix = Option.some(a1);
        Option<Type> type1 = Option.none();
        if (null != type) type1 = Option.some(type);
        if (s1 instanceof NoWhitespaceSymbol) {
          SyntaxSymbol tmp = ((NoWhitespaceSymbol) s1).getSymbol();

          yyValue = new NoWhitespaceSymbol(createSpan(yyStart, yyCount), new PrefixedSymbol(s1.getSpan(), prefix, type1, tmp));
        }
        else {
          yyValue = new PrefixedSymbol(createSpan(yyStart,yyCount), prefix, type1, s1);
        }}
    / s1:Symbol type:(void:colon Type)?
      { Option<Id> prefix = Option.none();
        Option<Type> type1 = Option.none();
	// System.out.println( "Matched symbol " + s1 );
        if (null != type) type1 = Option.some(type);
        if (s1 instanceof NoWhitespaceSymbol) {
          SyntaxSymbol tmp = ((NoWhitespaceSymbol) s1).getSymbol();
          yyValue = new NoWhitespaceSymbol(createSpan(yyStart, yyCount), new PrefixedSymbol(s1.getSpan(), prefix, type1, tmp));
        } else {
          if (s1 instanceof SpecialSymbol) {
            if (type == null) {
              yyValue = s1;
            } else {
              yyValue = syntaxError(createSpan(yyStart,yyCount), "A type declaration is not allowed immediately after a special symbol.");
            }
          } else {
            yyValue = new PrefixedSymbol(createSpan(yyStart,yyCount), prefix, type1, s1);
          }
        }};

SyntaxSymbol GroupSymbol =
      "{" w syms:SyntaxSymbolsX w "}"
      {
        yyValue = new GroupSymbol(createSpan(yyStart, yyCount), syms);
      };

SyntaxSymbol Breakline = a1:breakline
      { yyValue = new BreaklineSymbol(createSpan(yyStart,yyCount), a1); };

SyntaxSymbol Symbol =
      a1:Item hash
      { yyValue = new NoWhitespaceSymbol(createSpan(yyStart,yyCount), a1); }
     / yyValue:Item;

/*
SyntaxSymbol Suffix =
      a1:Item questionmark
      { yyValue = new OptionalSymbol(createSpan(yyStart,yyCount), a1); }
    / a1:Item star
     { yyValue = new RepeatSymbol(createSpan(yyStart,yyCount), a1); }
    / a1:Item plus
     { yyValue = new RepeatOneOrMoreSymbol(createSpan(yyStart,yyCount), a1); }
    / yyValue:Item;
    */

SyntaxSymbol Item =
      !(w (leftDelimiter)) s:ItemText
      { yyValue = new ItemSymbol(createSpan(yyStart,yyCount), s); }
    /  openSquareBraket a1:CharacterClass* closeSquareBraket
      { yyValue = new CharacterClassSymbol(createSpan(yyStart,yyCount), a1.list()); }
    /  anyChar
      { yyValue = new AnyCharacterSymbol(createSpan(yyStart,yyCount)); }
    /  Tab
      { yyValue = new TabSymbol(createSpan(yyStart,yyCount)); }
    /  Formfeed
      { yyValue = new FormfeedSymbol(createSpan(yyStart,yyCount)); }
    /  Return
      { yyValue = new CarriageReturnSymbol(createSpan(yyStart,yyCount)); }
    /  Newline
      { yyValue = new NewlineSymbol(createSpan(yyStart,yyCount)); }
    /  Space
      { yyValue = new WhitespaceSymbol(createSpan(yyStart,yyCount), " "); }
    /  Backspace
      { yyValue = new BackspaceSymbol(createSpan(yyStart,yyCount)); };

CharacterSymbol CharacterClass =
       c1:Char colon c2:Char { yyValue = new CharacterInterval(createSpan(yyStart,yyCount), c1, c2); }
    / c1:Char { yyValue = new CharSymbol(createSpan(yyStart,yyCount), c1); };

String Char =
    Tab
      { yyValue = "\t"; }
    /  Formfeed
      { yyValue = "\f"; }
    /  Return
      { yyValue = "\r"; }
    /  Newline
      { yyValue = "\n"; }
    /  Space
      { yyValue = " "; }
    /  Backspace
      { yyValue = "\u2408"; }
    / yyValue:utf16;


String ItemText =
      !(SpecialSymbols) (utf16 utf16*)
   / SpecialSymbols utf16+ ;

String utf16 =
      EscapedSpecialChars
   / EscapedSpecialSymbols
   / !(SpecialChars) c1:[\u0000-\uFFFF];

String SpecialChars =
      space / breakline / colon / questionmark / hash
   / plus / star / openSquareBraket / closeSquareBraket
   / pling / bar / anyChar / "{" / "}";

String EscapedSpecialChars =
   pling SpecialChars;

String EscapedSpecialSymbols =
   pling SpecialSymbols;

String SpecialSymbols =
      Tab / Formfeed / Return / Newline / Space
    / Backspace / Not / And / leftDelimiter;

transient String anyChar = "_";
transient String bar = "|";
transient String hash = "#";
transient String colon = ":";
transient String pling = "`";
transient String plus = "+";
transient String questionmark = "?";
transient String star = "*";
transient String openSquareBraket = "[";
transient String closeSquareBraket = "]";
transient String leftParen = "(";
transient String rightParen = ")";

transient String leftDelimiter = "<[";
transient String rightDelimiter = "]>";

transient String And = "AND";
transient String Backspace = "BACKSPACE";      // backspace
transient String Formfeed = "FORMFEED";      // form feed
transient String Newline = "NEWLINE";      // break line
transient String Not = "NOT";
transient String Return = "RETURN";      // carriage return
transient String Space = "SPACE";      // whitespace
transient String Tab = "TAB";      // tabulator

String sr  = space+; // significant space
private String space = " ";
private String breakline = "\r\n" / "\r" / "\n"; /* / nel / formfeed / ls / ps; */
private String nel = '\u0085';
private String formfeed = "\f";
private String ls = '\u2028';
private String ps = '\u2029';

/* Unicode line terminator symbols
 CR+LF: CR followed by LF, U+000D followed by U+000A
 LF:    Line Feed,  U+000A
 CR:    Carriage Return, U+000D
 NEL:   Next Line, U+0085
 FF:    Form Feed, U+000C
 LS:    Line Separator, U+2028
 PS:    Paragraph Separator, U+2029
*/
