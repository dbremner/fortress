/*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress headers.
 */
module com.sun.fortress.parser.MayNewlineHeader(Other, Type, Header, Expr,
                                                DelimitedExpr, Literal,
                                                Identifier, Keyword, Symbol,
                                                Spacing);

import Other;
import Type;
import Header;
import Expr;
import DelimitedExpr;
import Literal;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* IsType ::= : w Type */
Type IsType = void:colon w Type ;

/* WhereConstraintList ::= WhereConstraint (w , w WhereConstraint)* */
transient List<WhereConstraint> WhereConstraintList =
     a1:WhereConstraint a2s:(w comma w WhereConstraint)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* WhereConstraint ::=
     Id w Extends
   | TypeAlias
   | Type w coerces w Type
   | Type w widens w Type
   | UnitConstraint
   | QualifiedName w = w QualifiedName
   | IntConstraint
   | BoolConstraint
 */
transient WhereConstraint WhereConstraint =
     a1:Id w a2:Extends
     { yyValue = new WhereExtends(createSpan(yyStart,yyCount), a1, a2); }
   / <ErrorProduction> a1:OpName w a2:Extends
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid type parameter name.");
       Id id = NodeFactory.bogusId(span);
       yyValue = new WhereExtends(span, id, a2);
     }
   / a1:TypeAlias
     { yyValue = new WhereTypeAlias(createSpan(yyStart,yyCount), a1); }
   / a1:Type w coerces w a2:Type
     { yyValue = new WhereCoerces(createSpan(yyStart,yyCount), a1, a2,
                                  true, false);
     }
   / a1:Type w widens w a2:Type
     { yyValue = new WhereCoerces(createSpan(yyStart,yyCount), a1, a2,
                                  false, true);
     }
   / UnitConstraint
   / a1:QualifiedName w equals w a2:QualifiedName
     { yyValue = new WhereEquals(createSpan(yyStart,yyCount), a1, a2); }
   / IntConstraint
   / a1:BoolConstraint
     { yyValue = new BoolConstraintExpr(createSpan(yyStart,yyCount), a1); };

/* UnitConstraint ::=
     dimensionless w = w Id
   | Id w = w dimensionless
 */
transient UnitConstraint UnitConstraint =
     "dimensionless" w equals w a1:Id
     { yyValue = new UnitConstraint(createSpan(yyStart,yyCount), a1); }
   / a1:Id w equals w "dimensionless"
     { yyValue = new UnitConstraint(createSpan(yyStart,yyCount), a1); }
   / <ErrorProduction1> "dimensionless" w equals w a1:OpName
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid unit name.");
       Id id = NodeFactory.bogusId(span);
       yyValue = new UnitConstraint(span, id);
     }
   / <ErrorProduction2> a1:OpName w equals w "dimensionless"
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid unit name.");
       Id id = NodeFactory.bogusId(span);
       yyValue = new UnitConstraint(span, id);
     };

/* IntConstraint ::=
     IntExpr w <= w IntExpr
   | IntExpr w <  w IntExpr
   | IntExpr w >= w IntExpr
   | IntExpr w >  w IntExpr
   | IntExpr w =  w IntExpr
 */
transient private IntConstraint IntConstraint =
     a1:IntExpr w lessthanequal w a2:IntExpr
     { Op op = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "<=");
       yyValue = new IntConstraint(createSpan(yyStart,yyCount), a1, a2, op);
     }
   / a1:IntExpr w lessthan w a2:IntExpr
     { Op op = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "<");
       yyValue = new IntConstraint(createSpan(yyStart,yyCount), a1, a2, op);
     }
   / a1:IntExpr w greaterthanequal w a2:IntExpr
     { Op op = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), ">=");
       yyValue = new IntConstraint(createSpan(yyStart,yyCount), a1, a2, op);
     }
   / a1:IntExpr w greaterthan w a2:IntExpr
     { Op op = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), ">");
       yyValue = new IntConstraint(createSpan(yyStart,yyCount), a1, a2, op);
     }
   / a1:IntExpr w equals w a2:IntExpr
     { Op op = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "=");
       yyValue = new IntConstraint(createSpan(yyStart,yyCount), a1, a2, op);
     };

/* IntVal ::=
     IntLiteralExpr
   | QualifiedName
 */
transient IntExpr IntVal =
     a1:IntLiteralExpr
     { yyValue = new IntBase(createSpan(yyStart,yyCount), false, a1); }
   / a1:QualifiedName
     { yyValue = NodeFactory.makeIntRef(createSpan(yyStart,yyCount), a1); };

/* IntExpr ::=
     IntVal
   | IntExpr w + w IntExpr
   | IntExpr w - w IntExpr
   | IntExpr sr IntExpr
   | IntExpr w DOT w IntExpr
   | IntExpr ^ IntVal
   | ( w IntExpr w )
 */
transient IntExpr IntExpr =
     seed:IntExprFront list:IntExprTail*
     { yyValue = (IntExpr)apply(list, seed); };

transient private IntExpr IntExprFront =
     IntVal
   / openparen w a1:IntExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); };

private constant transient Action<IntExpr> IntExprTail =
     SumIntExpr
   / MinusIntExpr
   / ProductIntExpr
   / ExponentIntExpr
   ;

private constant inline Action<IntExpr> SumIntExpr =
     w plus w a1:IntExpr
     { yyValue = new Action<IntExpr>() {
           public IntExpr run(IntExpr base) {
               Op plus = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "+");
               return NodeFactory.makeIntBinaryOp(createSpan(yyStart,yyCount),
                                      (IntExpr)base, a1, plus);
           }};
     };

private constant inline Action<IntExpr> MinusIntExpr =
     w minus w a1:IntExpr
     { yyValue = new Action<IntExpr>() {
           public IntExpr run(IntExpr base) {
               Op minus = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "-");
               return NodeFactory.makeIntBinaryOp(createSpan(yyStart,yyCount),
                                      (IntExpr)base, a1, minus);
           }};
     };

private constant inline Action<IntExpr> ProductIntExpr =
     (w DOT w / sr) a1:IntExpr
     { yyValue = new Action<IntExpr>() {
           public IntExpr run(IntExpr base) {
               Op product = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), " ");
               return NodeFactory.makeIntBinaryOp(createSpan(yyStart,yyCount),
                                      (IntExpr)base, a1, product);
           }};
     };

private constant inline Action<IntExpr> ExponentIntExpr =
     caret a1:IntVal
     { yyValue = new Action<IntExpr>() {
           public IntExpr run(IntExpr base) {
               Span span = createSpan(yyStart,yyCount);
               Op exponent = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "^");
               if (NodeUtil.isExponentiation((IntExpr)base)) {
                   log(NodeUtil.getSpan((IntExpr)base),
                       "An exponentiation should not be immediately followed " +
                       "by an exponentiation.");
                   return NodeFactory.makeIntBinaryOp(span, (IntExpr)base, a1, exponent);
               } return NodeFactory.makeIntBinaryOp(span, (IntExpr)base, a1, exponent);
           }};
     };

/* BoolConstraint ::=
     NOT w BoolExpr
   | BoolExpr w OR w BoolExpr
   | BoolExpr w AND w BoolExpr
   | BoolExpr w IMPLIES w BoolExpr
   | BoolExpr w = w BoolExpr
 */
transient private BoolConstraint BoolConstraint =
     seed:BoolConstraintFront list:BoolConstraintTail*
     { yyValue = (BoolConstraint)apply(list, seed); };

transient private BoolConstraint BoolConstraintFront =
     NOT w a1:BoolExpr
     { Span span = createSpan(yyStart,yyCount);
       Op not = NodeFactory.makeOpPrefix(span, "NOT");
       yyValue = new BoolUnaryOp(span, false, a1, not);
     }
   / a1:BoolConstraintHead w OR w a2:BoolExpr
     { Span span = createSpan(yyStart,yyCount);
       Op op = NodeFactory.makeOpInfix(span, "OR");
       yyValue = NodeFactory.makeBoolBinaryOp(span, a1, a2, op);
     }
   / a1:BoolConstraintHead w AND w a2:BoolExpr
     { Span span = createSpan(yyStart,yyCount);
       Op op = NodeFactory.makeOpInfix(span, "AND");
       yyValue = NodeFactory.makeBoolBinaryOp(span, a1, a2, op);
     }
   / a1:BoolConstraintHead w IMPLIES w a2:BoolExpr
     { Span span = createSpan(yyStart,yyCount);
       Op op = NodeFactory.makeOpInfix(span, "IMPLIES");
       yyValue = NodeFactory.makeBoolBinaryOp(span, a1, a2, op);
     }
   / a1:BoolConstraintHead w equals w a2:BoolExpr
     { Span span = createSpan(yyStart,yyCount);
       Op op = NodeFactory.makeOpInfix(span, "=");
       yyValue = NodeFactory.makeBoolBinaryOp(span, a1, a2, op);
     };

transient private BoolExpr BoolConstraintHead =
     BoolVal
   / openparen w a1:BoolExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); };

private constant transient Action<BoolConstraint> BoolConstraintTail =
     OrBoolConstraint
   / AndBoolConstraint
   / ImpliesBoolConstraint
   / EqualsBoolConstraint
   ;

private constant inline Action<BoolConstraint> OrBoolConstraint =
     w OR w a1:BoolExpr
     { yyValue = new Action<BoolConstraint>() {
           public BoolConstraint run(BoolConstraint base) {
               Span span = createSpan(yyStart,yyCount);
               Op op = NodeFactory.makeOpInfix(span, "OR");
               return NodeFactory.makeBoolBinaryOp(span, (BoolConstraint)base, a1, op);
           }};
     };

private constant inline Action<BoolConstraint> AndBoolConstraint =
     w AND w a1:BoolExpr
     { yyValue = new Action<BoolConstraint>() {
           public BoolConstraint run(BoolConstraint base) {
               Span span = createSpan(yyStart,yyCount);
               Op op = NodeFactory.makeOpInfix(span, "AND");
               return NodeFactory.makeBoolBinaryOp(span, (BoolConstraint)base, a1, op);
           }};
     };

private constant inline Action<BoolConstraint> ImpliesBoolConstraint =
     w IMPLIES w a1:BoolExpr
     { yyValue = new Action<BoolConstraint>() {
           public BoolConstraint run(BoolConstraint base) {
               Span span = createSpan(yyStart,yyCount);
               Op op = NodeFactory.makeOpInfix(span, "IMPLIES");
               return NodeFactory.makeBoolBinaryOp(span, (BoolConstraint)base, a1, op);
           }};
     };

private constant inline Action<BoolConstraint> EqualsBoolConstraint =
     w equals w a1:BoolExpr
     { yyValue = new Action<BoolConstraint>() {
           public BoolConstraint run(BoolConstraint base) {
               Span span = createSpan(yyStart,yyCount);
               Op op = NodeFactory.makeOpInfix(span, "");
               return NodeFactory.makeBoolBinaryOp(span, (BoolConstraint)base, a1, op);
           }};
     };

/* BoolVal ::=
     true
   | false
   | QualifiedName
 */
transient private BoolExpr BoolVal =
     a1:"true"
     { yyValue = new BoolBase(createSpan(yyStart,yyCount), false, true); }
   / a1:"false"
     { yyValue = new BoolBase(createSpan(yyStart,yyCount), false, false); }
   / a1:QualifiedName
     { yyValue = NodeFactory.makeBoolRef(createSpan(yyStart,yyCount), a1); };

/* BoolExpr ::=
     BoolVal
   | BoolConstraint
   | ( w BoolExpr w )
 */
transient BoolExpr BoolExpr =
     seed:BoolExprFront list:BoolExprTail*
     { yyValue = (BoolExpr)apply(list, seed); };

transient private BoolExpr BoolExprFront =
     BoolVal
   / openparen w a1:BoolExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); }
   / NOT w a1:BoolExpr
     { Span span = createSpan(yyStart,yyCount);
       Op not = NodeFactory.makeOpPrefix(span, "NOT");
       yyValue = new BoolUnaryOp(span, false, a1, not);
     };

private constant transient Action<BoolExpr> BoolExprTail =
     OrBoolExpr
   / AndBoolExpr
   / ImpliesBoolExpr
   / EqualsBoolExpr
   ;

private constant inline Action<BoolExpr> OrBoolExpr =
     w OR w a1:BoolExpr
     { yyValue = new Action<BoolExpr>() {
           public BoolExpr run(BoolExpr base) {
               Span span = createSpan(yyStart,yyCount);
               Op op = NodeFactory.makeOpInfix(span, "OR");
               return NodeFactory.makeBoolBinaryOp(span, (BoolExpr)base, a1, op);
           }};
     };

private constant inline Action<BoolExpr> AndBoolExpr =
     w AND w a1:BoolExpr
     { yyValue = new Action<BoolExpr>() {
           public BoolExpr run(BoolExpr base) {
               Span span = createSpan(yyStart,yyCount);
               Op op = NodeFactory.makeOpInfix(span, "AND");
               return NodeFactory.makeBoolBinaryOp(span, (BoolExpr)base, a1, op);
           }};
     };

private constant inline Action<BoolExpr> ImpliesBoolExpr =
     w IMPLIES w a1:BoolExpr
     { yyValue = new Action<BoolExpr>() {
           public BoolExpr run(BoolExpr base) {
               Span span = createSpan(yyStart,yyCount);
               Op op = NodeFactory.makeOpInfix(span, "IMPLIES");
               return NodeFactory.makeBoolBinaryOp(span, (BoolExpr)base, a1, op);
           }};
     };

private constant inline Action<BoolExpr> EqualsBoolExpr =
     w equals w a1:BoolExpr
     { yyValue = new Action<BoolExpr>() {
           public BoolExpr run(BoolExpr base) {
               Span span = createSpan(yyStart,yyCount);
               Op op = NodeFactory.makeOpInfix(span, "=");
               return NodeFactory.makeBoolBinaryOp(span, (BoolExpr)base, a1, op);
           }};
     };

/* UnitExpr ::=
     dimensionless
   | QualifiedName
   | UnitExpr sr UnitExpr
   | UnitExpr w DOT w UnitExpr
   | UnitExpr / UnitExpr
   | UnitExpr per UnitExpr
   | UnitExpr ^ UnitExpr
   | ( w UnitExpr w )
 */
transient UnitExpr UnitExpr =
     seed:UnitExprFront list:UnitExprTail*
     { yyValue = (UnitExpr)apply(list, seed); };

transient private UnitExpr UnitExprFront =
     a1:"dimensionless"
     { Span span = createSpan(yyStart,yyCount);
       yyValue = new UnitRef(span, false, NodeFactory.makeId(span, a1));
     }
   / a1:QualifiedName
     { yyValue = new UnitRef(createSpan(yyStart,yyCount), false, a1); }
   / openparen w a1:UnitExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); };

private constant transient Action<UnitExpr> UnitExprTail =
     ProductUnitExpr
   / QuotientUnitExpr
   / ExponentUnitExpr
   ;

private constant inline Action<UnitExpr> ProductUnitExpr =
     (w DOT w / sr) a1:UnitExpr
     { yyValue = new Action<UnitExpr>() {
           public UnitExpr run(UnitExpr base) {
               Op product = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), " ");
               return new UnitBinaryOp(createSpan(yyStart,yyCount), false,
                                       (UnitExpr)base, a1, product);
           }};
     };

private constant inline Action<UnitExpr> QuotientUnitExpr =
     (slash / per) a1:UnitExpr
     { yyValue = new Action<UnitExpr>() {
           public UnitExpr run(UnitExpr base) {
               Op quotient = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "/");
               return new UnitBinaryOp(createSpan(yyStart,yyCount), false,
                                       (UnitExpr)base, a1, quotient);
           }};
     };

private constant inline Action<UnitExpr> ExponentUnitExpr =
     caret a1:UnitExpr
     { yyValue = new Action<UnitExpr>() {
           public UnitExpr run(UnitExpr base) {
               Op exponent = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "^");
               return new UnitBinaryOp(createSpan(yyStart,yyCount), false,
                                       (UnitExpr)base, a1, exponent);
           }};
     };

/* Contract ::= (w Requires)? (w Ensures)? (w Invariant)? */
transient Contract Contract =
     <ErrorProduction1>
     w Requires w (ExtendsWhere / Throws / Where) (w Ensures)? (w Invariant)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before throws/where/contract clauses.");
     }
   / <ErrorProduction2>
     w Requires w Ensures w (ExtendsWhere / Throws / Where) (w Invariant)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before throws/where/contract clauses.");
     }
   / <ErrorProduction3>
     w Requires w Ensures w Invariant w (ExtendsWhere / Throws / Where)
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before throws/where/contract clauses.");
     }
   / <ErrorProduction4>
     w Ensures w (ExtendsWhere / Throws / Where) (w Invariant)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before throws/where/contract clauses.");
     }
   / <ErrorProduction5>
     w Ensures w Invariant w (ExtendsWhere / Throws / Where)
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before throws/where/contract clauses.");
     }
   / <ErrorProduction6>
     w Invariant w (ExtendsWhere / Throws / Where)
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before throws/where/contract clauses.");
     }
   / <ErrorProduction7>
     w Requires w Invariant w Ensures
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Ensures clauses should come before invariant clauses.");
     }
   / <ErrorProduction8>
     w Invariant w Ensures w Requires
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Requires clauses should come before ensures/invariant clauses.");
     }
   / <ErrorProduction9>
     w Invariant w Requires (w Ensures)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Requires clauses should come before ensures/invariant clauses.");
     }
   / <ErrorProduction10>
     w Ensures w Invariant w Requires
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Requires clauses should come before ensures/invariant clauses.");
     }
   / <ErrorProduction111>
     w Ensures w Requires (w Invariant)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Requires clauses should come before ensures/invariant clauses.");
     }
   / <ErrorProduction12>
     w Invariant w Ensures
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Ensures clauses should come before invariant clauses.");
     }
   / a1:(w Requires)? a2:(w Ensures)? a3:(w Invariant)?
     { Option<List<Expr>> requires = Option.wrap(a1);
       Option<List<EnsuresClause>> ensures = Option.wrap(a2);
       Option<List<Expr>> invariant = Option.wrap(a3);
       if (a1 == null && a2 == null && a3 == null) yyValue = null;
       else yyValue = new Contract(createSpan(yyStart,yyCount), requires,
                                   ensures, invariant);
     };

/* Requires ::= requires w { (w ExprList)? w } */
transient List<Expr> Requires = requires w opencurly a1:(w ExprList)? w closecurly
     { if (a1 == null) yyValue = FortressUtil.emptyExprs();
       else            yyValue = a1;
     };

/* Ensures  ::= ensures w { (w EnsuresClauseList)? w } */
transient List<EnsuresClause> Ensures =
     ensures w opencurly a1:(w EnsuresClauseList)? w closecurly
     { if (a1 == null) yyValue = FortressUtil.emptyEnsuresClauses();
       else            yyValue = a1;
     };

/* EnsuresClauseList ::= EnsuresClause (w , w EnsuresClause)* */
transient private List<EnsuresClause> EnsuresClauseList =
     a1:EnsuresClause a2s:(w comma w EnsuresClause)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* EnsuresClause ::= Expr (w provided w Expr)? */
transient private EnsuresClause EnsuresClause = a1:Expr a2:(w provided w Expr)?
     { Option<Expr> ensures = Option.wrap(a2);
       yyValue = new EnsuresClause(createSpan(yyStart,yyCount), a1, ensures);
     };

/* Invariant::= invariant w { (w ExprList)? w } */
transient List<Expr> Invariant =
     invariant w opencurly a1:(w ExprList)? w closecurly
     { if (a1 == null) yyValue = FortressUtil.emptyExprs();
       else            yyValue = a1;
     };

/* StaticArgs ::= [\ w StaticArgList w \] */
List<StaticArg> StaticArgs =
    opendoublesquare w StaticArgList w closedoublesquare ;

/* StaticArgList ::= StaticArg (w , w StaticArg)*  */
List<StaticArg> StaticArgList = a1:StaticArg a2s:(w comma w StaticArg)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* StaticArg ::=
     Op
   | IntExpr
   | BoolExpr
   | Type
   | DimExpr
   | UnitExpr
 */
StaticArg StaticArg =
     a1:Op
     { yyValue = new OpArg(createSpan(yyStart,yyCount), ExprFactory.makeOpRef(a1)); }
   / !(QualifiedName (w closedoublesquare / w closesquare / w comma /
                      w opendoublesquare / w opensquare / w rightarrow /
                      w OR / w AND / w IMPLIES / w equals) /
       "Unity" / "dimensionless" / "true" / "false")
     a1:IntExpr
     { yyValue = new IntArg(createSpan(yyStart,yyCount), a1); }
   / !(QualifiedName (w closedoublesquare / w closesquare / w comma /
                      w opendoublesquare / w opensquare / w rightarrow) /
       "Unity" / "dimensionless")
     a1:BoolExpr
     { yyValue = new BoolArg(createSpan(yyStart,yyCount), a1); }
   / a1:"true"
     { Span span = createSpan(yyStart,yyCount);
       yyValue = new BoolArg(span, new BoolBase(span, false, true));
     }
   / a1:"false"
     { Span span = createSpan(yyStart,yyCount);
       yyValue = new BoolArg(span, new BoolBase(span, false, false));
     }
   / !(QualifiedName (w DOT / w slash / w per / w DimPostfixOp) / "dimensionless")
     a1:Type
     { yyValue = new TypeArg(createSpan(yyStart,yyCount), a1); }
   / a1:UnitExpr
     { yyValue = new UnitArg(createSpan(yyStart,yyCount), a1); }
   ;
