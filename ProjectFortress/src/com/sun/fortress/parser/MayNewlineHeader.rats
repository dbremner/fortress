/*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress headers.
 */
module com.sun.fortress.parser.MayNewlineHeader(Other, Type, Header, Expr,
                                                DelimitedExpr, Literal,
                                                Identifier, Keyword, Symbol,
                                                Spacing);

import Other;
import Type;
import Header;
import Expr;
import DelimitedExpr;
import Literal;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* IsType ::= : w Type */
Type IsType = void:colon w Type ;

/* WhereConstraintList ::= WhereConstraint (w , w WhereConstraint)* */
transient List<WhereConstraint> WhereConstraintList =
     a1:WhereConstraint a2s:(w comma w WhereConstraint)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* WhereConstraint ::=
     Id w Extends
   | TypeAlias
   | Type w coerces w Type
   | Type w widens w Type
   | UnitConstraint
   | QualifiedName w = w QualifiedName
   | IntConstraint
   | BoolConstraint
 */
transient WhereConstraint WhereConstraint =
     a1:Id w a2:Extends
     { yyValue = new WhereExtends(createSpan(yyStart,yyCount), a1, a2); }
   / <ErrorProduction> a1:OpName w a2:Extends
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             a1 + " is not a valid type parameter name.\n" +
                             "A non-reserved word that is made up of a mixture" +
                             " of uppercase letters and underscores (but no " +
                             "digits), does not begin or end with an " +
                             "underscore, and contains at least two distinct " +
                             "letters is an operator name.");
     }
   / TypeAlias
   / a1:Type w coerces w a2:Type
     { yyValue = new WhereCoerces(createSpan(yyStart,yyCount), a1, a2); }
   / a1:Type w widens w a2:Type
     { yyValue = new WhereWidens(createSpan(yyStart,yyCount), a1, a2); }
   / UnitConstraint
   / a1:QualifiedName w equals w a2:QualifiedName
     { yyValue = new WhereEquals(createSpan(yyStart,yyCount), a1, a2); }
   / IntConstraint
   / a1:BoolConstraint
     { yyValue = new BoolConstraintExpr(createSpan(yyStart,yyCount), a1); };

/* UnitConstraint ::=
     dimensionless w = w Id
   | Id w = w dimensionless
 */
transient UnitConstraint UnitConstraint =
     "dimensionless" w equals w a1:Id
     { yyValue = new UnitConstraint(createSpan(yyStart,yyCount), a1); }
   / a1:Id w equals w "dimensionless"
     { yyValue = new UnitConstraint(createSpan(yyStart,yyCount), a1); }
   / <ErrorProduction1> "dimensionless" w equals w a1:OpName
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             a1 + " is not a valid unit name.\n" +
                             "A non-reserved word that is made up of a mixture" +
                             " of uppercase letters and underscores (but no " +
                             "digits), does not begin or end with an " +
                             "underscore, and contains at least two distinct " +
                             "letters is an operator name.");
     }
   / <ErrorProduction2> a1:OpName w equals w "dimensionless"
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             a1 + " is not a valid unit name.\n" +
                             "A non-reserved word that is made up of a mixture" +
                             " of uppercase letters and underscores (but no " +
                             "digits), does not begin or end with an " +
                             "underscore, and contains at least two distinct " +
                             "letters is an operator name.");
     };

/* IntConstraint ::=
     IntExpr w <= w IntExpr
   | IntExpr w <  w IntExpr
   | IntExpr w >= w IntExpr
   | IntExpr w >  w IntExpr
   | IntExpr w =  w IntExpr
 */
transient private IntConstraint IntConstraint =
     a1:IntExpr w lessthanequal w a2:IntExpr
     { yyValue = new LEConstraint(createSpan(yyStart,yyCount), a1, a2); }
   / a1:IntExpr w lessthan w a2:IntExpr
     { yyValue = new LTConstraint(createSpan(yyStart,yyCount), a1, a2); }
   / a1:IntExpr w greaterthanequal w a2:IntExpr
     { yyValue = new GEConstraint(createSpan(yyStart,yyCount), a1, a2); }
   / a1:IntExpr w greaterthan w a2:IntExpr
     { yyValue = new GTConstraint(createSpan(yyStart,yyCount), a1, a2); }
   / a1:IntExpr w equals w a2:IntExpr
     { yyValue = new IEConstraint(createSpan(yyStart,yyCount), a1, a2); };

/* IntVal ::=
     IntLiteralExpr
   | QualifiedName
 */
transient IntVal IntVal =
     a1:IntLiteralExpr
     { yyValue = new NumberConstraint(createSpan(yyStart,yyCount), a1); }
   / a1:QualifiedName
     { yyValue = new IntRef(createSpan(yyStart,yyCount), a1); };

/* IntExpr ::=
     IntVal
   | IntExpr w + w IntExpr
   | IntExpr w - w IntExpr
   | IntExpr sr IntExpr
   | IntExpr w DOT w IntExpr
   | IntExpr ^ IntVal
   | ( w IntExpr w )
 */
transient IntExpr IntExpr =
     seed:IntExprFront list:IntExprTail*
     { yyValue = (IntExpr)apply(list, seed); };

transient private IntExpr IntExprFront =
     IntVal
   / openparen w a1:IntExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); };

private constant transient Action<IntExpr> IntExprTail =
     SumIntExpr
   / MinusIntExpr
   / ProductIntExpr
   / ExponentIntExpr
   ;

private constant inline Action<IntExpr> SumIntExpr =
     w plus w a1:IntExpr
     { yyValue = new Action<IntExpr>() {
           public IntExpr run(IntExpr base) {
               return new SumConstraint(createSpan(yyStart,yyCount),
                                        (IntExpr)base, a1);
           }};
     };

private constant inline Action<IntExpr> MinusIntExpr =
     w minus w a1:IntExpr
     { yyValue = new Action<IntExpr>() {
           public IntExpr run(IntExpr base) {
               return new MinusConstraint(createSpan(yyStart,yyCount),
                                          (IntExpr)base, a1);
           }};
     };

private constant inline Action<IntExpr> ProductIntExpr =
     (w DOT w / sr) a1:IntExpr
     { yyValue = new Action<IntExpr>() {
           public IntExpr run(IntExpr base) {
               return new ProductConstraint(createSpan(yyStart,yyCount),
                                            (IntExpr)base, a1);
           }};
     };

private constant inline Action<IntExpr> ExponentIntExpr =
     caret a1:IntVal
     { yyValue = new Action<IntExpr>() {
           public IntExpr run(IntExpr base) {
               if (NodeUtil.isExponentiation((IntExpr)base))
                   return syntaxError(((IntExpr)base).getSpan(),
                                      "It is a static error if an " +
                                      "exponentiation is immediately followed " +
                                      "by an exponentiation.");
               return new ExponentConstraint(createSpan(yyStart,yyCount),
                                             (IntExpr)base, a1);
           }};
     };

/* BoolConstraint ::=
     NOT w BoolExpr
   | BoolExpr w OR w BoolExpr
   | BoolExpr w AND w BoolExpr
   | BoolExpr w IMPLIES w BoolExpr
   | BoolExpr w = w BoolExpr
 */
transient private BoolConstraint BoolConstraint =
     seed:BoolConstraintFront list:BoolConstraintTail*
     { yyValue = (BoolConstraint)apply(list, seed); };

transient private BoolConstraint BoolConstraintFront =
     NOT w a1:BoolExpr
     { yyValue = new NotConstraint(createSpan(yyStart,yyCount), a1); }
   / a1:BoolConstraintHead w OR w a2:BoolExpr
     { yyValue = new OrConstraint(createSpan(yyStart,yyCount), a1, a2); }
   / a1:BoolConstraintHead w AND w a2:BoolExpr
     { yyValue = new AndConstraint(createSpan(yyStart,yyCount), a1, a2); }
   / a1:BoolConstraintHead w IMPLIES w a2:BoolExpr
     { yyValue = new ImpliesConstraint(createSpan(yyStart,yyCount), a1, a2); }
   / a1:BoolConstraintHead w equals w a2:BoolExpr
     { yyValue = new BEConstraint(createSpan(yyStart,yyCount), a1, a2); };

transient private BoolExpr BoolConstraintHead =
     BoolVal
   / openparen w a1:BoolExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); };

private constant transient Action<BoolConstraint> BoolConstraintTail =
     OrBoolConstraint
   / AndBoolConstraint
   / ImpliesBoolConstraint
   / EqualsBoolConstraint
   ;

private constant inline Action<BoolConstraint> OrBoolConstraint =
     w OR w a1:BoolExpr
     { yyValue = new Action<BoolConstraint>() {
           public BoolConstraint run(BoolConstraint base) {
               return new OrConstraint(createSpan(yyStart,yyCount),
                                       (BoolConstraint)base, a1);
           }};
     };

private constant inline Action<BoolConstraint> AndBoolConstraint =
     w AND w a1:BoolExpr
     { yyValue = new Action<BoolConstraint>() {
           public BoolConstraint run(BoolConstraint base) {
               return new AndConstraint(createSpan(yyStart,yyCount),
                                        (BoolConstraint)base, a1);
           }};
     };

private constant inline Action<BoolConstraint> ImpliesBoolConstraint =
     w IMPLIES w a1:BoolExpr
     { yyValue = new Action<BoolConstraint>() {
           public BoolConstraint run(BoolConstraint base) {
               return new ImpliesConstraint(createSpan(yyStart,yyCount),
                                            (BoolConstraint)base, a1);
           }};
     };

private constant inline Action<BoolConstraint> EqualsBoolConstraint =
     w equals w a1:BoolExpr
     { yyValue = new Action<BoolConstraint>() {
           public BoolConstraint run(BoolConstraint base) {
               return new BEConstraint(createSpan(yyStart,yyCount),
                                       (BoolConstraint)base, a1);
           }};
     };

/* BoolVal ::=
     true
   | false
   | QualifiedName
 */
transient private BoolVal BoolVal =
     a1:"true"
     { yyValue = new BoolConstant(createSpan(yyStart,yyCount), true); }
   / a1:"false"
     { yyValue = new BoolConstant(createSpan(yyStart,yyCount), false); }
   / a1:QualifiedName
     { yyValue = new BoolRef(createSpan(yyStart,yyCount), a1); };

/* BoolExpr ::=
     BoolVal
   | BoolConstraint
   | ( w BoolExpr w )
 */
transient BoolExpr BoolExpr =
     seed:BoolExprFront list:BoolExprTail*
     { yyValue = (BoolExpr)apply(list, seed); };

transient private BoolExpr BoolExprFront =
     BoolVal
   / openparen w a1:BoolExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); }
   / NOT w a1:BoolExpr
     { Span span = createSpan(yyStart,yyCount);
       yyValue = new NotConstraint(span, a1);
     };

private constant transient Action<BoolExpr> BoolExprTail =
     OrBoolExpr
   / AndBoolExpr
   / ImpliesBoolExpr
   / EqualsBoolExpr
   ;

private constant inline Action<BoolExpr> OrBoolExpr =
     w OR w a1:BoolExpr
     { yyValue = new Action<BoolExpr>() {
           public BoolExpr run(BoolExpr base) {
               Span span = createSpan(yyStart,yyCount);
               return new OrConstraint(span, (BoolExpr)base, a1);
           }};
     };

private constant inline Action<BoolExpr> AndBoolExpr =
     w AND w a1:BoolExpr
     { yyValue = new Action<BoolExpr>() {
           public BoolExpr run(BoolExpr base) {
               Span span = createSpan(yyStart,yyCount);
               return new AndConstraint(span, (BoolExpr)base, a1);
           }};
     };

private constant inline Action<BoolExpr> ImpliesBoolExpr =
     w IMPLIES w a1:BoolExpr
     { yyValue = new Action<BoolExpr>() {
           public BoolExpr run(BoolExpr base) {
               Span span = createSpan(yyStart,yyCount);
               return new ImpliesConstraint(span, (BoolExpr)base, a1);
           }};
     };

private constant inline Action<BoolExpr> EqualsBoolExpr =
     w equals w a1:BoolExpr
     { yyValue = new Action<BoolExpr>() {
           public BoolExpr run(BoolExpr base) {
               Span span = createSpan(yyStart,yyCount);
               return new BEConstraint(span, (BoolExpr)base, a1);
           }};
     };

/* UnitExpr ::=
     dimensionless
   | QualifiedName
   | UnitExpr sr UnitExpr
   | UnitExpr w DOT w UnitExpr
   | UnitExpr / UnitExpr
   | UnitExpr per UnitExpr
   | UnitExpr ^ UnitExpr
   | ( w UnitExpr w )
 */
transient UnitExpr UnitExpr =
     seed:UnitExprFront list:UnitExprTail*
     { yyValue = (UnitExpr)apply(list, seed); };

transient private UnitExpr UnitExprFront =
     a1:"dimensionless"
     { Span span = createSpan(yyStart,yyCount);
       yyValue = new UnitRef(span, NodeFactory.makeId(span, a1));
     }
   / a1:QualifiedName
     { yyValue = new UnitRef(createSpan(yyStart,yyCount), a1); }
   / openparen w a1:UnitExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); };

private constant transient Action<UnitExpr> UnitExprTail =
     ProductUnitExpr
   / QuotientUnitExpr
   / ExponentUnitExpr
   ;

private constant inline Action<UnitExpr> ProductUnitExpr =
     (w DOT w / sr) a1:UnitExpr
     { yyValue = new Action<UnitExpr>() {
           public UnitExpr run(UnitExpr base) {
               return new ProductUnit(createSpan(yyStart,yyCount),
                                      (UnitExpr)base, a1);
           }};
     };

private constant inline Action<UnitExpr> QuotientUnitExpr =
     (slash / per) a1:UnitExpr
     { yyValue = new Action<UnitExpr>() {
           public UnitExpr run(UnitExpr base) {
               return new QuotientUnit(createSpan(yyStart,yyCount),
                                      (UnitExpr)base, a1);
           }};
     };

private constant inline Action<UnitExpr> ExponentUnitExpr =
     caret a1:UnitExpr
     { yyValue = new Action<UnitExpr>() {
           public UnitExpr run(UnitExpr base) {
               return new ExponentUnit(createSpan(yyStart,yyCount),
                                      (UnitExpr)base, a1);
           }};
     };

/* Contract ::= (w Requires)? (w Ensures)? (w Invariant)? */
transient Contract Contract =
     <ErrorProduction1>
     w Requires w (ExtendsWhere / Throws / Where) (w Ensures)? (w Invariant)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before throws/where/contract clauses.");
     }
   / <ErrorProduction2>
     w Requires w Ensures w (ExtendsWhere / Throws / Where) (w Invariant)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before throws/where/contract clauses.");
     }
   / <ErrorProduction3>
     w Requires w Ensures w Invariant w (ExtendsWhere / Throws / Where)
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before throws/where/contract clauses.");
     }
   / <ErrorProduction4>
     w Ensures w (ExtendsWhere / Throws / Where) (w Invariant)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before throws/where/contract clauses.");
     }
   / <ErrorProduction5>
     w Ensures w Invariant w (ExtendsWhere / Throws / Where)
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before throws/where/contract clauses.");
     }
   / <ErrorProduction6>
     w Invariant w (ExtendsWhere / Throws / Where)
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before throws/where/contract clauses.");
     }
   / <ErrorProduction7>
     w Requires w Invariant w Ensures
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Ensures clauses should come before invariant clauses.");
     }
   / <ErrorProduction8>
     w Invariant w Ensures w Requires
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Requires clauses should come before ensures/invariant clauses.");
     }
   / <ErrorProduction9>
     w Invariant w Requires (w Ensures)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Requires clauses should come before ensures/invariant clauses.");
     }
   / <ErrorProduction10>
     w Ensures w Invariant w Requires
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Requires clauses should come before ensures/invariant clauses.");
     }
   / <ErrorProduction111>
     w Ensures w Requires (w Invariant)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Requires clauses should come before ensures/invariant clauses.");
     }
   / <ErrorProduction12>
     w Invariant w Ensures
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Ensures clauses should come before invariant clauses.");
     }
   / a1:(w Requires)? a2:(w Ensures)? a3:(w Invariant)?
     { Option<List<Expr>> requires = Option.wrap(a1);
       Option<List<EnsuresClause>> ensures = Option.wrap(a2);
       Option<List<Expr>> invariant = Option.wrap(a3);
       if (a1 == null && a2 == null && a3 == null) yyValue = null;
       else yyValue = new Contract(createSpan(yyStart,yyCount), requires,
                                   ensures, invariant);
     };

/* Requires ::= requires w { (w ExprList)? w } */
transient List<Expr> Requires = requires w opencurly a1:(w ExprList)? w closecurly
     { if (a1 == null) yyValue = FortressUtil.emptyExprs();
       else            yyValue = a1;
     };

/* Ensures  ::= ensures w { (w EnsuresClauseList)? w } */
transient List<EnsuresClause> Ensures =
     ensures w opencurly a1:(w EnsuresClauseList)? w closecurly
     { if (a1 == null) yyValue = FortressUtil.emptyEnsuresClauses();
       else            yyValue = a1;
     };

/* EnsuresClauseList ::= EnsuresClause (w , w EnsuresClause)* */
transient private List<EnsuresClause> EnsuresClauseList =
     a1:EnsuresClause a2s:(w comma w EnsuresClause)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* EnsuresClause ::= Expr (w provided w Expr)? */
transient private EnsuresClause EnsuresClause = a1:Expr a2:(w provided w Expr)?
     { Option<Expr> ensures = Option.wrap(a2);
       yyValue = new EnsuresClause(createSpan(yyStart,yyCount), a1, ensures);
     };

/* Invariant::= invariant w { (w ExprList)? w } */
transient List<Expr> Invariant =
     invariant w opencurly a1:(w ExprList)? w closecurly
     { if (a1 == null) yyValue = FortressUtil.emptyExprs();
       else            yyValue = a1;
     };

/* StaticArgs ::= [\ w StaticArgList w \] */
List<StaticArg> StaticArgs =
    opendoublesquare w StaticArgList w closedoublesquare ;

/* StaticArgList ::= StaticArg (w , w StaticArg)*  */
List<StaticArg> StaticArgList = a1:StaticArg a2s:(w comma w StaticArg)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* StaticArg ::=
     Op
   | IntExpr
   | BoolExpr
   | Type
   | DimExpr
   | UnitExpr
 */
StaticArg StaticArg =
     a1:Op
     { yyValue = new OpArg(createSpan(yyStart,yyCount), ExprFactory.makeOpRef(a1)); }
   / !(QualifiedName (w closedoublesquare / w closesquare / w comma /
                      w opendoublesquare / w opensquare / w rightarrow /
                      w OR / w AND / w IMPLIES / w equals) /
       "Unity" / "dimensionless" / "true" / "false")
     a1:IntExpr
     { yyValue = new IntArg(createSpan(yyStart,yyCount), a1); }
   / !(QualifiedName (w closedoublesquare / w closesquare / w comma /
                      w opendoublesquare / w opensquare / w rightarrow) /
       "Unity" / "dimensionless")
     a1:BoolExpr
     { yyValue = new BoolArg(createSpan(yyStart,yyCount), a1); }
   / a1:"true"
     { Span span = createSpan(yyStart,yyCount);
       yyValue = new BoolArg(span, new BoolConstant(span, true));
     }
   / a1:"false"
     { Span span = createSpan(yyStart,yyCount);
       yyValue = new BoolArg(span, new BoolConstant(span, false));
     }
   / !(QualifiedName (w DOT / w slash / w per / w DimPostfixOp) / "dimensionless")
     a1:Type
     { yyValue = new TypeArg(createSpan(yyStart,yyCount), a1); }
   / a1:UnitExpr
     { yyValue = new UnitArg(createSpan(yyStart,yyCount), a1); }
   ;
