/*******************************************************************************
    Copyright 2009 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress headers.
 */
module com.sun.fortress.parser.MayNewlineHeader(Other, Type, Header, Expr,
                                                DelimitedExpr, Literal,
                                                Identifier, Keyword, Symbol,
                                                Spacing);

import Other;
import Type;
import Header;
import Expr;
import DelimitedExpr;
import Literal;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* IsType ::= : w Type */
Type IsType = void:colon w Type ;

/* WhereConstraintList ::= WhereConstraint (w , w WhereConstraint)* */
transient List<WhereConstraint> WhereConstraintList =
     a1:WhereConstraint a2s:(w comma w WhereConstraint)*
     { yyValue = Useful.cons(a1, a2s.list()); };

/* WhereConstraint ::=
     Id w Extends
   | TypeAlias
   | Type w coerces w Type
   | Type w widens w Type
   | UnitConstraint
   | QualifiedName w = w QualifiedName
   | IntConstraint
   | BoolConstraint
   | Type w widens w or w coerces w Type
 */
transient WhereConstraint WhereConstraint =
     a1:Id w a2:Extends
     { yyValue = NodeFactory.makeWhereExtends(createSpan(yyStart,yyCount), a1, a2); }
   / <ErrorProduction> a1:OpName w a2:Extends
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid type parameter name.");
       Id id = NodeFactory.bogusId(span);
       yyValue = NodeFactory.makeWhereExtends(span, id, a2);
     }
   / a1:TypeAlias
     { yyValue = NodeFactory.makeWhereTypeAlias(createSpan(yyStart,yyCount), a1); }
   / a1:Type w coerces w a2:Type
     { yyValue = NodeFactory.makeWhereCoerces(createSpan(yyStart,yyCount), a1, a2,
                                  true, false);
     }
   / a1:Type w widens w a2:Type
     { yyValue = NodeFactory.makeWhereCoerces(createSpan(yyStart,yyCount), a1, a2,
                                  false, true);
     }
   / UnitConstraint
   / a1:QualifiedName w equals w a2:QualifiedName
     { yyValue = NodeFactory.makeWhereEquals(createSpan(yyStart,yyCount), a1, a2); }
   / IntConstraint
   / a1:BoolConstraint
     { yyValue = NodeFactory.makeBoolConstraintExpr(createSpan(yyStart,yyCount), a1); }
   / a1:Type w widens w or w coerces w a2:Type
     { yyValue = NodeFactory.makeWhereCoerces(createSpan(yyStart,yyCount), a1, a2,
                                              true, true);
     };

/* UnitConstraint ::=
     dimensionless w = w Id
   | Id w = w dimensionless
 */
transient UnitConstraint UnitConstraint =
     "dimensionless" w equals w a1:Id
     { yyValue = NodeFactory.makeUnitConstraint(createSpan(yyStart,yyCount), a1); }
   / a1:Id w equals w "dimensionless"
     { yyValue = NodeFactory.makeUnitConstraint(createSpan(yyStart,yyCount), a1); }
   / <ErrorProduction1> "dimensionless" w equals w a1:OpName
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid unit name.");
       Id id = NodeFactory.bogusId(span);
       yyValue = NodeFactory.makeUnitConstraint(span, id);
     }
   / <ErrorProduction2> a1:OpName w equals w "dimensionless"
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid unit name.");
       Id id = NodeFactory.bogusId(span);
       yyValue = NodeFactory.makeUnitConstraint(span, id);
     };

/* IntConstraint ::=
     IntExpr w <= w IntExpr
   | IntExpr w <  w IntExpr
   | IntExpr w >= w IntExpr
   | IntExpr w >  w IntExpr
   | IntExpr w =  w IntExpr
 */
transient private IntConstraint IntConstraint =
     a1:IntExpr w lessthanequal w a2:IntExpr
     { Op op = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "<=");
       yyValue = NodeFactory.makeIntConstraint(createSpan(yyStart,yyCount), a1, a2, op);
     }
   / a1:IntExpr w lessthan w a2:IntExpr
     { Op op = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "<");
       yyValue = NodeFactory.makeIntConstraint(createSpan(yyStart,yyCount), a1, a2, op);
     }
   / a1:IntExpr w greaterthanequal w a2:IntExpr
     { Op op = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), ">=");
       yyValue = NodeFactory.makeIntConstraint(createSpan(yyStart,yyCount), a1, a2, op);
     }
   / a1:IntExpr w greaterthan w a2:IntExpr
     { Op op = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), ">");
       yyValue = NodeFactory.makeIntConstraint(createSpan(yyStart,yyCount), a1, a2, op);
     }
   / a1:IntExpr w equals w a2:IntExpr
     { Op op = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "=");
       yyValue = NodeFactory.makeIntConstraint(createSpan(yyStart,yyCount), a1, a2, op);
     };

/* IntVal ::=
     IntLiteralExpr
   | QualifiedName
 */
transient IntExpr IntVal =
     a1:IntLiteralExpr
     { yyValue = NodeFactory.makeIntBase(createSpan(yyStart,yyCount), false, a1); }
   / a1:QualifiedName
     { yyValue = NodeFactory.makeIntRef(createSpan(yyStart,yyCount), a1); };

/* IntExpr ::=
     IntVal
   | IntExpr w + w IntExpr
   | IntExpr w - w IntExpr
   | IntExpr sr IntExpr
   | IntExpr w DOT w IntExpr
   | IntExpr ^ IntVal
   | ( w IntExpr w )
 */
transient IntExpr IntExpr =
     seed:IntExprFront list:IntExprTail*
     { yyValue = (IntExpr)apply(list, seed); };

transient private IntExpr IntExprFront =
     IntVal
   / openparen w a1:IntExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); };

private constant transient Action<IntExpr> IntExprTail =
     SumIntExpr
   / MinusIntExpr
   / ProductIntExpr
   / ExponentIntExpr
   ;

private constant inline Action<IntExpr> SumIntExpr =
     w plus w a1:IntExpr
     { yyValue = new Action<IntExpr>() {
           public IntExpr run(IntExpr base) {
               Op plus = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "+");
               return NodeFactory.makeIntBinaryOp(createSpan(yyStart,yyCount),
                                      (IntExpr)base, a1, plus);
           }};
     };

private constant inline Action<IntExpr> MinusIntExpr =
     w minus w a1:IntExpr
     { yyValue = new Action<IntExpr>() {
           public IntExpr run(IntExpr base) {
               Op minus = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "-");
               return NodeFactory.makeIntBinaryOp(createSpan(yyStart,yyCount),
                                      (IntExpr)base, a1, minus);
           }};
     };

private constant inline Action<IntExpr> ProductIntExpr =
     (w DOT w / sr) a1:IntExpr
     { yyValue = new Action<IntExpr>() {
           public IntExpr run(IntExpr base) {
               Op product = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), " ");
               return NodeFactory.makeIntBinaryOp(createSpan(yyStart,yyCount),
                                      (IntExpr)base, a1, product);
           }};
     };

private constant inline Action<IntExpr> ExponentIntExpr =
     caret a1:IntVal
     { yyValue = new Action<IntExpr>() {
           public IntExpr run(IntExpr base) {
               Span span = createSpan(yyStart,yyCount);
               Op exponent = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "^");
               if (NodeUtil.isExponentiation((IntExpr)base)) {
                   log(NodeUtil.getSpan((IntExpr)base),
                       "An exponentiation should not be immediately followed " +
                       "by an exponentiation.");
                   return NodeFactory.makeIntBinaryOp(span, (IntExpr)base, a1, exponent);
               } return NodeFactory.makeIntBinaryOp(span, (IntExpr)base, a1, exponent);
           }};
     };

/* BoolConstraint ::=
     NOT w BoolExpr
   | BoolExpr w OR w BoolExpr
   | BoolExpr w AND w BoolExpr
   | BoolExpr w IMPLIES w BoolExpr
   | BoolExpr w = w BoolExpr
 */
transient private BoolConstraint BoolConstraint =
     seed:BoolConstraintFront list:BoolConstraintTail*
     { yyValue = (BoolConstraint)apply(list, seed); };

transient private BoolConstraint BoolConstraintFront =
     NOT w a1:BoolExpr
     { Span span = createSpan(yyStart,yyCount);
       Op not = NodeFactory.makeOpPrefix(span, "NOT");
       yyValue = NodeFactory.makeBoolUnaryOp(span, false, a1, not);
     }
   / a1:BoolConstraintHead w OR w a2:BoolExpr
     { Span span = createSpan(yyStart,yyCount);
       Op op = NodeFactory.makeOpInfix(span, "OR");
       yyValue = NodeFactory.makeBoolBinaryOp(span, a1, a2, op);
     }
   / a1:BoolConstraintHead w AND w a2:BoolExpr
     { Span span = createSpan(yyStart,yyCount);
       Op op = NodeFactory.makeOpInfix(span, "AND");
       yyValue = NodeFactory.makeBoolBinaryOp(span, a1, a2, op);
     }
   / a1:BoolConstraintHead w IMPLIES w a2:BoolExpr
     { Span span = createSpan(yyStart,yyCount);
       Op op = NodeFactory.makeOpInfix(span, "IMPLIES");
       yyValue = NodeFactory.makeBoolBinaryOp(span, a1, a2, op);
     }
   / a1:BoolConstraintHead w equals w a2:BoolExpr
     { Span span = createSpan(yyStart,yyCount);
       Op op = NodeFactory.makeOpInfix(span, "=");
       yyValue = NodeFactory.makeBoolBinaryOp(span, a1, a2, op);
     };

transient private BoolExpr BoolConstraintHead =
     BoolVal
   / openparen w a1:BoolExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); };

private constant transient Action<BoolConstraint> BoolConstraintTail =
     OrBoolConstraint
   / AndBoolConstraint
   / ImpliesBoolConstraint
   / EqualsBoolConstraint
   ;

private constant inline Action<BoolConstraint> OrBoolConstraint =
     w OR w a1:BoolExpr
     { yyValue = new Action<BoolConstraint>() {
           public BoolConstraint run(BoolConstraint base) {
               Span span = createSpan(yyStart,yyCount);
               Op op = NodeFactory.makeOpInfix(span, "OR");
               return NodeFactory.makeBoolBinaryOp(span, (BoolConstraint)base, a1, op);
           }};
     };

private constant inline Action<BoolConstraint> AndBoolConstraint =
     w AND w a1:BoolExpr
     { yyValue = new Action<BoolConstraint>() {
           public BoolConstraint run(BoolConstraint base) {
               Span span = createSpan(yyStart,yyCount);
               Op op = NodeFactory.makeOpInfix(span, "AND");
               return NodeFactory.makeBoolBinaryOp(span, (BoolConstraint)base, a1, op);
           }};
     };

private constant inline Action<BoolConstraint> ImpliesBoolConstraint =
     w IMPLIES w a1:BoolExpr
     { yyValue = new Action<BoolConstraint>() {
           public BoolConstraint run(BoolConstraint base) {
               Span span = createSpan(yyStart,yyCount);
               Op op = NodeFactory.makeOpInfix(span, "IMPLIES");
               return NodeFactory.makeBoolBinaryOp(span, (BoolConstraint)base, a1, op);
           }};
     };

private constant inline Action<BoolConstraint> EqualsBoolConstraint =
     w equals w a1:BoolExpr
     { yyValue = new Action<BoolConstraint>() {
           public BoolConstraint run(BoolConstraint base) {
               Span span = createSpan(yyStart,yyCount);
               Op op = NodeFactory.makeOpInfix(span, "");
               return NodeFactory.makeBoolBinaryOp(span, (BoolConstraint)base, a1, op);
           }};
     };

/* BoolVal ::=
     true
   | false
   | QualifiedName
 */
transient private BoolExpr BoolVal =
     a1:"true"
     { yyValue = NodeFactory.makeBoolBase(createSpan(yyStart,yyCount), false, true); }
   / a1:"false"
     { yyValue = NodeFactory.makeBoolBase(createSpan(yyStart,yyCount), false, false); }
   / a1:QualifiedName
     { yyValue = NodeFactory.makeBoolRef(createSpan(yyStart,yyCount), a1); };

/* BoolExpr ::=
     BoolVal
   | BoolConstraint
   | ( w BoolExpr w )
 */
transient BoolExpr BoolExpr =
     seed:BoolExprFront list:BoolExprTail*
     { yyValue = (BoolExpr)apply(list, seed); };

transient private BoolExpr BoolExprFront =
     BoolVal
   / openparen w a1:BoolExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); }
   / NOT w a1:BoolExpr
     { Span span = createSpan(yyStart,yyCount);
       Op not = NodeFactory.makeOpPrefix(span, "NOT");
       yyValue = NodeFactory.makeBoolUnaryOp(span, false, a1, not);
     };

private constant transient Action<BoolExpr> BoolExprTail =
     OrBoolExpr
   / AndBoolExpr
   / ImpliesBoolExpr
   / EqualsBoolExpr
   ;

private constant inline Action<BoolExpr> OrBoolExpr =
     w OR w a1:BoolExpr
     { yyValue = new Action<BoolExpr>() {
           public BoolExpr run(BoolExpr base) {
               Span span = createSpan(yyStart,yyCount);
               Op op = NodeFactory.makeOpInfix(span, "OR");
               return NodeFactory.makeBoolBinaryOp(span, (BoolExpr)base, a1, op);
           }};
     };

private constant inline Action<BoolExpr> AndBoolExpr =
     w AND w a1:BoolExpr
     { yyValue = new Action<BoolExpr>() {
           public BoolExpr run(BoolExpr base) {
               Span span = createSpan(yyStart,yyCount);
               Op op = NodeFactory.makeOpInfix(span, "AND");
               return NodeFactory.makeBoolBinaryOp(span, (BoolExpr)base, a1, op);
           }};
     };

private constant inline Action<BoolExpr> ImpliesBoolExpr =
     w IMPLIES w a1:BoolExpr
     { yyValue = new Action<BoolExpr>() {
           public BoolExpr run(BoolExpr base) {
               Span span = createSpan(yyStart,yyCount);
               Op op = NodeFactory.makeOpInfix(span, "IMPLIES");
               return NodeFactory.makeBoolBinaryOp(span, (BoolExpr)base, a1, op);
           }};
     };

private constant inline Action<BoolExpr> EqualsBoolExpr =
     w equals w a1:BoolExpr
     { yyValue = new Action<BoolExpr>() {
           public BoolExpr run(BoolExpr base) {
               Span span = createSpan(yyStart,yyCount);
               Op op = NodeFactory.makeOpInfix(span, "=");
               return NodeFactory.makeBoolBinaryOp(span, (BoolExpr)base, a1, op);
           }};
     };

/* UnitExpr ::=
     dimensionless
   | QualifiedName
   | UnitExpr sr UnitExpr
   | UnitExpr w DOT w UnitExpr
   | UnitExpr / UnitExpr
   | UnitExpr per UnitExpr
   | UnitExpr ^ UnitExpr
   | ( w UnitExpr w )
 */
transient UnitExpr UnitExpr =
     seed:UnitExprFront list:UnitExprTail*
     { yyValue = (UnitExpr)apply(list, seed); };

transient private UnitExpr UnitExprFront =
     a1:"dimensionless"
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makeUnitRef(span, false, NodeFactory.makeId(span, a1));
     }
   / a1:QualifiedName
     { yyValue = NodeFactory.makeUnitRef(createSpan(yyStart,yyCount), false, a1); }
   / openparen w a1:UnitExpr w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); };

private constant transient Action<UnitExpr> UnitExprTail =
     ProductUnitExpr
   / QuotientUnitExpr
   / ExponentUnitExpr
   ;

private constant inline Action<UnitExpr> ProductUnitExpr =
     (w DOT w / sr) a1:UnitExpr
     { yyValue = new Action<UnitExpr>() {
           public UnitExpr run(UnitExpr base) {
               Op product = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), " ");
               return NodeFactory.makeUnitBinaryOp(createSpan(yyStart,yyCount), false,
                                       (UnitExpr)base, a1, product);
           }};
     };

private constant inline Action<UnitExpr> QuotientUnitExpr =
     (slash / per) a1:UnitExpr
     { yyValue = new Action<UnitExpr>() {
           public UnitExpr run(UnitExpr base) {
               Op quotient = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "/");
               return NodeFactory.makeUnitBinaryOp(createSpan(yyStart,yyCount), false,
                                       (UnitExpr)base, a1, quotient);
           }};
     };

private constant inline Action<UnitExpr> ExponentUnitExpr =
     caret a1:UnitExpr
     { yyValue = new Action<UnitExpr>() {
           public UnitExpr run(UnitExpr base) {
               Op exponent = NodeFactory.makeOpInfix(NodeUtil.getSpan(a1), "^");
               return NodeFactory.makeUnitBinaryOp(createSpan(yyStart,yyCount), false,
                                       (UnitExpr)base, a1, exponent);
           }};
     };

/* Contract ::= (w Requires)? (w Ensures)? (w Invariant)? */
transient Contract Contract =
     <ErrorProduction1>
     w Requires w (ExtendsWhere / Throws / Where) (w Ensures)? (w Invariant)?
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Extends clauses should come before throws/where/contract clauses.");
       yyValue = NodeFactory.makeContract(span, Option.<List<Expr>>none(),
                                          Option.<List<EnsuresClause>>none(),
                                          Option.<List<Expr>>none());
     }
   / <ErrorProduction2>
     w Requires w Ensures w (ExtendsWhere / Throws / Where) (w Invariant)?
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Extends clauses should come before throws/where/contract clauses.");
       yyValue = NodeFactory.makeContract(span, Option.<List<Expr>>none(),
                                          Option.<List<EnsuresClause>>none(),
                                          Option.<List<Expr>>none());
     }
   / <ErrorProduction3>
     w Requires w Ensures w Invariant w (ExtendsWhere / Throws / Where)
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Extends clauses should come before throws/where/contract clauses.");
       yyValue = NodeFactory.makeContract(span, Option.<List<Expr>>none(),
                                          Option.<List<EnsuresClause>>none(),
                                          Option.<List<Expr>>none());
     }
   / <ErrorProduction4>
     w Ensures w (ExtendsWhere / Throws / Where) (w Invariant)?
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Extends clauses should come before throws/where/contract clauses.");
       yyValue = NodeFactory.makeContract(span, Option.<List<Expr>>none(),
                                          Option.<List<EnsuresClause>>none(),
                                          Option.<List<Expr>>none());
     }
   / <ErrorProduction5>
     w Ensures w Invariant w (ExtendsWhere / Throws / Where)
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Extends clauses should come before throws/where/contract clauses.");
       yyValue = NodeFactory.makeContract(span, Option.<List<Expr>>none(),
                                          Option.<List<EnsuresClause>>none(),
                                          Option.<List<Expr>>none());
     }
   / <ErrorProduction6>
     w Invariant w (ExtendsWhere / Throws / Where)
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Extends clauses should come before throws/where/contract clauses.");
       yyValue = NodeFactory.makeContract(span, Option.<List<Expr>>none(),
                                          Option.<List<EnsuresClause>>none(),
                                          Option.<List<Expr>>none());
     }
   / <ErrorProduction7>
     w Requires w Invariant w Ensures
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Ensures clauses should come before invariant clauses.");
       yyValue = NodeFactory.makeContract(span, Option.<List<Expr>>none(),
                                          Option.<List<EnsuresClause>>none(),
                                          Option.<List<Expr>>none());
     }
   / <ErrorProduction8>
     w Invariant w Ensures w Requires
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Requires clauses should come before ensures/invariant clauses.");
       yyValue = NodeFactory.makeContract(span, Option.<List<Expr>>none(),
                                          Option.<List<EnsuresClause>>none(),
                                          Option.<List<Expr>>none());
     }
   / <ErrorProduction9>
     w Invariant w Requires (w Ensures)?
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Requires clauses should come before ensures/invariant clauses.");
       yyValue = NodeFactory.makeContract(span, Option.<List<Expr>>none(),
                                          Option.<List<EnsuresClause>>none(),
                                          Option.<List<Expr>>none());
     }
   / <ErrorProduction10>
     w Ensures w Invariant w Requires
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Requires clauses should come before ensures/invariant clauses.");
       yyValue = NodeFactory.makeContract(span, Option.<List<Expr>>none(),
                                          Option.<List<EnsuresClause>>none(),
                                          Option.<List<Expr>>none());
     }
   / <ErrorProduction111>
     w Ensures w Requires (w Invariant)?
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Requires clauses should come before ensures/invariant clauses.");
       yyValue = NodeFactory.makeContract(span, Option.<List<Expr>>none(),
                                          Option.<List<EnsuresClause>>none(),
                                          Option.<List<Expr>>none());
     }
   / <ErrorProduction12>
     w Invariant w Ensures
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Ensures clauses should come before invariant clauses.");
       yyValue = NodeFactory.makeContract(span, Option.<List<Expr>>none(),
                                          Option.<List<EnsuresClause>>none(),
                                          Option.<List<Expr>>none());
     }
   / a1:(w Requires)? a2:(w Ensures)? a3:(w Invariant)?
     { Option<List<Expr>> requires = Option.<List<Expr>>wrap(a1);
       Option<List<EnsuresClause>> ensures = Option.<List<EnsuresClause>>wrap(a2);
       Option<List<Expr>> invariant = Option.<List<Expr>>wrap(a3);
       if (a1 == null && a2 == null && a3 == null) yyValue = null;
       else yyValue = NodeFactory.makeContract(createSpan(yyStart,yyCount), requires,
                                               ensures, invariant);
     };

/* Requires ::= requires w { (w ExprList)? w } */
transient List<Expr> Requires = requires w opencurly a1:(w ExprList)? w closecurly
     { if (a1 == null) yyValue = Collections.<Expr>emptyList();
       else            yyValue = a1;
     };

/* Ensures  ::= ensures w { (w EnsuresClauseList)? w } */
transient List<EnsuresClause> Ensures =
     ensures w opencurly a1:(w EnsuresClauseList)? w closecurly
     { if (a1 == null) yyValue = Collections.<EnsuresClause>emptyList();
       else            yyValue = a1;
     };

/* EnsuresClauseList ::= EnsuresClause (w , w EnsuresClause)* */
transient private List<EnsuresClause> EnsuresClauseList =
     a1:EnsuresClause a2s:(w comma w EnsuresClause)*
     { yyValue = Useful.cons(a1, a2s.list()); };

/* EnsuresClause ::= Expr (w provided w Expr)? */
transient private EnsuresClause EnsuresClause = a1:Expr a2:(w provided w Expr)?
     { Option<Expr> ensures = Option.<Expr>wrap(a2);
       yyValue = NodeFactory.makeEnsuresClause(createSpan(yyStart,yyCount), a1, ensures);
     };

/* Invariant::= invariant w { (w ExprList)? w } */
transient List<Expr> Invariant =
     invariant w opencurly a1:(w ExprList)? w closecurly
     { if (a1 == null) yyValue = Collections.<Expr>emptyList();
       else            yyValue = a1;
     };

/* StaticArgs ::= [\ w StaticArgList w \] */
List<StaticArg> StaticArgs =
    opendoublesquare w StaticArgList w closedoublesquare ;

/* StaticArgList ::= StaticArg (w , w StaticArg)*  */
List<StaticArg> StaticArgList = a1:StaticArg a2s:(w comma w StaticArg)*
     { yyValue = Useful.cons(a1, a2s.list()); };

/* StaticArg ::=
     Op
   | IntExpr
   | BoolExpr
   | Type
   | DimExpr
   | UnitExpr
 */
StaticArg StaticArg =
     a1:Op
     { yyValue = NodeFactory.makeOpArg(createSpan(yyStart,yyCount), ExprFactory.makeOpRef(a1)); }
   / !(QualifiedName (w closedoublesquare / w closesquare / w comma /
                      w opendoublesquare / w opensquare / w rightarrow /
                      w OR / w AND / w IMPLIES / w equals) /
       "Unity" / "dimensionless" / "true" / "false")
     a1:IntExpr
     { yyValue = NodeFactory.makeIntArg(createSpan(yyStart,yyCount), a1); }
   / !(QualifiedName (w closedoublesquare / w closesquare / w comma /
                      w opendoublesquare / w opensquare / w rightarrow) /
       "Unity" / "dimensionless")
     a1:BoolExpr
     { yyValue = NodeFactory.makeBoolArg(createSpan(yyStart,yyCount), a1); }
   / a1:"true"
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makeBoolArg(span, NodeFactory.makeBoolBase(span, false, true));
     }
   / a1:"false"
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makeBoolArg(span, NodeFactory.makeBoolBase(span, false, false));
     }
   / !(QualifiedName (w DOT / w slash / w per / w DimPostfixOp) / "dimensionless")
     a1:Type
     { yyValue = NodeFactory.makeTypeArg(createSpan(yyStart,yyCount), a1); }
   / a1:UnitExpr
     { yyValue = NodeFactory.makeUnitArg(createSpan(yyStart,yyCount), a1); }
   ;
