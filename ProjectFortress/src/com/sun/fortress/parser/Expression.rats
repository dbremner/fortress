/*******************************************************************************
    Copyright 2009 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress expressions.
 */
module com.sun.fortress.parser.Expression(Param, NoNewlineHeader,
                                          MayNewlineHeader, Type, DelimitedExpr,
                                          Literal, Identifier, Keyword, Symbol,
                                          Spacing);

import Param;
import NoNewlineHeader;
import MayNewlineHeader;
import Type;
import DelimitedExpr;
import Literal;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* Expr ::=
     AssignExpr
   | OpExpr
   | DelimitedExpr
   | FlowExpr
   | fn w ValParam (w IsType)? (w Throws)? w => w Expr
   | Expr w as w Type
   | Expr w asif w Type
 */
Expr Expr =
     seed:ExprFront list:ExprTail* { yyValue = (Expr)apply(list, seed); };

Expr ExprFront =
     <AssignExpr> AssignExpr
   / OpExpr
   / DelimitedExpr
   / <Flow> FlowExpr
   / <Fn> fn w a1:ValParam a2:(w IsType)? a3:(w Throws)? w match w a4:Expr
     { yyValue = ExprFactory.makeFnExpr(createSpan(yyStart,yyCount), a1,
                                        Option.<Type>wrap(a2),
                                        Option.<List<BaseType>>wrap(a3), a4);
     };

constant transient Action<Expr> ExprTail =
     <As> As
   / <Asif> AsIf
   ;

constant inline Action<Expr> As =
     w as w a1:Type
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               return ExprFactory.makeAsExpr(createSpan(yyStart,yyCount),
                                             (Expr)base, a1);
           }};
     };

constant inline Action<Expr> AsIf =
     w asif w a1:Type
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               return ExprFactory.makeAsIfExpr(createSpan(yyStart,yyCount),
                                               (Expr)base, a1);
           }};
     };

/* AssignExpr ::= AssignLefts w AssignOp w Expr */
Expr AssignExpr = a1:AssignLefts w a2:AssignOp w a3:Expr
    { yyValue = ExprFactory.makeAssignment(createSpan(yyStart,yyCount),
                                           a1, a2, a3);
    };

/* AssignLefts ::=
     ( w AssignLeft (w , w AssignLeft)* w )
   | AssignLeft
 */
List<Lhs> AssignLefts =
     openparen w a1:AssignLeft a2s:(w comma w AssignLeft)* w closeparen
     { yyValue = Useful.cons(a1, a2s.list()); }
   / a1:AssignLeft
     { yyValue = Useful.list(a1); };

/* AssignLeft ::=
     SubscriptExpr
   | FieldSelection
   | QualifiedName
   SubscriptExpr ::= Primay LeftEncloser StaticArgs? (w ExprList)? w RightEncloser
   FieldSelection ::= Primary . Id
 */
Lhs AssignLeft =
     seed:PrimaryFront list:AssignLeftTail+
     { Expr left = (Expr)apply(list, seed);
       if (left instanceof Lhs) yyValue = (Lhs)left;
       else yyValue = null;
     }
   / a1:QualifiedName
     { yyValue = ExprFactory.makeVarRef(createSpan(yyStart,yyCount), a1); };

constant transient Action<Expr> AssignLeftTail =
     SubscriptAssign
   / FieldSelectionAssign
   ;

constant inline Action<Expr> SubscriptAssign =
     a1:LeftEncloser a2:hasW a3:StaticArgs? a4:(w ExprList)? w a5:RightEncloser
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
             Span span = createSpan(yyStart,yyCount);
             if ( a2.booleanValue() && a3 != null )
                 log(span, "Space is not allowed immediately " +
                     "before left white square bracket.");
             List<StaticArg> sargs;
             if (a3 == null) sargs = Collections.<StaticArg>emptyList();
             else            sargs = a3;
             List<Expr> es;
             if (a4 == null) es = Collections.<Expr>emptyList();
             else            es = a4;
             Op op = NodeFactory.makeEnclosing(NodeUtil.spanTwo(a1,a5),
                                               a1.getText(), a5.getText());
             return ExprFactory.makeSubscriptExpr(span, base, es,
                                                  Option.<Op>some(op), sargs);
            }};
     };

constant inline Action<Expr> FieldSelectionAssign =
    dot a1:Id
    { yyValue = new Action<Expr>() {
          public Expr run(Expr base) {
              return ExprFactory.makeFieldRef(createSpan(yyStart,yyCount),
                                              base, a1);
          }};
    };

/* OpExpr ::=
     OpExprNoEnc
   | OpExprLeftEncloser
   | Encloser
 */
Expr OpExpr =
     <FIRST> a1:OpExprNoEnc
     { yyValue = Resolver.resolveOps(a1); }
   / a1:OpExprLeftEncloser
     { yyValue = Resolver.resolveOps(a1); }
   / a1:Encloser
     { PrecedenceOpExpr e =
           new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
       yyValue = Resolver.resolveOps(PureList.make(e));
     };

/* OpExprNoEnc ::=
     OpExprPrimary
   | OpExprPrefix
   | Op
 */
PureList<PrecedenceOpExpr> OpExprNoEnc =
     <FIRST> OpExprPrimary
   / OpExprPrefix
   / a1:Op
     { PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
       yyValue = PureList.make(e);
     };

/* TightInfixRight ::=
     Encloser OpExprPrimary
   | Encloser OpExprPrefix
   | Encloser wr OpExprPrimary
   | Encloser wr LooseInfix
   | Encloser wr LeftLooseInfix
   | Encloser
 */
PureList<PrecedenceOpExpr> TightInfixRight =
     a1:Encloser a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1)); }
   / a1:Encloser a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1)); }
   / <Primary>   a1:Encloser wr a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new Right(a1)); }
   / <Loose>     a1:Encloser wr a2:LooseInfix
     { yyValue = a2.cons((PrecedenceOpExpr)new Right(a1)); }
   / <LeftLoose> a1:Encloser wr a2:LeftLooseInfix
     { yyValue = a2.cons((PrecedenceOpExpr)new Right(a1)); }
   / a1:Encloser
     { yyValue = PureList.make((PrecedenceOpExpr)new Right(a1)); };

/* LeftLooseInfix ::=
     OpExprLeftEncloser
   | Encloser wr OpExprPrimary
   | Encloser wr OpExprPrefix
   | Encloser wr OpExprLeftEncloser
 */
PureList<PrecedenceOpExpr> LeftLooseInfix =
     OpExprLeftEncloser
   / <Primary> a1:Encloser wr a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); }
   / <Prefix>  a1:Encloser wr a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); }
   / <Left>    a1:Encloser wr a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); };

/* OpExprLeftEncloser ::= Encloser OpExprNoEnc */
PureList<PrecedenceOpExpr> OpExprLeftEncloser =
     a1:Encloser a2:OpExprNoEnc
     { yyValue = a2.cons(new Left(a1)); };

/* OpExprPrimary ::=
     Primary TightInfixPostfix
   | Primary TightInfixRight
   | Primary wr OpExprPrimary
   | Primary wr LooseInfix
   | Primary wr LeftLooseInfix
   | Primary
 */
PureList<PrecedenceOpExpr> OpExprPrimary =
     a1:Primary a2:TightInfixPostfix
     { yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1))); }
   / a1:Primary a2:TightInfixRight
     { yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1))); }
   / <Primary>   a1:Primary wr a2:OpExprPrimary
     { yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1))); }
   / <Loose>     a1:Primary wr a2:LooseInfix
     { yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1))); }
   / <LeftLoose> a1:Primary wr a2:LeftLooseInfix
     { yyValue = a2.cons(new RealExpr(ExprFactory.buildPrimary(a1))); }
   / a1:Primary
     { yyValue =
           PureList.make((PrecedenceOpExpr)new RealExpr(ExprFactory.buildPrimary(a1))); };

/* OpExprPrefix ::=
     Op OpExprPrimary
   | Op OpExprPrefix
   | Op OpExprLeftEncloser
   | Op wr OpExprPrimary
   | Op wr OpExprPrefix
   | Op wr OpExprLeftEncloser
 */
PureList<PrecedenceOpExpr> OpExprPrefix =
     a1:Op a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1)); }
   / a1:Op a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1)); }
   / a1:Op a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1)); }
   / <Primary> a1:Op wr a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1)); }
   / <Prefix>  a1:Op wr a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1)); }
   / <Left>    a1:Op wr a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1)); };

/* TightInfixPostfix ::=
     Op OpExprPrimary
   | Op OpExprPrefix
   | Op OpExprLeftEncloser
   | Op wr OpExprPrimary
   | Op wr OpExprPrefix
   | Op wr OpExprLeftEncloser
   | Op
 */
PureList<PrecedenceOpExpr> TightInfixPostfix =
     a1:Op a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1)); }
   / a1:Op a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1)); }
   / a1:Op a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1)); }
   / <Primary> a1:Op wr a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1)); }
   / <Prefix>  a1:Op wr a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1)); }
   / <Left>    a1:Op wr a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1)); }
   / a1:Op
     { yyValue = PureList.make((PrecedenceOpExpr)new Postfix(a1)); };

/* LooseInfix ::=
     Op wr OpExprPrimary
   | Op wr OpExprPrefix
   | Op wr OpExprLeftEncloser
 */
PureList<PrecedenceOpExpr> LooseInfix =
     a1:Op wr a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); }
   / a1:Op wr a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); }
   / <Left> a1:Op wr a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); };

/* Primary ::= PrimaryItem (w , w PrimaryItem)* */
constant PureList<Expr> Primary =
    a1:PrimaryItem a2s:(w comma w PrimaryItem)+
    &(Encloser (wr / br / w comma / w RightEncloser))
     { List<Expr> es = new ArrayList<Expr>();
       for (PureList<Expr> elist : Useful.cons(a1, a2s.list())) {
           es.add(ExprFactory.buildPrimary(elist));
       }
       yyValue = PureList.make((Expr)ExprFactory.makeTupleExpr(createSpan(yyStart,yyCount),
                                                               es));
     }
   / PrimaryItem ;

/* PrimaryItem ::=
     LeftAssociatedPrimary
   | MathPrimary
 */
constant PureList<Expr> PrimaryItem =
     a1:(LeftAssociatedPrimary / MathPrimary)
     { yyValue = PureList.make(a1); };

/* LeftAssociatedPrimary ::=
     DottedIdChain StaticArgs? Subscripting* ParenthesisDelimited* Selector*
   | PrimaryFront Subscripting* ParenthesisDelimited* Selector+
 */
constant Expr LeftAssociatedPrimary =
     a1:DottedIdChain a2:hasW a3:StaticArgs a4:ParenthesisDelimited
     a5s:ParenthesisDelimitedLeft* a6s:Selector*
     { Id last = IterUtil.last(a1);
       Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
       Span span = NodeUtil.spanTwo(receiver,a4);
       if ( a2.booleanValue() )
           log(span, "Space is not allowed immediately " +
               "before left white square bracket.");
       Expr e1 = ExprFactory.makeMethodInvocation(span, receiver, last, a3, a4);
       Expr e2 = (Expr)apply(a5s, e1);
       yyValue = (Expr)apply(a6s, e2);
     }
   / a1:DottedIdChain a2s:SubscriptingLeft+ a3s:ParenthesisDelimitedLeft*
     a4s:Selector*
     { Id last = IterUtil.last(a1);
       Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
       Span span = NodeUtil.spanTwo(receiver,last);
       Expr e1 = ExprFactory.makeFieldRef(span, receiver, last);
       Expr e2 = (Expr)apply(a2s, e1);
       Expr e3 = (Expr)apply(a3s, e2);
       yyValue = (Expr)apply(a4s, e3);
     }
   / a1:DottedIdChain a2:ParenthesisDelimited a3s:ParenthesisDelimitedLeft*
     a4s:Selector*
     { Id last = IterUtil.last(a1);
       Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
       Span span = NodeUtil.spanTwo(receiver,a2);
       Expr e1 = ExprFactory.makeMethodInvocation(span, receiver, last, a2);
       Expr e2 = (Expr)apply(a3s, e1);
       yyValue = (Expr)apply(a4s, e2);
     }
   / a1:DottedIdChain a2s:Selector*
     { Id last = IterUtil.last(a1);
       Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
       Span span = NodeUtil.spanTwo(receiver,last);
       Expr e1 = ExprFactory.makeFieldRef(span, receiver, last);
       yyValue = (Expr)apply(a2s, e1);
     }
   / a1:PrimaryFront a2s:SubscriptingLeft* a3s:ParenthesisDelimitedLeft*
     a4s:Selector+
     { Expr e1 = (Expr)apply(a2s, a1);
       Expr e2 = (Expr)apply(a3s, e1);
       yyValue = (Expr)apply(a4s, e2);
     };

/* A primary expression is always left-associated if it contains any dot
   (i.e., ".") not within parentheses or some pair of enclosing operators.
   If such a primary expression begins with an identifier immediately
   followed by a dot then the maximal prefix of identifiers separated by
   dots (whitespace may follow but not precede the dots) is collected into
   a "dotted id chain", which is subsequently partitioned into the longest
   prefix, if any, that is a qualified name, and the remaining dots and
   identifiers, which are interpreted as selectors.  If the last identifier
   in the dotted id chain is part of a selector (i.e., the entire dotted id
   chain is not a qualified name), and it is immediately followed by a left
   parenthesis, then the last selector together with the subsequent parenthesis-
   delimited term is a method selector.
 */
/* QualifiedName is not yet implemented in the interpreter. */
/* DottedIdChain ::= Id(. w Id)+ */
List<Id> DottedIdChain = a1:Id a2s:(dot w Id)+
    { yyValue = Useful.cons(a1, a2s.list()); };

/* MathPrimary ::= PrimaryFront MathItem* */
constant Expr MathPrimary =
    a1:PrimaryFront a2s:MathItem*
    { Span span = createSpan(yyStart,yyCount);
      List<MathItem> mis = a2s.list();
      if (mis.size() == 0)
          yyValue = a1;
      else if (mis.size() == 1)
          yyValue = ExprFactory.simplifyMathPrimary(span, a1, mis.get(0));
      else // mis.size() > 1
          yyValue = ExprFactory.makeMathPrimary(span, a1, mis);
    };

/* PrimaryFront ::=
     ArrayExpr
   | MapExpr
   | Comprehension
   | LeftEncloser StaticArgs? (w ExprList)? w RightEncloser
   | ParenthesisDelimited
   | LiteralExpr
   | VarOrFnRef
   | self
 */
Expr PrimaryFront =
     ArrayExpr
   / MapExpr
   / Comprehension
   / <ErrorProduction>
     LeftEncloser wr StaticArgs (w ExprList)? w RightEncloser
     { Span span = createSpan(yyStart,yyCount);
       yyValue = ExprFactory.makeVoidLiteralExpr(span);
     }
   / a1:LeftEncloser a2:hasW a3:StaticArgs? a4:(w ExprList)? w a5:RightEncloser
     { if (a4 == null) a4 = Collections.<Expr>emptyList();
       Span span = NodeUtil.spanTwo(a1, a5);
       if ( a2.booleanValue() && a3 != null )
           log(span, "Space is not allowed immediately " +
               "before left white square bracket.");
       if (a3 == null) yyValue = ASTUtil.enclosing(span, a1, a4, a5);
       else            yyValue = ASTUtil.enclosing(span, a1, a3, a4, a5);
     }
   / ParenthesisDelimited
   / LiteralExpr
   / VarOrFnRef
   / a1:self
     { yyValue = ExprFactory.makeVarRef(createSpan(yyStart,yyCount), a1); };

/* ArrayExpr is defined in Literal.rats */

/* VarOrFnRef ::= Id StaticArgs? */
Expr VarOrFnRef =
     a1:Id a2:hasW a3:StaticArgs
     { Span span = createSpan(yyStart,yyCount);
       if ( a2.booleanValue() )
           log(span, "Space is not allowed immediately " +
               "before left white square bracket.");
       yyValue = ExprFactory.makeFnRef(createSpan(yyStart,yyCount), a1, a3);
     }
   / a1:Id
     { yyValue = ExprFactory.makeVarRef(createSpan(yyStart,yyCount), a1); };

/* Subscripting ::=
     [ StaticArgs? (w ExprList)? w ]
   | { StaticArgs? (w ExprList)? w }
   | LeftEncloser StaticArgs? (w ExprList)? w RightEncloser
 */
constant inline Action<Expr> SubscriptingLeft =
     a1:(opensquare / opencurly) a2:hasW a3:StaticArgs? a4:(w ExprList)? w
     a5:(closesquare / closecurly)
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               Span span = createSpan(yyStart,yyCount);
               if ( a2.booleanValue() && a3 != null )
                   log(span, "Space is not allowed immediately " +
                       "before left white square bracket.");
               if (PrecedenceMap.ONLY.matchedBrackets(a1, a5)) {
                   Span spanOpen = createSpan(yyStart, yyStart+1);
                   Span spanClose = createSpan(yyCount-1,1);
                   List<StaticArg> ss;
                   if (a3 == null) ss = Collections.<StaticArg>emptyList();
                   else            ss = a3;
                   return ExprFactory.makeSubscripting(span, a1, a5, base, a4, ss);
               } else {
                   log(span, "Mismatched subscripting operator: " +
                       a1 + " and " + a5);
                   return ExprFactory.makeVoidLiteralExpr(span);
               }
           }};
     }
   / a1:LeftEncloser a2:hasW a3:StaticArgs? a4:(w ExprList)? w a5:RightEncloser
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               Span span = createSpan(yyStart,yyCount);
               if ( a2.booleanValue() && a3 != null )
                   log(span, "Space is not allowed immediately " +
                       "before left white square bracket.");
               List<StaticArg> ss;
               if (a3 == null) ss = Collections.<StaticArg>emptyList();
               else            ss = a3;
               return ExprFactory.makeSubscripting(span, base, a1.getText(),
                                                   a5.getText(), a4, ss);
           }};
     };

/* ParenthesisDelimited ::=
     Parenthesized
   | ArgExpr
   | ( w )
 */
constant inline Action<Expr> ParenthesisDelimitedLeft =
    a1:ParenthesisDelimited
    { yyValue = new Action<Expr>() {
          public Expr run(Expr base) {
              return ExprFactory.makeTightJuxt(NodeUtil.spanTwo(base, a1),
                                               false, Useful.list(base, a1));
          }};
    };

Expr ParenthesisDelimited =
     Parenthesized
   / ArgExpr
   / openparen w closeparen
     { yyValue = ExprFactory.makeVoidLiteralExpr(createSpan(yyStart,yyCount)); };

/* Selector ::=
     MethodInvocation ParenthesisDelimited*
   | FieldSelection Subscripting* ParenthesisDelimited*
   MethodInvocation ::= . w Id StaticArgs? ParenthesisDelimited
   FieldSelection ::= . w Id
 */
constant transient Action<Expr> Selector =
     MethodInvocationSelector
   / FieldSelectionSelector
   ;

constant inline Action<Expr> MethodInvocationSelector = /* REVERSE ORDER */
     <ErrorProduction>
     dot w Id wr StaticArgs ParenthesisDelimited ParenthesisDelimitedLeft*
     { log(createSpan(yyStart,yyCount),
           "Space is not allowed immediately before left white square bracket.");
       yyValue = new Action<Expr>() { public Expr run(Expr base) { return base; }};
     }
   / dot w a1:Id a2:StaticArgs? a3:ParenthesisDelimited
     a4s:ParenthesisDelimitedLeft*
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               List<StaticArg> sargs;
               if (a2 == null) sargs = Collections.<StaticArg>emptyList();
               else            sargs = a2;
               Expr mtdInv = ExprFactory.makeMethodInvocation(NodeUtil.spanTwo(base, a3),
                                                              base, a1, sargs, a3);
               return (Expr)apply(a4s, mtdInv);
           }};
     };

constant inline Action<Expr> FieldSelectionSelector =
     dot w a1:Id a2s:SubscriptingLeft* a3s:ParenthesisDelimitedLeft*
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               Expr fldSel = ExprFactory.makeFieldRef(createSpan(yyStart,yyCount),
                                                      base, a1);
               return (Expr)apply(a3s, (Expr)apply(a2s, fldSel));
           }};
     };

/* MathItem ::=
     Subscripting
   | Exponentiation
   | ParenthesisDelimited
   | LiteralExpr
   | VarOrFnRef
   | self
 */
MathItem MathItem =
     Subscripting
   / Exponentiation
   / a1:ParenthesisDelimited
     { yyValue = ExprFactory.makeParenthesisDelimitedMI(NodeUtil.getSpan(a1), a1); }
   / a1:LiteralExpr
     { yyValue = ExprFactory.makeNonParenthesisDelimitedMI(NodeUtil.getSpan(a1), a1); }
   / a1:VarOrFnRef
     { yyValue = ExprFactory.makeNonParenthesisDelimitedMI(NodeUtil.getSpan(a1), a1); }
   / a1:self
     { Span span = createSpan(yyStart,yyCount);
       Expr expr = ExprFactory.makeVarRef(span, a1);
       yyValue = ExprFactory.makeNonParenthesisDelimitedMI(span, expr);
     };

/* Subscripting ::=
     [ StaticArgs? (w ExprList)? w ]
   | { StaticArgs? (w ExprList)? w }
   | LeftEncloser StaticArgs? (w ExprList)? w RightEncloser
 */
SubscriptingMI Subscripting =
     a1:(opensquare / opencurly) a2:hasW a3:StaticArgs? a4:(w ExprList)? w
     a5:(closesquare / closecurly)
     { Span span = createSpan(yyStart,yyCount);
       Op op = NodeFactory.makeEnclosing(span, a1, a5);
       if ( a2.booleanValue() && a3 != null )
           log(span, "Space is not allowed immediately " +
               "before left white square bracket.");
       if (a3 == null) a3 = Collections.<StaticArg>emptyList();
       if (a4 == null) a4 = Collections.<Expr>emptyList();
       if (! PrecedenceMap.ONLY.matchedBrackets(a1, a5))
           log(span, "Mismatched subscripting operator: " + a1 + " and " + a5);
       yyValue = ExprFactory.makeSubscriptingMI(span, op, a4, a3);
     }
   / a1:LeftEncloser a2:hasW a3:StaticArgs? a4:(w ExprList)? w a5:RightEncloser
     { Span span = createSpan(yyStart,yyCount);
       Op op = NodeFactory.makeEnclosing(span, a1.getText(),a5.getText());
       if ( a2.booleanValue() && a3 != null )
           log(span, "Space is not allowed immediately " +
               "before left white square bracket.");
       if (a3 == null) a3 = Collections.<StaticArg>emptyList();
       if (a4 == null) a4 = Collections.<Expr>emptyList();
       yyValue = ExprFactory.makeSubscriptingMI(span, op, a4, a3);
     };

/* Exponentiation ::=
     ^ Exponent
   | ExponentOp
 */
ExponentiationMI Exponentiation =
     a1:caret a2:hasW a3:Exponent
     { Span span = createSpan(yyStart,yyCount);
       if ( a2.booleanValue() )
           log(span, "Space is not allowed immediately after '^'.");
       yyValue = ExprFactory.makeExponentiationMI(span,
                                                  ExprFactory.makeOpRef(NodeFactory.makeOpInfix(span, a1)),
                                                  Option.<Expr>some(a3));
     }
   / a1:ExponentOp
     { yyValue = ExprFactory.makeExponentiationMI(NodeUtil.getSpan(a1),
                                                  ExprFactory.makeOpRef(a1),
                                                  Option.<Expr>none());
     };

/* Exponent ::=
     ParenthesisDelimited
   | LiteralExpr
   | Id
   | self
 */
Expr Exponent =
     ParenthesisDelimited
   / LiteralExpr
   / a1:Id { yyValue = ExprFactory.makeVarRef(a1); }
   / a1:self
     { yyValue = ExprFactory.makeVarRef(createSpan(yyStart,yyCount), a1); };

/* FlowExpr ::=
     exit (w Id)? (w with w Expr)?
   | Accumulator StaticArgs? (w [ w GeneratorClauseList w ])? w Expr
   | BIG w { w |-> StaticArgs? w } w Expr
   | BIG w LeftEncloser StaticArgs? w RightEncloser w Expr
   | atomic w AtomicBack
   | tryatomic w AtomicBack
   | spawn w Expr
   | throw w Expr
 */
Expr FlowExpr =
     exit a1:(w Id)? a2:(w with w Expr)?
     { Option<Id> name = (a1 == null) ? Option.<Id>none() : Option.<Id>some(a1);
       yyValue = ExprFactory.makeExit(createSpan(yyStart,yyCount),
                                      Option.<Type>none(), name,
                                      Option.<Expr>wrap(a2));
     }
   / a1:Accumulator a2:hasW a3:StaticArgs?
     a4:(w void:opensquare w GeneratorClauseList w void:closesquare)? w a5:Expr
     { Span span = createSpan(yyStart,yyCount);
       if ( a2.booleanValue() && a3 != null )
           log(span, "Space is not allowed immediately " +
               "before left white square bracket.");
       if (a3 == null) a3 = Collections.<StaticArg>emptyList();
       if (a4 == null)
           yyValue = ExprFactory.makeOpExpr(span, a1, a5, a3);
       else
           yyValue = ExprFactory.makeAccumulator(span, a3, a1, a4, a5);
     }
   / BIG w opencurly w mapsto a1:StaticArgs? w closecurly w a2:Expr
     { Span span = createSpan(yyStart,yyCount);
       if (a1 == null) a1 = Collections.<StaticArg>emptyList();
       Op opr = NodeFactory.makeEnclosing(span, "BIG {|->", "BIG }");
       yyValue = ExprFactory.makeOpExpr(span, opr, a2, a1);
     }
   / BIG w a1:LeftEncloser a2:hasW a3:StaticArgs? w a4:RightEncloser w a5:Expr
     { Span span = createSpan(yyStart,yyCount);
       if ( a2.booleanValue() && a3 != null )
           log(span, "Space is not allowed immediately " +
               "before left white square bracket.");
       if (a3 == null) a3 = Collections.<StaticArg>emptyList();
       Op opr = NodeFactory.makeEnclosing(span, "BIG " + a1.getText(),
                                          "BIG " + a4.getText());
       yyValue = ExprFactory.makeOpExpr(span, opr, a5, a3);
     }
   / atomic w a1:AtomicBack
     { yyValue = ExprFactory.makeAtomicExpr(createSpan(yyStart,yyCount), a1); }
   / tryatomic w a1:AtomicBack
     { yyValue = ExprFactory.makeTryAtomicExpr(createSpan(yyStart,yyCount), a1); }
   / spawn w a1:Expr
     { yyValue = ExprFactory.makeSpawn(createSpan(yyStart,yyCount), a1); }
   / throw w a1:Expr
     { yyValue = ExprFactory.makeThrow(createSpan(yyStart,yyCount), a1); };

/* AtomicBack ::=
     AssignExpr
   | OpExpr
   | DelimitedExpr
 */
Expr AtomicBack =
     AssignExpr
   / OpExpr
   / DelimitedExpr ;

/* GeneratorClauseList ::= GeneratorBinding (w , w GeneratorClause)* */
List<GeneratorClause> GeneratorClauseList =
     a1:GeneratorBinding a2s:(w comma w GeneratorClause)*
     { yyValue = Useful.cons(a1, a2s.list()); };

/* GeneratorBinding ::= BindIdOrBindIdTuple w <- w Expr */
GeneratorClause GeneratorBinding =
     a1:BindIdOrBindIdTuple w leftarrow w a2:Expr
     { yyValue = ExprFactory.makeGeneratorClause(createSpan(yyStart,yyCount),
                                                 a1, a2);
     };

/* GeneratorClause ::=
     GeneratorBinding
   | Expr
 */
GeneratorClause GeneratorClause =
     GeneratorBinding
   / a1:Expr
     { yyValue = NodeFactory.makeGeneratorClause(createSpan(yyStart,yyCount),
                                                 Collections.<Id>emptyList(), a1);
     };
