/*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress expressions.
 */
module com.sun.fortress.parser.Expression(Param, NoNewlineHeader,
                                          MayNewlineHeader, Type, DelimitedExpr,
                                          Literal, Identifier, Keyword, Symbol,
                                          Spacing);

import Param;
import NoNewlineHeader;
import MayNewlineHeader;
import Type;
import DelimitedExpr;
import Literal;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* Expr ::=
     AssignExpr
   | OpExpr
   | DelimitedExpr
   | FlowExpr
   | fn w ValParam (w IsType)? (w Throws)? w => w Expr
   | Expr w as w Type
   | Expr w asif w Type
 */
Expr Expr =
     seed:ExprFront list:ExprTail* { yyValue = (Expr)apply(list, seed); };

Expr ExprFront =
     <AssignExpr> AssignExpr
   / OpExpr
   / DelimitedExpr
   / <Flow> FlowExpr
   / <Fn> fn w a1:ValParam a2:(w IsType)? a3:(w Throws)? w match w a4:Expr
     { Option<Type> ty_opt = Option.wrap(a2);
       Option<List<BaseType>> tys = Option.wrap(a3);
       yyValue = ExprFactory.makeFnExpr(createSpan(yyStart,yyCount), a1, ty_opt,
                                        tys, a4);
     };

constant transient Action<Expr> ExprTail =
     <As> As
   / <Asif> AsIf
   ;

constant inline Action<Expr> As =
     w as w a1:Type
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               return new AsExpr(createSpan(yyStart,yyCount), false, (Expr)base,
                                 a1);
           }};
     };

constant inline Action<Expr> AsIf =
     w asif w a1:Type
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               return new AsIfExpr(createSpan(yyStart,yyCount), false,
                                   (Expr)base, a1);
           }};
     };

/* AssignExpr ::= AssignLefts w AssignOp w Expr */
Expr AssignExpr = a1:AssignLefts w a2:AssignOp w a3:Expr
    { yyValue = new Assignment(createSpan(yyStart,yyCount), false, a1, a2, a3);};

/* AssignLefts ::=
     ( w AssignLeft (w , w AssignLeft)* w )
   | AssignLeft
 */
List<Lhs> AssignLefts =
     openparen w a1:AssignLeft a2s:(w comma w AssignLeft)* w closeparen
     { yyValue = FortressUtil.mkList(a1, a2s.list()); }
   / a1:AssignLeft
     { yyValue = FortressUtil.mkList(a1); };

/* AssignLeft ::=
     SubscriptExpr
   | FieldSelection
   | QualifiedName
   SubscriptExpr ::= Primay LeftEncloser StaticArgs? (w ExprList)? w RightEncloser
   FieldSelection ::= Primary . Id
 */
Lhs AssignLeft =
     seed:PrimaryFront list:AssignLeftTail+
     { Expr left = (Expr)apply(list, seed);
       if (left instanceof Lhs) yyValue = (Lhs)left;
       else yyValue = null;
     }
   / a1:QualifiedName
     { yyValue = new VarRef(createSpan(yyStart,yyCount), false, a1,
                            Collections.<StaticArg>emptyList()); };

constant transient Action<Expr> AssignLeftTail =
     SubscriptAssign
   / FieldSelectionAssign
   ;

constant inline Action<Expr> SubscriptAssign =
     <ErrorProduction>
     LeftEncloser wr StaticArgs (w ExprList)? w RightEncloser
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately before left white square bracket.");
     }
   / a1:LeftEncloser a2:StaticArgs? a3:(w ExprList)? w a4:RightEncloser
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
             Span span = createSpan(yyStart,yyCount);
             List<StaticArg> sargs;
             if (a2 == null) sargs = Collections.<StaticArg>emptyList();
             else            sargs = a2;
             List<Expr> es;
             if (a3 == null) es = FortressUtil.emptyExprs();
             else            es = a3;
             Op op = NodeFactory.makeEnclosing(FortressUtil.spanTwo(a1,a4),
                                               a1.getText(),a4.getText());
             return ExprFactory.makeSubscriptExpr(span,base,es,Option.some(op),
                                                  sargs);
            }};
     };

constant inline Action<Expr> FieldSelectionAssign =
    dot a1:Id
    { yyValue = new Action<Expr>() {
          public Expr run(Expr base) {
              return ExprFactory.makeFieldRef(createSpan(yyStart,yyCount), base, a1);
          }};
    };

/* OpExpr ::=
     OpExprNoEnc
   | OpExprLeftEncloser
   | Encloser
 */
Expr OpExpr =
     <FIRST> a1:OpExprNoEnc
     { yyValue = Resolver.resolveOps(a1); }
   / a1:OpExprLeftEncloser
     { yyValue = Resolver.resolveOps(a1); }
   / a1:Encloser
     { PrecedenceOpExpr e =
           new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
       yyValue = Resolver.resolveOps(PureList.make(e));
     };

/* OpExprNoEnc ::=
     OpExprPrimary
   | OpExprPrefix
   | Op
 */
PureList<PrecedenceOpExpr> OpExprNoEnc =
     <FIRST> OpExprPrimary
   / OpExprPrefix
   / a1:Op
     { PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
       yyValue = PureList.make(e);
     };

/* TightInfixRight ::=
     Encloser OpExprPrimary
   | Encloser OpExprPrefix
   | Encloser wr OpExprPrimary
   | Encloser wr LooseInfix
   | Encloser wr LeftLooseInfix
   | Encloser
 */
PureList<PrecedenceOpExpr> TightInfixRight =
     a1:Encloser a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1)); }
   / a1:Encloser a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1)); }
   / <Primary>   a1:Encloser wr a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new Right(a1)); }
   / <Loose>     a1:Encloser wr a2:LooseInfix
     { yyValue = a2.cons((PrecedenceOpExpr)new Right(a1)); }
   / <LeftLoose> a1:Encloser wr a2:LeftLooseInfix
     { yyValue = a2.cons((PrecedenceOpExpr)new Right(a1)); }
   / a1:Encloser
     { yyValue = PureList.make((PrecedenceOpExpr)new Right(a1)); };

/* LeftLooseInfix ::=
     OpExprLeftEncloser
   | Encloser wr OpExprPrimary
   | Encloser wr OpExprPrefix
   | Encloser wr OpExprLeftEncloser
 */
PureList<PrecedenceOpExpr> LeftLooseInfix =
     OpExprLeftEncloser
   / <Primary> a1:Encloser wr a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); }
   / <Prefix>  a1:Encloser wr a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); }
   / <Left>    a1:Encloser wr a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); };

/* OpExprLeftEncloser ::= Encloser OpExprNoEnc */
PureList<PrecedenceOpExpr> OpExprLeftEncloser =
     a1:Encloser a2:OpExprNoEnc
     { yyValue = a2.cons(new Left(a1)); };

/* OpExprPrimary ::=
     Primary TightInfixPostfix
   | Primary TightInfixRight
   | Primary wr OpExprPrimary
   | Primary wr LooseInfix
   | Primary wr LeftLooseInfix
   | Primary
 */
PureList<PrecedenceOpExpr> OpExprPrimary =
     a1:Primary a2:TightInfixPostfix
     { yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1))); }
   / a1:Primary a2:TightInfixRight
     { yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1))); }
   / <Primary>   a1:Primary wr a2:OpExprPrimary
     { yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1))); }
   / <Loose>     a1:Primary wr a2:LooseInfix
     { yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1))); }
   / <LeftLoose> a1:Primary wr a2:LeftLooseInfix
     { yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1))); }
   / a1:Primary
     { yyValue =
           PureList.make((PrecedenceOpExpr)new RealExpr(FortressUtil.buildPrimary(a1))); };

/* OpExprPrefix ::=
     Op OpExprPrimary
   | Op OpExprPrefix
   | Op OpExprLeftEncloser
   | Op wr OpExprPrimary
   | Op wr OpExprPrefix
   | Op wr OpExprLeftEncloser
 */
PureList<PrecedenceOpExpr> OpExprPrefix =
     a1:Op a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1)); }
   / a1:Op a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1)); }
   / a1:Op a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1)); }
   / <Primary> a1:Op wr a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1)); }
   / <Prefix>  a1:Op wr a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1)); }
   / <Left>    a1:Op wr a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1)); };

/* TightInfixPostfix ::=
     Op OpExprPrimary
   | Op OpExprPrefix
   | Op OpExprLeftEncloser
   | Op wr OpExprPrimary
   | Op wr OpExprPrefix
   | Op wr OpExprLeftEncloser
   | Op
 */
PureList<PrecedenceOpExpr> TightInfixPostfix =
     a1:Op a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1)); }
   / a1:Op a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1)); }
   / a1:Op a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1)); }
   / <Primary> a1:Op wr a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1)); }
   / <Prefix>  a1:Op wr a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1)); }
   / <Left>    a1:Op wr a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1)); }
   / a1:Op
     { yyValue = PureList.make((PrecedenceOpExpr)new Postfix(a1)); };

/* LooseInfix ::=
     Op wr OpExprPrimary
   | Op wr OpExprPrefix
   | Op wr OpExprLeftEncloser
 */
PureList<PrecedenceOpExpr> LooseInfix =
     a1:Op wr a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); }
   / a1:Op wr a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); }
   / <Left> a1:Op wr a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); };

/* Primary ::= PrimaryItem (w , w PrimaryItem)* */
constant PureList<Expr> Primary =
    a1:PrimaryItem a2s:(w comma w PrimaryItem)+
    &(Encloser (wr / br / w comma / w RightEncloser))
     { List<PureList<Expr>> elists = FortressUtil.mkList(a1, a2s.list());
       List<Expr> es = new ArrayList<Expr>();
       for (PureList<Expr> elist : elists) {
           es.add(FortressUtil.buildPrimary(elist));
       }
       yyValue = PureList.make((Expr)new TupleExpr(createSpan(yyStart,yyCount),
                                                   false, es));
     }
   / PrimaryItem ;

/* PrimaryItem ::=
     LeftAssociatedPrimary
   | MathPrimary
 */
constant PureList<Expr> PrimaryItem =
     a1:(LeftAssociatedPrimary / MathPrimary)
     { yyValue = PureList.make(a1); };

/* LeftAssociatedPrimary ::=
     DottedIdChain StaticArgs? Subscripting* ParenthesisDelimited* Selector*
   | PrimaryFront Subscripting* ParenthesisDelimited* Selector+
 */
constant Expr LeftAssociatedPrimary =
     <ErrorProduction>
     DottedIdChain wr StaticArgs ParenthesisDelimited
     ParenthesisDelimitedLeft* Selector*
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately before left white square bracket.");
     }
   / a1:DottedIdChain a2:StaticArgs a3:ParenthesisDelimited
     a4s:ParenthesisDelimitedLeft* a5s:Selector*
     { Id last = IterUtil.last(a1);
       Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
       Span span = FortressUtil.spanTwo(receiver,a3);
       Expr e1 = new MethodInvocation(span, receiver, last, a2, a3);
       Expr e2 = (Expr)apply(a4s, e1);
       yyValue = (Expr)apply(a5s, e2);
     }
   / a1:DottedIdChain a2s:SubscriptingLeft+ a3s:ParenthesisDelimitedLeft*
     a4s:Selector*
     { Id last = IterUtil.last(a1);
       Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
       Span span = FortressUtil.spanTwo(receiver,last);
       Expr e1 = ExprFactory.makeFieldRef(span, receiver, last);
       Expr e2 = (Expr)apply(a2s, e1);
       Expr e3 = (Expr)apply(a3s, e2);
       yyValue = (Expr)apply(a4s, e3);
     }
   / a1:DottedIdChain a2:ParenthesisDelimited a3s:ParenthesisDelimitedLeft*
     a4s:Selector*
     { Id last = IterUtil.last(a1);
       Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
       Span span = FortressUtil.spanTwo(receiver,a2);
       Expr e1 = new MethodInvocation(span, receiver, last, a2);
       Expr e2 = (Expr)apply(a3s, e1);
       yyValue = (Expr)apply(a4s, e2);
     }
   / a1:DottedIdChain a2s:Selector*
     { Id last = IterUtil.last(a1);
       Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
       Span span = FortressUtil.spanTwo(receiver,last);
       Expr e1 = ExprFactory.makeFieldRef(span, receiver, last);
       yyValue = (Expr)apply(a2s, e1);
     }
   / a1:PrimaryFront a2s:SubscriptingLeft* a3s:ParenthesisDelimitedLeft*
     a4s:Selector+
     { Expr e1 = (Expr)apply(a2s, a1);
       Expr e2 = (Expr)apply(a3s, e1);
       yyValue = (Expr)apply(a4s, e2);
     };

/* QualifiedName is not yet implemented in the interpreter. */
/* DottedIdChain ::= Id(. w Id)+ */
List<Id> DottedIdChain = a1:Id a2s:(dot w Id)+
    { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* MathPrimary ::= PrimaryFront MathItem* */
constant Expr MathPrimary =
    a1:PrimaryFront a2s:MathItem*
    { Span span = createSpan(yyStart,yyCount);
      List<MathItem> mis = a2s.list();
      if (mis.size() == 0) {
          yyValue = a1;
      } else if (mis.size() == 1) {
          yyValue = ExprFactory.simplifyMathPrimary(span, a1, mis.get(0));
      } else { // mis.size() > 1
          yyValue = new MathPrimary(span, a1, mis);
      }
    };

/* PrimaryFront ::=
     ArrayExpr
   | MapExpr
   | Comprehension
   | LeftEncloser StaticArgs? (w ExprList)? w RightEncloser
   | ParenthesisDelimited
   | LiteralExpr
   | VarOrFnRef
   | self
 */
Expr PrimaryFront =
     ArrayExpr
   / MapExpr
   / Comprehension
   / <ErrorProduction>
     LeftEncloser wr StaticArgs (w ExprList)? w RightEncloser
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately before left white square bracket.");
     }
   / a1:LeftEncloser a2:StaticArgs? a3:(w ExprList)? w a4:RightEncloser
     { if (a3 == null) a3 = FortressUtil.emptyExprs();
       Span span = FortressUtil.spanTwo(a1, a4);
       if (a2 == null) yyValue = ASTUtil.enclosing(span, a1, a3, a4);
       else            yyValue = ASTUtil.enclosing(span, a1, a2, a3, a4);
     }
   / ParenthesisDelimited
   / LiteralExpr
   / VarOrFnRef
   / a1:self
     { yyValue = ExprFactory.makeVarRef(createSpan(yyStart,yyCount), a1); }
   ;

/* ArrayExpr is defined in Literal.rats */

/* VarOrFnRef ::= Id StaticArgs? */
Expr VarOrFnRef =
     <ErrorProduction>
     Id wr StaticArgs
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately before left white square bracket.");
     }
   / a1:Id a2:StaticArgs?
     { if (a2 == null)
            yyValue = new VarRef(createSpan(yyStart,yyCount),false,a1,
                                 Collections.<StaticArg>emptyList());
       else yyValue = ExprFactory.makeFnRef(createSpan(yyStart,yyCount),a1,a2);
     };

/* Subscripting ::=
     [ StaticArgs? (w ExprList)? w ]
   | { StaticArgs? (w ExprList)? w }
   | LeftEncloser StaticArgs? (w ExprList)? w RightEncloser
 */
constant inline Action<Expr> SubscriptingLeft =
     <ErrorProduction1>
     (opensquare / opencurly) wr StaticArgs (w ExprList)? w
     (closesquare / closecurly)
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately before left white square bracket.");
     }
   / a1:(opensquare / opencurly) a2:StaticArgs? a3:(w ExprList)? w
     a4:(closesquare / closecurly)
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               Span span = createSpan(yyStart,yyCount);
               if (PrecedenceMap.ONLY.matchedBrackets(a1, a4)) {
                   Span spanOpen = createSpan(yyStart, yyStart+1);
                   Span spanClose = createSpan(yyCount-1,1);
                   List<StaticArg> ss;
                   if (a2 == null) ss = Collections.<StaticArg>emptyList();
                   else            ss = a2;
                   return FortressUtil.makeSubscripting(span,
                                                        a1, a4, base, a3, ss);
               } else return syntaxError(span,
                                         "Mismatched subscripting operator: " +
                                         a1 + " and " + a4);
           }};
     }
   / <ErrorProduction2>
     LeftEncloser wr StaticArgs (w ExprList)? w RightEncloser
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately before left white square bracket.");
     }
   / a1:LeftEncloser a2:StaticArgs? a3:(w ExprList)? w a4:RightEncloser
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               Span span = createSpan(yyStart,yyCount);
               List<StaticArg> ss;
               if (a2 == null) ss = Collections.<StaticArg>emptyList();
               else            ss = a2;
               return FortressUtil.makeSubscripting(span, base, a1.getText(),
                                                    a4.getText(), a3, ss);
           }};
     };

/* ParenthesisDelimited ::=
     Parenthesized
   | ArgExpr
   | ( w )
 */
constant inline Action<Expr> ParenthesisDelimitedLeft =
    a1:ParenthesisDelimited
    { yyValue = new Action<Expr>() {
          public Expr run(Expr base) {
              List<Expr> exprs = FortressUtil.mkList(base, a1);
              return ExprFactory.makeTightJuxt(FortressUtil.spanTwo(base, a1), false, exprs);
          }};
    };

Expr ParenthesisDelimited =
     Parenthesized
   / ArgExpr
   / openparen w closeparen
     { yyValue = ExprFactory.makeVoidLiteralExpr(createSpan(yyStart,yyCount)); };

/* Selector ::=
     MethodInvocation ParenthesisDelimited*
   | FieldSelection Subscripting* ParenthesisDelimited*
   MethodInvocation ::= . w Id StaticArgs? ParenthesisDelimited
   FieldSelection ::= . w Id
 */
constant transient Action<Expr> Selector =
     MethodInvocationSelector
   / FieldSelectionSelector
   ;

constant inline Action<Expr> MethodInvocationSelector = /* REVERSE ORDER */
     <ErrorProduction>
     dot w Id wr StaticArgs ParenthesisDelimited ParenthesisDelimitedLeft*
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately before left white square bracket.");
     }
   / dot w a1:Id a2:StaticArgs? a3:ParenthesisDelimited
     a4s:ParenthesisDelimitedLeft*
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               List<StaticArg> sargs;
               if (a2 == null) sargs = Collections.<StaticArg>emptyList();
               else            sargs = a2;
               Expr mtdInv = new MethodInvocation(FortressUtil.spanTwo(base, a3),
                                                  false, base, a1, sargs, a3);
               return (Expr)apply(a4s, mtdInv);
           }};
     };

constant inline Action<Expr> FieldSelectionSelector =
     dot w a1:Id a2s:SubscriptingLeft* a3s:ParenthesisDelimitedLeft*
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               Expr fldSel = ExprFactory.makeFieldRef(createSpan(yyStart,yyCount),
                                                      base, a1);
               return (Expr)apply(a3s, (Expr)apply(a2s, fldSel));
           }};
     };

/* MathItem ::=
     Subscripting
   | Exponentiation
   | ParenthesisDelimited
   | LiteralExpr
   | VarOrFnRef
   | self
 */
MathItem MathItem =
     Subscripting
   / Exponentiation
   / a1:ParenthesisDelimited
     { yyValue = new ParenthesisDelimitedMI(a1.getSpan(), a1); }
   / a1:LiteralExpr
     { yyValue = new NonParenthesisDelimitedMI(a1.getSpan(), a1); }
   / a1:VarOrFnRef
     { yyValue = new NonParenthesisDelimitedMI(a1.getSpan(), a1); }
   / a1:self
     { Span span = createSpan(yyStart,yyCount);
       Expr expr = ExprFactory.makeVarRef(span, a1);
       yyValue = new NonParenthesisDelimitedMI(span, expr);
     };

/* Subscripting ::=
     [ StaticArgs? (w ExprList)? w ]
   | { StaticArgs? (w ExprList)? w }
   | LeftEncloser StaticArgs? (w ExprList)? w RightEncloser
 */
SubscriptingMI Subscripting =
     <ErrorProduction1>
     (opensquare / opencurly) wr StaticArgs (w ExprList)? w
     (closesquare / closecurly)
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately before left white square bracket.");
     }
   / a1:(opensquare / opencurly) a2:StaticArgs? a3:(w ExprList)? w
     a4:(closesquare / closecurly)
     { Span span = createSpan(yyStart,yyCount);
       if (PrecedenceMap.ONLY.matchedBrackets(a1, a4)) {
           Op op = NodeFactory.makeEnclosing(span, a1, a4);
           if (a2 == null) a2 = Collections.<StaticArg>emptyList();
           if (a3 == null) a3 = Collections.<Expr>emptyList();
           yyValue = new SubscriptingMI(span, op, a3, a2);
       } else return syntaxError(span,
                                 "Mismatched subscripting operator: " + a1 +
                                 " and " + a4);
     }
   / <ErrorProduction2>
     LeftEncloser wr StaticArgs (w ExprList)? w RightEncloser
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately before left white square bracket.");
     }
   / a1:LeftEncloser a2:StaticArgs? a3:(w ExprList)? w a4:RightEncloser
     { Span span = createSpan(yyStart,yyCount);
       Op op = NodeFactory.makeEnclosing(span, a1.getText(),a4.getText());
       if (a2 == null) a2 = Collections.<StaticArg>emptyList();
       if (a3 == null) a3 = Collections.<Expr>emptyList();
       yyValue = new SubscriptingMI(span, op, a3, a2);
     };

/* Exponentiation ::=
     ^ Exponent
   | ExponentOp
 */
ExponentiationMI Exponentiation =
     <ErrorProduction>
     caret wr Exponent
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately after '^'.");
     }
   / a1:caret a2:Exponent
     { Span span = createSpan(yyStart,yyCount);
       yyValue = new ExponentiationMI(span, ExprFactory.makeOpRef(NodeFactory.makeOpInfix(span, a1)),
                                      Option.some(a2));
     }
   / a1:ExponentOp
     { yyValue = new ExponentiationMI(a1.getSpan(), ExprFactory.makeOpRef(a1), Option.<Expr>none()); };

/* Exponent ::=
     ParenthesisDelimited
   | LiteralExpr
   | Id
   | self
 */
Expr Exponent =
     ParenthesisDelimited
   / LiteralExpr
   / a1:Id { yyValue = ExprFactory.makeVarRef(a1); }
   / a1:self
     { yyValue = ExprFactory.makeVarRef(createSpan(yyStart,yyCount), a1); };

/* FlowExpr ::=
     exit (w Id)? (w with w Expr)?
   | Accumulator StaticArgs? (w [ w GeneratorClauseList w ])? w Expr
   | BIG w { w |-> StaticArgs? w } w Expr
   | BIG w LeftEncloser StaticArgs? w RightEncloser w Expr
   | atomic w AtomicBack
   | tryatomic w AtomicBack
   | spawn w Expr
   | throw w Expr
 */
Expr FlowExpr =
     exit a1:(w Id)? a2:(w with w Expr)?
     { Option<Id> name = (a1 == null) ? Option.<Id>none() : Option.some(a1);
       Option<Expr> expr = Option.wrap(a2);
       yyValue = new Exit(createSpan(yyStart,yyCount), false, Option.<Type>none() ,name, expr);
     }
   / <ErrorProduction1>
     Accumulator wr StaticArgs
     (w opensquare w GeneratorClauseList w closesquare)? w Expr
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately before left white square bracket.");
     }
   / a1:Accumulator a2:StaticArgs?
     a3:(w void:opensquare w GeneratorClauseList w void:closesquare)? w a4:Expr
     { Span span = createSpan(yyStart,yyCount);
       if (a2 == null) a2 = Collections.<StaticArg>emptyList();
       if (a3 == null) {
           yyValue = ExprFactory.makeOpExpr(span, a1, a4, a2);
       } else
           yyValue = new Accumulator(span, a2, a1, a3, a4);
     }
   / <ErrorProduction2>
     BIG w LeftEncloser wr StaticArgs w RightEncloser w Expr
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately before left white square bracket.");
     }
   / BIG w opencurly w mapsto a1:StaticArgs? w closecurly w a2:Expr
     { Span span = createSpan(yyStart,yyCount);
       if (a1 == null) a1 = Collections.<StaticArg>emptyList();
       Op opr = NodeFactory.makeEnclosing(span, "BIG {|->", "BIG }");
       yyValue = ExprFactory.makeOpExpr(span, opr, a2, a1);
     }
   / BIG w a1:LeftEncloser a2:StaticArgs? w a3:RightEncloser w a4:Expr
     { Span span = createSpan(yyStart,yyCount);
       if (a2 == null) a2 = Collections.<StaticArg>emptyList();
       Op opr = NodeFactory.makeEnclosing(span, "BIG " + a1.getText(),
                                          "BIG " + a3.getText());
       yyValue = ExprFactory.makeOpExpr(span, opr, a4, a2);
     }
   / atomic w a1:AtomicBack
     { yyValue = new AtomicExpr(createSpan(yyStart,yyCount), false, a1); }
   / tryatomic w a1:AtomicBack
     { yyValue = new TryAtomicExpr(createSpan(yyStart,yyCount), false, a1); }
   / spawn w a1:Expr
     { yyValue = new Spawn(createSpan(yyStart,yyCount), false, a1); }
   / throw w a1:Expr
     { yyValue = new Throw(createSpan(yyStart,yyCount), false, a1); };

/* AtomicBack ::=
     AssignExpr
   | OpExpr
   | DelimitedExpr
 */
Expr AtomicBack =
     AssignExpr
   / OpExpr
   / DelimitedExpr ;

/* GeneratorClauseList ::= GeneratorBinding (w , w GeneratorClause)* */
List<GeneratorClause> GeneratorClauseList =
     a1:GeneratorBinding a2s:(w comma w GeneratorClause)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* GeneratorBinding ::= BindIdOrBindIdTuple w <- w Expr */
GeneratorClause GeneratorBinding =
     a1:BindIdOrBindIdTuple w leftarrow w a2:Expr
     { yyValue = ExprFactory.makeGeneratorClause(createSpan(yyStart,yyCount),
                                                 a1,a2);
     };

/* GeneratorClause ::=
     GeneratorBinding
   | Expr
 */
GeneratorClause GeneratorClause =
     GeneratorBinding
   / a1:Expr
     { yyValue = new GeneratorClause(createSpan(yyStart,yyCount),
                               Collections.<Id>emptyList(), a1);
     };
