/*******************************************************************************
    Copyright 2009 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress headers.
 */
module com.sun.fortress.parser.NoNewlineHeader(Other, NoNewlineType,
                                               NoNewlineExpr, MayNewlineHeader,
                                               Literal, Identifier, Keyword,
                                               Symbol, Spacing);

import NoNewlineType;
import NoNewlineExpr;
import MayNewlineHeader;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* ExtendsWhere ::= extends w TraitTypeWheres */
List<TraitTypeWhere> ExtendsWhere = extends w TraitTypeWheres ;

/* TraitTypeWheres ::= TraitTypeWhere | { w TraitTypeWhereList w } */
private List<TraitTypeWhere> TraitTypeWheres =
     a1:TraitTypeWhere { yyValue = FortressUtil.mkList(a1); }
   / void:opencurly w TraitTypeWhereList w void:closecurly ;

/* TraitTypeWhereList ::= TraitTypeWhere (w , w TraitTypeWhere)* */
private List<TraitTypeWhere> TraitTypeWhereList =
     a1:TraitTypeWhere a2s:(w comma w TraitTypeWhere)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* TraitTypeWhere ::= TraitType (w Where)? */
private TraitTypeWhere TraitTypeWhere =
     a1:TraitType a2:(w Where)?
     { Option<WhereClause> where;
       if (a2 == null)
           where = Option.<WhereClause>none();
       else
           where = Option.some(a2);
       yyValue = NodeFactory.makeTraitTypeWhere(createSpan(yyStart,yyCount),
                                                a1, where);
     };

/* Extends ::= extends w TraitTypes */
List<BaseType> Extends = extends w TraitTypes ;

/* Excludes ::= excludes w TraitTypes */
List<BaseType> Excludes = excludes w TraitTypes ;

/* Comprises ::= comprises w TraitTypes */
List<BaseType> Comprises = comprises w TraitTypes ;

/* AbsComprises ::= comprises w ComprisingTypes */
List<BaseType> AbsComprises = comprises w ComprisingTypes ;

/* TraitTypes ::= TraitType | { w TraitTypeList w } */
List<BaseType> TraitTypes =
     a1:TraitType { yyValue = FortressUtil.mkList(a1); }
   / void:opencurly w TraitTypeList w void:closecurly ;

/* TraitTypeList ::= TraitType (w , w TraitType)* */
private List<BaseType> TraitTypeList = a1:TraitType a2s:(w comma w TraitType)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* ComprisingTypes ::= TraitType | { w ComprisingTypeList w } */
private List<BaseType> ComprisingTypes =
     a1:TraitType { yyValue = FortressUtil.mkList(a1); }
   / void:opencurly w ComprisingTypeList w void:closecurly ;

/* ComprisingTypeList ::=
     ...
   | TraitType (w , w TraitType)* (w , w ...)?
 */
private List<BaseType> ComprisingTypeList =
     ellipses
     { yyValue = FortressUtil.emptyTraitTypes(); }
   / a1:TraitType a2s:(w comma w TraitType)* (w comma w ellipses)?
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* Where ::=
     where w [\ w WhereBindingList w \] (w { w WhereConstraintList w })?
   | where w { w WhereConstraintList w }
 */
transient WhereClause Where =
     where w opendoublesquare w a1:WhereBindingList w closedoublesquare
     a2:(w void:opencurly w WhereConstraintList w void:closecurly)?
     { if (a2 == null)
         yyValue = NodeFactory.makeWhereClause(createSpan(yyStart,yyCount),
                                   a1, Collections.<WhereConstraint>emptyList());
       else
         yyValue = NodeFactory.makeWhereClause(createSpan(yyStart,yyCount),
                                   a1, a2);
     }
   / where w opencurly w a1:WhereConstraintList w closecurly
     { yyValue = NodeFactory.makeWhereClause(createSpan(yyStart,yyCount),
                                 Collections.<WhereBinding>emptyList(), a1);
     };

/* WhereBindingList ::= WhereBinding (w , w WhereBinding)* */
transient List<WhereBinding> WhereBindingList =
     a1:WhereBinding a2s:(w comma w WhereBinding)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* WhereBinding ::=
     nat w Id
   | int w Id
   | bool w Id
   | unit w Id
   | Id (w Extends)?
 */
transient WhereBinding WhereBinding =
     nat w a1:Id
     { List<BaseType> supers = Collections.<BaseType>emptyList();
       yyValue = NodeFactory.makeWhereBinding(createSpan(yyStart,yyCount),
                                              a1, supers, new KindNat());
     }
   / <ErrorProduction1> nat w a1:OpName
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid nat parameter name.\n");
       yyValue = NodeFactory.makeWhereBinding(span, NodeFactory.bogusId(span),
                                              FortressUtil.emptyTraitTypes(),
                                              new KindType());
     }
   / int w a1:Id
     { List<BaseType> supers = Collections.<BaseType>emptyList();
       yyValue = NodeFactory.makeWhereBinding(createSpan(yyStart,yyCount),
                                              a1, supers, new KindInt());
     }
   / <ErrorProduction2> int w a1:OpName
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid int parameter name.\n");
       yyValue = NodeFactory.makeWhereBinding(span, NodeFactory.bogusId(span),
                                              FortressUtil.emptyTraitTypes(),
                                              new KindType());
     }
   / bool w a1:Id
     { List<BaseType> supers = Collections.<BaseType>emptyList();
       yyValue = NodeFactory.makeWhereBinding(createSpan(yyStart,yyCount),
                                              a1, supers, new KindBool());
     }
   / <ErrorProduction3> bool w a1:OpName
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid bool parameter name.\n");
       yyValue = NodeFactory.makeWhereBinding(span, NodeFactory.bogusId(span),
                                              FortressUtil.emptyTraitTypes(),
                                              new KindType());
     }
   / unit w a1:Id
     { List<BaseType> supers = Collections.<BaseType>emptyList();
       yyValue = NodeFactory.makeWhereBinding(createSpan(yyStart,yyCount),
                                              a1, supers, new KindUnit());
     }
   / <ErrorProduction4> unit w a1:OpName
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid unit parameter name.\n");
       yyValue = NodeFactory.makeWhereBinding(span, NodeFactory.bogusId(span),
                                              FortressUtil.emptyTraitTypes(),
                                              new KindType());
     }
   / <ErrorProduction5> a1:OpName w a2:Extends
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid type parameter name.\n");
       yyValue = NodeFactory.makeWhereBinding(span, NodeFactory.bogusId(span),
                                              FortressUtil.emptyTraitTypes(),
                                              new KindType());
     }
   / a1:Id a2:(w a2:Extends)?
     { if (a2 == null) a2 = FortressUtil.emptyTraitTypes();
         yyValue = NodeFactory.makeWhereBinding(createSpan(yyStart,yyCount),
                                                a1, a2, new KindType());
     }
   / <ErrorProduction6> opendoublesquare
     { Span span = createSpan(yyStart,yyCount);
       log(span, "White square bracket is not a valid where-clause binding.");
       yyValue = NodeFactory.makeWhereBinding(span, NodeFactory.bogusId(span),
                                              FortressUtil.emptyTraitTypes(),
                                              new KindType());
     };

/* FnHeaderClause ::= (w NoNewlineIsType)? FnClauses */
FnHeaderClause FnHeaderClause = a1:(w NoNewlineIsType)? a2:FnClauses
     { Option<Type> returnType = Option.wrap(a1);
       yyValue = new FnHeaderClause(a2.getThrowsClause(), a2.getWhereClause(),
                                    a2.getContractClause(), returnType);
     };

/* FnClauses ::= (w Throws)? (w Where)? Contract */
FnHeaderClause FnClauses =
     <ErrorProduction1>
     w Throws w ExtendsWhere (w Where)? Contract
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Extends clauses should come before throws/where/contract clauses.");
       yyValue = new FnHeaderClause(Option.<List<BaseType>>none(),
                                    Option.<WhereClause>none(),
                                    Option.<Contract>none(),
                                    Option.<Type>none());
     }
   / <ErrorProduction2>
     w Throws w Where w ExtendsWhere Contract
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Extends clauses should come before throws/where/contract clauses.");
       yyValue = new FnHeaderClause(Option.<List<BaseType>>none(),
                                    Option.<WhereClause>none(),
                                    Option.<Contract>none(),
                                    Option.<Type>none());
     }
   / <ErrorProduction3>
     w Where w ExtendsWhere Contract
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Extends clauses should come before throws/where/contract clauses.");
       yyValue = new FnHeaderClause(Option.<List<BaseType>>none(),
                                    Option.<WhereClause>none(),
                                    Option.<Contract>none(),
                                    Option.<Type>none());
     }
   / <ErrorProduction4>
     w Where w Throws Contract
     { Span span = createSpan(yyStart,yyCount);
       log(span,
           "Throws clauses should come before where clauses.");
       yyValue = new FnHeaderClause(Option.<List<BaseType>>none(),
                                    Option.<WhereClause>none(),
                                    Option.<Contract>none(),
                                    Option.<Type>none());
     }
   / a1:(w Throws)? a2:(w Where)? a3:Contract
     { Option<List<BaseType>> throwsClause = Option.wrap(a1);
       Option<WhereClause> where;
       if (a2 == null)
           where = Option.<WhereClause>none();
       else
           where = Option.<WhereClause>some(a2);
       Option<Contract> contractClause = Option.wrap(a3);
       yyValue = new FnHeaderClause(throwsClause, where, contractClause,
                                    Option.<Type>none());
     };

/* Throws ::= throws w MayTraitTypes */
List<BaseType> Throws = throws w MayTraitTypes ;

/* MayTraitTypes ::= { w } | TraitTypes  */
private List<BaseType> MayTraitTypes =
     opencurly w closecurly { yyValue = FortressUtil.emptyTraitTypes(); }
   / TraitTypes ;

/* Each modifier cannot appear more than once. */
/* Mods ::= (Mod w)+ */
transient Modifiers Mods = a1s:(Mod w)+
     { yyValue = NodeUtil.noDuplicate(writer, createSpan(yyStart,yyCount), a1s);
     };

/* Mod ::=
   atomic | hidden | io | override | private | settable | test | value | var | wrapped
 */
transient Modifiers Mod =
     atomic   { yyValue = Modifiers.Atomic; }
   / hidden   { yyValue = Modifiers.Hidden; }
   / io       { yyValue = Modifiers.IO; }
   / override { yyValue = Modifiers.Override; }
   / private  { yyValue = Modifiers.Private; }
   / settable { yyValue = Modifiers.Settable; }
   / test     { yyValue = Modifiers.Test; }
   / value    { yyValue = Modifiers.Value; }
   / var      { yyValue = Modifiers.Var; }
   / wrapped  { yyValue = Modifiers.Wrapped; };


/* Each modifier cannot appear more than once. */
/* ParamFldMods ::= (ParamFldMod w)+ */
transient Modifiers ParamFldMods = a1s:(ParamFldMod w)+
     { yyValue =
           NodeUtil.noDuplicate(writer, createSpan(yyStart,yyCount),
                                    FortressUtil.mkList(a1s.list()));
     };

/* ParamFldMod ::= var | hidden | settable | wrapped */
transient private Modifiers ParamFldMod =
     var      { yyValue = Modifiers.Var; }
   / hidden   { yyValue = Modifiers.Hidden; }
   / settable { yyValue = Modifiers.Settable; }
   / wrapped  { yyValue = Modifiers.Wrapped; };

/* StaticParams ::= [\ w StaticParamList w \] */
List<StaticParam> StaticParams =
     opendoublesquare w StaticParamList w closedoublesquare ;

/* StaticParamList ::= StaticParam (w , w StaticParam)* */
private List<StaticParam> StaticParamList =
     a1:StaticParam a2s:(w comma w StaticParam)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* StaticParam ::=
     nat w Id
   | int w Id
   | bool w Id
   | dim w Id
   | unit w Id (w : w NoNewlineType)? (w absorbs w unit)?
   | opr w Op
   | Id (w Extends)? (w absorbs w unit)?
*/
private StaticParam StaticParam =
     nat w a1:Id
     { yyValue = NodeFactory.makeStaticParam(createSpan(yyStart,yyCount), a1,
                                             Collections.<BaseType>emptyList(),
                                             Option.<Type>none(), false,
                                             new KindNat());
     }
   / <ErrorProduction1>
     nat w a1:OpName
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid nat parameter name.\n");
       yyValue = NodeFactory.makeStaticParam(span, NodeFactory.bogusId(span),
                                             Collections.<BaseType>emptyList(),
                                             Option.<Type>none(), false,
                                             new KindNat());
     }
   / int w a1:Id
     { yyValue = NodeFactory.makeStaticParam(createSpan(yyStart,yyCount), a1,
                                 Collections.<BaseType>emptyList(),
                                 Option.<Type>none(), false,
                                 new KindInt());
     }
   / <ErrorProduction2>
     int w a1:OpName
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid int parameter name.\n");
       yyValue = NodeFactory.makeStaticParam(span, NodeFactory.bogusId(span),
                                             Collections.<BaseType>emptyList(),
                                             Option.<Type>none(), false,
                                             new KindNat());
     }
   / bool w a1:Id
     { yyValue = NodeFactory.makeStaticParam(createSpan(yyStart,yyCount), a1,
                                 Collections.<BaseType>emptyList(),
                                 Option.<Type>none(), false,
                                 new KindBool());
     }
   / <ErrorProduction3>
     bool w a1:OpName
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid bool parameter name.\n");
       yyValue = NodeFactory.makeStaticParam(span, NodeFactory.bogusId(span),
                                             Collections.<BaseType>emptyList(),
                                             Option.<Type>none(), false,
                                             new KindNat());
     }
   / dim w a1:Id
     { yyValue = NodeFactory.makeStaticParam(createSpan(yyStart,yyCount), a1,
                                 Collections.<BaseType>emptyList(),
                                 Option.<Type>none(), false,
                                 new KindDim());
     }
   / <ErrorProduction4>
     dim w a1:OpName
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid dim parameter name.\n");
       yyValue = NodeFactory.makeStaticParam(span, NodeFactory.bogusId(span),
                                             Collections.<BaseType>emptyList(),
                                             Option.<Type>none(), false,
                                             new KindNat());
     }
   / unit w a1:Id a2:(w void:colon w NoNewlineType)? a3:(w absorbs w unit)?
     { Option<Type> derived = Option.wrap(a2);
       boolean absorbs = (a3 == null) ? false : true;
       yyValue = NodeFactory.makeStaticParam(createSpan(yyStart,yyCount), a1,
                                 Collections.<BaseType>emptyList(),
                                 derived, absorbs,
                                 new KindUnit());
     }
   / <ErrorProduction5>
     unit w a1:OpName a2:(w void:colon w NoNewlineType)? a3:(w absorbs w unit)?
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid unit parameter name.\n");
       yyValue = NodeFactory.makeStaticParam(span, NodeFactory.bogusId(span),
                                             Collections.<BaseType>emptyList(),
                                             Option.<Type>none(), false,
                                             new KindNat());
     }
   / opr w a1:Op
     { yyValue = NodeFactory.makeStaticParam(createSpan(yyStart,yyCount), a1,
                                 Collections.<BaseType>emptyList(),
                                 Option.<Type>none(), false,
                                 new KindOp()); }
   / <ErrorProduction6>
     a1:OpName w a2:Extends a3:(w absorbs w unit)?
     { Span span = createSpan(yyStart,yyCount);
       log(span, a1 + " is not a valid type parameter name.\n");
       yyValue = NodeFactory.makeStaticParam(span, NodeFactory.bogusId(span),
                                             Collections.<BaseType>emptyList(),
                                             Option.<Type>none(), false,
                                             new KindNat());
     }
   / a1:Id a2:(w Extends)? a3:(w absorbs w unit)?
     { if (a2 == null) a2 = Collections.<BaseType>emptyList();
       boolean absorbs;
       if (a3 == null) absorbs = false;
       else            absorbs = true;
       yyValue = NodeFactory.makeStaticParam(createSpan(yyStart,yyCount), a1, a2,
                                 Option.<Type>none(), absorbs,
                                 new KindType());
     }
   / <ErrorProduction7>
     opendoublesquare
     { Span span = createSpan(yyStart,yyCount);
       log(span, "White square bracket is not a valid static parameter.");
       yyValue = NodeFactory.makeStaticParam(span, NodeFactory.bogusId(span),
                                             Collections.<BaseType>emptyList(),
                                             Option.<Type>none(), false,
                                             new KindNat());
     };
