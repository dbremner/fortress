/*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress headers.
 */
module com.sun.fortress.parser.NoNewlineHeader(Other, NoNewlineType,
                                               NoNewlineExpr, MayNewlineHeader,
                                               Literal, Identifier, Keyword,
                                               Symbol, Spacing);

import NoNewlineType;
import NoNewlineExpr;
import MayNewlineHeader;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* ExtendsWhere ::= extends w TraitTypeWheres */
List<TraitTypeWhere> ExtendsWhere = extends w TraitTypeWheres ;

/* TraitTypeWheres ::= TraitTypeWhere | { w TraitTypeWhereList w } */
private List<TraitTypeWhere> TraitTypeWheres =
     a1:TraitTypeWhere { yyValue = FortressUtil.mkList(a1); }
   / void:opencurly w TraitTypeWhereList w void:closecurly ;

/* TraitTypeWhereList ::= TraitTypeWhere (w , w TraitTypeWhere)* */
private List<TraitTypeWhere> TraitTypeWhereList =
     a1:TraitTypeWhere a2s:(w comma w TraitTypeWhere)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* TraitTypeWhere ::= TraitType (w Where)? */
private TraitTypeWhere TraitTypeWhere =
     a1:TraitType a2:(w Where)?
     { Option<WhereClause> where;
       if (a2 == null)
           where = Option.<WhereClause>none();
       else
           where = Option.some(a2);
       yyValue = new TraitTypeWhere(createSpan(yyStart,yyCount),
                                    a1, where);
     };

/* Extends ::= extends w TraitTypes */
List<BaseType> Extends = extends w TraitTypes ;

/* Excludes ::= excludes w TraitTypes */
List<BaseType> Excludes = excludes w TraitTypes ;

/* Comprises ::= comprises w TraitTypes */
List<BaseType> Comprises = comprises w TraitTypes ;

/* AbsComprises ::= comprises w ComprisingTypes */
List<BaseType> AbsComprises = comprises w ComprisingTypes ;

/* TraitTypes ::= TraitType | { w TraitTypeList w } */
List<BaseType> TraitTypes =
     a1:TraitType { yyValue = FortressUtil.mkList(a1); }
   / void:opencurly w TraitTypeList w void:closecurly ;

/* TraitTypeList ::= TraitType (w , w TraitType)* */
private List<BaseType> TraitTypeList = a1:TraitType a2s:(w comma w TraitType)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* ComprisingTypes ::= TraitType | { w ComprisingTypeList w } */
private List<BaseType> ComprisingTypes =
     a1:TraitType { yyValue = FortressUtil.mkList(a1); }
   / void:opencurly w ComprisingTypeList w void:closecurly ;

/* ComprisingTypeList ::=
     ...
   | TraitType (w , w TraitType)* (w , w ...)?
 */
private List<BaseType> ComprisingTypeList =
     ellipses
     { yyValue = FortressUtil.emptyTraitTypes(); }
   / a1:TraitType a2s:(w comma w TraitType)* (w comma w ellipses)?
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* Where ::=
     where w [\ w WhereBindingList w \] (w { w WhereConstraintList w })?
   | where w { w WhereConstraintList w }
 */
transient WhereClause Where =
     where w opendoublesquare w a1:WhereBindingList w closedoublesquare
     a2:(w void:opencurly w WhereConstraintList w void:closecurly)?
     { if (a2 == null)
         yyValue = new WhereClause(createSpan(yyStart,yyCount),
                                   a1, Collections.<WhereConstraint>emptyList());
       else
         yyValue = new WhereClause(createSpan(yyStart,yyCount),
                                   a1, a2);
     }
   / where w opencurly w a1:WhereConstraintList w closecurly
     { yyValue = new WhereClause(createSpan(yyStart,yyCount),
                                 Collections.<WhereBinding>emptyList(), a1);
     };

/* WhereBindingList ::= WhereBinding (w , w WhereBinding)* */
transient List<WhereBinding> WhereBindingList =
     a1:WhereBinding a2s:(w comma w WhereBinding)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* WhereBinding ::=
     nat w Id
   | int w Id
   | bool w Id
   | unit w Id
   | Id (w Extends)?
 */
transient WhereBinding WhereBinding =
     nat w a1:Id
     { yyValue = new WhereNat(createSpan(yyStart,yyCount), a1); }
   / <ErrorProduction1> nat w a1:OpName
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             a1 + " is not a valid nat parameter name.\n" +
                             "A non-reserved word that is made up of a mixture" +
                             " of uppercase letters and underscores (but no " +
                             "digits), does not begin or end with an " +
                             "underscore, and contains at least two distinct " +
                             "letters is an operator name.");
     }
   / int w a1:Id
     { yyValue = new WhereInt(createSpan(yyStart,yyCount), a1); }
   / <ErrorProduction2> int w a1:OpName
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             a1 + " is not a valid int parameter name.\n" +
                             "A non-reserved word that is made up of a mixture" +
                             " of uppercase letters and underscores (but no " +
                             "digits), does not begin or end with an " +
                             "underscore, and contains at least two distinct " +
                             "letters is an operator name.");
     }
   / bool w a1:Id
     { yyValue = new WhereBool(createSpan(yyStart,yyCount), a1); }
   / <ErrorProduction3> bool w a1:OpName
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             a1 + " is not a valid bool parameter name.\n" +
                             "A non-reserved word that is made up of a mixture" +
                             " of uppercase letters and underscores (but no " +
                             "digits), does not begin or end with an " +
                             "underscore, and contains at least two distinct " +
                             "letters is an operator name.");
     }
   / unit w a1:Id
     { yyValue = new WhereUnit(createSpan(yyStart,yyCount), a1); }
   / <ErrorProduction4> unit w a1:OpName
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             a1 + " is not a valid unit parameter name.\n" +
                             "A non-reserved word that is made up of a mixture" +
                             " of uppercase letters and underscores (but no " +
                             "digits), does not begin or end with an " +
                             "underscore, and contains at least two distinct " +
                             "letters is an operator name.");
     }
   / <ErrorProduction5> a1:OpName w a2:Extends
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             a1 + " is not a valid type parameter name.\n" +
                             "A non-reserved word that is made up of a mixture" +
                             " of uppercase letters and underscores (but no " +
                             "digits), does not begin or end with an " +
                             "underscore, and contains at least two distinct " +
                             "letters is an operator name.");
     }
   / a1:Id a2:(w a2:Extends)?
     { if (a2 == null) a2 = FortressUtil.emptyTraitTypes();
       yyValue = new WhereType(createSpan(yyStart,yyCount), a1, a2);
     }
   / <ErrorProduction6> opendoublesquare
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "White square bracket is not a valid where-clause binding.");
     };

/* FnHeaderClause ::= (w NoNewlineIsType)? FnClauses */
FnHeaderClause FnHeaderClause = a1:(w NoNewlineIsType)? a2:FnClauses
     { Option<Type> returnType = Option.wrap(a1);
       yyValue = new FnHeaderClause(a2.getThrowsClause(), a2.getWhereClause(),
                                    a2.getContractClause(), returnType);
     };

/* FnClauses ::= (w Throws)? (w Where)? Contract */
FnHeaderClause FnClauses =
     <ErrorProduction1>
     w Throws w ExtendsWhere (w Where)? Contract
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before throws/where/contract clauses.");
     }
   / <ErrorProduction2>
     w Throws w Where w ExtendsWhere Contract
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before throws/where/contract clauses.");
     }
   / <ErrorProduction3>
     w Where w ExtendsWhere Contract
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Extends clauses should come before throws/where/contract clauses.");
     }
   / <ErrorProduction4>
     w Where w Throws Contract
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Throws clauses should come before where clauses.");
     }
   / a1:(w Throws)? a2:(w Where)? a3:Contract
     { Option<List<BaseType>> throwsClause = Option.wrap(a1);
       Option<WhereClause> where;
       if (a2 == null)
           where = Option.<WhereClause>none();
       else
           where = Option.some(a2);
       Option<Contract> contractClause = Option.wrap(a3);
       yyValue = new FnHeaderClause(throwsClause, where, contractClause,
                                    Option.<Type>none());
     };

/* Throws ::= throws w MayTraitTypes */
List<BaseType> Throws = throws w MayTraitTypes ;

/* MayTraitTypes ::= { w } | TraitTypes  */
private List<BaseType> MayTraitTypes =
     opencurly w closecurly { yyValue = FortressUtil.emptyTraitTypes(); }
   / TraitTypes ;

/* Each modifier cannot appear more than once. */
/* TraitMods ::= (TraitMod w)+ */
transient List<Modifier> TraitMods = a1s:(TraitMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* TraitMod ::= AbsTraitMod | private */
transient private Modifier TraitMod =
     AbsTraitMod
   / private { yyValue = new ModifierPrivate(createSpan(yyStart,yyCount)); };

/* Each modifier cannot appear more than once. */
/* AbsTraitMods ::= (AbsTraitMod w)+ */
transient List<Modifier> AbsTraitMods = a1s:(AbsTraitMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* AbsTraitMod ::= value | test */
transient private Modifier AbsTraitMod =
     value { yyValue = new ModifierValue(createSpan(yyStart,yyCount)); }
   / test  { yyValue = new ModifierTest(createSpan(yyStart,yyCount)); };

/* Each modifier cannot appear more than once. */
/* ObjectMods ::= TraitMods */
transient List<Modifier> ObjectMods = TraitMods ;

/* Each modifier cannot appear more than once. */
/* AbsObjectMods ::= AbsTraitMods */
transient List<Modifier> AbsObjectMods = AbsTraitMods ;

/* Each modifier cannot appear more than once. */
/* MdMods ::= (MdMod w)+ */
transient List<Modifier> MdMods = a1s:(MdMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* MdMod ::= FnMod | override */
transient private Modifier MdMod =
     FnMod
   / override { yyValue = new ModifierOverride(createSpan(yyStart,yyCount)); };

/* Each modifier cannot appear more than once. */
/* AbsMdMods ::= (AbsMdMod w)+ */
transient List<Modifier> AbsMdMods = a1s:(AbsMdMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* AbsMdMod ::= AbsMdMod | override */
transient private Modifier AbsMdMod =
     AbsFnMod
   / override { yyValue = new ModifierOverride(createSpan(yyStart,yyCount)); };

/* Each modifier cannot appear more than once. */
/* FnMods ::= (FnMod w)+ */
transient List<Modifier> FnMods = a1s:(FnMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* FnMod ::= AbsFnMod | private */
transient private Modifier FnMod =
     AbsFnMod
   / private { yyValue = new ModifierPrivate(createSpan(yyStart,yyCount)); };

/* Each modifier cannot appear more than once. */
/* AbsFnMods ::= (AbsFnMod w)+ */
transient List<Modifier> AbsFnMods = a1s:(AbsFnMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* AbsFnMod ::= LocalFnMod | test */
transient private Modifier AbsFnMod =
     LocalFnMod
   / test { yyValue = new ModifierTest(createSpan(yyStart,yyCount)); };

/* Each modifier cannot appear more than once. */
/* LocalFnMods ::= (LocalFnMod w)+ */
transient List<Modifier> LocalFnMods = a1s:(LocalFnMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* LocalFnMod ::= atomic | io */
transient private Modifier LocalFnMod =
     atomic { yyValue = new ModifierAtomic(createSpan(yyStart,yyCount)); }
   / io     { yyValue = new ModifierIO(createSpan(yyStart,yyCount)); } ;

/* Each modifier cannot appear more than once. */
/* ParamFldMods ::= (ParamFldMod w)+ */
transient List<Modifier> ParamFldMods = a1s:(ParamFldMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* ParamFldMod ::= hidden | settable | wrapped */
transient private Modifier ParamFldMod =
     hidden   { yyValue = new ModifierHidden(createSpan(yyStart,yyCount)); }
   / settable { yyValue = new ModifierSettable(createSpan(yyStart,yyCount)); }
   / wrapped  { yyValue = new ModifierWrapped(createSpan(yyStart,yyCount)); };

/* Each modifier cannot appear more than once. */
/* FldMods ::= (FldMod w)+ */
transient List<Modifier> FldMods = a1s:(FldMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* Each modifier cannot appear more than once. */
/* FldImmutableMods ::= (FldImmutableMod w)+ */
transient List<Modifier> FldImmutableMods = a1s:(FldImmutableMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* FldMod ::= var | AbsFldMod */
transient private Modifier FldMod =
     var { yyValue = new ModifierVar(createSpan(yyStart,yyCount)); }
   / AbsFldMod ;

/* FldImmutableMod ::= AbsFldMod */
transient private Modifier FldImmutableMod = AbsFldMod ;

/* Each modifier cannot appear more than once. */
/* AbsFldMods ::= (AbsFldMod w)+ */
transient List<Modifier> AbsFldMods = a1s:(AbsFldMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* AbsFldMod ::= ApiFldMod | wrapped | private */
transient private Modifier AbsFldMod =
     ApiFldMod
   / wrapped { yyValue = new ModifierWrapped(createSpan(yyStart,yyCount)); }
   / private { yyValue = new ModifierPrivate(createSpan(yyStart,yyCount)); };

/* Each modifier cannot appear more than once. */
/* ApiFldMods ::= (ApiFldMod w)+ */
transient List<Modifier> ApiFldMods = a1s:(ApiFldMod w)+
     { yyValue = FortressUtil.mkList(a1s.list());
       FortressUtil.noDuplicate(yyValue);
     };

/* ApiFldMod ::= hidden | settable | test */
transient private Modifier ApiFldMod =
     hidden   { yyValue = new ModifierHidden(createSpan(yyStart,yyCount)); }
   / settable { yyValue = new ModifierSettable(createSpan(yyStart,yyCount)); }
   / test     { yyValue = new ModifierTest(createSpan(yyStart,yyCount)); };

/* StaticParams ::= [\ w StaticParamList w \] */
List<StaticParam> StaticParams =
     opendoublesquare w StaticParamList w closedoublesquare ;

/* StaticParamList ::= StaticParam (w , w StaticParam)* */
private List<StaticParam> StaticParamList =
     a1:StaticParam a2s:(w comma w StaticParam)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* StaticParam ::=
     nat w Id
   | int w Id
   | bool w Id
   | dim w Id
   | unit w Id (w : w NoNewlineType)? (w absorbs w unit)?
   | opr w Op
   | Id (w Extends)? (w absorbs w unit)?
*/
private StaticParam StaticParam =
     nat w a1:Id
     { yyValue = new NatParam(createSpan(yyStart,yyCount), a1);}
   / <ErrorProduction1>
     nat w a1:OpName
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             a1 + " is not a valid nat parameter name.\n" +
                             "A non-reserved word that is made up of a mixture" +
                             " of uppercase letters and underscores (but no " +
                             "digits), does not begin or end with an " +
                             "underscore, and contains at least two distinct " +
                             "letters is an operator name.");
     }
   / int w a1:Id
     { yyValue = new IntParam(createSpan(yyStart,yyCount), a1); }
   / <ErrorProduction2>
     int w a1:OpName
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             a1 + " is not a valid int parameter name.\n" +
                             "A non-reserved word that is made up of a mixture" +
                             " of uppercase letters and underscores (but no " +
                             "digits), does not begin or end with an " +
                             "underscore, and contains at least two distinct " +
                             "letters is an operator name.");
     }
   / bool w a1:Id
     { yyValue = new BoolParam(createSpan(yyStart,yyCount), a1); }
   / <ErrorProduction3>
     bool w a1:OpName
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             a1 + " is not a valid bool parameter name.\n" +
                             "A non-reserved word that is made up of a mixture" +
                             " of uppercase letters and underscores (but no " +
                             "digits), does not begin or end with an " +
                             "underscore, and contains at least two distinct " +
                             "letters is an operator name.");
     }
   / dim w a1:Id
     {yyValue = new DimParam(createSpan(yyStart,yyCount), a1);}
   / <ErrorProduction4>
     dim w a1:OpName
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             a1 + " is not a valid dim parameter name.\n" +
                             "A non-reserved word that is made up of a mixture" +
                             " of uppercase letters and underscores (but no " +
                             "digits), does not begin or end with an " +
                             "underscore, and contains at least two distinct " +
                             "letters is an operator name.");
     }
   / unit w a1:Id a2:(w void:colon w NoNewlineType)? a3:(w absorbs w unit)?
     { Option<Type> derived = Option.wrap(a2);
       boolean absorbs = (a3 == null) ? false : true;
       yyValue = new UnitParam(createSpan(yyStart,yyCount), a1,
                               derived, absorbs);
     }
   / <ErrorProduction5>
     unit w a1:OpName a2:(w void:colon w NoNewlineType)? a3:(w absorbs w unit)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             a1 + " is not a valid unit parameter name.\n" +
                             "A non-reserved word that is made up of a mixture" +
                             " of uppercase letters and underscores (but no " +
                             "digits), does not begin or end with an " +
                             "underscore, and contains at least two distinct " +
                             "letters is an operator name.");
     }
   / opr w a1:Op
     { yyValue = new OpParam(createSpan(yyStart,yyCount), a1); }
   / <ErrorProduction6>
     a1:OpName w a2:Extends a3:(w absorbs w unit)?
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             a1 + " is not a valid type parameter name.\n" +
                             "A non-reserved word that is made up of a mixture" +
                             " of uppercase letters and underscores (but no " +
                             "digits), does not begin or end with an " +
                             "underscore, and contains at least two distinct " +
                             "letters is an operator name.");
     }
   / a1:Id a2:(w Extends)? a3:(w absorbs w unit)?
     { if (a2 == null) a2 = Collections.<BaseType>emptyList();
       boolean absorbs;
       if (a3 == null) absorbs = false;
       else            absorbs = true;
       yyValue = new TypeParam(createSpan(yyStart,yyCount), a1, a2, absorbs);
     }
   / <ErrorProduction7>
     opendoublesquare
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "White square bracket is not a valid static parameter.");
     };
