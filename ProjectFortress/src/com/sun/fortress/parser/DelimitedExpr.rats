/*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress expressions that are enclosed by keywords.
 */
module com.sun.fortress.parser.DelimitedExpr(TraitObject, NoNewlineHeader,
                                             MayNewlineHeader, Type, Expr,
                                             LocalDecl, Literal, Identifier,
                                             Keyword, Symbol, Spacing);
import TraitObject;
import NoNewlineHeader;
import MayNewlineHeader;
import Type;
import Expr;
import LocalDecl;
import Literal;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* DelimitedExpr ::=
     ArgExpr
   | Parenthesized
   | object (w ExtendsWhere)? (w GoInAnObject)? w end
   | Do
   | label w Id w BlockElems w end w Id
   | while w Expr w Do
   | for w GeneratorClauseList w DoFront w end
   | if w GeneratorClause w then w BlockElems (w Elifs)? (w Else)? w end
   | ( w if w GeneratorClause w then w BlockElems (w Elifs)? w Else (w end)? w )
   | case w Expr (w (Encloser / Op))? w of w CaseClauses (br CaseElse)? w end
   | case w most w (Encloser / Op) w of w CaseClauses w end
   | typecase w TypecaseBindings w of w TypecaseClauses (br CaseElse)? w end
   | try w BlockElems (w Catch)? (w forbid w TraitTypes)?
       (w finally w BlockElems)? w end
 */
Expr DelimitedExpr =
     ArgExpr
   / Parenthesized
   / object a1:(w ExtendsWhere)? a2:(w GoInAnObject)? w end
     { if (a1 == null) a1 = FortressUtil.emptyTraitTypeWheres();
       if (a2 == null) a2 = Collections.<Decl>emptyList();
       yyValue = ExprFactory.makeObjectExpr(createSpan(yyStart,yyCount), a1, a2);
     }
   / Do
   / label w a1:Id w a2:BlockElems w end w a3:Id
     { if (!a1.getText().equals(a3.getText()))
             syntaxError(a1.getSpan(),
                         "Mismatched identifiers for label expressions:\n'" +
                         a1 + "' at " + a1.getSpan() + " and\n'" +
                         a3 + "' at " + a3.getSpan());
       yyValue = new Label(createSpan(yyStart,yyCount), false, a1, a2);
     }
   / <ErrorProduction>
     label w a1:OpName w a2:BlockElems w end w a3:OpName
     { Span span = createSpan(yyStart,yyCount);
       if (a1.equals("in"))
           yyValue = syntaxError(span, "'in' is a reserved word, and cannot be used as a label.");
       else
           yyValue = syntaxError(span, a1 + " is not a valid label name.\n" +
                                 "A non-reserved word that is made up of a mixture" +
                                 " of uppercase letters and underscores (but no " +
                                 "digits),\ndoes not begin or end with an " +
                                 "underscore, and contains at least two distinct " +
                                 "letters is an operator name.");
     }
   / while w a1:GeneratorClause w a2:Do
     { yyValue = new While(createSpan(yyStart,yyCount), false, a1, a2); }
   / for w a1:GeneratorClauseList w a2:DoFront w end
     { yyValue = new For(createSpan(yyStart,yyCount), false, a1, a2); }
   / if w a1:GeneratorClause w then w a2:BlockElems a3:(w Elifs)? a4:(w Else)? w end
     { IfClause ic = new IfClause(FortressUtil.spanTwo(a1,a2), a1, a2);
       List<IfClause> clauses = FortressUtil.mkList(ic);
       if (a3 != null) clauses.addAll(a3);
       Option<Block> elseC = Option.wrap(a4);
       yyValue = ExprFactory.makeIf(createSpan(yyStart,yyCount), clauses, elseC);
     }
   / if w a1:GeneratorClause w then w a2:BlockElems a3:(w Elifs)? w a4:Else
     (w end)? &(w closeparen)
     { IfClause ic = new IfClause(FortressUtil.spanTwo(a1,a2), a1, a2);
       List<IfClause> clauses = FortressUtil.mkList(ic);
       if (a3 != null) clauses.addAll(a3);
       yyValue = ExprFactory.makeIf(createSpan(yyStart,yyCount), clauses,
                                    Option.some(a4));
     }
   / openparen w if w a1:GeneratorClause w then w a2:BlockElems a3:(w Elifs)? w a4:Else
       (w end)? w closeparen
     { IfClause ic = new IfClause(FortressUtil.spanTwo(a1,a2), a1, a2);
       List<IfClause> clauses = FortressUtil.mkList(ic);
       if (a3 != null) clauses.addAll(a3);
       yyValue = ExprFactory.makeIf(createSpan(yyStart,yyCount), clauses,
                                    Option.some(a4));
     }
   / case w a1:Expr a2:(w (Encloser / Op))? w of w a3:CaseClauses
     a4:(br CaseElse)? w end
     { Option<FunctionalRef> compare;
       if (a2 == null) compare = Option.<FunctionalRef>none();
       else            compare = Option.<FunctionalRef>some(ExprFactory.makeOpRef(NodeFactory.makeOpInfix(a2)));
       Option<Block> _else;
       if (a4 == null)
           _else = Option.none();
       else _else = Option.some(a4);
       yyValue = ExprFactory.makeCaseExpr(createSpan(yyStart,yyCount),
                                          Option.some(a1), compare, a3, _else);
     }
   / <ErrorProduction1>
     case w Expr (w (Encloser / Op))? w do w CaseClauses (br CaseElse)? w end
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "In a case expression, 'do' is used incorrectly.  Use 'of' instead.");
     }
   / case w most w a1:(Encloser / Op) w of w a2:CaseClauses w end
     { Option<FunctionalRef> compare = Option.<FunctionalRef>some(ExprFactory.makeOpRef(NodeFactory.makeOpInfix(a1)));
       yyValue = ExprFactory.makeCaseExpr(createSpan(yyStart,yyCount),
                                          Option.<Expr>none(), compare, a2,
                                          Option.<Block>none());
     }
   / <ErrorProduction2>
     case w most w (Encloser / Op) w do w CaseClauses w end
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "In an extremum expression, 'do' is used incorrectly.  Use 'of' instead.");
     }
   / typecase w a1:TypecaseBindings w of w a2:TypecaseClauses a3:(br CaseElse)?
     w end
     { Option<Block> caseElse = Option.wrap(a3);
       yyValue = ExprFactory.makeTypecase(createSpan(yyStart,yyCount), false,
                                          Option.<Type>none(), a1.getA(),
                                          a1.getB(), a2, caseElse);
     }
   / <ErrorProduction3>
     typecase w TypecaseBindings w do w TypecaseClauses (br CaseElse)? w end
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "In a typecase expression, 'do' is used incorrectly.  Use 'of' instead.");
     }
   / <ErrorProduction4>
     typecase w self w of w TypecaseClauses (br CaseElse)? w end
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "In a typecase expression, 'self' is used incorrectly.  Use a binding such as 'x = self' instead.");
     }
   / <TRY> try w a1:BlockElems a2:(w Catch)? a3:(w forbid w TraitTypes)?
     a4:(w finally w BlockElems)? w end
     { Option<Catch> catch_ = Option.wrap(a2);
       if (a3 == null) a3 = FortressUtil.emptyTraitTypes();
       Option<Block> finally_ = Option.wrap(a4);
       yyValue = ExprFactory.makeTry(createSpan(yyStart,yyCount), a1, catch_, a3,
                                     finally_);
     };

/* Do ::= (DoFront w also w)* DoFront w end */
Do Do = a1s:(DoFront w also w)* a2:DoFront w end
     { yyValue = new Do(createSpan(yyStart, yyCount), false,
                        FortressUtil.mkList(a1s.list(), a2));
     };

/* DoFront ::= (at w Expr w)? (atomic w)? do (w BlockElems)? */
private Block DoFront =
     a1:(at w Expr w)? a2:(atomic w)? do a3:(w BlockElems)?
     { Span span = createSpan(yyStart,yyCount);
       Option<Expr> at = Option.wrap(a1);
       boolean atomic = (a2 == null) ? false : true;
       List<Expr> es;
       if (a3 == null) es = Collections.<Expr>emptyList();
       else es = a3.getExprs();
       yyValue = ExprFactory.makeBlock(span, false, Option.<Type>none(),
                                       at, atomic, true, es);
     };

/* ArgExpr ::=
     ( w (Expr w , w)* (Expr w ... w , w)? KeywordExpr (w , w KeywordExpr)* w )
   | ( w (Expr w , w)* Expr w ... w )
   | TupleExpr
 */
Expr ArgExpr =
     openparen w a1s:(Expr w comma w)* a2:(Expr w void:ellipses w comma w)?
     a3:KeywordExpr a4s:(w comma w KeywordExpr)* w closeparen
     { List<Expr> es = a1s.list();
       Option<Expr> vs = ((a2 != null) ? Option.some(a2)
                                       : Option.<Expr>none());
       List<KeywordExpr> ks = new ArrayList<KeywordExpr>();
       ks.add(a3);
       for (KeywordExpr b : (List<KeywordExpr>)a4s.list()) {
           ks.add(b);
       }
       yyValue = ExprFactory.makeTupleExpr(createSpan(yyStart,yyCount),
                                           false, Option.<Type>none(),
                                           es, vs, ks, false);
     }
   / openparen w a1s:(Expr w comma w)* a2:Expr w ellipses w closeparen
     { Option<Expr> vs = Option.some(a2);
       yyValue = ExprFactory.makeTupleExpr(createSpan(yyStart,yyCount),
                                           false, Option.<Type>none(),
                                           a1s.list(), vs,
                                           Collections.<KeywordExpr>emptyList(),
                                           false);
     }
   / TupleExpr ;

/* TupleExpr ::= ( w (Expr w , w)+  Expr w ) */
Expr TupleExpr =
     openparen w a1s:(Expr w comma w)+ a2:Expr w closeparen
     { List<Expr> es = FortressUtil.mkList(a1s.list(), a2);
       yyValue = ExprFactory.makeTupleExpr(createSpan(yyStart,yyCount), es);
     };

/* KeywordExpr ::= BindId w = w Expr */
private KeywordExpr KeywordExpr = a1:BindId w equals w a2:Expr
     { yyValue = new KeywordExpr(createSpan(yyStart,yyCount), a1, a2); };

/* Parenthesized ::= ( w Expr w ) */
Expr Parenthesized =
     openparen w a1:Expr w closeparen
     { yyValue = ExprFactory.makeInParentheses(a1); };

/* Elifs ::= Elif (w Elif)* */
List<IfClause> Elifs = a1:Elif a2s:(w Elif)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* Elif ::= elif w GeneratorClause w then w BlockElems */
private IfClause Elif = elif w a1:GeneratorClause w then w a2:BlockElems
     { yyValue = new IfClause(createSpan(yyStart,yyCount), a1, a2); };

/* Else ::= else w BlockElems */
Block Else = else w yyValue:BlockElems;

/* CaseClause is defined in LocalDecl.rats */

/* CaseClauses ::= CaseClause (br CaseClause)* */
private List<CaseClause> CaseClauses = a1:CaseClause a2s:(br CaseClause)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* CaseElse ::= else w => w BlockElems */
Block CaseElse = else w match w BlockElems ;

/* TypecaseBindings ::= TypecaseVars (w = w Expr)? */
private com.sun.fortress.useful.Pair<List<Id>,Option<Expr>> TypecaseBindings =
     a1:TypecaseVars a2:(w void:equals w Expr)?
     { yyValue = new com.sun.fortress.useful.Pair(a1, Option.wrap(a2)); };

/* TypecaseVars ::=
     BindId
   | ( w BindId(w , w BindId)+ w )
 */
private List<Id> TypecaseVars =
     a1:BindId
     { yyValue = FortressUtil.mkList(a1); }
   / openparen w a1:BindId a2s:(w comma w BindId)+ w closeparen
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* TypecaseClauses ::= TypecaseClause (br TypecaseClause)* */
private List<TypecaseClause> TypecaseClauses =
     a1:TypecaseClause a2s:(br TypecaseClause)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* TypecaseClause ::= TypecaseTypes w => w BlockElems */
TypecaseClause TypecaseClause =
     a1:TypecaseTypes w match w a2:BlockElems
     { yyValue = new TypecaseClause(createSpan(yyStart,yyCount), a1, a2); };

/* TypecaseTypes ::=
     ( w TypeList w )
   | Type
 */
List<Type> TypecaseTypes =
     openparen w TypeList w closeparen
   / a1:Type { yyValue = FortressUtil.mkList(a1); };

/* Catch ::= catch w BindId w CatchClauses */
Catch Catch = catch w a1:BindId w a2:CatchClauses
     { yyValue = new Catch(createSpan(yyStart,yyCount), a1, a2); };

/* CatchClauses ::= CatchClause (br CatchClause)* */
private List<CatchClause> CatchClauses = a1:CatchClause a2s:(br CatchClause)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* CatchClause ::= TraitType w => w BlockElems */
private CatchClause CatchClause = a1:TraitType w match w a2:BlockElems
     { yyValue = new CatchClause(createSpan(yyStart,yyCount), a1, a2); };

/* MapExpr ::= { StaticArgs? (w EntryList)? w } */
Expr MapExpr =
     void:opencurly a1:StaticArgs? a2:(w EntryList)? w void:closecurly
     { if (a2 == null) a2 = FortressUtil.emptyExprs();
       Span span = createSpan(yyStart,yyCount);
       Op open  = NodeFactory.makeOpEnclosing(createSpan(yyStart,yyStart+1),
                                              "{|->");
       Op close = NodeFactory.makeOpEnclosing(createSpan(yyCount-1,1), "}");
       if (a1 == null)
            yyValue = ASTUtil.enclosing(span, open, a2, close);
       else yyValue = ASTUtil.enclosing(span, open, a1, a2, close);
     };

/* Comprehension ::=
     (BIG w)? [ StaticArgs? w ArrayComprehensionClause
              (br ArrayComprehensionClause)* w ]
   | (BIG w)? { StaticArgs? w Entry wr | wr GeneratorClauseList w }
   | (BIG w)? LeftEncloser StaticArgs? w Expr wr | wr GeneratorClauseList w
              RightEncloser
 */
Expr Comprehension =
     <ErrorProduction1>
     (BIG w)? opensquare wr StaticArgs w ArrayComprehensionClause
     (br ArrayComprehensionClause)* w closesquare
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately before left white square bracket.");
     }
   / <ErrorProduction2>
     (BIG w)? opencurly wr StaticArgs w Entry wr bar wr GeneratorClauseList w closecurly
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately before left white square bracket.");
     }
   / <ErrorProduction3>
     (BIG w)? LeftEncloser wr StaticArgs w Expr wr bar wr GeneratorClauseList w RightEncloser
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately before left white square bracket.");
     }
   / (BIG w)? opensquare a1:StaticArgs? w a2:ArrayComprehensionClause
     a3s:(br ArrayComprehensionClause)* w closesquare
     { List<ArrayComprehensionClause> clauses = FortressUtil.mkList(a2,
                                                                    a3s.list());
       if (a1 == null) a1 = Collections.<StaticArg>emptyList();
       yyValue = ExprFactory.makeArrayComprehension(createSpan(yyStart,yyCount),a1,clauses);
     }
   / (BIG w)? opencurly a1:StaticArgs? w a2:Entry wr bar wr
     a3:GeneratorClauseList w closecurly
     { Span span = createSpan(yyStart,yyCount);
       Op opr = NodeFactory.makeEnclosing(span, "BIG {|->", "BIG }");
       if (a1 == null) a1 = Collections.<StaticArg>emptyList();
       yyValue = ExprFactory.makeAccumulator(createSpan(yyStart,yyCount), a1, opr, a3, a2);
     }
   / (BIG w)? a1:LeftEncloser a2:StaticArgs? w a3:Expr wr bar wr
     a4:GeneratorClauseList w a5:RightEncloser
     { Span span = createSpan(yyStart,yyCount);
       Op opr = NodeFactory.makeEnclosing(span, "BIG " + a1.getText(),
                                          "BIG " + a5.getText());
       if (a2 == null) a2 = Collections.<StaticArg>emptyList();
       yyValue = ExprFactory.makeAccumulator(createSpan(yyStart,yyCount), a2, opr, a4, a3);
     };

/* The operator "|->" should not be in the left-hand sides of map expressions
   and map/array comprehensions.
 */
String mapstoOp =
     !("|->" w Expr (w mapsto / wr bar / w closecurly / w comma)) "|->" ;

/* The operator "<-" should not be in the left-hand sides of
   generator clause lists. */
String leftarrowOp = !("<-" w Expr (w leftarrow / w comma)) "<-";

/* Entry ::= Expr w |-> w Expr */
Expr Entry = a1:Expr w mapsto w a2:Expr
     { yyValue = ExprFactory.makeTupleExpr(a1, a2); };

/* ArrayComprehensionLeft ::=
     IdOrInt w |-> w Expr
   | ( w IdOrInt w , w IdOrIntList w ) w |-> w Expr
 */
com.sun.fortress.useful.Pair<List<Expr>,Expr> ArrayComprehensionLeft =
     a1:IdOrInt w mapsto w a2:Expr
     { List<Expr> exprs = FortressUtil.mkList(a1);
       yyValue = new com.sun.fortress.useful.Pair<List<Expr>,Expr>(exprs, a2);
     }
   / openparen w a1:IdOrInt w comma w a2:IdOrIntList w closeparen w mapsto w
     a3:Expr
     { List<Expr> exprs = FortressUtil.mkList(a1);
       for (Expr i : a2) {
           exprs.add(i);
       }
       yyValue = new com.sun.fortress.useful.Pair<List<Expr>,Expr>(exprs, a3);
     };

/* IdOrInt ::= Id | IntLiteralExpr */
Expr IdOrInt =
     a1:Id { yyValue = ExprFactory.makeVarRef(a1); }
   / IntLiteralExpr ;

/* IdOrIntList ::= IdOrInt (w , w IdOrInt)* */
List<Expr> IdOrIntList = a1:IdOrInt a2s:(w comma w IdOrInt)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* ExprList ::= Expr (w , w Expr)* */
List<Expr> ExprList = a1:Expr a2s:(w comma w Expr)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* EntryList ::= Entry (w , w Entry)* */
List<Expr> EntryList = a1:Entry a2s:(w comma w Entry)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };
