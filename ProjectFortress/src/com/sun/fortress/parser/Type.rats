/*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress types.
 */
module com.sun.fortress.parser.Type(NoNewlineHeader, MayNewlineHeader,
                                    Expression, Literal, Identifier, Keyword,
                                    Symbol, Spacing);

import NoNewlineHeader;
import MayNewlineHeader;
import Expression;
import Literal;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* Type ::= TypePrimary (w in w Expr)? */
Type Type =
     !(one) a1:TypePrimary a2:(w in w Expr)?
     { Type ty = TypeResolver.resolveOps(a1);
       if (a2 == null)
           yyValue = ty;
       else {
           if (ty instanceof TaggedDimType) {
               TaggedDimType _ty = (TaggedDimType)ty;
               yyValue = new TaggedDimType(_ty.getSpan(), _ty.getType(),
                                           _ty.getDim(), Option.some(a2));
           } else {
               yyValue = syntaxError(ty.getSpan(),
                                     "A dimension type is expected.");
           }
       }
     };

/* OpType ::=
     TypePrimary
   | TypePrefix
 */
PureList<PostfixOpExpr> OpType =
     TypePrimary
   / TypePrefix ;

/* TypePrimary ::=
     TypePrimaryFront TightInfixPostfix
   | TypePrimaryFront wr TypePrimary
   | TypePrimaryFront wr LooseInfix
   | TypePrimaryFront
 */
PureList<PostfixOpExpr> TypePrimary =
     a1:TypePrimaryFront a2:TightInfixPostfix
     { yyValue = a2.cons(new RealType(a1)); }
   / <LooseJuxt> a1:TypePrimaryFront wr a2:TypePrimary
     { yyValue = a2.cons(new RealType(a1)); }
   / <LooseInfix> a1:TypePrimaryFront wr a2:LooseInfix
     { yyValue = a2.cons(new RealType(a1)); }
   / a1:TypePrimaryFront
     { yyValue = PureList.make((PostfixOpExpr)new RealType(a1)); };

/* TypePrefix ::=
     DimPrefixOp TypePrimary
   | DimPrefixOp TypePrefix
   | DimPrefixOp wr TypePrimary
   | DimPrefixOp wr TypePrefix
 */
PureList<PostfixOpExpr> TypePrefix =
     a1:DimPrefixOp a2:TypePrimary
     { yyValue = a2.cons((PostfixOpExpr)new TightPrefix(a1)); }
   / a1:DimPrefixOp a2:TypePrefix
     { yyValue = a2.cons((PostfixOpExpr)new TightPrefix(a1)); }
   / <Prefix> a1:DimPrefixOp wr a2:TypePrimary
     { yyValue = a2.cons((PostfixOpExpr)new LoosePrefix(a1)); }
   / <PrePrefix> a1:DimPrefixOp wr a2:TypePrefix
     { yyValue = a2.cons((PostfixOpExpr)new LoosePrefix(a1)); };

/* TightInfixPostfix ::=
     TypeInfixOp TypePrimary (w Throws)?
   | TypeInfixOp TypePrefix (w Throws)?
   | DimInfixOp TypePrimary
   | DimInfixOp TypePrefix
   | DimPostfixOp wr TypePrimary
   | DimPostfixOp wr TypePrefix
   | DimPostfixOp
 */
PureList<PostfixOpExpr> TightInfixPostfix =
     <Arrow> a1:TypeInfixOp a2:TypePrimary a3:(w Throws)?
     { yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1, NodeFactory.makeEffect(Option.wrap(a3)))); }
   / <ArrowPrefix> a1:TypeInfixOp a2:TypePrefix a3:(w Throws)?
     { yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1, NodeFactory.makeEffect(Option.wrap(a3)))); }
   / a1:DimInfixOp a2:TypePrimary
     { yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1)); }
   / a1:DimInfixOp a2:TypePrefix
     { yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1)); }
   / <Postfix> a1:DimPostfixOp wr a2:TypePrimary
     { yyValue = a2.cons((PostfixOpExpr)new Postfix(a1)); }
   / <PostPrefix> a1:DimPostfixOp wr a2:TypePrefix
     { yyValue = a2.cons((PostfixOpExpr)new Postfix(a1)); }
   / a1:DimPostfixOp
     { yyValue = PureList.make((PostfixOpExpr)new Postfix(a1)); };

/* LooseInfix ::=
     TypeInfixOp wr TypePrimary (w Throws)?
   | TypeInfixOp wr TypePrefix (w Throws)?
   | DimInfixOp wr TypePrimary
   | DimInfixOp wr TypePrefix
 */
PureList<PostfixOpExpr> LooseInfix =
     <Arrow> a1:TypeInfixOp wr a2:TypePrimary a3:(w Throws)?
     { yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1, NodeFactory.makeEffect(Option.wrap(a3)))); }
   / <ArrowPrefix> a1:TypeInfixOp wr a2:TypePrefix a3:(w Throws)?
     { yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1, NodeFactory.makeEffect(Option.wrap(a3)))); }
   / <Infix> a1:DimInfixOp wr a2:TypePrimary
     { yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1)); }
   / <InPrefix> a1:DimInfixOp wr a2:TypePrefix
     { yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1)); };

/* TypePrimaryFront ::= TypeFront TypeTail* */
TypeOrDomain TypePrimaryFront =
    seed:TypeFront list:TypeTail+
    { yyValue = (Type)apply(list, (Type)seed); }
  / yyValue:TypeFront ;

/* TypeFront ::=
     ParenthesizedType
   | Domain
   | TupleType
   | TypeRef
   | VoidType
   | 1
 */
private TypeOrDomain TypeFront =
     ParenthesizedType
   / Domain
   / TupleType
   / TypeRef
   / VoidType
   / one { yyValue = new BaseDim(createSpan(yyStart,1)); };

/* ParenthesizedType ::= ( w Type w ) */
private Type ParenthesizedType =
     openparen w a1:Type w closeparen
     { yyValue = NodeFactory.makeInParentheses(a1); };

/* Domain ::=
     ( w (Type w , w)* (Type w ... w , w)? KeywordType (w , w KeywordType)* w )
   | ( w (Type w , w)* Type w ... w )
 */
Domain Domain =
     openparen w a1s:(Type w comma w)* a2:(Type w void:ellipses w comma w)?
     a3:KeywordType a4s:(w comma w KeywordType)* w closeparen
     { List<Type>   ts1 = a1s.list();
       Span span = createSpan(yyStart,yyCount);
       Option<Type> ts2 = Option.wrap(a2);
       List<KeywordType> ts3 = a4s.list();
       ts3.add(0, a3);
       yyValue = new Domain(span, ts1, ts2, ts3);
     }
   / openparen w a1s:(Type w comma w)* a2:Type w ellipses w closeparen
     { List<Type> ts1 = FortressUtil.mkList(a1s.list());
       Span span = createSpan(yyStart,yyCount);
       Option<Type> ts2 = Option.some(a2);
       yyValue = new Domain(span, ts1, ts2);
     };

/* KeywordType ::= BindId w = w Type */
private KeywordType KeywordType = a1:BindId w equals w a2:Type
     { yyValue = new KeywordType(createSpan(yyStart,yyCount), a1, a2); };

/* TupleType ::= ( w Type w , w TypeList w ) */
TupleType TupleType =
     openparen w a1:Type w comma w a2:TypeList w closeparen
     { List<Type> ts = FortressUtil.mkList(a1, a2);
       yyValue = NodeFactory.makeTupleType(createSpan(yyStart,yyCount), ts);
     };

/* TypeList ::= Type (w , w Type)* */
List<Type> TypeList = a1:Type a2s:(w comma w Type)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* TypeRef ::= DottedIdChain StaticArgs? */
/* TypeRef ::= Id StaticArgs? */
private Type TypeRef =
     <ErrorProduction>
     Id wr StaticArgs
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately before left white square bracket.");
     }
   / "Unity"
     { Span span = createSpan(yyStart,yyCount);
       yyValue = new BaseDim(span);
     }
   / a1:Id a2:StaticArgs?
     { if (a2 == null)
            yyValue = new VarType(createSpan(yyStart,yyCount), a1);
       else yyValue = new TraitType(createSpan(yyStart,yyCount),a1,a2);
     };

/* VoidType ::= ( w ) */
private Type VoidType =
     openparen w closeparen
     { yyValue = new VoidType(createSpan(yyStart,yyCount)); };

/* TypeTail ::=
     ArrayTypeSize
   | Exponentiation
   | ParenthesizedType
   | Id                // DottedIdChain
 */
constant transient Action<Type> TypeTail =
     ArrayTypeSize
   / Exponentiation
   / ParenthesizedTypeLeft
   / IdLeft
   ;

/* ArrayTypeSize ::= [ (w ArraySize)? w ] */
constant inline Action<Type> ArrayTypeSize =
     opensquare a1:(w ArraySize)? w closesquare
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               if (NodeUtil.isExponentiation((Type)base))
                   return syntaxError(((Type)base).getSpan(),
                                      "It is a static error if an " +
                                      "exponentiation or a vector type or an " +
                                      "array type is immediately followed by " +
                                      "a left square bracket.");
               return NodeFactory.makeArrayType(createSpan(yyStart,yyCount),
                                                (Type)base, Option.wrap(a1));
           }};
     };

/* ArraySize ::= ExtentRange (w , w ExtentRange)* */
private Indices ArraySize = a1:ExtentRange a2s:(w comma w ExtentRange)*
     { List<ExtentRange> es = FortressUtil.mkList(a1, a2s.list());
       yyValue = new Indices(createSpan(yyStart,yyCount), es);
     };

/* ExtentRange ::=
     (StaticArg w)? # (w StaticArg)?
   | (StaticArg w)? : (w StaticArg)?
   | StaticArg
 */
ExtentRange ExtentRange =
     a1:(StaticArg w)? pound a2:(w StaticArg)?
     { Option<StaticArg> base = Option.wrap(a1);
       Option<StaticArg> size = Option.wrap(a2);
       yyValue = new ExtentRange(createSpan(yyStart,yyCount), base, size);
     }
   / a1:(StaticArg w)? colon a2:(w StaticArg)?
     { Option<StaticArg> base = Option.wrap(a1);
       Option<StaticArg> size = Option.wrap(a2);
       yyValue = new ExtentRange(createSpan(yyStart,yyCount), base, size);
     }
   / a1:StaticArg
     { yyValue = new ExtentRange(createSpan(yyStart,yyCount),
                                 Option.<StaticArg>none(),
                                 Option.some(a1));
     };

/* Exponentiation ::=
     ^ IntExpr
   | ^ ( w ExtentRange (w x w ExtentRange)* w )
 */
constant inline Action<Type> Exponentiation =
     <ErrorProduction1>
     caret wr IntExpr
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately after '^'.");
     }
   / caret a1:IntExpr
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               if (NodeUtil.isExponentiation((Type)base) ||
                   NodeUtil.isExponentiation(a1))
                   return syntaxError(((Type)base).getSpan(),
                                      "It is a static error if an " +
                                      "exponentiation is immediately followed " +
                                      "by an exponentiation.");
               if (base instanceof DimExpr) {
                   return new ExponentDim(createSpan(yyStart,yyCount),
                                          (DimExpr)base, a1);
               } else { // !(base instanceof DimExpr)
                   return new ExponentType(createSpan(yyStart,yyCount),
                                           (Type)base, a1);
               }
           }};
     }
   / <ErrorProduction2>
     caret wr openparen w ExtentRange (w cross w ExtentRange)* w closeparen
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately after '^'.");
     }
   / caret openparen w a1:ExtentRange a2s:(w cross w ExtentRange)* w closeparen
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               if (NodeUtil.isExponentiation((Type)base))
                   return syntaxError(((Type)base).getSpan(),
                                      "It is a static error if an " +
                                      "exponentiation is immediately followed " +
                                      "by an exponentiation.");
               return NodeFactory.makeMatrixType(createSpan(yyStart,yyCount),
                                                 (Type)base,a1,a2s.list());
           }};
     };

/* ParenthesizedType ::= ( w OpType w ) */
constant inline Action<Type> ParenthesizedTypeLeft =
     openparen w a1:OpType w closeparen
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               DimExpr dim = TypeResolver.resolveOpsDim(a1);
               return new TaggedDimType(createSpan(yyStart,yyCount), (Type)base,
                                        NodeFactory.makeInParentheses(dim),
                                        Option.<Expr>none());
           }};
     };

constant inline Action<Type> IdLeft =
     a1:Id
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               return new TaggedDimType(createSpan(yyStart,yyCount), (Type)base,
                                        new DimRef(a1.getSpan(), a1),
                                        Option.<Expr>none());
           }};
     };

/* TypeInfixOp ::= -> */
Op TypeInfixOp =
     a1:rightarrow
     { yyValue = NodeFactory.makeOpInfix(createSpan(yyStart,yyCount), a1); };

/* DimInfixOp ::= DOT | / | per */
Op DimInfixOp =
     a1:(DOT / slash / per)
     { yyValue = NodeFactory.makeOpInfix(createSpan(yyStart,yyCount), a1); };

/* DimPrefixOp ::= square | cubic | inverse */
Op DimPrefixOp =
     a1:(square / cubic / inverse)
     { yyValue = NodeFactory.makeOpPrefix(createSpan(yyStart,yyCount), a1); };

/* DimPostfixOp ::= squared | cubed */
Op DimPostfixOp =
     a1:(squared / cubed)
     { yyValue = NodeFactory.makeOpPostfix(createSpan(yyStart,yyCount), a1); };

/* TraitType ::=
     TraitTypeFront TraitTypeTail+
   | TypeRef
 */
BaseType TraitType =
     seed:TraitTypeFront list:TraitTypeTail+
     { yyValue = (BaseType)apply(list, seed); }
   / TypeRef ;

/* TraitTypeFront ::=
     ParenthesizedType
   | TupleType
   | TypeRef
   | VoidType
 */
private Type TraitTypeFront =
     ParenthesizedType
   / TupleType
   / TypeRef
   / VoidType
   ;

/* TraitTypeTail ::=
     ArrayTypeSize
   | Exponentiation
 */
constant transient Action<Type> TraitTypeTail =
     ArrayTypeSizeTrait
   / ExponentiationTrait
   ;

/* ArrayTypeSize ::= [ (w ArraySize)? w ] */
constant inline Action<Type> ArrayTypeSizeTrait =
     opensquare a1:(w ArraySize)? w closesquare
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               if (NodeUtil.isExponentiation((Type)base))
                   return syntaxError(((Type)base).getSpan(),
                                      "It is a static error if an " +
                                      "exponentiation or a vector type or an " +
                                      "array type is immediately followed by " +
                                      "a left square bracket.");
               return NodeFactory.makeArrayType(createSpan(yyStart,yyCount),
                                                (Type)base, Option.wrap(a1));
           }};
     };

/* Exponentiation ::=
     ^ IntExpr
   | ^ ( w ExtentRange (w x w ExtentRange)* w )
 */
constant inline Action<Type> ExponentiationTrait =
     <ErrorProduction1>
     caret wr IntExpr
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately after '^'.");
     }
   / caret a1:IntExpr
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               if (NodeUtil.isExponentiation((Type)base) ||
                   NodeUtil.isExponentiation(a1))
                   return syntaxError(((Type)base).getSpan(),
                                      "It is a static error if an " +
                                      "exponentiation is immediately followed " +
                                      "by an exponentiation.");
               return TypeResolver.makeMatrixType(createSpan(yyStart,yyCount),
                                                  (Type)base, a1);
           }};
     }
   / <ErrorProduction2>
     caret wr openparen w ExtentRange (w cross w ExtentRange)* w closeparen
     { yyValue = syntaxError(createSpan(yyStart,yyCount),
                             "Space is not allowed immediately after '^'.");
     }
   / caret openparen w a1:ExtentRange a2s:(w cross w ExtentRange)* w closeparen
     { yyValue = new Action<Type>() {
           public Type run(Type base) {
               if (NodeUtil.isExponentiation((Type)base))
                   return syntaxError(((Type)base).getSpan(),
                                      "It is a static error if an " +
                                      "exponentiation is immediately followed " +
                                      "by an exponentiation.");
               return NodeFactory.makeMatrixType(createSpan(yyStart,yyCount),
                                                 (Type)base,a1,a2s.list());
           }};
     };
