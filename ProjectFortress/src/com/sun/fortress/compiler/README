* Static Checker
 - StaticChecker is the main entry point.
 - It calls Parser, Disambiguator, IndexBuilder, and maybe some others to
   process ASTs (all in the compiler package).
 - Disambiguator calls some things in the compiler.disambiguator package.
 - compiler.index contains the intermediate data representations -- syntax
   wrapped in indices, which map things like names to functions.
 - compiler.IndexBuilder creates these indices.
 - The disambiguator pass resolves names and converts them to qualified names.
 - The typechecker pass performs analysis that requires a complete type
   environment (TraitIndexes, etc.)
 - typechecker.TypeChecker is a visitor; it creates a TypeAnalyzer object for
   each type variable scope it enters, and uses that object to make subtyping
   checks.
 - The TypeAnalyzer.subtype method produces a ConstraintFormula, which
   describes the constraints on inference variables. There are trivial formulas
   representing true and false.
 - The type checker combines all these formulas that it encounters in a certain
   scope, and then solves them to produce a substitution from inference variables
   to types, which it then performs on the syntax in that scope.
 - The formulas catch errors early -- if a certain formula is not satisfiable,
   then it will be false, and that can be checked.

* To Do
 - Immediate concerns:
  = Eliminate a nonterminating recursion in ConstraintFormula.and().
  = Generalize the equality check in the SubtypeHistory to handle types that are
    equal modulo inference variable renaming.
 - Missing features:
  = Implement TraitIndex's type parameter/hidden variable/where constraint
    accessors; fix the corresponding subtyping implementation.
  = Implement relationships defined by in-scope where constraints.
  = Implement disjunctive constraint formulas.
  = Add mu-types; determine how to handle them in subtyping, etc.
  = Implement constraint formula solving (eliminating inference variables from
    the variables' bounds).
  = Implement exclusion and negative subtyping.  Does this require that we
    support negative assertions in constraint formulas?
  = Implement equivalence and inequivalence of non-type static arguments.
  = Implement subset checking -- extending subtyping with comprises clauses,
    used to check domain coverage in overloadings, type cases, etc.
  = Implement coercion checking.
  = Implement method lookup.
  = Extend inference?  (Is it good enough at this point to behave as it has been
    specified?)
 - Optimizations:
  = Implement memoization; figure out how to generalize results for different
    sizes/contents of the SubtypeHistory parameter.
  = Find obvious opportunities for simplification, and (informally) prove that
    they're valid.  (If s and t are both trait types, for example, there's no
    point in pursuing an intersection supertype involving s.)
  = Replace binary intersections and unions with sets (eliminating the need for
    associative and commutative rules).
  = Determine if it will be necessary for the memoization cache to "forget"
    results, in order to limit memory usage; determine if it would be useful to
    separate cached results that are globally true from those that are only true
    in a certain type variable's scope.
  = Use a better metric than recursion depth to decide when a certain path
    should be abandoned (number of introduced inference variables, perhaps?).
