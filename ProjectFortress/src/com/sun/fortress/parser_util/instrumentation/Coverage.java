/*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

package com.sun.fortress.parser_util.instrumentation;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;

import java.io.File;
import java.io.FileFilter;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.StringWriter;
import java.io.FileNotFoundException;
import java.io.IOException;

import com.sun.fortress.useful.Useful;
import com.sun.fortress.exceptions.ProgramError;

import com.sun.fortress.parser.FortressInstrumented;

/*
 * Parser coverage command-line tool
 *
 * usage: java com.sun.parser_util.instrumentation.Coverage 
 *   (no arguments)
 * 
 * The coverage tool runs the instrumented parser (c.s.f.parser.FortressInstrumented,
 * generated by InstrumentedParserGenerator) on the test files in TEST_DIRS ("tests" 
 * and "static_tests"), excluding the ones expected to raise a parse error ("XXX*.fs[is]"). 
 * These files constitute the sample corpus. It reports coverage of the Fortress grammar 
 * based on all of the test files together.
 * 
 * The report currently consists of two parts: a summary and a detailed analysis of 
 * alternates.
 * 
 * Example summary line:
 *   74% alternate coverage in com.sun.fortress.parser.Type (attempted  97%)
 *
 * Of all of the alternates belonging to all of the nonterminals in module Type, 
 * the parser started to try 97% of the alternates, but only 74% of them had
 * committed parses. The other 23% contains alternates that failed to parse and
 * also alternates that successfully parsed but were reverted because they were on 
 * a branch that failed later.
 *
 * Example detailed section:
 *   Module com.sun.fortress.parser.Symbol
 *     EncloserPair case 1/1 (no name) was never tried
 *     ExponentOp case 1/1 (no name) never succeeded
 *     bar case 1/1 (no name) had successful parses reverted
 *     closingComprehension case 1/4 (no name) had successful parses reverted
 *     closingComprehension case 2/4 (no name) had successful parses reverted
 *     closingComprehension case 3/4 (no name) was never tried
 *     closingComprehension case 4/4 (no name) was never tried
 *     ...
 *
 * The EncloserPair nonterminal's single alternate was never tried.
 * The ExponentOp nonterminals' single alternate was tried, but always failed.
 * The bar nonterminal's single alternate was tried and successfully parsed, but
 * only on a failed branch; it had no surviving successful parses.
 * The closingComprehension nonterminal has four cases, and the coverage tool 
 * reports them separately.
 */

public class Coverage {

    private static final String[] TEST_DIRS = 
        new String[] {"tests", "static_tests"};

    public static void main(String[] args) {
        if (args.length > 0) {
            System.err.println("Warning: Ignoring command-line arguments!");
        }
        parseFiles();
        reportCoverage();
    }

    private static void parseFiles() {
        for (String dir : TEST_DIRS) {
            File f = new File(dir);
            File[] srcfiles = f.listFiles(new FileFilter() {
                    public boolean accept(File sf) {
                        return (sf.getName().endsWith(".fsi") || sf.getName().endsWith(".fss"))
                            && !sf.getName().startsWith("XXX") ;
                    }
                });
            System.out.println("Loading " + srcfiles.length + " test files from " + dir);
            for (File srcfile : srcfiles) {
                parseFile(srcfile);
            }
        }
    }

    private static void parseFile(File file) {
        String filename = file.getAbsolutePath();
        try {
            Reader in = Useful.utf8BufferedFileReader(filename);
            FortressInstrumented p = new FortressInstrumented(in, filename);
            p.pFile(0);
        } catch (ProgramError pe) {
            // FIXME: Make sure this parser error is expected.
            System.out.println("Parse error in file: " + filename);
            throw pe;
        } catch (FileNotFoundException fnfe) {
            throw new RuntimeException(fnfe);
        } catch (IOException ioe) {
            throw new RuntimeException(ioe);
        }
    }

    private static void reportCoverage() {
        Collection<Info.ModuleInfo> rawModuleInfos = FortressInstrumented.moduleInfos();
        List<Info.ModuleInfo> moduleInfos;
        moduleInfos = new LinkedList<Info.ModuleInfo>(rawModuleInfos);
        Collections.sort(moduleInfos,
                         new Comparator<Info.ModuleInfo>() {
                             public int compare(Info.ModuleInfo a, Info.ModuleInfo b) {
                                 return a.module.compareTo(b.module);
                             }
                         });
        System.out.println("** Coverage summary: Alternate coverage by module");
        for (Info.ModuleInfo moduleInfo : moduleInfos) {
            printStats(moduleInfo);
        }
        System.out.println();
        System.out.println("** Coverage details");
        for (Info.ModuleInfo moduleInfo : moduleInfos) {
            printUnused(moduleInfo);
        }
    }

    private static void printStats(Info.ModuleInfo m) {
        int all = 0;
        int started = 0;
        int ended = 0;
        int committed = 0;
        for (Info.ProductionInfo p : m.productions) {
            for (Info.SequenceInfo s : p.sequences) {
                all++;
                if (s.startedCount > 0) started++;
                if (s.endedCount > 0) ended++;
                if (s.committedCount > 0) committed++;
            }
        }

        double start_coverage = ((double) started) / ((double) all) * 100.0;
        double comit_coverage = ((double) committed) / ((double) all) * 100.0;

        System.out.println(String.format("%3d%% alternate coverage in %s (attempted %3d%%)",
                                         (int)comit_coverage, m.module, (int)start_coverage));
    }

    private static void printDetails(Info.ModuleInfo m) {
        int m_all = 0;
        int m_started = 0;
        int m_ended = 0;
        int m_committed = 0;
        StringWriter string_out = new StringWriter();
        PrintWriter out = new PrintWriter(string_out);
        for (Info.ProductionInfo p : m.productions) {
            int p_all = 0;
            int p_started = 0;
            int p_ended = 0;
            int p_committed = 0;
            for (Info.SequenceInfo s : p.sequences) {
                p_all++;
                if (s.startedCount > 0) p_started++;
                if (s.endedCount > 0) p_ended++;
                if (s.committedCount > 0) p_committed++;
            }
            out.println("  Production " + p.production);
            //out.println(coverage(2, "started", p_started, p_all));
            //out.println(coverage(2, "ended", p_ended, p_all));
            out.println(coverage(2, "committed", p_committed, p_all));

            m_all++;
            if (p_started > 0) m_started++;
            if (p_ended > 0) m_ended++;
            if (p_committed > 0) m_committed++;
        }
        System.out.println("Module " + m.module);
        //System.out.println(coverage(0,"started", m_started, m_all));
        //System.out.println(coverage(0,"ended", m_ended, m_all));
        System.out.println(coverage(0,"committed", m_committed, m_all));
        System.out.println(string_out.toString());
    }

    private static void printUnused(Info.ModuleInfo m) {
        System.out.println("Module " + m.module);
        for (Info.ProductionInfo p : m.productions) {
            int sequenceCount = p.sequences.size();
            for (Info.SequenceInfo s : p.sequences) {
                if (s.committedCount == 0) {
                    System.out.print(String.format("    %s case %d/%d (%s)",
                                                   p.production,
                                                   s.sequenceIndex,
                                                   sequenceCount,
                                                   s.sequence == null ? "no name" : s.sequence));
                    if (s.startedCount == 0) {
                        System.out.println(" was never tried");
                    } else if (s.endedCount > 0) {
                        System.out.println(" had successful parses reverted");
                    } else {
                        System.out.println(" never succeeded");
                    }
                }
            }
        }
    }
    private static String coverage(int indent, String label, int covered, int total) {
        double percentage = (100.0 * covered) / (double)total;
        char[] indentation = new char[indent];
        Arrays.fill(indentation, ' ');
        return String.format("%s-- %s %3d%% (%d/%d)", 
                             new String(indentation),
                             label, (int)percentage, covered, total);
    }
}
