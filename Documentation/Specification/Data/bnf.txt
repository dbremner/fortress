$$$$$ Components and API

File ::=
     | CompilationUnit
     | Imports? Exports Decls?
     | Imports? AbsDecls
     | Imports AbsDecls?

CompilationUnit ::=
     | Component
     | Api

Component ::=
     | component DottedId Imports? Exports Decls? end

Api ::=
     | api DottedId Imports? AbsDecls? end

Imports ::=
     | Import+

Import ::=
     | import ImportFrom
     | import AliasedDottedIds

ImportFrom ::=
     | * ( except Names)? from DottedId
     | AliasedNames from DottedId

Names ::=
     | Name
     | {NameList } 

NameList ::=
     | Name( , Name)*

AliasedNames ::=
     | AliasedName
     | {AliasedNameList } 

AliasedName ::=
     | Id ( as DottedId)?
     | opr Op ( as Op)?
     | opr LeftEncloser RightEncloser ( as LeftEncloser RightEncloser)?

AliasedNameList ::=
     | AliasedName( , AliasedName)*

AliasedDottedIds ::=
     | AliasedDottedId
     | {AliasedDottedIdList } 

AliasedDottedId ::=
     | DottedId ( as DottedId)?

AliasedDottedIdList ::=
     | AliasedDottedId( , AliasedDottedId)*

Exports ::=
     | Export+

Export ::=
     | export DottedIds

DottedIds ::=
     | DottedId
     | {DottedIdList } 

DottedIdList ::=
     | DottedId( , DottedId)*

$$$$$ Top-level Declarations

Decls ::=
     | Decl+

Decl ::=
     | TraitDecl
     | ObjectDecl
     | VarDecl
     | FnDecl
     | DimUnitDecl
     | TypeAlias
     | TestDecl
     | PropertyDecl
     | ExternalSyntax

AbsDecls ::=
     | AbsDecl+

AbsDecl ::=
     | AbsTraitDecl
     | AbsObjectDecl
     | AbsVarDecl
     | AbsFnDecl
     | DimUnitDecl
     | TypeAlias
     | TestDecl
     | PropertyDecl
     | AbsExternalSyntax

$$$$$ Trait and Object Declarations

TraitDecl ::=
     | TraitHeader GoInATrait? end

TraitHeader ::=
     | TraitMods? trait Id StaticParams? Extends? TraitClauses?

TraitClauses ::=
     | TraitClause+

TraitClause ::=
     | Excludes
     | Comprises
     | Where

GoInATrait ::=
     | GoFrontInATrait GoBackInATrait?
     | GoBackInATrait

GoFrontInATrait ::=
     | GoesFrontInATrait+

GoesFrontInATrait ::=
     | AbsFldDecl
     | GetterSetterDecl
     | PropertyDecl

GoBackInATrait ::=
     | GoesBackInATrait+

GoesBackInATrait ::=
     | MdDecl
     | PropertyDecl

ObjectDecl ::=
     | ObjectHeader GoInAnObject? end

ObjectHeader ::=
     | ObjectMods? object Id StaticParams? ObjectValParam? Extends? FnClauses

ObjectValParam ::=
     | ( ObjectParams? )

ObjectParams ::=
     | (ObjectParam , )* (ObjectVarargs , )? ObjectKeyword( , ObjectKeyword)*
     | (ObjectParam , )* ObjectVarargs
     | ObjectParam ( , ObjectParam)*

ObjectVarargs ::=
     | transient Varargs

ObjectKeyword ::=
     | ObjectParam=Expr

ObjectParam ::=
     | FldMods? Param
     | transient Param

GoInAnObject ::=
     | GoFrontInAnObject GoBackInAnObject?
     | GoBackInAnObject

GoFrontInAnObject ::=
     | GoesFrontInAnObject+

GoesFrontInAnObject ::=
     | FldDecl
     | GetterSetterDef
     | PropertyDecl

GoBackInAnObject ::=
     | GoesBackInAnObject+

GoesBackInAnObject ::=
     | MdDef
     | PropertyDecl

AbsTraitDecl ::=
     | TraitHeader AbsGoInATrait? end

AbsGoInATrait ::=
     | AbsGoFrontInATrait AbsGoBackInATrait?
     | AbsGoBackInATrait

AbsGoFrontInATrait ::=
     | AbsGoesFrontInATrait+

AbsGoesFrontInATrait ::=
     | ApiFldDecl
     | AbsGetterSetterDecl
     | PropertyDecl

AbsGoBackInATrait ::=
     | AbsGoesBackInATrait+

AbsGoesBackInATrait ::=
     | AbsMdDecl
     | AbsCoercion
     | PropertyDecl

AbsObjectDecl ::=
     | ObjectHeader AbsGoInAnObject? end

AbsGoInAnObject ::=
     | AbsGoFrontInAnObject AbsGoBackInAnObject?
     | AbsGoBackInAnObject

AbsGoFrontInAnObject ::=
     | AbsGoesFrontInAnObject+

AbsGoesFrontInAnObject ::=
     | ApiFldDecl
     | AbsGetterSetterDecl
     | PropertyDecl

AbsGoBackInAnObject ::=
     | AbsGoesBackInAnObject+

AbsGoesBackInAnObject ::=
     | AbsMdDecl
     | AbsCoercion
     | PropertyDecl

$$$$$ Variable Declaration

VarDecl ::=
     | VarWTypes InitVal
     | VarWoTypes = Expr
     | VarWoTypes : TypeRef ... InitVal
     | VarWoTypes : SimpleTupleType InitVal

VarWTypes ::=
     | VarWType
     | ( VarWType( , VarWType)+ )

VarWType ::=
     | VarMods? Id IsType

VarWoTypes ::=
     | VarWoType
     | ( VarWoType( , VarWoType)+ )

VarWoType ::=
     | VarMods? Id

InitVal ::=
     | ( = | := ) Expr    

AbsVarDecl ::=
     | VarWTypes
     | VarWoTypes : TypeRef ...
     | VarWoTypes : SimpleTupleType

$$$$$ Function Declaration

FnDecl ::=
     | FnDef
     | AbsFnDecl

FnDef ::=
     | FnMods? FnHeaderFront FnHeaderClause = Expr

AbsFnDecl ::=
     | FnMods? FnHeaderFront FnHeaderClause
     | Name : ArrowType

FnHeaderFront ::=
     | Id StaticParams? ValParam
     | OpHeaderFront

$$$$$ Headers

Extends ::=
     | extends TraitTypes

Excludes ::=
     | excludes TraitTypes

Comprises ::=
     | comprises ComprisingTypes

TraitTypes ::=
     | TraitType
     | {TraitTypeList } 

TraitTypeList ::=
     | TraitType( , TraitType)*

ComprisingTypes ::=
     | TraitType
     | {ComprisingTypeList } 

ComprisingTypeList ::=
     | . . .
     | TraitType( , TraitType)* ( , . . . )?

Where ::=
     | where { WhereClauseList } 

WhereClauseList ::=
     | WhereClause( , WhereClause)*

BoolRef ::=
     | StaticArg

UnitConstraint ::=
     | unit Id
     | UnitRef = UnitRef

FnHeaderClause ::=
     | IsType? FnClauses

FnClauses ::=
     | Throws? Where? Contract

Throws ::=
     | throws MayTraitTypes

MayTraitTypes ::=
     | {}
     | TraitTypes

Contract ::=
     | Requires? Ensures? Invariant?

Requires ::=
     | requires { ExprList? } 

Ensures ::=
     | ensures { ProvidedList? } 

ProvidedList ::=
     | Provided( , Provided)*

Provided ::=
     | Expr ( provided Expr)?

Invariant ::=
     | invariant { ExprList? } 

CoercionClauses ::=
     | Throws? CoercionWhere? Contract

CoercionWhere ::=
     | where { CoercionWhereClauseList } 

CoercionWhereClauseList ::=
     | CoercionWhereClause( , CoercionWhereClause)*

CoercionWhereClause ::=
     | WhereClause
     | TypeRef widens or coerces TypeRef

UniversalMod ::=
     | private      
     | test

TraitMod ::=
     | value      
     | UniversalMod

TraitMods ::=
     | TraitMod+

ObjectMods ::=
     | TraitMods

FnMod ::=
     | LocalFnMod      
     | UniversalMod

FnMods ::=
     | FnMod+

VarMod ::=
     | var      
     | UniversalMod

VarMods ::=
     | VarMod+

AbsFldMod ::=
     | hidden      
     | settable      
     | wrapped      
     | UniversalMod

AbsFldMods ::=
     | AbsFldMod+

FldMod ::=
     | var      
     | AbsFldMod

FldMods ::=
     | FldMod+


ApiFldMod ::=
     | hidden      
     | settable      
     | UniversalMod

ApiFldMods ::=
     | ApiFldMod+

LocalFnMod ::=
     | atomic      
     | io

LocalFnMods ::=
     | LocalFnMod+

StaticParams ::=
     | [[[StaticParamList]]]  

StaticParamList ::=
     | StaticParam( , StaticParam)*

StaticParam ::=
     | Id Extends? (absorbs unit )?
     | nat Id
     | int Id
     | bool Id
     | dim Id
     | unit Id ( : DimRef )? ( absorbs unit )?
     | opr Op
     | ident Id

$$$$$ Parameters

ValParam ::=
     | BindId
     | (Params?)

Params ::=
     | (Param , )* (Varargs , )? Keyword( ,Keyword)*
     | (Param , )* Varargs
     | Param( , Param)*

VarargsParam ::=
     | Id : TypeRef ...

Varargs ::=
     | VarargsParam

Keyword ::=
     | Param=Expr

PlainParam ::=
     | BindId IsType?
     | TypeRef

Param ::=
     | PlainParam

OpHeaderFront ::=
     | opr StaticParams? (LeftEncloser      | Encloser) Params (RightEncloser      | Encloser)( := ( SubscriptAssignParam ))?
     | opr StaticParams? ValParam Op
     | opr (Op      | Encloser) StaticParams? ValParam

SubscriptAssignParam ::=
     | Varargs
     | Param

$$$$$ Method Declaration

MdDecl ::=
     | MdDef
     | AbsMdDecl

MdDef ::=
     | FnMods? MdHeaderFront FnHeaderClause = Expr
     | Coercion

AbsMdDecl ::=
     | abstract ? FnMods? MdHeaderFront FnHeaderClause

MdHeaderFront ::=
     | (Receiver . )?Id StaticParams? MdValParam
     | OpHeaderFront

Receiver ::=
     | Id
     | self

GetterSetterDecl ::=
     | GetterSetterDef
     | AbsGetterSetterDecl

GetterSetterDef ::=
     | FnMods? GetterSetterMod MdHeaderFront FnHeaderClause = Expr

GetterSetterMod ::=
     | getter      | setter

AbsGetterSetterDecl ::=
     | abstract ? FnMods? GetterSetterMod MdHeaderFront FnHeaderClause

Coercion ::=
     | widening ? coercion StaticParams?(Id IsType)CoercionClauses =Expr

AbsCoercion ::=
     | widening ? coercion StaticParams?(Id IsType)CoercionClauses

$$$$$ Method Parameters

MdValParam ::=
     | ( MdParams? )

MdParams ::=
     | (MdParam , )* (Varargs , )? MdKeyword( ,MdKeyword)*
     | (MdParam , )* Varargs
     | MdParam( , MdParam)*

MdKeyword ::=
     | MdParam=Expr

MdParam ::=
     | Param
     | self

$$$$$ Field Declarations

FldDecl ::=
     | FldWTypes InitVal
     | FldWoTypes = Expr
     | FldWoTypes : TypeRef ... InitVal
     | FldWoTypes : SimpleTupleType InitVal

FldWTypes ::=
     | FldWType
     | ( FldWType( , FldWType)+ )

FldWType ::=
     | FldMods? Id IsType

FldWoTypes ::=
     | FldWoType
     | ( FldWoType( , FldWoType)+ )

FldWoType ::=
     | FldMods? Id

$$$$$ Abstract Filed Declaration

AbsFldDecl ::=
     | AbsFldWTypes
     | AbsFldWoTypes : TypeRef ...
     | AbsFldWoTypes : SimpleTupleType

AbsFldWTypes ::=
     | AbsFldWType
     | ( AbsFldWType( , AbsFldWType)+ )

AbsFldWType ::=
     | AbsFldMods? Id IsType

AbsFldWoTypes ::=
     | AbsFldWoType
     | ( AbsFldWoType( , AbsFldWoType)+ )

AbsFldWoType ::=
     | AbsFldMods? Id

ApiFldDecl ::=
     | ApiFldMods? Id IsType

$$$$$ Expressions

Expr ::=
     | AssignLefts AssignOp Expr
     | OpExpr
     | DelimitedExpr
     | FlowExpr
     | fn ValParam IsType? Throws? => Expr
     | Expr as TypeRef
     | Expr asif TypeRef
     | UnitExpr

UnitExpr ::=
     | UnitRef
     | Expr UnitRef
     | Expr . UnitRef
     | Expr / UnitRef
     | Expr per UnitRef
     | Expr in UnitRef

UnitRef ::=
     | StaticArg

AssignLefts ::=
     | ( AssignLeft( , AssignLeft)* )
     | AssignLeft

AssignLeft ::=
     | SubscriptExpr
     | FieldSelection
     | BindId

SubscriptExpr ::=
     | Primary [ExprList?]

FieldSelection ::=
     | Primary . Id

OpExpr ::=
     | EncloserOp OpExpr? EncloserOp?
     | OpExpr EncloserOp OpExpr?
     | Primary

EncloserOp ::=
     | Encloser
     | Op

Primary ::=
     | Comprehension
     | Id[[[ StaticArgList ]]]
     | BaseExpr
     | LeftEncloser ExprList? RightEncloser
     | Primary[ExprList?]
     | Primary . Id ([[[StaticArgList]]])? TupleExpr
     | Primary . Id ([[[StaticArgList]]])?()
     | Primary . Id
     | Primary ^ BaseExpr
     | Primary ExponentOp
     | Primary TupleExpr
     | Primary()
     | Primary Primary
     | TraitType . coercion ([[[StaticArgList]]])?(Expr)

FlowExpr ::=
     | exit Id? (with Expr)?
     | Accumulator ([ GeneratorList ])? Expr
     | atomic AtomicBack
     | tryatomic AtomicBack
     | spawn Expr
     | throw Expr

AtomicBack ::=
     | AssignLefts AssignOp Expr
     | OpExpr
     | DelimitedExpr

GeneratorList ::=
     | Generator( , Generator)*

Generator ::=
     | Id<-Expr
     | ( Id , IdList )<-Expr
     | Expr

$$$$$ Expressions Enclosed by Keywords

DelimitedExpr ::=
     | TupleExpr
     | object Extends? GoInAnObject end
     | Do
     | label Id BlockElems end Id
     | while Expr Do
     | for GeneratorList DoFront end
     | if Expr then BlockElems Elifs? Else? end
     | ( if Expr then BlockElems Elifs? Else end ?)
     | case Expr Op? of CaseClauses CaseElse? end
     | case ( largest      | smallest ) Op? of CaseClauses end
     | typecase TypecaseBindings of TypecaseClauses CaseElse? end
     | try BlockElems Catch? (forbid TraitTypes)? ( finally BlockElems)? end

Do ::=
     | (DoFront also )* DoFront end

DoFront ::=
     | ( at Expr)? atomic ? do BlockElems?

TupleExpr ::=
     | ( (Expr , )* (Expr ... , )? Binding ( , Binding)* )
     | NoKeyTuple

NoKeyTuple ::=
     | ( (Expr , )* Expr ... )
     | ( (Expr , )* Expr )

Elifs ::=
     | Elif+

Elif ::=
     | elif Expr then BlockElems

Else ::=
     | else BlockElems

CaseClauses ::=
     | CaseClause+

CaseClause ::=
     | Expr => BlockElems

CaseElse ::=
     | else => BlockElems

TypecaseBindings ::=
     | ( BindingList )
     | Binding
     | Id

BindingList ::=
     | Binding( , Binding)*

Binding ::=
     | BindId = Expr

TypecaseClauses ::=
     | TypecaseClause+

TypecaseClause ::=
     | TypecaseTypeRefs => BlockElems

TypecaseTypeRefs ::=
     | ( TypeRefList )
     | TypeRef

Catch ::=
     | catch Id CatchClauses

CatchClauses ::=
     | CatchClause+

CatchClause ::=
     | TraitType => BlockElems

Comprehension ::=
     | { Expr      | GeneratorList }
     | {Entry      | GeneratorList }
     | <Expr      | GeneratorList  > 
     | [ ArrayComprehensionClause+ ]

Entry ::=
     | Expr |-> Expr   

ArrayComprehensionLeft ::=
     | IdOrInt |-> Expr
     | ( IdOrInt , IdOrIntList ) |-> Expr

ArrayComprehensionClause ::=
     | ArrayComprehensionLeft      
     | GeneratorList

IdOrInt ::=
     | Id
     | IntLiteral

IdOrIntList ::=
     | IdOrInt( , IdOrInt)*

BaseExpr ::=
     | NoKeyTuple
     | Literal
     | Id
     | self

ExprList ::=
     | Expr( , Expr)*

$$$$$ Local Declarations

BlockElems ::=
     | BlockElem+

BlockElem ::=
     | LocalVarFnDecl
     | Expr( , GeneratorList)?

LocalVarFnDecl ::=
     | LocalFnDecl+
     | LocalVarDecl

LocalFnDecl ::=
     | LocalFnMods? FnHeaderFront FnHeaderClause = Expr

LocalVarDecl ::=
     | LocalVarWTypes InitVal
     | LocalVarWTypes
     | LocalVarWoTypes = Expr
     | LocalVarWoTypes : TypeRef ... InitVal?
     | LocalVarWoTypes : SimpleTupleType InitVal?

LocalVarWTypes ::=
     | LocalVarWType
     | ( LocalVarWType( , LocalVarWType)+ )

LocalVarWType ::=
     | var ? Id IsType

LocalVarWoTypes ::=
     | LocalVarWoType
     | ( LocalVarWoType( , LocalVarWoType)+ )

LocalVarWoType ::=
     | var ? Id
     | Unpasting

Unpasting ::=
     | [ UnpastingElems ]

UnpastingElems ::=
     | UnpastingElem RectSeparator UnpastingElems
     | UnpastingElem

UnpastingElem ::=
     | Id ([ UnpastingDim ])?
     | Unpasting

UnpastingDim ::=
     | ExtentRange (SQRT ExtentRange)+

$$$$$ Literals

Literal ::=
     | ( )
     | NumericLiteral
     | CharLiteral
     | StringLiteral
     | {Entry ( , Entry)* }
     | [ RectElements ]

RectElements ::=
     | Expr MultiDimCons*

MultiDimCons ::=
     | RectSeparator Expr

RectSeparator ::=
     | ; +
     | Whitespace

$$$$$ Types

IsType ::=
     | : TypeRef

TypeRef ::=
     | TraitType
     | ArrowType
     | TupleType
     | (TypeRef ?)
     | DimType

TraitType ::=
     | DottedId ([[[StaticArgList]]])?
     | {TypeRef |-> TypeRef }
     | [[[TypeRef]]]
     | TypeRef [ ArraySize? ]
     | TypeRef ^ StaticArg
     | TypeRef ^ ( ExtentRange (SQRT ExtentRange)* )

ArrowType ::=
     | TypeRef -> TypeRef Throws?

DimType ::=
     | DimRef
     | TypeRef DimRef
     | TypeRef . DimRef
     | TypeRef / DimRef
     | TypeRef per DimRef
     | TypeRef UnitRef
     | TypeRef . UnitRef
     | TypeRef / UnitRef
     | TypeRef per UnitRef
     | TypeRef in DimRef

DimRef ::=
     | StaticArg

TupleType ::=
     | ( (TypeRef , )* (TypeRef ... , )? KeywordType( , KeywordType)* )
     | ( (TypeRef , )* TypeRef ... )
     | SimpleTupleType

KeywordType ::=
     | Id=TypeRef

SimpleTupleType ::=
     | ( TypeRef , TypeRefList )

TypeRefList ::=
     | TypeRef ( , TypeRef )*

StaticArgList ::=
     | StaticArg( , StaticArg)*

StaticArg ::=
     | Number
     | Op
     | true
     | false
     | Unity
     | dimensionless
     | StaticArg + StaticArg
     | StaticArg . StaticArg
     | StaticArg StaticArg
     | StaticArg / StaticArg
     | 1 / StaticArg
     | StaticArg ^ StaticArg
     | StaticArg per StaticArg
     | DUPreOp StaticArg
     | StaticArg DUPostOp
     | NOT StaticArg
     | StaticArg OR StaticArg
     | StaticArg AND StaticArg
     | StaticArg IMPLIES StaticArg
     | TypeRef
     | (StaticArg)

DUPreOp ::=
     | square      
     | cubic      
     | inverse

DUPostOp ::=
     | squared      
     | cubed

ArraySize ::=
     | ExtentRange( , ExtentRange)*

ExtentRange ::=
     | StaticArg? SHARP StaticArg?
     | StaticArg? : StaticArg?
     | StaticArg

Number ::=
     | IntLiteral

$$$$$ Symbols and Operators

AssignOp ::=
     | :=      
     | Op=

$$$$$ Identifiers

IdList ::=
     | Id( , Id)*

Name ::=
     | Id
     | opr Op

DottedId ::=
     | Id( . Id)*

BindId ::=
     | Id
     | UNDERSCORE

