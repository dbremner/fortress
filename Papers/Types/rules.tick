% Stuff needed in set up
% intersection and union types
%   can be structural types
%   distribute over structural types (tuples, arrows, intersection, union)
% Extensions of the class table
%   what does it mean for an extension to be well formed
%   what does this mean for condition 1)
% Language is call by value

% Guaranteeing valid overloading requires constraints 
% on the sets of overloaded function declarations
% that are allowed to appear in a legal program \cite{millstein02,millstein03}.
% Some languages require program constructs that encapsulate all overloaded definitions;
% such constructs essentially guarantee valid overloading ````by construction''.
% Examples in other languages include type classes \cite{wadler89,dreyer07,siek05}
% and multimethods \cite{millstein02,millstein03,bourdoncle97}.
% We take a different approach: Rather than introducing additional language facilities,
% we impose rules on the function declarations themselves.
% % These aren't necessarily strictly "minimal" though, so:
% We intend these rules to be ````minimal'' in that they should be as unrestrictive as possible
% while preserving the ability to guarantee valid overloading and be checked in a modular way.
% We took a similar approach to guarantee safety for overloaded monomorphic functions \cite{allen07}.
% However, handling parametric polymorphism and implicit instantiation (i.e., type inference)
% requires more sophisticated type analysis.
% We achieve this analysis by introducing universal and existential quantification
% over the ground types defined by class tables.

In this section, 
we define three rules---%
the \emph{No Duplicates Rule}, 
\emph{Meet Rule}, 
and \emph{Return Type Rule}---%
for pairs of overloaded function definitions.
A set of overloaded function definitions is \emph{valid with respect to a class table}
if it pairwise satisfies all these rules using the subtyping relation 
induced by that class table.
In Section~\ref{sec:safety},
we show that any valid set of overloaded function declarations is safe.
We later describe how to mechanically verify these rules in a modular way
in terms of subtyping relations on universal and existential types 
in Section~\ref{sec:checking}.

%% \TODO{Discuss intended minimality of these rules?}

\subsection{Overloading Rules}
\label{sec:threerules}

In this section, we describe the rules for valid overloading.
For each function name $f$,
we determine whether a set of overloaded function declarations $\Df$ is valid
by independently considering every pair of declarations in the set.
A pair of declarations is a valid overloading 
if it satisfies the three rules described below with respect to a class
table $\T$, and a set $\Df$ is valid
with respect to $\T$ if every pair of declarations in the set is valid with
respect to $\T$.

The meet rule of Castagna \emph{et al.} imposes two conditions:
the existence of a meet and its uniqueness.
We split these into two rules.

To avoid the obvious ambiguity, 
$\Df$ should not contain equally specific declarations:
for each pair of overloaded declarations, 
either one declaration is strictly more specific
than the other or they are incomparable.
\begin{description}
\item[No Duplicates Rule]
For every $d_1, d_2 \in \Df$, if $d_1 \ms d_2$ and $d_2 \ms d_1$ then $d_1$
and $d_2$ denote the same declaration. In other words, there are no two
distinct declarations in $\Df$ that are equally specific.
\end{description}

A pair of declarations is unambiguous
if for any type to which both declarations are applicable,
there is a {\em disambiguating declaration} (possibly one of the pair)
that is also applicable to that type and is more specific than both declarations. Moreover, that declaration is applicable exactly when
both of the others are applicable.
\begin{description}
\item[Meet Rule]
For every $d_1, d_2 \in \Df$,
there should exist a declaration $d_0 \in \Df$ (possibly one of the pair) 
such that,
for every type $T \in \T$, $d_0$ is applicable to $T$ 
if and only if both $d_1$ and $d_2$ are applicable to $T$.
\end{description}

%% \TODO{Discuss what types $T$ we must consider, 
%% and relevance to extensibility.}

%% \TODO{Explain motivation for intersection types (i.e., as meet).
%% Perhaps this belongs in Types section.}

%% \TODO{Note the following ````lemma'':
%% If one overloaded declaration is strictly more specific than another 
%% then that pair of declarations satisfies the No Duplicates Rule 
%% and the Meet Rule.}

If one monomorphic declaration is more specific than another monomorphic one,
then there is no ambiguity between these two declarations:
for any type to which both are applicable, the first is more specific.
In the parametrically polymorphic setting,
if one declaration is to be regarded as more specific than another,
we require that for every instance of the second that is applicable to a type,
there exists an instance of the first that is also applicable to the type.
As in other object-oriented languages, to ensure type safety in the face of dynamic dispatch,
we also require that the return type of the first declaration be a subtype of the return type of the second.
% We can ensure that the second well-formedness condition for overloading
% holds by checking the following rule for each function name $f$:
\begin{description}
\item[Return Type Rule]
For every $d_1, d_2 \in \Df$ with $d_1 \ms d_2$, 
for every type $W$ to which $d_1$ is applicable
(and therefore $d_2$ is also applicable),
and for every instance $\decl{f}{S_2}{T_2}$ of $d_2$ that is applicable to $W$,
there must exist an instance \decl{f}{S_1}{T_1} of $d_1$
that is applicable to $W$ and satisfies \mbox{$T_1 <: T_2$}.
\end{description}

Since $\Bottom$ is well-formed with respect to any class table, 
and tuple types with different numbers of arguments 
have no common subtype other than \Bottom,
the Meet Rule technically requires that 
an overloaded function with declarations that take different numbers of arguments 
has a declaration applicable only to \Bottom.
Because \Bottom\ is not first-class in Fortress, 
such a declaration cannot be written, 
and in any case it would, of course, never be applied
because no value belongs to \Bottom.
To avoid this technicality, 
we implicitly augment the set $\Df$ of overloaded function declarations with name $f$ 
with a declaration $\decl{f}{\Bottom}{\Bottom}$.
Because this declaration is strictly more specific 
than any declaration that a programmer can write, and because its return
type is \Bottom,
it trivially satisfies all three rules when checked with any other
declaration in $\Df$.

\subsection{Properties of Overloaded Functions}
With the rules for valid overloading laid out, we now describe some useful
properties of valid overloaded sets and of the rules themselves.

\begin{lemma}
\label{lem:strictms}
If $d_1$ and $d_2$ are declarations in $\Df$ such that
$d_1 \ms d_2$ and $d_2 \not\ms d_1$, then the pair $(d_1, d_2)$ satisfies the
No Duplicates Rule and the Meet Rule.
\end{lemma}
\begin{proof}
The No Duplicates Rule is vacuously satisfied, and the Meet Rule is satisfied
with $d_0 = d_1$ since $d_1 \ms d_2$ implies that $d_1$ is applicable to a type $T$ if and only if both $d_1$ and $d_2$ are applicable to $T$.
\end{proof}

\begin{lemma}
\label{lem:subsetvalid}
For every type $T \in \T$, if $\Df$ is a valid set with respect to $\T$ then
so is $\Df(T)$.
\end{lemma}
\begin{proof}
The No Duplicates Rule and Return Type Rule are straightforward applications
of the respective rules on $\Df$.

Let $d_1, d_2$ be declarations in $\Df(T)$ and let $d_0 \in \Df$ be its
disambiguating declaration guaranteed by the Meet Rule on $\Df$. Then $d_0$ is applicable to exactly those types $U$ to which $d_1$ and $d_2$ are
both applicable. Since $d_1$ and $d_2$ are by definition both applicable
to $T$, $d_0$ must also be applicable to $T$, and hence $d_0 \in \Df(T)$.
Therefore the Meet Rule on $\Df(T)$ is satisfied.
\end{proof}

To further characterize valid sets of overloaded definitions and the
more specific relation $\ms$, we interpret them as
meet semilattices. A partially ordered set $(A, \sqsubseteq)$ forms a
\emph{meet semilattice} if, for every pair of elements $a,b \in A$, their
greatest lower bound, or \emph{meet}, is also in $A$.
\begin{lemma}
\label{lem:meetsemilattice}
A valid set of overloaded function declarations forms a meet semilattice with
the more specific relation.
\end{lemma}
\begin{proof}
Suppose $\Df$ is a valid set of overloaded function declarations
with respect to class table $\T$.
First, $(\Df, \ms)$ forms a partially ordered set: clearly $\ms$ is
reflexive and transitive, and antisymmetry is a direct corollary of the
No Duplicates Rule.

Second, we must
show that (i) for every $d_1, d_2 \in \Df$ there exists a $d_0 \in \Df$
such that $d_0 \ms d_1$ and $d_0 \ms d_2$ and (ii) if there exists a
$d_0' \in \Df$ such that $d_0' \ms d_1$ and $d_0' \ms d_2$ then
$d_0' \ms d_0$.

Let $d_1$ and $d_2$ be declarations in $\Df$. By the Meet Rule, there
exists a declaration $d_0 \in \Df$ that is applicable to a type $T \in \T$
if and only if both $d_1$ and $d_2$ are too. Since for every $T$ to which
$d_0$ is applicable we have that $d_1$ and $d_2$ are also applicable to it,
we know that $d_0 \ms d_1$ and $d_0 \ms d_2$.

Now let $d_0' \in \Df$ be more specific than both $d_1$ and $d_2$.
Then for every type $T \in \T$ such that $d_0'$ is applicable
to $T$, $d_1$ and $d_2$ are also applicable to $T$; thus $d_0$ is
applicable to $T$ and $d_0' \ms d_0$.
\end{proof}

The No Duplicates Rule and the Meet Rule each
corresponds to a defining property of
meet semilattices (antisymmetry and the existence of meets,
respectively), while the Return Type
Rule guarantees that this interpretation is consistent with the
semantics of multiple dynamic dispatch.

\begin{lemma}
\label{lem:leastelement}
A valid set of overloaded function declarations $\Df(T)$ has a unique
most specific declaration.
\end{lemma}
\begin{psketch}
The set $\Df(T)$ forms a meet semilattice by the previous lemma and moreover
it is clearly finite. By straightforward induction a finite meet semilattice
has a least element, so there exists a unique declaration in $\Df(T)$ that
is more specific than all others.
\end{psketch}
