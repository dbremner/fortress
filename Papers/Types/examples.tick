We now consider whether several overloaded generic functions
are permitted by the rules in Section~\ref{sec:rules}.
In this section, 
we simply argue informally why each set of overloaded definitions is valid or not,
and point out where multiple instantiation exclusion is required.
We give a formal system and algorithm for doing these checks 
in Section~\ref{sec:checking}.

% Throughout this section, 
% we assume the following class table:
% \TODO{Make sure this table is up-to-date.
% Possibly put in a figure}

% \small
%   Object
%   Number <: Object
%   ZZ <: Number
%   String <: Object excludes Number
%   List[\X\] <: Object
%   ArrayList[\X\] <: List[\X\]
% 
% \normalsize

First, consider the function `foo`
from the introduction:

\small
`  foo[\X <: Object\](x: X, y: Object): ZZ = 1
  foo[\Y <: Number\](x: Number, y: Y): ZZ = 2`
\normalsize
This overloading is valid: 
The second definition is strictly more specific than the first 
because the first definition is applicable to a pair of arguments 
exactly if the type of each argument is a subtype of `Object`, 
whereas the second is applicable to a pair of arguments exactly if
the type of each argument is a subtype of `Number`.
Thus, these definitions satisfy the no duplicates rule 
and the meet rule.
And they satisfy the return type rule 
because the return type of both definitions is always `ZZ`.

The overloaded definitions for `tail` are also valid:
\small
`  tail[\X\](x: List[\X\]): List[\X\] = e1
  tail[\X <: Number\](x: List[\X\]): List[\X\] = e2
  tail(x: List[\ZZ\]): List[\ZZ\] = e3`
\normalsize
The first definition is applicable to any argument 
of type `List[\T\]` for any well-formed type `T`, 
the second is applicable to an argument 
of type `List[\T\]` when `T <: Number`, 
and the third is applicable to an argument 
of type `List[\ZZ\]`.
Thus, 
each definition is strictly more specific than the preceding one, 
so the no duplicates rule and meet rule 
are satisfied for each pair of definitions.

To see that the return type rule is satisfied 
by the first two definitions, 
consider any type `W NEQUIV Bottom` 
to which the second definition is applicable,
and any instantiation of the first definition with type $U$ 
that is applicable to $W$.
Then `W <: List[\T\]` for some `T <: Number` 
and `W <: List[\U\]`, 
so `W <: List[\T\] CAP List[\U\]`.
By multiple instantiation exclusion,
`List[\T\] CAP List[\U\] EQUIV Bottom`
unless $T \equiv U$.
Therefore, 
since $W \not\equiv \Bottom$, 
we have $T \equiv U$,
so $W \subtypeof \TYP{List}\ob{U}$ 
with $U \subtypeof \TYP{Number}$.
Then the instantiation of the second definition with $U$ 
has return type `List[\U\]`, 
which is also the return type 
of the instantiation of the first definition 
under consideration.

Similarly, 
the return type rule is satisfied by the third definition 
and either of the first two 
because the third definition is applicable 
only to arguments of type `List[\ZZ\]`,
and because of multiple instantiation exclusion, 
the only instantiation of either the first or second definition 
that is applicable to such an argument 
is its instantiation with `ZZ`.
That instantiation has return type `List[\ZZ\]`, 
which is also the return type of the third definition.

The `min` example from Section~\ref{sec:exclusion} is similar, 
except we need multiple instantiation exclusion 
to satisfy the meet rule rather than the return type rule:

\small
`  min[\X <: Number, Y <: ZZ\](p: Pair[\X,Y\]): Number
  min[\X <: ZZ, Y <: Number\](p: Pair[\X,Y\]): Number
  min[\X <: ZZ, Y <: ZZ\](p: Pair[\X,Y\]): ZZ
`
\normalsize
Any argument to which the first two definitions are both applicable 
must be of type $\TYP{Pair}\ob{X_1,Y_1} \cap \TYP{Pair}\ob{X_2,Y_2}$
for some $X_1 \subtypeof \TYP{Number}$, 
$Y_1 \subtypeof `ZZ`$, 
$X_2 \subtypeof `ZZ`$, 
and $Y_2 \subtypeof \TYP{Number}$.
Multiple instantiation exclusion 
implies that $X_1 = X_2$ and $Y_1 = Y_2$,
% \[
% \TYP{Pair}\ob{X_1,Y_1} \cap \TYP{Pair}\ob{X_2,Y_2} = \Bottom
% \]
% unless 
so the argument must be of type $\TYP{Pair}\ob{X_1,Y_1}$, 
where $X_1 \subtypeof \TYP{Number} \cap `ZZ` = `ZZ`$
and $Y_1 \subtypeof `ZZ` \cap \TYP{Number} = `ZZ`$, 
so the third definition is applicable to it.
And since the third definition is more specific than the first two,
it satisfies the requirement of the meet rule.



\small
`  bar[\X\](x: X): ZZ = 1
  bar(x: Number): ZZ = 2
`
\normalsize
What do you get if you call `bar(2)`?


\small
`  bar[\X\](x: X): X
  bar(x: ZZ): ZZ
`
\normalsize




\TODO{Some stuff to mention?}
In a single-inheritance language (without parametric polymorphism?), 
the constructed types trivially form a meet semilattice: 
two types have a common nontrivial subtype 
only if one is a subtype of the other.
Thus, the tuple types and constructed types form a meet semilattice.
(But arrow types don't: 
the meet of `S->T` and `U->V` is \emph{not} an arrow type.)






`  foo[\X <: Any\]ArrayList[\X\]: ZZ
  foo[\Y <: ZZ\]List[\Y\]: ZZ
  foo[\Z <: ZZ\]ArrayList[\Z\]: ZZ`
The first two declarations are incomparable under specificity---%
the first declaration applies to applications of `ArrayList` to any type,
the second to applications of `List` with subtypes of type `ZZ`.
The third definition,
which is the ````obvious'' candidate to disambiguate the two, 

is not actually the meet;
the domain of this meet candidate is the existential type:
`  EXISTS[\W <: ZZ\]ArrayList[\W\]
`
and needs to be proven equivalent to the domain of the computed meet:
`  EXISTS[\X <: Any, Y <: ZZ\](ArrayList[\X\] CAP List[\Y\])
`
which requires that the latter be a subtype of the former.
However, there is no type `W <: ZZ` such that:
\\[.5em]
\hspace*{.5em}
%\jgsub[`X <: Any, Y <: ZZ`]{`ArrayList[\X\] CAP List[\Y\]`}{`ArrayList[\W\]`}
\ensuremath{
\begin{array}{l}
{`X <: Any, Y <: ZZ`}\,\vdash
\\
\quad\quad\quad\quad
{`ArrayList[\X\] CAP List[\Y\]`}\;{\subtypeof}\;{`ArrayList[\W\]`}
\end{array}
}
\\[.5em]
Our definition of the meet is not faulty: these declarations actually are unsafe.
Consider the (user-defined) constructed type:
`  BadList <: {ArrayList[\String\], List[\ZZ\]}
`
Our meet candidate is not applicable to `BadList`, but the two other definitions of `foo` are.
Since neither of those is more specific than the other,
this set of overloaded declarations must be rejected.



The following overloading example,
in which the second declaration is more specific than the first,
is also ill-formed:
`  tail[\X <: Any\]List[\X\]:List[\X\]
  tail[\Y <: Any\]ArrayList[\Y\]:ArrayList[\Y\]`
The declarations do not satisfy the Return Type Rule
because we cannot find a specific type `V <: Any` such that:
\\[.8em]
\begin{tabular}{lr}
%% \jgsub[`X <: Any, Y <: Any`]{`ArrayList[\V\] -> ArrayList[\V\]`}{`ArrayList[\Y\] CAP List[\X\] -> List[\X\]`}
\multicolumn{2}{l}{`X <: Any, Y <: Any` $\vdash$} \\
\quad\quad\quad\quad\quad\quad
&`ArrayList[\V\] -> ArrayList[\V\]` \\
&$\subtypeof$ `ArrayList[\Y\] CAP List[\X\] -> List[\X\]`
\end{tabular}
\\[.8em]
%% `X <: Any, Y <: Any` \; &\vdash `ArrayList[\V\] -> ArrayList[\V\]` \\
%% \;&\subtypeof\; `ArrayList[\Y\] CAP List[\X\] -> List[\X\]`
Once again, the type `BadList` proves that this set of overloaded declarations must be rejected. Consider the instance:
`  tail List[\ZZ\]:List[\ZZ\]
`
of the first declaration. We need to find an instance of the second declaration that is applicable to `BadList`
and has a return type that is a subtype of `List[\ZZ\]`,
but the only instance of the second declaration applicable to `BadList` is:
`  tail ArrayList[\String\]:ArrayList[\String\]
`
whose return type is not a subtype of `List[\ZZ\]`.
Therefore, this set of overloaded declarations must be rejected.
