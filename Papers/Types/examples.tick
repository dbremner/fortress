We now consider several sets of overloaded generic function declarations, 
and argue informally why they are 
(or are not, in one case) 
permitted by the rules in Section~\ref{sec:rules}, 
paying particular attention to where multiple instantiation exclusion is required.
We give a formal system and algorithm for doing these checks 
in Section~\ref{sec:checking}.

First, consider the function `foo`
from the introduction:

\small
`  foo[\X <: Object\](x: X, y: Object): ZZ = 1
  foo[\Y <: Number\](x: Number, y: Y): ZZ = 2`
\normalsize
This overloading is valid: 
The second definition is strictly more specific than the first 
because the first definition is applicable to a pair of arguments 
exactly if the type of each is a subtype of `Object`, 
whereas the second is applicable to a pair of arguments exactly if
the type of each is a subtype of `Number`.
Thus, these definitions satisfy the no duplicates rule 
and the meet rule.
And they satisfy the return type rule 
because the return type of both definitions is always `ZZ`.

The overloaded definitions for `tail` are also valid:

\small
`  tail[\X\](x: List[\X\]): List[\X\] = e1
  tail[\X <: Number\](x: List[\X\]): List[\X\] = e2
  tail(x: List[\ZZ\]): List[\ZZ\] = e3`
\normalsize
The first definition is applicable to any argument 
of type `List[\T\]` for any well-formed type `T`, 
the second is applicable to an argument 
of type `List[\T\]` when `T <: Number`, 
and the third is applicable to an argument 
of type `List[\ZZ\]`.
Thus, 
each definition is strictly more specific than the preceding one, 
so the no duplicates rule and meet rule 
are satisfied for each pair of definitions.

To see that the return type rule is satisfied 
by the first two definitions, 
consider any type `W NEQUIV Bottom` 
to which the second definition is applicable---%
so `W <: List[\T\]` for some `T <: Number`---%
and any instantiation of the first definition with type $U$ 
that is applicable to $W$---so `W <: List[\U\]`.
Then 
`W <: List[\T\] CAP List[\U\]`.
By multiple instantiation exclusion,
`List[\T\] CAP List[\U\] EQUIV Bottom`
unless $T \equiv U$.
Since $W \not\equiv \Bottom$, 
we have $T \equiv U$,
so $W \subtypeof \TYP{List}\ob{U}$ 
with $U \subtypeof \TYP{Number}$.
Thus, the instantiation of the second definition with $U$ 
has return type `List[\U\]`, 
which is also the return type 
of the instantiation of the first definition 
under consideration.

The return type rule is also satisfied by the third definition 
and either of the first two 
because the third definition is applicable 
only to arguments of type `List[\ZZ\]`,
and because of multiple instantiation exclusion, 
the only instantiation of either the first or second definition 
that is applicable to such an argument 
is its instantiation with `ZZ`.
That instantiation has return type `List[\ZZ\]`, 
which is also the return type of the third definition.

The `min` example from Section~\ref{sec:exclusion} is also valid 
under multiple instantiation exclusion,
which is necessary in this case 
to satisfy the meet rule rather than the return type rule:

\small
`  min[\X <: RR, Y <: ZZ\](p: Pair[\X,Y\]): RR
  min[\X <: ZZ, Y <: RR\](p: Pair[\X,Y\]): RR
  min[\X <: ZZ, Y <: ZZ\](p: Pair[\X,Y\]): ZZ
`
\normalsize
Any argument to which the first two definitions are both applicable 
must be of type $\TYP{Pair}\ob{X_1,Y_1} \cap \TYP{Pair}\ob{X_2,Y_2}$
for some $X_1 \subtypeof `RR`$, 
$Y_1 \subtypeof `ZZ`$, 
$X_2 \subtypeof `ZZ`$, 
and $Y_2 \subtypeof `RR`$.
Multiple instantiation exclusion 
implies that $X_1 = X_2$ and $Y_1 = Y_2$,
so the argument must be of type $\TYP{Pair}\ob{X_1,Y_1}$, 
where $X_1 \subtypeof `RR` \cap `ZZ` = `ZZ`$
and $Y_1 \subtypeof `ZZ` \cap `RR` = `ZZ`$, 
so the third definition is applicable to it.
And since the third definition is more specific than the first two,
it satisfies the requirement of the meet rule.

The following set of overloaded declarations is also valid 
(given the declaration `ArrayList[\X\] <: List[\X\]`):

\small
`  bar[\X\]ArrayList[\X\]: ZZ
  bar[\Y <: ZZ\]List[\Y\]: ZZ
  bar[\Z <: ZZ\]ArrayList[\Z\]: ZZ`
\normalsize
The first two declarations are incomparable:
the first is applicable to `ArrayList[\T\]` for any type `T`,
the second to `List[\U\]` for `U <: ZZ`.
Thus, both declarations are applicable to any argument 
of type `ArrayList[\T\] CAP List[\U\]` 
for any `T` and `U <: ZZ`.
Since `ArrayList[\T\] <: List[\T\]`, 
this type is a subtype of `List[\T\] CAP List[\U\]`, 
which, because of multiple instantiation exclusion, 
is \Bottom\ unless $T \equiv U$,
in which case,
`ArrayList[\T\] CAP List[\U\] EQUIV ArrayList[\U\]`.
This is exactly the type to which the third declaration is applicable, 
so the meet rule is satisfied.

Note that this example is similar to the previous one with `min`
except that rather than having each of the two definitions 
being more restrictive on a type parameter, 
one uses a more specific type constructor.

Finally, we consider three examples do not involve generic types.
First consider the following declarations:

\small
`  bar[\X\](x: X): X
  bar(x: ZZ): ZZ
`
\normalsize
This pair of overloaded declarations is \emph{not} valid.
The second is strictly more specific, 
so the declarations satisfy the no duplicates and meet rules.
But they do \emph{not} satisfy the return type rule.
Consider, for example, 
an argument of type `NN <: ZZ`.
The second declaration
and the instantiation of the first declaration with `NN`
are both applicable to this argument,
but the return type `ZZ` of the second declaration 
is not a subtype of the return type `NN` of the instance of the first declaration.

\small
`  bar[\X\](x: X): ZZ = 1
  bar(x: Number): ZZ = 2
`
\normalsize
What do you get if you call `bar(2)`?


\small
`  bar[\X\](x: X): X
  bar[\X <: ZZ\](x: X): X
`
\normalsize




\TODO{Some stuff to mention?}
In a single-inheritance language (without parametric polymorphism?), 
the constructed types trivially form a meet semilattice: 
two types have a common nontrivial subtype 
only if one is a subtype of the other.
Thus, the tuple types and constructed types form a meet semilattice.
(But arrow types don't: 
the meet of `S->T` and `U->V` is \emph{not} an arrow type.)




