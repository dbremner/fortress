\TODO{Polish this section, add examples, 
and fix it so that it comes after the exclusion section 
rather than before.}

We now reconsider the overloaded generic function definitions from the introduction, 
and also some new ones, 
to see whether they are permitted by the rules in Section~\ref{sec:rules}.
In this section, 
we simply argue informally why each set of overloaded definitions is valid or not.
We give a formal system and algorithm for doing these checks 
in Section~\ref{sec:checking}.

First, we consider the overloaded generic functions 
from the introduction (in reverse order):

\small
`  foo[\X <: Object\](x: X, y: Object): ZZ = 1
  foo[\Y <: Number\](x: Number, y: Y): ZZ = 2`
\normalsize
This overloading is valid: 
The second definition is strictly more specific than the first 
because the first definition is applicable to a pair of arguments 
exactly if the type of each argument is a subtype of `Object`, 
whereas the second is applicable to a pair of arguments exactly if
the type of each argumet is a subtype of `Number`.
Thus, these definitions satisfy the no duplicates rule 
and the meet rule.
And they satisfy the subtype rule 
because the return type of both definitions is always `ZZ`.

\small
`  append[\X\](x: List[\X\], y: List[\X\]): List[\X\] = e1
  append[\X <: Number\](x: List[\X\], y: List[\X\]): List[\X\] = e3`
\normalsize
This overloading is also valid:
The first definition is applicable to any pair of arguments 
whose types are both `List[\T\]` for any well-formed type `T`, 
whereas the second is applicable to any such pair 
if and only if `T <: Number`.
Thus, the second definition is strictly more specific than the first, 
so the no duplicates rule and meet rule are satisfied.

\TODO{The following argument is wrong.}
To see that the subtype rule is satisfied, 
consider any pair of arguments to which the second definition is applicable.
It must be of type `(List[\T\],List[\T\])` for some `T <: Number`, 
and the return type is also type `List[\T\]`.
Because type constructors are invariant in their type parameters,\!\footnote{%
This overloading would also be valid if `List` were covariant, 
but such consideration is beyond the scope of this paper.}
the only instance of the first definition that is applicable to this argument 
is the instantiation with `T`, 
which also has return type `List[\T\]`.
\TODO{The return type rule is not satisfied without polymorphic exclusion.}


\small
`  append[\T\](x: List[\T\], y: List[\T\]): List[\T\] = e1
  append(x: List[\ZZ\], y: List[\ZZ\]): List[\ZZ\] = e2`
\normalsize
Although the second definition is strictly more specific than the first, 
this overloading is invalid:
it fails to satisfy the return type rule!
To see this, 
suppose `append` is called on an argument of type `List[\NN\]`, 
where `NN` is a subtype of `ZZ`.
In that case, 
both definitions are applicable, 
as is `append (List[\NN\], List[\NN\]): List[\NN\]`, 
the instantiation of the first definition with `NN`.
Thus, the return type rule is not satisfied 
since `append (List[\ZZ\], List[\ZZ\]): List[\ZZ\]` 
is the only instance of the second defintion, 
and `List[\ZZ\]` is not a subtype of `List[\NN\]`.\!\footnote{%
The type system described in this paper does not support covariance, 
so `List` is \emph{invariant} in its type parameter.
However, even if `List` were covariant,
this overloading would be invalid 
because `ZZ` is not a subtype of `NN`.}
This might be surprising at first, 
but a little thought shows that it is necessary to reject this overloading:
the function 


The second definition is strictly more specific than 
both the first and the third definitions: 
it is applicable only when the arguments are both of type `List[\ZZ\]`.
(But they don't satisfy the return type rule 
without polymorphic exclusion.)




\TODO{Some stuff to mention?}
In a single-inheritance language (without parametric polymorphism?), 
the constructed types trivially form a meet semilattice: 
two types have a common nontrivial subtype 
only if one is a subtype of the other.
Thus, the tuple types and constructed types form a meet semilattice.
(But arrow types don't: 
the meet of `S->T` and `U->V` is \emph{not} an arrow type.)

\TODO{Go over examples in intro, say which are valid and why.}

Also, reconsider example of overloading `append` 
with one generic definition and one monomorphic one.
This example is still not allowed 
(but the one with two generic definitions is).
The problem is that `ZZ` may have a subtype `NN`.
In that case, 
both definitions are applicable 
a call to `append` on two arguments of type `List[\NN\]` 
but the return type of the more specific monomorphic definition is `ZZ`, 
but the return type of the best instantiation of the generic definition is `NN`.





While the rules presented in Section~\ref{sec:rules} allow programmers to
write valid sets of overloaded generic function declarations,
they sometimes reject ````seemingly'' valid overloadings.
In fact, these are not false negatives;
many declarations that programmers would like to write are actually unsafe due to multiple inheritance.

For example, even though the following function declarations look like
a valid overloading, they are not because the Meet Rule is not satisfied:
`  simple String:String
  simple ZZ:ZZ`
Moreover, in Fortress it is impossible to disambiguate the declarations by providing the meet
because intersection types are not allowed in the Fortress syntax.
In a language with single inheritance, we might infer that these
overloadings were safe because a class can only have a single superclass.
However, due to multiple inheritance, we cannot be sure that these types
do not have a common subtype, no matter what the programmer intends.

Now consider this less trivial set of overloaded functions:
`  foo[\X <: Any\]ArrayList[\X\]:ZZ
  foo[\Y<: ZZ\]List[\Y\]:ZZ
  foo[\W<: ZZ\]ArrayList[\W\]:ZZ`
where `ArrayList[\T\] <: List[\T\]` for all types $T$.\footnote{We use this standard declaration for `ArrayList` throughout.}
The first two declarations are incomparable under specificity---%
the first declaration applies to all instantiations of type constructor `ArrayList`,
whereas the second declaration applies only to instantiations of
type constructor `List` with subtypes of type `ZZ`. The third definition,
which is the ````obvious" candidate to disambiguate the two, is not actually the meet;
the domain of this meet candidate is the existential type:
`  EXISTS[\W <: ZZ\]ArrayList[\W\]
`
and needs to be proven equivalent to the domain of the computed meet:
`  EXISTS[\X <: Any, Y <: ZZ\](ArrayList[\X\] CAP List[\Y\])
`
which requires that the latter be a subtype of the former.
However, there is no type `W <: ZZ` such that:
\\[.5em]
\hspace*{.5em}
%\jgsub[`X <: Any, Y <: ZZ`]{`ArrayList[\X\] CAP List[\Y\]`}{`ArrayList[\W\]`}
\ensuremath{
\begin{array}{l}
{`X <: Any, Y <: ZZ`}\,\vdash
\\
\quad\quad\quad\quad
{`ArrayList[\X\] CAP List[\Y\]`}\;{\subtypeof}\;{`ArrayList[\W\]`}
\end{array}
}
\\[.5em]
Our definition of the meet is not faulty: these declarations actually are unsafe.
Consider the (user-defined) constructed type:
`  BadList <: {ArrayList[\String\], List[\ZZ\]}
`
Our meet candidate is not applicable to `BadList`, but the two other definitions of `foo` are.
Since neither of those is more specific than the other,
this set of overloaded declarations must be rejected.



The following overloading example,
in which the second declaration is more specific than the first,
is also ill-formed:
`  tail[\X <: Any\]List[\X\]:List[\X\]
  tail[\Y <: Any\]ArrayList[\Y\]:ArrayList[\Y\]`
The declarations do not satisfy the Return Type Rule
because we cannot find a specific type `V <: Any` such that:
\\[.8em]
\begin{tabular}{lr}
%% \jgsub[`X <: Any, Y <: Any`]{`ArrayList[\V\] -> ArrayList[\V\]`}{`ArrayList[\Y\] CAP List[\X\] -> List[\X\]`}
\multicolumn{2}{l}{`X <: Any, Y <: Any` $\vdash$} \\
\quad\quad\quad\quad\quad\quad
&`ArrayList[\V\] -> ArrayList[\V\]` \\
&$\subtypeof$ `ArrayList[\Y\] CAP List[\X\] -> List[\X\]`
\end{tabular}
\\[.8em]
%% `X <: Any, Y <: Any` \; &\vdash `ArrayList[\V\] -> ArrayList[\V\]` \\
%% \;&\subtypeof\; `ArrayList[\Y\] CAP List[\X\] -> List[\X\]`
Once again, the type `BadList` proves that this set of overloaded declarations must be rejected. Consider the instance:
`  tail List[\ZZ\]:List[\ZZ\]
`
of the first declaration. We need to find an instance of the second declaration that is applicable to `BadList`
and has a return type that is a subtype of `List[\ZZ\]`,
but the only instance of the second declaration applicable to `BadList` is:
`  tail ArrayList[\String\]:ArrayList[\String\]
`
whose return type is not a subtype of `List[\ZZ\]`.
Therefore, this set of overloaded declarations must be rejected.
