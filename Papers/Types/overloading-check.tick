
In this section we describe how to mechanically check 
the three overloading rules from Section~\ref{sec:rules}. The
algorithm we describe does not check every possible valid set of overloaded
functions (according to the rule definitions), but it does accept
many desired overloadings, including all of the (valid) example overloadings
provided so far.
Thus we provide a sound but incomplete algorithm for determining that a
set of overloaded function declarations is valid.


Previously the notions of applicability and specificity for generic
declarations required an existential quantification over instances thereof.
We rephrase these definitions in terms of universal and existential types,
the generalizations of ````arrow type'' and ````domain type'' of generic
declarations, in the same manner as \cite{bourdoncle97}.


For a generic function declaration $d = \hdeclg{f}{\Delta}{S}{T}$,
its arrow type, written $\arrow(d)$, is
the \emph{universal type} \mbox{$\forall\ob{\Delta}S \rightarrow T$}.
A universal type binds type parameter declarations over some type and
can be instantiated by any types fitting the type parameters' bounds.
We write $\forall\tplist{X}{N}T$ to bind each type variable $X_i$ with bounds
$\{\bar{N_i}\}$ over the type $T$, and we use the metavariable $\sigma$ to range over universal types.


Moreover, the domain type of $d$, written $\dom(d)$, is the
\emph{existential type} $\exists\ob{\Delta}{S}$. An \emph{existential type}
also binds type parameter declarations over a type, 
but unlike a universal type, it cannot be instantiated; 
instead, it represents some hidden type instantiation 
and the corresponding instantiated type. We write
$\exists\tplist{X}{N}T$ to bind each type variable $X_i$ with bounds
$\{\bar{N_i}\}$ over the type $T$, and we use the metavariable $\delta$ to
range over existential types.

Note that universal and existential types are not actually \emph{types} in
our system. To distinguish between the different notions, we refer to types
$T$ as \emph{simple types} and the original subtyping relation $\subtypeof$ as
\emph{simple subtyping}. When the meaning is clear from context, we equate
both $\forall\ob{}T$ and $\exists\ob{}T$ with the simple type $T$. 

% \input{fig-application}

%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCE SUBTYPING!
\subsection{Universal and Existential Subtyping}
We define subtyping judgments for universal types and for existential types,
which we utilize in checking the overloading rules. We actually define inner
and outer subtyping judgments on universals and existentials; the former
corresponds to a relatively standard interpretation of each (which
resembles those defined in \cite{bourdoncle97}), while the latter
incorporates \emph{existential reduction}, defined in the next section.


\input{fig-existential}

The inner subtyping judgment on universals defined in
Figure~\ref{fig:existential}, 
$\jqsubinner{\sigma_1}{\sigma_2}$, stems from the notion of ````generic
instances'' from Hindley-Milner type systems \cite{damas82},
augmented with F-bounded quantification \cite{canning89,baldan99} to account
for type parameters that may appear in their bounds. The single rule
states that $\sigma_1$ is a subtype
of $\sigma_2$ if, in the environment extended by $\sigma_2$'s type parameters,
there exists an instantiation $\bar{V}$ of $\sigma_1$ such that the
constituent type of $\sigma_1$ is a (simple) subtype of the constituent type
of $\sigma_2$; in other words, $\sigma_1$ must be instantiated in $\sigma_2$'s
environment to a simple subtype of $\sigma_2$'s type.

The inner subtyping judgment on existentials also defined in
Figure~\ref{fig:existential}, $\jqsubinner{\delta_1}{\delta_2}$, is the
logical dual of that for universals. The rule states that $\delta_1$ is
a subtype of $\delta_2$ if $\delta_2$'s type parameters can be instantiated
in $\delta_1$'s environment such that its instantiated type is a simple
supertype of $\delta_1$'s type.

The outer subtyping judgments incorporate a single step of \emph{existential reduction} (Section~\ref{sec:exred}). Reduction on an existential type preserves the collective extent of all its instantiations---it is sound to include it in our definitions of universal and existential subtyping.
In the
existential subtyping judgment $\jqsub{\delta}{\delta}$ the l.h.s.
is reduced and its result is checked with the r.h.s. using the inner subtying judgment.
Its use in the universal subtyping judgment $\jqsub{\sigma}{\sigma}$ requires
a bit more explanation. We only use universal subtyping to compare
generic arrow types of the form $\arrow(d)$ for a generic function declaration
$d$. In this case, the r.h.s. arrow is reduced by reducing its
domain type $\dom(d) = \exttype[\Delta']{T}$, resulting not only in a new existential type $\exttype[\Delta'']{U}$ but
also a substitution $\phi$ mapping type variables from $\Delta'$
to types with variables in $\Delta''$. Before
appealing to the inner subtyping judgment, that substitution is
applied to $\arrow(d)$'s return type $T$. We will explain existential reduction in more detail in Section~\ref{sec:exred}.

These subtyping judgments offer a nice interpretation of applicability and
specificity of generic function declarations. Recall that a generic
function declaration $d = \hdeclg{f}{\Delta}{S}{T}$ is applicable to a type
$T$ if there is some instance $d'$ such that $T \subtypeof \dom(d')$.
Note the existential quantification over instances of the generic function
declaration. With our extended notion of domain type, we lift this
criterion to the level of existential types; observe the same existential
quantification over type instantiations $\bar{V}$ in the definition of
existential subtyping. We can
interpret the fact that a generic function declaration $d$ is applicable 
to a type $T$ with the existential subtyping assertion $\vdash T \le \dom(d)$. 
Furthermore, we interpret the fact that $d_1$ is more specific than
$d_2$ with the existential subtyping assertion
$\vdash \dom(d_1) \le \dom(d_2)$.

These interpretations are clearly correct with respect to the inner subtyping judgments. Shortly, we will show that the existential
reduction in the outer subtyping judgment does not upset these
interpretations. \TODO{(where exactly?)}


\input{fig-meet}


\subsection{Mechanically Checking the Rules}
With our interpretations of applicability and specificity into existential
subtyping, we now describe the process of checking the validity of a set of 
overloaded declarations $\Df$ according to the rules in
Section~\ref{sec:rules}.

We can check the No Duplicates Rule by verifying that for every pair of distinct function
declarations $d_1, d_2 \in \Df$ either $d_1 \not \ms d_2$ or $d_1 \not \ms d_2$. 

The Meet Rule requires that every pair of declarations $d_1, d_2 \in \Df$ has a meet in $\Df$. Thus, because
more specific relation on function declarations corresponds to the subtyping relation on existential types, we just
need to compute the meet $\dom(d_1) \wedge \dom(d_2)$ of the existential types $\dom(d_1)$ and $\dom(d_2)$ and search for a declaration
$d_0 \in \Df$ with $dom(d_0) \equiv \dom(d_1) \wedge \dom(d_2)$. Fortunately, computing the meet of two existential types is easily dones (see Figure~\ref{fig:meet}).

\begin{lemma}\label{lem:meet}
$\delta_1 \meet \delta_2$ is actually the meet of $\delta_1$ and $\delta_2$ under $\subtypeof$.
\end{lemma}
\begin{proof}
First we will show that $\delta_1 \meet \delta_2$ is the meet of $\delta_1$ and $\delta_2$ under $\subtypeofinner$. That $\delta_1 \meet \delta_2 \subtypeofinner \delta_1$ and $\delta_1 \meet \delta_2 \subtypeofinner \delta_2$ is obvious.
For any $\delta_0$, if $\bar{U}$ and $\bar{V}$ are instantiations that prove
$\delta_0 \subtypeofinner \delta_1$ and $\delta_0 \subtypeofinner \delta_1$, respectively,
then we can use the instantiation $\bar{U},\bar{V}$ to prove that $\delta_0 \subtypeof \delta_1 \meet \delta_2$.

Now we will show that the meet under $\subtypeofinner$ is also the meet under $\subtypeof$. Suppose that $\delta_0 \subtypeof \delta_1$, $\delta_0] \subtypeof \delta_1$
and $\delta_0 \eqred \reduce(\delta_0)$. A little work lets us deduce that $\reduce(\delta_0) \subtypeofinner \delta_1 \meet \delta_2$ and hence $\delta_0 \subtypeof \delta_1 \meet \delta_2$.
The fact that $\delta_1 \meet \delta_2 \subtypeof \delta_1$ and $\delta_1 \meet \delta_2 \subtypeof \delta_1$ follows from the fact that $\subtypeofinner$ implies $\subtypeof$.
\end{proof}

We can check the Return Type Rule using the subtype relation on universal types.
\begin{theorem}
Let $d_1 = \hdeclg{f}{\Delta_1}{S_1}{T_1}$ and $d_2 = \hdeclg{f}{\Delta_2}{S_2}{T_2}$ be declarations
in $\Df$ with $d_1 \ms d_2$. They satisfy the return type rule if and only if $\arrow(d_1)$ is a subtype of
the arrow type $\sigma_{meet} = \forall\ob{\Delta_1, \Delta_2}(S_1 \cap S_2) \rightarrow T_2$.
\end{theorem}

\begin{psketch}
First note that the pair $\sigma_meet$, $\arrow(d2)$ satisfies the return type rule. Now notice that
since $\arrow(d_1)$ and $\sigma_meet$ are equally specific
\end{psketch}



