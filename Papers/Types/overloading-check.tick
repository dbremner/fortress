
In this section we describe how to mechanically check 
the three overloading rules from Section~\ref{sec:rules}. The
algorithm we describe does not check every possible valid set of overloaded
functions (according to the rule definitions), but it does accept
many desired overloadings, including all of the (valid) example overloadings
provided so far.
Thus we provide a sound but incomplete algorithm for determining that a
set of overloaded function declarations is valid.


Previously the notions of applicability and specificity for generic
declarations required an existential quantification over instances thereof.
We rephrase these definitions in terms of universal and existential types,
the generalizations of ````arrow type'' and ````domain type'' of generic
declarations, in the same manner as \cite{bourdoncle97}.


For a generic function declaration $d = \hdeclg{f}{\Delta}{S}{T}$,
its arrow type, written $\arrow(d)$, is
the \emph{universal type} \mbox{$\forall\ob{\Delta}S \rightarrow T$}.
A universal type binds type parameter declarations over some type and
can be instantiated by any types fitting the type parameters' bounds.
We write $\forall\tplist{X}{N}T$ to bind each type variable $X_i$ with bounds
$\{\bar{N_i}\}$ over the type $T$, and we use the metavariable $\sigma$ to range over universal types.


Moreover, the domain type of $d$, written $\dom(d)$, is the
\emph{existential type} $\exists\ob{\Delta}{S}$. An \emph{existential type}
also binds type parameter declarations over a type, 
but unlike a universal type, it cannot be instantiated; 
instead, it represents some hidden type instantiation 
and the corresponding instantiated type. We write
$\exists\tplist{X}{N}T$ to bind each type variable $X_i$ with bounds
$\{\bar{N_i}\}$ over the type $T$, and we use the metavariable $\delta$ to
range over existential types.

Note that universal and existential types are not actually \emph{types} in
our system. To distinguish between the different notions, we refer to types
$T$ as \emph{simple types} and the original subtyping relation $\subtypeof$ as
\emph{simple subtyping}. When the meaning is clear from context, we equate
both $\forall\ob{}T$ and $\exists\ob{}T$ with the simple type $T$. 

% \input{fig-application}

%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCE SUBTYPING!
\subsection{Universal and Existential Subtyping}
We define subtyping judgments for universal types and for existential types,
which we utilize in checking the overloading rules. We actually define inner
and outer subtyping judgments on universals and existentials; the former
corresponds to a relatively standard interpretation of each (which
resembles those defined in \cite{bourdoncle97}), while the latter
incorporates \emph{quantifier reduction}, defined in the next section.


\input{fig-existential}

The inner subtyping judgment on universals defined in
Figure~\ref{fig:existential}, 
$\jleinner{\sigma_1}{\sigma_2}$, stems from the notion of ````generic
instances'' from Hindley-Milner type systems \cite{damas82},
augmented with F-bounded quantification \cite{canning89,baldan99} to account
for type parameters that may appear in their bounds. The single rule
states that $\sigma_1$ is a subtype
of $\sigma_2$ if, in the environment extended by $\sigma_2$'s type parameters,
there exists an instantiation $\bar{V}$ of $\sigma_1$ such that the
constituent type of $\sigma_1$ is a (simple) subtype of the constituent type
of $\sigma_2$; in other words, $\sigma_1$ must be instantiated in $\sigma_2$'s
environment to a simple subtype of $\sigma_2$'s type.

The inner subtyping judgment on existentials also defined in
Figure~\ref{fig:existential}, $\jleinner{\delta_1}{\delta_2}$, is the
logical dual of that for universals. The rule states that $\delta_1$ is
a subtype of $\delta_2$ if $\delta_2$'s type parameters can be instantiated
in $\delta_1$'s environment such that its instantiated type is a simple
supertype of $\delta_1$'s type.


In the outer subtypinf judgment $\jle{\delta}{\delta'}$, we first perform \emph{existential reduction} to produce $\reduce{\delta}$. Then we check whether $\jleinner{\reduce{\delta}}{\delta'}$.
We provide the rules for existential reduction in Section~\ref{sec:exred}, but the judgment $\jtred{\delta}{\reduce{\delta}}$ is with the following properties:
\begin{enumerate}
\item $\jleinner{\reduce{\delta}}{\delta}$
\item $\jleinner{\delta}{\delta'} implies \jleinner{\reduce{\delta}}{\reduce{\delta'}}$
\item $\reduce{(\reduce{\delta}) = \reduce{\delta}}$
\item $\reduce{\exttype[]{T}} = \exttype[]{T}$
\end{enumerate}
The first three properties show that $\le$ is a preorder and that $\leinner$ implies $\le$.
Adding the fourth property lets us show that any ground instance $T$ of $\delta$ with $T \neq \Bottom$ is an instance of $\reduce(\delta)$


Dually, in the universal subtyping judgment $\jle{\sigma}{\sigma'}$ we first perform $\emph{universal reduction}$ to produce $\reduce{\reduce{\sigma'}}$. Then we check whether
$\jleinner{\sigma}{\sigma''}$
\item $\jleinner{\reduce{\sigma}}{\reduce{\sigma}}$
\item $\jleinner{\sigma}{\sigma'} implies \jleinner{\reduce{\sigma}}{\reduce{\sigma'}}$
\item $\reduce{(\reduce{\sigma}) = \reduce{\sigma}}$
\item $\reduce{\unitype[]{\arrowtype{S}{T}}} = \unitype[]{\arrowtype{S}{T}}$
\end{enumerate}
Again the first three properties show that $\le$ is a preorder and that $\lteinner$ implies $\le$.
Adding the fourth property lets us show that any ground instance $\arrowtype{S}{T}$ of $\delta$ with $S \neq \Bottom$ is an instance of $\reduce{\sigma}$.

We explain how to compute generic reductions in in Section~\ref{sec:exred}.

\input{fig-meet}

\subsection{Mechanically Checking the Rules}
With our interpretations of applicability and specificity into existential
subtyping, we now describe the process of checking the validity of a set of 
overloaded declarations $\Df$ according to the rules in
Section~\ref{sec:rules}.

We can check the No Duplicates Rule by verifying that for every pair of distinct function
declarations $d_1, d_2 \in \Df$ either $d_1 \not \ms d_2$ or $d_1 \not \ms d_2$. 

The Meet Rule requires that every pair of declarations $d_1, d_2 \in \Df$ 
has a meet in $\Df$. 
Because the more specific relation on function declarations 
corresponds to the subtyping relation on the (existential) domain types,
we just need to find a declaration $d_0 \in \Df$ 
whose domain type $dom(d_0)$ 
is equivalent to the meet (under $\le$) 
of the existential types $\dom(d_1)$ and $\dom(d_2)$.
Figure~\ref{fig:meet} shows how to compute the meet of two existential types.

\begin{lemma}\label{lem:meet}
$\delta_1 \meet \delta_2$ (as defined in Figure~\ref{fig:meet}) 
is the meet of $\delta_1$ and $\delta_2$ under $\le$.
\end{lemma}
\begin{proof}
First we show that $\delta_1 \meet \delta_2$ is the meet of $\delta_1$ and $\delta_2$ under $\leinner$. That $\delta_1 \meet \delta_2 \leinner \delta_1$ and $\delta_1 \meet \delta_2 \leinner \delta_2$ is obvious.
For any $\delta_0$, if $\bar{U}$ and $\bar{V}$ are instantiations that prove
$\delta_0 \leinner \delta_1$ and $\delta_0 \leinner \delta_2$, respectively,
then we can use the instantiation $\bar{U},\bar{V}$ to prove that $\delta_0 \le \delta_1 \meet \delta_2$.

Now we show that the meet under $\leinner$ is also the meet under $\le$. Suppose that $\delta_0 \le \delta_1$, $\delta_0 \le \delta_1$,
and $\jtred{\delta_0}{\delta'_0}$. A little work lets us deduce that $\delta'_0 \leinner \delta_1 \meet \delta_2$ and hence $\delta_0 \le \delta_1 \meet \delta_2$.
The fact that $\delta_1 \meet \delta_2 \le \delta_1$ and $\delta_1 \meet \delta_2 \le \delta_2$ follows from the fact that $\leinner$ implies $\le$.
\end{proof}

We can check the Return Type Rule using the subtype relation on universal types.
\begin{theorem}
Let $d_1 = \hdeclg{f}{\Delta_1}{S_1}{T_1}$ and $d_2 = \hdeclg{f}{\Delta_2}{S_2}{T_2}$ be declarations
in $\Df$ with $d_1 \ms d_2$. They satisfy the Return Type Rule if and only if $\arrow(d_1)$ is a subtype of
the arrow type $\sigma_{\wedge} = \forall\ob{\Delta_1, \Delta_2}(S_1 \cap S_2) \rightarrow T_2$.
\end{theorem}

\begin{proof}
Note that $arrow(d_1)$ and $\sigma_{\wedge}$ are equally specific, and that $arrow(d_1) \le \sigma_{\wedge}$ implies that for every instance $\arrowtype{U}{V}$ of $\sigma_{\wedge}$ with $U \not \equiv \Bottom$
we can find an instance $\arrowtype{U_1}{V_1}$ of $\arrow(d_1)$ with $U \subtypeof U_1$ and $V_1 \subtypeof V$. Thus the pair $d_1, d_2$ satisfies the Return Type Rule if
the pair $\sigma_{\wedge}, d_2$\footnote{As an abuse of notation we use $\sigma_\wedge$ here to mean an illusory overloading of $f$, $d_\wedge$, such that $arrow(d_\wedge) = \sigma_\wedge$.} does. This is clear because $\sigma_{\wedge}$ can match the return type of any instance of $d_2$ whose domain type is not $\Bottom$.
\end{proof}



