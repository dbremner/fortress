To provide more expressive power to describe richer type relationships,
we augment our formalism with an \emph{exclusion} relation $\exc$ on types:
$S \exc T$ asserts that types $S$ and $T$ have no common subtypes other than \BottomType.
This allows us to describe explicitly what is typically only implicit in single-inheritance
class hierarchies.

We define the exclusion relation by extending type constructor declarations with
two new optional clauses, `excludes` and `comprises`:
\[
C\tplist{X}{M} \extends `{N_bar} [excludes {L_bar}] [comprises {K_bar}]`
\]
We also allow another form of declaration that is frequently convenient for defining ````leaf types'':
\[
`object` \; C\tplist{X}{M} \extends `{N_bar}`
\]

% The `excludes` clause explicitly states that
% the intersection of any application `C[\T_bar\]` of type constructor `C`
% and any of `L_bar` is `BottomType` 
% (i.e., 
% `C[\T_bar\] CAP [T_bar / X_bar]M[i] EQUIV BottomType` 
% for any `T_bar` and for each `L[i]` in `L_bar`).
% This implies, of course, 
% that any subtype of `C[\T_bar\]` also excludes 
% `[T_bar / X_bar] L[i]`.
% The `comprises` clause stipulates that
% an application of type constructor `C` with `T_bar`
% consists of exactly the types in `K_bar` that are instantiated with `T_bar`
% (i.e., 
% `C[\T_bar\] EQUIV [T_bar / X_bar]K[1]` $\cup \ldots \cup$ `[T_bar / X_bar] K[n]`).
% Thus, if a type excludes `[T_bar / X_bar]K[i]` for each $i$, then it
% also necessarily excludes `C[\T_bar\]`.
%
The exclusion relation on constructed types can then be described in terms of
more precise sub-relations on those types, each of which corresponds to a certain
reason for (or proof of) exclusion:
\begin{enumerate}
  \item The `excludes` clause explicitly states that
the constructed type `C[\T_bar\]`
excludes $\substb{T}{X}L_i$ for each $L_i$ in $\bar{L}$, which
implies that any subtype of `C[\T_bar\]` also excludes
each $\substb{T}{X}L_i$. We write this exclusion sub-relation as
$C\obb{T} \,\excre\, \substb{T}{X}L_i$.

\item The `comprises` clause stipulates that any subtype of `C[\T_bar\]` 
\emph{must} be a subtype of `[T_bar / X_bar]K[i]` for some `K[i]` in `K_bar`. 
Then if every `[T_bar / X_bar]K[i]` in `K_bar` excludes some type $U$, 
`C[\T_bar\]` must also exclude $U$. 
We write this exclusion sub-relation as $C\obb{T} \,\excrc\, U$.
  
\item The `object` keyword denotes a type constructor 
whose applications have no nontrivial subtypes; 
an `object` type constructor is a leaf of the class hierarchy. 
Since such a constructed type `C[\T_bar\]` has no subtypes 
other than itself and \BottomType, 
we know that it excludes any type `U` other than its supertypes. 
We write this exclusion sub-relation as $C\obb{T} \,\excro\, U$.
\end{enumerate}
We take the symmetric closure of each of these relations 
to get the relations $\exce$, $\excc$ and $\exco$.
Exclusion between constructed types is informally defined as the union
of these symmetric relations.
(We introduce another sub-relation $\excp$ in Section~\ref{sec:exc-polyrules}.)

We can extend the exclusion relation 
to structural and compound types as follows:
Every arrow type excludes every non-arrow type.
Every singleton tuple type excludes exactly those types excluded by its element type.
Every non-singleton tuple type excludes every non-tuple type.
Tuple type $(\bar{V})$ excludes $(\bar{W})$ if either $|\bar{V}| \neq |\bar{W}|$
or $V_i$ excludes $W_i$ for some $i$. An intersection type excludes any type excluded by \emph{any} of its constituent types, 
while a union type excludes any type excluded by \emph{all} of its constituent types.
$\BottomType$ excludes every type (including itself---it is the only type 
that excludes itself), 
and $\Any$ does not exclude any type other than $\BottomType$.
(We define the exclusion relation formally in Figure~\ref{fig:jexc}
in Section~\ref{sec:constraints}.)

We augment our notion of a well-formed class table 
to require that the subtyping and exclusion relations it induces 
````respect'' each other.
That is, for all constructed types $M$ and $N$:
\begin{enumerate}
\item  If $M$ excludes $N$ then $M$ must not be a subtype of $N$.

\TODO{Following two points should be about instantiations.}
% FUTURE FIX REQUIRED:
% Technically the following two statements should be about instantiations
% of what is in a comprises clause.
% Leaving this for now, but we should fix it.

\item 
If $N \subtypeof M$ and $M$ has a `comprises` clause,
then there is some constructed type $K$ in the `comprises` clause of $M$
such that $N \subtypeof K$.

\item
If the type constructor $C$ is declared as an `object`, then its `comprises`
clause must be empty, and there is no other constructed type $N$ such that
$N \subtypeof C\obb{T}$ for any types $\bar{T}$.

\end{enumerate}
As with the subtyping relation, 
a valid extension to a class table $\T$ 
must preserve these well-formedness properties.

For convenience, 
we allow the `excludes` and `comprises` clauses to be omitted.
Omitting an `excludes` clause is equivalent to having `excludes {}`;
omitting a `comprises` clause is equivalent to having `comprises { Any }`.\footnote{For
the sake of catching likely programming errors, the Fortress language requires that every $K_i$
in a `comprises` clause for $C\obb{T}$ be a subtype of $C\obb{T}$, but allowing
`Any` to appear in a `comprises` clause simplifies our presentation here.}
We define the sets of instantiations of the types 
in these clauses analogously to $\myextends{C\obb{T}}$.
That is, 
for an application $C\obb{T}$ 
of a declaration with the `excludes` and/or `comprises` clause above,\\[-.2em]
\begin{align*}
\myexcludes{C\obb{T}}  &= \{ \bar{\substb{T}{X}M} \} \\
\mycomprises{C\obb{T}} &= \{ \bar{\substb{T}{X}K} \}
\end{align*}


\subsection{Overloading Rule with Exclusion}\label{sec:exc-rules}

\TODO{This section should go away.}
\TODO{Meld into previous and rules sections.}

If the parameter types of a set of overloaded functions are disjoint,
the set does not introduce ambiguity: they are never applicable to the same call.
Therefore, to allow the function `simple` as a valid overloading,
any ````reasonable" class table $\T$ that declares types `ZZ` and `String` would also
declare one to exclude the other, so \hbox{`ZZ` $\exc$ `String`}.

However, the Meet Rule still requires a third declaration in $\D(`simple`)$ that is applicable
to every type $T$ if and only if $`simple`_1$ and $`simple`_2$ are applicable to $T$.
Such $T$ would necessarily be a subtype of both `ZZ` and `String`, but since
these types exclude, no such $T$ exists (in $\T$ or in any extension thereof).
We thus augment every collection of overloaded function declarations $\D$ such
that each $\D(f)$ includes an additional, implicit declaration $\decl{f_\bot}{\BottomType}{\Any}$.
This declaration is trivially more specific than any declaration possibly written
by a programmer, but it does not conflict with overloading safety since it is
only applicable to \BottomType.

With $`simple`_\bot$ implicitly part of $\D(`simple`)$, the two `simple`
declarations \emph{almost} satisfy the Meet Rule: the checker now must verify
that $\textit{dom}(`simple`_\bot)$, \BottomType, is equivalent to the computed meet,
`String CAP ZZ`. Therefore we augment our judgment for the subtype relation
with the rule necessary for constructing this equivalence:
\infrule
{S \;\exc\; T}
{\Delta \vdash S \cap T <: \BottomType}
With these adjustments, $\D(`simple`)$ is now a valid overloading.
