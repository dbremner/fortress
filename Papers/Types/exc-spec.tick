To incorporate exclusion into our type system, 
we make two kinds of changes.
First, we augment type constructor declarations 
with two additional (optional) clauses, 
the `excludes` clause and the `comprises` clause, 
and we add a new kind of type constructor declaration, 
the `object` declaration.
Second, 
we change the definition of well-formed class tables 
to reflect the new features, 
and also to enforce multiple instantiation exclusion.

A type constructor declaration has two optional clauses, 
an `excludes` clause and a `comprises` clause, 
each of which specifies a list of types.
The new syntax is as follows:
\[
C\tplist{X}{M} \extends `{N_bar} [excludes {L_bar}] [comprises {K_bar}]`
\]

This declaration asserts that for well-formed type `C[\T_bar\]`, 
the only common subtype of `C[\T_bar\]` 
and $\substb{T}{X}L_i$ for any $L_i$ in $\bar{L}$ 
is \BottomType, 
and any strict subtype of `C[\T_bar\]` 
must also be a subtype of $\substb{T}{X}K_i$ for some $K_i$ in $\bar{K}$.

% The `excludes` clause asserts that
% the intersection of any application `C[\T_bar\]` of type constructor `C`
% and any of `L_bar` is `BottomType` 
% (i.e., 
% `C[\T_bar\] CAP [T_bar / X_bar]M[i] EQUIV BottomType` 
% for any `T_bar` and for each `L[i]` in `L_bar`).
% This implies, of course, 
% that any subtype of `C[\T_bar\]` also excludes 
% `[T_bar / X_bar] L[i]`.

% The `comprises` clause stipulates that
% an application of type constructor `C` with `T_bar`
% consists of exactly the types in `K_bar` that are instantiated with `T_bar`
% (i.e., 
% `C[\T_bar\] EQUIV [T_bar / X_bar]K[1]` $\cup \ldots \cup$ `[T_bar / X_bar] K[n]`).
% Thus, if a type excludes `[T_bar / X_bar]K[i]` for each $i$, then it
% also necessarily excludes `C[\T_bar\]`.

A class table may also include `object` declarations, 
which have the following syntax:
\[
`object` \; C\tplist{X}{M} \extends `{N_bar}`
\]
This declaration is convenient for defining ````leaf types'': 
it asserts that `C[\T_bar\]` has no subtypes 
other than itself and \BottomType.

As mentioned previously, 
multiple instantiation exclusion 
adds an additional restriction for all generic types: 
Two distinct instantiations of a generic type 
(i.e., distinct applications of the type constructor) 
have no common subtype other than \BottomType.

To define well-formedness for class tables with exclusion 
(including multiple instantiation exclusion),
we derive an \emph{exclusion relation} $\exc$ over well-formed types.


Except for the imposition of multiple instantation exclusion, 
these changes are generalizations of the standard type system 
described in Section~\ref{sec:pre}: 
A class table that does not use any of the new features 
is well-formed in this augmented system 
exactly when it is well-formed in the standard system.
On the other hand, 
multiple instantiation exclusion
restricts the set of well-formed class tables: 
a table that is well-formed when multiple instantiation inheritance is permitted
might not be well-formed under multiple instantiation exclusion.



We represent the new restrictions on well-formedness 
using an \emph{exclusion relation} $\exc$ on types.
$S \exc T$ asserts that 
types $S$ and $T$ have no common subtypes other than \BottomType.
This allows us to describe explicitly what is 
typically implicit in single-inheritance class hierarchies.

\TODO{Most of the following should be moved to Section~\ref{sec:constraints}, 
as part of an explanation of those rules.
But enough should be retained that a knowledgeable reader 
should be able to construct those rules on his/her own, 
at least the version without constraints.}

The exclusion relation on constructed types can then be described in terms of
more precise sub-relations on those types, each of which corresponds to a certain
reason for (or proof of) exclusion:
\begin{enumerate}

\item The `excludes` clause explicitly states that
the constructed type `C[\T_bar\]`
excludes $\substb{T}{X}L_i$ for each $L_i$ in $\bar{L}$, which
implies that any subtype of `C[\T_bar\]` also excludes
each $\substb{T}{X}L_i$. We write this exclusion sub-relation as
$C\obb{T} \,\excre\, \substb{T}{X}L_i$.

\item The `comprises` clause stipulates that any subtype of `C[\T_bar\]` 
\emph{must} be a subtype of `[T_bar / X_bar]K[i]` for some `K[i]` in `K_bar`. 
Then if every `[T_bar / X_bar]K[i]` in `K_bar` excludes some type $U$, 
`C[\T_bar\]` must also exclude $U$. 
We write this exclusion sub-relation as $C\obb{T} \,\excrc\, U$.
  
\item The `object` keyword denotes a type constructor 
whose applications have no nontrivial subtypes; 
an `object` type constructor is a leaf of the class hierarchy. 
Since such a constructed type `C[\T_bar\]` has no subtypes 
other than itself and \BottomType, 
we know that it excludes any type `U` other than its supertypes. 
We write this exclusion sub-relation as $C\obb{T} \,\excro\, U$.

\end{enumerate}

We take the symmetric closure of each of these relations 
to get the relations $\exce$, $\excc$ and $\exco$.
Exclusion between constructed types is informally defined as the union
of these symmetric relations.
(We introduce another sub-relation $\excp$ in Section~\ref{sec:exc-polyrules}.)

\TODO{Add in stuff for multiple instantiation exclusion.}

We can extend the exclusion relation 
to structural and compound types as follows:
Every arrow type excludes every non-arrow type.
Every singleton tuple type excludes exactly those types excluded by its element type.
Every non-singleton tuple type excludes every non-tuple type.
Tuple type $(\bar{V})$ excludes $(\bar{W})$ if either $|\bar{V}| \neq |\bar{W}|$
or $V_i$ excludes $W_i$ for some $i$. An intersection type excludes any type excluded by \emph{any} of its constituent types, 
while a union type excludes any type excluded by \emph{all} of its constituent types.
$\BottomType$ excludes every type (including itself---it is the only type 
that excludes itself), 
and $\Any$ does not exclude any type other than $\BottomType$.
(We define the exclusion relation formally in Figure~\ref{fig:jexc}
in Section~\ref{sec:constraints}.)

We augment our notion of a well-formed class table 
to require that the subtyping and exclusion relations it induces 
````respect'' each other.
That is, for all constructed types $M$ and $N$:
\begin{enumerate}
\item  If $M$ excludes $N$ then $M$ must not be a subtype of $N$.

\TODO{Following two points should be about instantiations.}
% FUTURE FIX REQUIRED:
% Technically the following two statements should be about instantiations
% of what is in a comprises clause.
% Leaving this for now, but we should fix it.

\item 
If $N \subtypeof M$ and $M$ has a `comprises` clause,
then there is some constructed type $K$ in the `comprises` clause of $M$
such that $N \subtypeof K$.

\item
If the type constructor $C$ is declared as an `object`, then its `comprises`
clause must be empty, and there is no other constructed type $N$ such that
$N \subtypeof C\obb{T}$ for any types $\bar{T}$.

\end{enumerate}
As with the subtyping relation, 
a valid extension to a class table $\T$ 
must preserve these well-formedness properties.

For convenience, 
we allow the `excludes` and `comprises` clauses to be omitted.
Omitting an `excludes` clause is equivalent to having `excludes {}`;
omitting a `comprises` clause is equivalent to having `comprises { Any }`.\footnote{For
the sake of catching likely programming errors, the Fortress language requires that every $K_i$
in a `comprises` clause for $C\obb{T}$ be a subtype of $C\obb{T}$, but allowing
`Any` to appear in a `comprises` clause simplifies our presentation here.}
We define the sets of instantiations of the types 
in these clauses analogously to $\myextends{C\obb{T}}$.
That is, 
for an application $C\obb{T}$ 
of a declaration with the `excludes` and/or `comprises` clause above,\\[-.2em]
\begin{align*}
\myexcludes{C\obb{T}}  &= \{ \bar{\substb{T}{X}L} \} \\
\mycomprises{C\obb{T}} &= \{ \bar{\substb{T}{X}K} \}
\end{align*}

\subsection{Overloading Rule with Exclusion}\label{sec:exc-rules}

\TODO{This section should go away.}
\TODO{Meld into previous and rules sections.}

If the parameter types of a set of overloaded functions are disjoint,
the set does not introduce ambiguity: they are never applicable to the same call.
Therefore, to allow the function `simple` as a valid overloading,
any ````reasonable" class table $\T$ that declares types `ZZ` and `String` would also
declare one to exclude the other, so \hbox{`ZZ` $\exc$ `String`}.

However, the Meet Rule still requires a third declaration in $\D(`simple`)$ that is applicable
to every type $T$ if and only if $`simple`_1$ and $`simple`_2$ are applicable to $T$.
Such $T$ would necessarily be a subtype of both `ZZ` and `String`, but since
these types exclude, no such $T$ exists (in $\T$ or in any extension thereof).
We thus augment every collection of overloaded function declarations $\D$ such
that each $\D(f)$ includes an additional, implicit declaration $\decl{f_\bot}{\BottomType}{\Any}$.
This declaration is trivially more specific than any declaration possibly written
by a programmer, but it does not conflict with overloading safety since it is
only applicable to \BottomType.

With $`simple`_\bot$ implicitly part of $\D(`simple`)$, the two `simple`
declarations \emph{almost} satisfy the Meet Rule: the checker now must verify
that $\textit{dom}(`simple`_\bot)$, \BottomType, is equivalent to the computed meet,
`String CAP ZZ`. Therefore we augment our judgment for the subtype relation
with the rule necessary for constructing this equivalence:
\infrule
{S \;\exc\; T}
{\Delta \vdash S \cap T <: \BottomType}
With these adjustments, $\D(`simple`)$ is now a valid overloading.

