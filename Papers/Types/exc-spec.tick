To provide more expressive power to describe richer type relationships,
we introduce the \emph{exclusion} relation $\exc$ on types:
$S \exc T$ asserts that types $S$ and $T$ have no common subtypes other than \BottomType.

We define the exclusion relation by extending type constructor declarations with
two new optional clauses, `excludes` and `comprises`:
\[
C\tplist{X}{L} \extends `{N_bar} [excludes {M_bar}] [comprises {K_bar}]`
\]
We also allow another form of declaration that is frequently convenient for defining ````leaf types'':
\[
`object` \; C\tplist{X}{L} \extends `{N_bar}`
\]

% The `excludes` clause explicitly states that
% the intersection of any application `C[\T_bar\]` of type constructor `C`
% and any of `M_bar` is `BottomType` 
% (i.e., 
% `C[\T_bar\] CAP [T_bar / X_bar]M[i] EQUIV BottomType` 
% for any `T_bar` and for each `M[i]` in `M_bar`).
% This implies, of course, 
% that any subtype of `C[\T_bar\]` also excludes 
% `[T_bar / X_bar] M[i]`.
% The `comprises` clause stipulates that
% an application of type constructor `C` with `T_bar`
% consists of exactly the types in `K_bar` that are instantiated with `T_bar`
% (i.e., 
% `C[\T_bar\] EQUIV [T_bar / X_bar]K[1]` $\cup \ldots \cup$ `[T_bar / X_bar] K[n]`).
% Thus, if a type excludes `[T_bar / X_bar]K[i]` for each $i$, then it
% also necessarily excludes `C[\T_bar\]`.
%
The exclusion relation on constructed types can then be informally described as the combination of
more precise sub-relations on those types that each corresponds to a certain
reason, or proof, of exclusion:
\begin{enumerate}
  \item The `excludes` clause explicitly states that
the constructed type `C[\T_bar\]`
excludes $\substb{T}{X}M_i$ for each $M_i$ in $\bar{M}$, which
implies that any subtype of `C[\T_bar\]` also excludes
each $\substb{T}{X}M_i$. We write this exclusion sub-relation as
$C\obb{T} \,\excre\, \substb{T}{X}M_i$.

  \item The `comprises` clause stipulates that any subtype of `C[\T_bar\]` \emph{must} be a subtype of `[T_bar / X_bar]K[i]` for some `K[i]` in `K_bar`. Then if every `[T_bar / X_bar]K[i]` in `K_bar` excludes some type $U$, `C[\T_bar\]` must also exclude $U$. We write this exclusion sub-relation as $C\obb{T} \,\excrc\, U$.
  
  \item The `object` keyword denotes a type constructor whose applications have no non-trivial subtypes; an `object` type constructor is a leaf of the class table. Since such a constructed type `C[\T_bar\]` has no subtypes other than itself and \BottomType, we know that it excludes any type `U` of which it is not a subtype. We write this exclusion sub-relation as $C\obb{T} \,\excro\, U$.
\end{enumerate}
Exclusion between constructed types is informally defined as the union
of the sub-relations $\excre$, $\excrc$, and $\excro$. (We shall
introduce another sub-relation $\excrp$ later in this section.)
Omitting an `excludes` clause is equivalent to have `excludes {}`, and
omitting a `comprises` clause is equivalent to have `comprises { Any }`.\footnote{For
the sake of catching likely programming errors, the Fortress language requires that every $K_i$
in a `comprises` clause for $C\obb{T}$ be a subtype of $C\obb{T}$, but allowing
`Any` to appear in a `comprises` clause simplifies our presentation here.}
For an application $C\obb{T}$ 
of a declaration with the `excludes` and/or `comprises` clause above, 
we define the sets of instantiations of the types 
in these clauses analogously to $\myextends{C\obb{T}}$.
That is,\\[-.2em]
\[
\begin{array}{rl}
\myexcludes{C\obb{T}}  =& \{ \bar{\substb{T}{X}M} \} \\
\mycomprises{C\obb{T}} =& \{ \bar{\substb{T}{X}K} \}
\end{array}
\]

The exclusion relation induced by a class table on all its types
is then the symmetric closure of the relation 
derived from the constructed types as described above, 
extended to structural and compound types as follows:
Every arrow type excludes every non-arrow type.
Every singleton tuple type excludes exactly those types excluded by its element type.
Every non-singleton tuple type excludes every non-tuple type 
and also every tuple type with a different number of element types.
An intersection type excludes any type excluded by \emph{any} of its constituent types, 
while a union type excludes any type excluded by \emph{all} of its constituent types.
$\BottomType$ excludes every type (including itself---it is the only type 
that excludes itself), 
and $\Any$ does not exclude any type other than $\BottomType$.
(Later in Section~\ref{sec:constraints}, we shall define the exclusion
relation formally in Figure~\ref{fig:jexc}.)
We augment our notion of a well-formed class table 
to require that the subtyping and exclusion relations it induces 
````respect'' each other.
That is, for all constructed types $M$ and $N$ other than \BottomType, 
\begin{enumerate}
\item  If $M$ excludes $N$ then $M$ must not be a subtype of $N$.

% FUTURE FIX REQUIRED:
% Technically the following two statements should be about instantiations
% of what is in a comprises clause.
% Leaving this for now, but we should fix it.

\item 
If $N \subtypeof M$ and $M$ has a `comprises` clause,
then there is some constructed type $K$ in the `comprises` clause of $M$
such that $N \subtypeof K$.

\item
If the type constructor $C$ is declared as an `object`, then its `comprises`
clause must be empty, and there is no other constructed type $N$ such that
$N \subtypeof C\obb{T}$ for any types $\bar{T}$.

\end{enumerate}
As with the subtyping relation, 
a valid extension to a class table $\T$ 
must preserve these well-formedness properties.



\subsection{Overloading Rule with Exclusion}\label{sec:exc-rules}
If the parameter types of a set of overloaded functions are disjoint,
the set does not introduce ambiguity: they are never applicable to the same call.
Therefore, to allow the function `simple` as a valid overloading,
any reasonable class table $\T$ that declares types `ZZ` and `String` would also
declare one to exclude the other, so \hbox{`ZZ` $\exc$ `String`}.

However, the Meet Rule still requires a third declaration in $\D(simple)$ that is applicable
to every type $T$ if and only if $simple_1$ and $simple_2$ are applicable to $T$.
Such $T$ would necessarily be a subtype of both `ZZ` and `String`, but since
these types exclude, no such $T$ exists (in $\T$ or in any extension thereof).
We thus augment every collection of overloaded function declarations $\D$ such
that each $\D(f)$ includes an additional, implicit declaration $\decl{f_\bot}{\BottomType}{\Any}$.
This declaration is trivially more specific than any declaration possibly written
by a programmer, but it does not conflict with overloading safety since it is
only applicable to \BottomType.

With $simple_\bot$ implicitly part of $\D(simple)$, the two `simple`
declarations \emph{almost} satisfy the Meet Rule: the checker now must verify
that $dom(simple_\bot)$, \BottomType, is equivalent to the computed meet,
`String CAP ZZ`. Therefore we augment our judgment for the subtype relation
with the rule necessary for constructing this equivalence:
\infrule
{S \;\exc\; T}
{\Delta \vdash S \cap T <: \BottomType}
With these adjustments, $\D(simple)$ is now a valid overloading.