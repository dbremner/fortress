The Haskell 98 definition \cite{haskell98} prevents two instances of the same
class from containing the same type.  The prevalent Glasgow Haskell Compiler (GHC),
however, allows such \emph{overlapping instances} among other commonplace
type class features \cite[\S 7.6]{ghc}.  With this feature,
one can write default and specialized implementations of class methods.
For example, the following code for counting things: \begin{ttquote}class Things a where
    things :: a -> Int

instance Things a where      -- (1)
    things _ = 1
instance Things [a] where    -- (2)
    things xs = length xs
instance Things String where -- (3)
    things _ = 1

f :: [b] -> Int
f x = things x
\end{ttquote}
includes overlapping instances of \mono{Things}.
The instances (2) and (3) overlap because \mono{String} is a synonym for \mono{[Char]},
and clearly both overlap with the fully general instance (1).
Instance (3) is included to guarantee that \mono{things s = 1}
for any string (i.e. list of characters) \mono{s}.

One might expect \mono{(f "foo")} to evaluate to \mono{1}, but instead it evaluates to \mono{3}. When GHC checks the call of \mono{things} inside the body of \mono{f}, it must find evidence for the constraint \mono{(Things [b])} generated by applying \mono{things} to an expression of type \mono{[b]}.
If \mono{f}'s signature denoted the constraint \mono{(Things [b])} as an assumption,
such evidence clearly exists; without that assumption, as is the case here,
the evidence can only be provided by the declared instances.
Thus, GHC resolves this call with the most fitting choice (2),
despite the possibility that at runtime \mono{b} could be instantiated with \mono{Char},
making the more specific instance (3) an even better choice.

Such overlapping instances are called \emph{incoherent},
and without enabling \emph{incoherent instances} feature,
these declarations would be rejected\footnote{GHC language features required for this example:
\mono{-XFlexibleInstances, -XTypeSynonymInstances, -XOverlappingInstances, -XIncoherentInstances}}.
However, as demonstrated recently in \cite{haskell2010},
the same behavior occurs with the popular \emph{generalized algebraic data types}
(GADTs) feature enabled. Consider packaging a list of countable things into a GADT:
\begin{ttquote}data SomeThings where
  MkST :: Things a => [a] -> SomeThings

g :: SomeThings -> Int
g (MkST ys) = things ys
\end{ttquote} As before, \,\mono{g (MkST "foo")} evaluates to \mono{3}
instead of \mono{1}, but there is no way to evaluate to \mono{1} in this case.
In the previous case, one could qualify the signature of \mono{f} with
the assumption \mono{(Things [b])} to avoid necessarily selecting
the general instance on lists, (2),
but here no such qualification on \mono{g} is even syntactically possible.
Moreover, the following, seemingly equivalent expressions evaluate to \mono{3} and \mono{1} respectively: \begin{ttquote}h3 = case (MkST "foo") of (MkST ys) -> things ys
h1 = things "foo"
\end{ttquote}

At the heart of this inconsistent behavior lies the static yet staggered nature of instance resolution in Haskell:
\emph{static} because instance resolution is determined while type checking \cite{haskell96,faxen02},
and \emph{staggered} because an instance is either resolved on a particular class method call or
passed in from elsewhere in the call graph.
If a more specific instance could override the statically determined instance at run time,
such inconsistency would never occur.
Instead of program behavior being determined by the static, possibly staggered evidence,
it would be determined precisely by all the evidence available at run time.
(The static evidence then serves as a guarantee that some exists;
whether that evidence is actually used depends on the presence of
\emph{subevidence} during execution.)  For example,
when the body of \mono{f} is executed with \mono{b = Char},
the execution could hot swap the more specific instance (3) in place of the statically determined (2).
Likewise in the case of \mono{g}, if the GADT contains a single string (i.e. list of characters)
like \mono{"foo"}, the execution could override the statically determined (2) with (3). Such behavior could then be described as a kind of dynamic dispatch.

With this notion of subevidence and dynamic dispatch in Haskell,
how can we be sure that there will always be a \emph{unique}
best choice of instance at run time?
Would choosing a more specific instance at run time respect type safety?
Such concerns are exactly those addressed by our system.

% The overloaded set of functions $\D(f)$ is gotten by substituting each \emph{instance head} for the \emph{class parameter}, for each instance of the class that declares $f$. Subtyping on ground types is defined by the \emph{instantiation order}. The same notion of $dom(f)$ exists as we describe, with the exception that the type of polymorphic domains in Haskell have the form $\forall \bar{\alpha}. \theta \Rightarrow \tau$, where $\theta$ is a set of type class constraints and $\tau$ is a type. Subtyping is defined (similarly to ours) as the reverse of the \emph{generalization order} \cite[\S4.1]{haskell98}, and the meet of two such types is given by
% \[
% \left(\forall\bar{\alpha}\,. \pi \Rightarrow \tau\right) %
%   \; \meet \; %
%   \left(\forall\bar{\beta}\,. \rho \Rightarrow \upsilon\right) %
%   \quad = \quad %
%   \forall\bar{\gamma}\,. (\phi(\pi) \meet \phi(\rho)) \Rightarrow \phi(\tau)
% \]
% where $\theta$ is a most general unifier of $(\tau = \upsilon)$, $\gamma = ftv(\phi(\bar{\alpha}\bar{\beta}))$, and $\pi_1 \meet \pi_2$ is the conjunction of those constraints. Now, our No Duplicates Rule, Meet Rule, and Return Type Rule may be applied in much the same way to prove safety of $\D(f)$.
