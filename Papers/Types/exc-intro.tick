% Outline for this section

% Many programs that users would like to write are unsafe
% Undefinable meets
%  ex1: String, ZZ example
%  ex2: [\X <: Any\]ArrayList[\X\], [\Y<: Foo\]List[\Y\] ([\X <: Foo\]ArrayList[\X\] doesn't work)
% Don't meet the subtype rule
%  ex3: ArrayList[\T\], List[\T\]

% Solution
% 1) Exclusion Relation
%  symmetric, irreflexive
%  change subtyping to ensure that the intersection of two excluding types is bottom
%  to lift to existential type schema: all instantiations exclude
%  we want same behavior when type checking programs with type variables
% 2) Outlaw multiple instance inheritance
%  lets us add a new kind of exclusion
%  can use that to reason that ex2 is safe
%  need to build this reasoning into subtyping for existential types
%  same machinery will help us fix ex3 in the next section

% What we will do in this section 
%  need to know constraints under which a type is not bottom => need to know when two types don't exclude
%  can get regular exclusion from not exclude

% Helpful notation
% Not Bottom \[\Delta \vdash T \not\equiv `BottomType`|\C\]
% Don't exclude under constraints \[\Delta \vdash T  \nexc S | \C\]

% How to get all instantiations exclude (written \exc)
% \infrule
%  {\Delta \vdash S \nexc T|False}
%  {\Delta \vdash S \exc T}

While the rules presented in Section~\ref{sec:rules}
guarantee the type safety of overloaded generic function declarations,
using only subtyping relation forbids many ````natural'' overloaded functions.
Moreover, these are not false negatives because many of these overloaded declaration are
actually unsafe due to multiple inheritance.

For example, even though the following function declarations look like
a valid overloading, they are not:
    % f String:String
    % f ZZ:ZZ
\begin{FortressCode}
 \\
\2\2\+f\, \TYP{String}\COLON\TYP{String} \\
f\, \mathbb{Z}\COLON\mathbb{Z}\-
\end{FortressCode}
since the Meet Rule is not satisfied. Moreover, it is impossible to define disambiguate the declarations by providing the meet
because intersection types are not allowed in the function declaration syntax.

Another example is the following:
    % h[\X <: Any\]ArrayList[\X\]:ZZ
    % h[\Y<: ZZ\]List[\Y\]:ZZ
\begin{FortressCode}
 \\
\2\2\+h\llbracket{}X \SHORTCUT{<} \TYP{Any}\rrbracket\TYP{ArrayList}\llbracket{}X\rrbracket\COLON\mathbb{Z} \\
h\llbracket{}Y\mathord{\SHORTCUT{<}}\: \mathbb{Z} \rrbracket\TYP{List}\llbracket{}Y\rrbracket\COLON\mathbb{Z}\-
\end{FortressCode}
where `ArrayList[\T\] <: List[\T\]`.
The first declaration is not more specific than the second;
it applies to all instantiations of type constructor `ArrayList`,
whereas the second declaration applies only to instantiations of
type constructor `List` with subtypes of type `ZZ`.
As things stand, we cannot provide a meet for these two declarations.
The following declaration might look like the meet:
    % h[\X <: ZZ\]ArrayList[\X\]:ZZ
\begin{FortressCode}
 \\
\2\2\+h\llbracket{}X \SHORTCUT{<} \mathbb{Z}\rrbracket\TYP{ArrayList}\llbracket{}X\rrbracket\COLON\mathbb{Z}\-
\end{FortressCode}
but consider the following type declaration:\\
`        BadList <: {ArrayList[\Any\], List[\ZZ\]}`The 
would-be meet is not applicable to `h(BadList)`, 
but the two other definitions of `h` are.
Therefore, the two declarations are not a valid overloading.

The following example is not a valid overloading:
    % g[\T <: Any\]List[\T\]:List[\T\]
    % g[\S <: Any\]ArrayList[\S\]:ArrayList[\S\]
\begin{FortressCode}
 \\
\2\2\+g\llbracket{}T \SHORTCUT{<} \TYP{Any}\rrbracket\TYP{List}\llbracket{}T\rrbracket\COLON\TYP{List}\llbracket{}T\rrbracket \\
g\llbracket{}S \SHORTCUT{<} \TYP{Any}\rrbracket\TYP{ArrayList}\llbracket{}S\rrbracket\COLON\TYP{ArrayList}\llbracket{}S\rrbracket\-
\end{FortressCode}
because the declarations do not satisfy the Return Type Rule.
Both declarations are only applicable to the argument type `BadList` with following instantiations:
    % g List[\ZZ\]:List[\ZZ\]
    % g ArrayList[\String\]:ArrayList[\String\]
\begin{FortressCode}
 \\
\2\2\+g\, \TYP{List}\llbracket\mathbb{Z}\rrbracket\COLON\TYP{List}\llbracket\mathbb{Z}\rrbracket \\
g\, \TYP{ArrayList}\llbracket\TYP{String}\rrbracket\COLON\TYP{ArrayList}\llbracket\TYP{String}\rrbracket\-
\end{FortressCode}
which violates progress.

%% but that these functions can be defined if we introduce an explicit exclusion relation over types.

To enable these kinds of overloaded functions to be defined, 
we introduce the \emph{exclusion} relation (written $\exc$) on types,
which asserts that two types have no common subtypes other than \BottomType.
We define the exclusion relation 
by extending class declarations with two new clauses: 
`excludes` and `comprises`:\\[-.2em]
\[
C\tplist{X}{L} \extends `{N_bar} excludes {M_bar} comprises {K_bar}`
\]
\\
The `excludes` clause states that
the intersection of any application `C[\T_bar\]` of type constructor `C`
and any of `M_bar` is `BottomType` 
(i.e., 
`C[\T_bar\] CAP [T_bar / X_bar]M[i] EQUIV BottomType` 
for any `T_bar` and for each `M[i]` in `M_bar`).
This implies, of course, 
that any subtype of `C[\T_bar\]` also excludes 
`[T_bar / X_bar] M[i]`.
The `comprises` clause stipulates that
an application of type constructor `C` with `T_bar`
consists of exactly the types in `K_bar` that are instantiated with `T_bar`
(i.e., 
`C[\T_bar\] EQUIV [T_bar / X_bar]K[1]` $\cup \ldots \cup$ `[T_bar / X_bar] K[n]`).
Thus, if a type that excludes 
`[T_bar / X_bar]K[1]` $\cup \ldots \cup$ `[T_bar / X_bar] K[n]` 
also necessarily excludes `C[\T_bar\]`.

The exclusion relation induced by a class table 
is then the symmetric closure of the relation 
derived from the declarations in the table as described above, 
extended to structural and compound types as follows:
Every arrow type excludes every non-arrow type.
Every tuple type excludes every non-tuple type 
and also every tuple type with a different number of element types.
An intersection type excludes any type excluded by \emph{any} its constituent types, 
while a union type excludes any type excluded by \emph{all} its constituent types.
$\BottomType$ excludes every type (including itself---it is the only type 
that excludes itself), 
and $\Any$ does not exclude any type other than $\BottomType$. 
We augment our notion of a well formed class table 
to require that the subtyping and exclusion relations it induces 
````respect'' each other.
That is, for all constructed types $M$ and $N$ other than \BottomType, 
\begin{enumerate}
\item  If $M$ excludes $N$ then $M$ must not be a subtype of $N$.

% FUTURE FIX REQUIRED:
% Technically the following two statements should be about instantiations
% of what is in a comprises clause.
% Leaving this for now, but we should fix it.

\item 
If $M$ is in a `comprises` clause of $N$ then
$M \subtypeof N$ and there is no constructed type $K$ 
such that $M \subtypeof K \subtypeof N$.

\item 
If $N \subtypeof M$ and $M$ has a `comprises` clause,
then there is some constructed type $N'$ in the `comprises` clause of $M$
such that $N \subtypeof N$'.

\end{enumerate}
As with the subtyping relation, 
a valid extension to a class table $\T$ 
must preserve these well-formedness properties. 
Especially,
we must modify the subtyping rules for intersection types to ensure that $S \exc T$  
is equivalent to $S \cap T = \BottomType$:

\infrule
{\Delta \vdash S \exc T}
{\Delta \vdash S \cap T <: \BottomType}

With exclusion declarations of `String` and `ZZ`, we can assert that `String` $\exc$ `ZZ`.
With such an assertion, now the declarations:
% f String:String
% f ZZ:ZZ
\begin{FortressCode}
 \\
\2\2\+f\, \TYP{String}\COLON\TYP{String} \\
f\, \mathbb{Z}\COLON\mathbb{Z}\-
\end{FortressCode}
are a valid overloading.

Allowing the following overloaded declarations is trickier:
% f[\X <: Any\]List[\X\]:List[\X\]
% f[\Y <: Any\]ArrayList[\Y\]:ArrayList[\Y\]
\begin{FortressCode}
 \\
\2\2\+g\llbracket{}X \SHORTCUT{<} \TYP{Any}\rrbracket\TYP{List}\llbracket{}X\rrbracket\COLON\TYP{List}\llbracket{}X\rrbracket \\
g\llbracket{}Y \SHORTCUT{<} \TYP{Any}\rrbracket\TYP{ArrayList}\llbracket{}Y\rrbracket\COLON\TYP{ArrayList}\llbracket{}Y\rrbracket\-
\end{FortressCode}
As our definition of type `BadArray` suggests, a fundamental problem
with such declarations is that a type such as `ArrayList[\ZZ\]` might be a subtype
of multiple instantiations of type constructor `List`.
A type hierarchy in which
some type extends multiple instantiations of the same type constructor is said
to exhibit \emph{multiple instantiation inheritance} \cite{kennedy07}.

We address this problem by imposing an additional restriction on well-formed class tables,
which, in effect, adds additional exclusion relations:
\begin{description}
\item[Polymorphic Exclusion] 
A type (other than \BottomType) 
must not be a subtype of multiple distinct instantiations of a parametric type. 
\end{description}
Effectively, if a type $M$ is a subtype of an application $N$ of type
constructor $C$, then $M$ excludes all other applications of $C$. 
This restriction is easy to statically enforce, and it has been shown in practice that
it is not an onerous restriction.
Indeed, it is already in the Java\texttrademark\ programming language,
and for good reason: Kennedy and Pierce showed that multiple instantiation inheritance
are one of three conditions that lead to the undecidability of
nominal subtyping with variance \cite{kennedy07}.

Polymorphic exclusion lets us determine whether one existential type
has the same extent (has the same monomorphic subtypes) as another.
For example, using polymorphic exclusion, we know that
the following existential type:
`
(1) EXISTS[\X <: Any, Y <: Foo \] (ArrayList[\X\] CAP List[\Y\])
`has the same extent as:
`
(2) EXISTS[\Z <: Foo\] ArrayList[\Z\]
`because, for all ground types `S` and `T`, the intersection type
`List[\S\] CAP ArrayList[\T\]` is equivalent to `BottomType`
unless `S` is equivalent to `T`.
This lets us deduce that `S` (equivalent to`T`)
is an appropriate instantiation for `Z`.
Therefore, now the following declarations:
\begin{FortressCode}
 \\
\2\2\+h\llbracket{}X \SHORTCUT{<} \TYP{Any}\rrbracket\TYP{ArrayList}\llbracket{}X\rrbracket\COLON\mathbb{Z} \\
h\llbracket{}Y\mathord{\SHORTCUT{<}}\: \TYP{Foo}\rrbracket\TYP{List}\llbracket{}Y\rrbracket\COLON\mathbb{Z}\-
\end{FortressCode}
satisfy the Meet Rule thanks to the following disambiguating declaration:
\begin{FortressCode}
 \\
\2\2\+h\llbracket{}Z \SHORTCUT{<} \TYP{Foo}\rrbracket\TYP{ArrayList}\llbracket{}Z\rrbracket\COLON\mathbb{Z}\-
\end{FortressCode}
If we incorporate this form of derivation into the subtyping rules for
existential and universal types, we can prove that many more sets of
overloaded declarations satisfy the overloading rules.

In this section,
we extend the exclusion relation to existential and universal types and
refine the subtyping rules for them.
%
%  need to know constraints under which a type is not bottom => need to know when two types don't exclude
%  can get regular exclusion from not exclude
%
We also augment our judgments to include \emph{constraints},
which state subtyping among types that we have inferred to hold.
For example, because of polymorphic exclusion,
if we infer that a given type $S$ is a subtype of two instantiations `C[\T_bar\]` and
`C[\U_bar\]` of the same type constructor `C`, we can infer constraints that
`T[i] EQUIV U[i]` for each `T[i] IN T_bar` and `U[i] IN U_bar`.
We also carry constraints that hold under the supposition
that an intersection type is not `BottomType`.
For example, when we decide whether two existential types (1) and (2) above have the same extent,
if we explore the ramifications of the possibility that
`List[\S\] CAP ArrayList[\T\]` is not equivalent to `BottomType`,
we need to infer and carry the constraint that `S EQUIV T`.

To augment the rules in this section, we introduce the following notation:
\begin{enumerate}

\item 
We write $\jcnonequiv{T}{\BottomType}{\C}$
to indicate that a type $T$ is not equivalent to \BottomType\ 
under the environment $\Delta$ and
the assumption that constraints $\C$ hold.

\item 
We write  $\jnexc{T}{S}{\C}$ to indicate that
$T$ does not exclude $S$ under the environment $\Delta$ and
the assumption that constraints $\C$ hold.
\end{enumerate}

% How to get all instantiations exclude (written \exc)
% \infrule
%  {\Delta \vdash S \nexc T|False}
%  {\Delta \vdash S \exc T}
