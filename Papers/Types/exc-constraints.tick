\TODO{Tie this in with one of the examples}
We now augment our subtyping and exclusion judgment to include \emph{constraints}.
With constraint-based typing, we perform backward reasoning from the
desired typing assertion to derive constraints on types under which the
assertion can be proved; 
when those constraints are satisfied, the assertion is also satisfied. 
These constraints on types are first generated and gathered, 
and solved later when more information about the environment is known.

\subsection{Constraints}
\input{fig-constraints}
Our grammar for type constraints is defined in Figure \ref{fig:constraints}.
A primitive constraint is either {\it positive} or {\it negative}. We define
positive primitive constraints of the forms: `S <: T`  which specifies that
a type $T$ is a subtype of $S$ and $S \exc T$ which specifies that a type $S$ must exclude a type $T$.
Similarly, we define negative primitive constraints: $S \nsubtypeof T$ and $S \nexc T$.
A conjunction constraint $\C_1 \wedge \C_2$ is satisfied exactly
when both $\C_1$ and $\C_2$ are satisfied,
and a disjunction constraint $\C_1 \vee \C_2$ is satisfied exactly
when one or both of $\C_1$ and $\C_2$ are satisfied.
The constraint $\FALSE$ is never satisfied, and the constraint $\TRUE$ is always satisfied.

We define the negation $\neg \C$ of a constraint $\C$ using de Morgan's law.

Clearly any bounds environment $\Delta = \bds{X}{M}$ naturally defines a constraint $\toConstraint{\Delta}. This conversion
has a partial inverse $\toBound{\C}$ that is defined whenever $\C$ can be written as a conjunction of constraints of the form `X <: M`. Both of these
operations will prove very convenient in Section \ref{sec:checking}.



\subsection{Judgments}
\input{fig-judgements}
In Figure \ref{fig:judgements} we list the judgments that will be used for generating constraints. Each judgment of the form

indicates that, under assumptions $\Delta$, the constraint $\C$ implies the predicate

. The judgment

is the contrapositive of the judgment

and indicates that if the predicate

holds the constraints must hold as well. 

An important point about both kinds of judgments is that the types
$S$ and $T$ should be considered \emph{inputs} and
constraint $\C$ should be considered \emph{output}.

Note that

is not the same judgment as

. They treat bound type variables quite differently.

\subsection{Subtype}

Smith and
Cartwright \cite{smith08} on which our system was based. Smith and
Cartwright provide a sound and complete algorithm for generating
constraints from the subtyping relation and an algorithm for
normalizing constraints to simplify, for example, those involving
contradictions or redundancies. We assume that constraints are
implicitly simplified in this manner. The soundness of constraint
generation entails that the predicate is a logical consequence of the
constraint; the completeness of generation entails the opposite.

For subtyping with constraints, we essentially preserve the semantics
of \cite{smith08}, but that system lacks our notion of
exclusion. Since we need our subtyping to take advantage of
exclusion, we must add an additional rule to the judgment:\\[-1em] 

\infrule
  {\jgconstrtemplate{S}{\exc}{T}{\C} \andalso
   \jsub{S}{U}{\C'} \andalso\jsub{T}{U}{\C''}}
  {\jsub{S \cap T}{U}{\C \vee \C' \vee \C''}}

\noindent This new rule states three possibilities for proving that the intersection $S \cap T$ is a subtype of $U$: $S$ and $T$ exclude (which means their intersection is a subtype of \BottomType), $S$ is a subtype of $U$, or $T$ is a subtype of $U$. If any of the constraints needed for these three judgments is satisfied, then $S \cap T$ is a subtype of $U$. Adding this rule should not affect completeness or soundness of constraint generation for $\subtypeof$ (since constraint generation for $\exc$ is complete and sound if constraint generation for $\subtypeof$ is).


\subsection{Exclusion}
\input{fig-exclusion}

With these additional constraints and judgments, we can now define
constraint generation for exclusion.
Figure~\ref{fig:jexc} presents our algorithm, which
formalizes our original definition of exclusion in
Section~\ref{sec:excdec}.
As before, exclusion on constructed types is
satisfied when any of the sub-relations from the previous section is
satisfied. Each sub-relation checks the conditions described before
by recursively generating and propagating constraints. Each
sub-relation except $\excrc$ depends only on other constraint
generation judgments, meaning the algorithmic checking
terminates. The $C\obb{T} \excrc D\obb{U}$ predicate recursively
checks exclusion on the comprised types of $C\obb{T}$, but due to
the acyclic nature of the class table, this process will also terminate. 
Thus, the algorithm is complete and sound if $\subtypeof$ is.

\subsection{Negation}

\subsection{Contrapositive}

\subsection{Constraint Solving}
Solving constraints
% We will also need to have the ability to solve constraints.
% $\Delta \vdash \textit{solve}(\C)$
% This
needs to be sound but not necessarily complete.\footnote{A 
failure in solving constraints may cause us to reject some overloadings that
were actually safe, 
but not to allow overloadings that are unsafe.}
Here is a simple algorithm which is sound but not complete. (We assume that all
constraints are kept in disjunctive normal form.)
\begin{enumerate}
\item Take $\C$ which is a union of intersection constraints and
try to solve each conjunct at a time (take the first one that succeeds).
\item Split the conjunct into positive and negative parts.
\item Deduce a set of equivalences from the positive part.
\item Solve the equivalences using unification (with subtyping) to get a substitution $\phi$.
\item Check whether applying $\phi$ to $\C$ reduces $\C$ to the trivial constraint 
$\TRUE$.
\item If so return $`Some`(\phi)$, otherwise return `None`.
\end{enumerate}
To get better completeness properties,
one can iterate constraint solving if $\phi(\C)$ is not false.
However, this might converge to a fixed point instead of terminating
because the constraints that are negative or that do not imply an equivalence
are never used to generate $\phi$.
