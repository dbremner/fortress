\TODO{Intro comments}
Here is where we give the rules to derive the exclusion relation.
We use constraint-based reasoning to do it.
(All the rules should here, rather than being spread around.)
We also have rules for constraint-based derivation of subtyping, 
and those are in an appendix.
This constraint-solving approach is necessary 
(or at least we use it) 
because of parametric exclusion.


\paragraph{Constraints}
We now augment our subtyping judgment to include \emph{constraints}.
With constraint-based subtyping, we perform backward reasoning from the
desired subtyping assertion to derive constraints on types under which the
assertion can be proved; 
when those constraints are satisfied, the assertion is also satisfied. 
These constraints on types are first generated and gathered, 
and solved later when more information about the environment is known.

% For example, because of polymorphic exclusion,
% if we need to prove that a given type $S$ is a subtype of two instantiations `C[\T_bar\]` and
% `C[\U_bar\]` of the same type constructor `C`, we can infer the constraints 
% `T[i] EQUIV U[i]` for each `T[i] IN T_bar` and `U[i] IN U_bar` as necessary conditions. If these conditions cannot immediately be solved, we can propagate them so that with more information about $\bar{T}$ and $\bar{U}$ we can prove that `S <: C[\T_bar\]` and `S <: C[\U_bar\]`.
% % More concretely, when we must prove that the two existential types from $foo$ in the previous section are equivalent, we can determine that $S \equiv T$ implies the subtyping judgment we need. We propagate the constraint that $S \equiv T$ because, if it were shown to hold, we could prove the desired subtyping judgment. The equivalence of the computed meet and candidate meet for $foo$ could thus be checked.

Our grammar for type constraints is defined as follows:\\[-.2em]
\[
\begin{array}{lll}
\C &::=& S <: T \\
&\mid& S \exc T \\
&\mid& S \not<: T \\
&\mid& S \nexc T \\
&\mid& \C \wedge \C \\
&\mid& \C \vee \C \\
&\mid& \FALSE \\
&\mid& \TRUE \\
\end{array}
\]
\\
A primitive constraint is either {\it positive} or {\it negative}.
A positive primitive constraint of the form `X <: S` specifies that
a type variable $X$ is a subtype of $S$, and likewise for `S <: X`.
The positive primitive constraint $X \exc S$ specifies that a type variable $X$ must exclude a type $S$.
To generate constraints for exclusion, we also define negative primitive constraints:
$X \not<: S$, $S \not<: X$, and $X \nexc S$.
A conjunction constraint $\C_1 \wedge \C_2$ is satisfied exactly
when both $\C_1$ and $\C_2$ are satisfied,
and a disjunction constraint $\C_1 \vee \C_2$ is satisfied exactly
when one or both of $\C_1$ and $\C_2$ are satisfied.
The constraint $\FALSE$ is never satisfied, and the constraint $\TRUE$ is always satisfied.

\paragraph{Constraint Generation}
We introduce the following syntactic judgments to generate these constraints:
\[ \jsub{S}{T}{\C} \andalso \jequiv{S}{T}{\C} \andalso \jexc{S}{T}{\C} \]%
Each judgment indicates that, under assumptions $\Delta$,
the respective predicate can be proved if the constraint $\C$ is
satisfied. An important point about these judgments is that the
predicates $S \subtypeof T$, $S \equiv T$, and $S \exc T$ should
be considered \emph{inputs} to our algorithmic checker, while the
constraint $\C$ should be considered its \emph{output}.

We do not give 
%in Figure~\ref{fig:jexc} 
the full semantics of
constraint generation for subtyping. Instead, we refer the reader to
the recent work by Smith and
Cartwright \cite{smith08} on which our system was based. Smith and
Cartwright provide a sound and complete algorithm for generating
constraints from the subtyping relation and an algorithm for
normalizing constraints to simplify, for example, those involving
contradictions or redundancies. We assume that constraints are
implicitly simplified in this manner. The soundness of constraint
generation entails that the predicate is a logical consequence of the
constraint; the completeness of generation entails the opposite.

\input{fig-exclusion}

The constraint generation judgment for equivalence is defined entirely by the following rule:\\[-1.5em]
\infrule
  {\jsub{S}{T}{\C} \andalso \jsub{T}{S}{\C'}}
  {\jgconstrtemplate{S}{\equiv}{T}{\C \wedge \C'}}
Equivalence constraint generation is complete and sound if and only if
the constraint generation for $\subtypeof$ is.

With negative constraints, we define a new judgment for ````not a subtype'' by the rule:\\[-1.5em]
\infrule
  {\jsub{S}{T}{\C}}
  {\jgconstrtemplate{S}{\not <:}{T}{\neg\C}}

\noindent where $\neg\C$ is the negated constraint formed by applying De Morgan's laws on $\C$. Similarly, we can define ````not equivalent'' by the rule:\\[-1em]
\infrule
  {\jequiv{S}{T}{\C}}
  {\jnequiv{S}{T}{\neg\C}}
These judgements are sound because constraint generation for $\subtypeof$ is complete (and complete because $\subtypeof$ is sound).




% We define the following exclusion judgment:\\[-.2em]
% \[ \jexc{S}{T}{\C} \]
% \\
% which states that, under assumptions $\Delta$,
% which reads as ````the types `S` and `T` exclude each other under the assumptions $\Delta$
% if the constraints $\C$ hold,'' in Figure~\ref{fig:jexc}.
% With these
With these additional constraints and judgments, we can now define
constraint generation for exclusion.
Figure~\ref{fig:jexc} presents our algorithm, which
formalizes our original definition of exclusion in
Section~\ref{sec:excdec}.
As before, exclusion on constructed types is
satisfied when any of the sub-relations from the previous section is
satisfied. Each sub-relation checks the conditions described before
by recursively generating and propagating constraints. Each
sub-relation except $\excrc$ depends only on other constraint
generation judgments, meaning the algorithmic checking
terminates. The $C\obb{T} \excrc D\obb{U}$ predicate recursively
checks exclusion on the comprised types of $C\obb{T}$, but due to
the acyclic nature of the class table, this process will also terminate. 
Thus, the algorithm is complete and sound if $\subtypeof$ is.


For subtyping with constraints, we essentially preserve the semantics
of \cite{smith08}, but that system lacks our notion of
exclusion. Since we need our subtyping to take advantage of
exclusion, we must add an additional rule to the judgment:\\[-1em] 

\infrule
  {\jgconstrtemplate{S}{\exc}{T}{\C} \andalso
   \jsub{S}{U}{\C'} \andalso\jsub{T}{U}{\C''}}
  {\jsub{S \cap T}{U}{\C \vee \C' \vee \C''}}

\noindent This new rule states three possibilities for proving that the intersection $S \cap T$ is a subtype of $U$: $S$ and $T$ exclude (which means their intersection is a subtype of \BottomType), $S$ is a subtype of $U$, or $T$ is a subtype of $U$. If any of the constraints needed for these three judgments is satisfied, then $S \cap T$ is a subtype of $U$. Adding this rule should not affect completeness or soundness of constraint generation for $\subtypeof$ (since constraint generation for $\exc$ is complete and sound if constraint generation for $\subtypeof$ is).

\paragraph{Constraint Solving}
Solving constraints
% We will also need to have the ability to solve constraints.
% $\Delta \vdash \textit{solve}(\C)$
% This
needs to be sound but not necessarily complete.\footnote{A 
failure in solving constraints may cause us to reject some overloadings that
were actually safe, 
but not to allow overloadings that are unsafe.}
Here is a simple algorithm which is sound but not complete. (We assume that all
constraints are kept in disjunctive normal form.)
\begin{enumerate}
\item Take $\C$ which is a union of intersection constraints and
try to solve each conjunct at a time (take the first one that succeeds).
\item Split the conjunct into positive and negative parts.
\item Deduce a set of equivalences from the positive part.
\item Solve the equivalences using unification (with subtyping) to get a substitution $\phi$.
\item Check whether applying $\phi$ to $\C$ reduces $\C$ to the trivial constraint 
$\TRUE$.
\item If so return $`Some`(\phi)$, otherwise return `None`.
\end{enumerate}
To get better completeness properties,
one can iterate constraint solving if $\phi(\C)$ is not false.
However, this might converge to a fixed point instead of terminating
because the constraints that are negative or that do not imply an equivalence
are never used to generate $\phi$.
