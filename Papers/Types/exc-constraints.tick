Up to this point the precise definitions of subtyping and exclusion between
types (and existential reduction) have remained unspecified. In this section
we describe a small language of type constraints and, more importantly, we
define subtyping, exclusion, and existential reduction with respect to
constraints. Finally we define the subtyping and exclusion judgments that
have appeared in the previous sections as straightforward applications of
their constraint-based counterparts.

Until now we have only considered types whose free variables are bound in an explicit type environment. To gather constraints, however, we must check
subtype and exclusion relationships between types with unbound \emph{inference} variables.
Intuitively, we have no control over the constraints on a bound type variable (which are fixed by the associated type environment), but we may introduce constraints on an inference variable.
While the syntax of type variables is uniform,
we conventionally distinguish them by using the metavariables $X$ and $Y$ for bound type variables and $I$ and $J$ for inference type variables.

\subsection{Judgment Forms}
\input{fig-judgements}

In Figure \ref{fig:judge} we list the judgments that will be used for generating constraints. Each judgment of the form
$\jgconstrtemplate{S}{\ast}{T}{\C}$
states that under the assumptions $\Delta$, the constraint $\C$ on the inference variables imply the proposition $S \propop T$,
where $\propop$ ranges over $\subtypeof$, $\nsubtypeof$, $\exc$, $\nexc$,
$\equiv$, and $\not\equiv$.
If $S$ and $T$ contain no inference variables the judgment behaves like an unconditional judgment (i.e., it only produces the constraints $\TRUE$ or $\FALSE$).

Similarly, the judgement of the form
\[\jgcontratemplate{S}{\propop}{T}{\C}\]
states that under the assumptions $\Delta$, if the proposition $S \propop T$ holds, then $\C$ must be true of the inference variables. In
particular when $\C$ holds of the inference variables, $S \propop T$ does not have to hold for every valid instantiation of the bound type variables. (Note that we only make use of this judgment where $\propop$ is $\not\equiv$.)

An important point about both kinds of judgments is that the types $S$ and $T$ should be considered \emph{inputs} and the
constraint $\C$ should be considered an \emph{output}.

\subsection{Constraint Forms}
\input{fig-constraints}
Our grammar for type constraints is defined in Figure \ref{fig:constraints}.
A primitive constraint is either {\it positive} or {\it negative}. We define
positive primitive constraints: $S \subtypeof T$ specifies that
a $S$ is a subtype of $T$, and $S \exc T$ specifies that $S$ must exclude $T$.
Similarly, we define negative primitive constraints: $S \nsubtypeof T$ and $S \nexc T$ with the obvious interpretations.
A conjunction constraint $\C_1 \wedge \C_2$ is satisfied exactly
when both $\C_1$ and $\C_2$ are satisfied,
and a disjunction constraint $\C_1 \vee \C_2$ is satisfied exactly
when one or both of $\C_1$ and $\C_2$ are satisfied.
The constraint $\FALSE$ is never satisfied, and the constraint $\TRUE$ is always satisfied. The equivalence constraint $S \equiv T$ is derived as $S \subtypeof T \wedge T \subtypeof S$.

As in the work of Smith and Cartwright \cite{smith08}, on which we based our constraint
generation rules, we normalize all constraint formulas into disjunctive normal form
and simplify away obvious contradictions and redundancies. We further make use
of some auxiliary meta-level definitions, defined in Figure~\ref{fig:constraints}. The (involutary) negation function
$\neg \C$ of a constraint $\C$ has a standard de Morgan interpretation.
Each type environment $\Delta = \bds{X}{M}$ naturally describes a constraint
on the variables $\bar{X}$,
which we denote $\textit{toConstraint}(\Delta)$. This conversion
has a partial inverse $\textit{toBound}(\C)$ that is defined whenever $\C$ can be written as a conjunction of constraints of the form $X \subtypeof M$.%
\footnote{If $\C$ has multiple conjuncts of this form for a single $X$, then the resulting environment contains multiple bounds for $X$ using the $\bd{M}$ notation.}

\noindent\TODO{Scott died right here. R.I.P.}

\subsection{Subtyping}
\TODO{Is Smith and Cartwright's system really so similar to warrant this?}
In \cite{smith08} Smith and Cartwright provide a sound and complete algorithm for generating constraints from the
Java subtyping relation. We essentially preserve their semantics
(see \cite[Appendix]{smith08} for details) with two notable differences.

First, we need to augment the subtyping rules for tuple types to account for the fact
that any tuple with a constituent type that is equivalent to $\Bottom$ is itself
equivalent to $\Bottom$.

\infrule
  {|\bar{S}| = |\bar{T}| \andalso \forall  i . \quad \jsub{S_i}{T_i}{\C_i} \\
   \forall i . \quad \jsub{S_i}{\Bottom}{\C'_i}}
  {\jsub{(\bar{S})}{(\bar{T})}{(\bigwedge \C_i) \vee (\bigvee \C'_i)}}

\infrule
  {|\bar{S}| \neq 1 \andalso \forall i . \quad \jsub{S_i}{\Bottom}{\C_i}}
  {\jsub{(\bar{S})}{T}{\bigvee \C_i}}

Second, we need to augment the rule for intersection types to account for
exclusion since the intersection of excluding types is equivalent to
$\Bottom$. (Note that this extension
makes the exclusion and subtyping rules mutually dependent.)

\infrule
  {\jsub{S}{U}{\C} \andalso \jsub{T}{U}{\C'} \\
   \jexc{S}{T}{\C''}}
  {\jsub{S \cap T}{U}{\C \vee \C' \vee \C''}}
  
We also define the subtyping judgment as a trivial application of
constraint-based subtyping with the following rule:

\infrule
  {\jsub{S}{T}{\TRUE}}
  {\jgsub{S}{T}}


\subsection{Exclusion}
\input{fig-exclusion}
Figure~\ref{fig:jexc} presents our exclusion rules, which formalize our original definition of exclusion in
Section~\ref{sec:exc-spec}. To make our rules algorithmic we needed to break the exclusion relation on constructed
types into four subrelations $\exce$, $\excc$, $\exco$, and $\excp$. The first three relations are then reduced
to checking the asymmetric relations $\excre$, $\excrc$, and $\excro$.
\begin{enumerate}
\item `C[\ S_bar \]`\,$\excre$\,`D[\ T_bar \]` determines whether `D[\ T_bar \]` has a super type $N$ such that $N$ appears in the excludes clause of an ancestor of `C[\ S_bar \]`.
\item `C[\ S_bar \]`\,$\excrc$\,`D[\ T_bar \]` determines whether `D[\ T_bar \]` excludes every type in the (nontrivial) comprises clause of `C[\ S_bar \]`.
\item `C[\ S_bar \]`\,$\excro$\,`D[\ T_bar \]` determines whether `C[\ S_bar \]` is an object and `D[\ T_bar \]` is not a supertype of `C[\ S_bar \]`.
\item `C[\ S_bar \]`\,$\excp$\,`D[\ T_bar \]` determines whether there is a pair of types $(M, N)$ such that $M$ is an ancestor of `C[\ S_bar \]`, $N$ is an ancestor of `D[\ T_bar \]`, and
$M$ and $N$ are distinct applications of the same type constructor.
\end{enumerate}

As with subtyping, we define the exclusion judgment as a trivial application
of constraint-based exclusion with the following rule:

\infrule
  {\jexc{S}{T}{\TRUE}}
  {\jgtemplate{S}{\exc}{T}}

\subsection{Negation}
\TODO{Scott doesn't understand this section; why the rules are such.}
In the exclusion rules we use the $\not\equiv$ and $\nsubtypeof$ judgements.
They are obtained by applying de Morgan's law and inversion of
primitive constraints
to the constraints that are generated by the various rules
and replacing the rules for var types with.

\infrule
  {}
  {\jnsub{X}{T}{\FALSE}}

\infrule
  {\jnsub{S}{\Delta(X)}{\C'}}
  {\jnsub{S}{X}{\C \wedge \C'}}
\TODO{What's $\C$???}
  
\infrule
  {}
  {\jnexc{X}{T}{\FALSE}}

\subsection{Unification}
\TODO{Expand on this a tad?}
Suppose that $\C$ is a conjunction of type equivalences. A \emph{unifier} of $\C$ is a substitution
$\phi$ of types for inference type variables such that $\phi(\C) = \TRUE$. We say that a unifier $\phi$ is more general than a unifier $\psi$ if there exists a substitution $\tau$
such that $\tau \circ \phi \equiv \psi$. In other words $\phi$ is more general than $\psi$ if $\psi$ factors throughout $\phi$ \TODO{(huh?)}.

We can extend the notion of a unifier to an arbitrary conjunction $\C$ by noting that $\C$ can be factor \TODO{(huh?)} a conjunction $\C' \wedge \C''$
where $\C'$ is entirely equivalences and $\C''$ contains no type equivalences. Then we define a unifier of $\C$ to be a unifier
of $\C'$. Finally, we can extend the notion of unifier to a constraint $\C$ in disjunctive normal form to be a unifier of a disjunct of $\C$.

The (partial) function $\textit{unify}$ in Figure~\ref{fig:constraints} takes a formula $\C$ and produces a most general unifier $\phi$ if one exists. This is always the case
if $\C$ consists of a single conjunct. Extending $\textit{unify}$ and the rules in Section \ref{sec:checking} to deal with (possible exponential) sets of maximally general unifiers is obvious future work. \TODO{What's ````possible exponential'' mean? And is this really ````obvious''? (No.)}
