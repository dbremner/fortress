\TODO{Tie this in with one of the examples}
We now augment our subtyping and exclusion judgment to include \emph{constraints}.
With constraint-based typing, we perform backward reasoning from the
desired typing assertion to derive constraints on types under which the
assertion can be proved; 
when those constraints are satisfied, the assertion is also satisfied. 
These constraints on types are first generated and gathered, 
and solved later when more information about the environment is known.

\subsection{Typing Judgments}
\input{fig-judgements}
Until now we have only considered types in environments that bound all of their free variables. We will now relax this restriction. We will continue
to use the metavariables $X$ and $Y$ to range over bound type variables and will use the metavariables $I$ and $J$ to range over unbound or \emph{inference}
 type variables. Intuitively, we have no control over the constraints on a bound type variable (they are fixed by $\Delta$) but we may place constraints on an inference variable. 

In Figure \ref{fig:judge} we list the judgments that will be used for generating constraints. Each judgment of the form
\[\jgconstrtemplate{S}{\ast}{T}{\C}\]
states that under the assumptions $\Delta$, the constraint $\C$ on the inference variables imply the proposition $S\,\ast\,T$.
If $S$ and $T$ contain no inference variables the judgment behaves like an unconditional judgment (ie, it only produces the constraints $\TRUE$ or $\FALSE$).

Similarly, a judgement of the form
\[\jgcontratemplate{S}{\ast}{T}{\C}\]
states that under the assumptions $\Delta$, if the proposition $S\,\ast\,T$ holds, then $\C$ must be true of the inference variables. In
particular when $\C$ holds of the inference variables $S\,\ast\,T$ does not have to hold for every valid instantiation of the bound type variables.

An important point about both kinds of judgments is that the types $S$ and $T$ should be considered \emph{inputs} and the
constraint $\C$ should be considered an \emph{output}.

\subsection{Constraints}
\input{fig-constraints}
Our grammar for type constraints is defined in Figure \ref{fig:constraints}.
A primitive constraint is either {\it positive} or {\it negative}. We define
positive primitive constraints of the forms: `S <: T`  which specifies that
a type $T$ is a subtype of $S$ and $S \exc T$ which specifies that a type $S$ must exclude a type $T$.
Similarly, we define negative primitive constraints: $S \nsubtypeof T$ and $S \nexc T$.
A conjunction constraint $\C_1 \wedge \C_2$ is satisfied exactly
when both $\C_1$ and $\C_2$ are satisfied,
and a disjunction constraint $\C_1 \vee \C_2$ is satisfied exactly
when one or both of $\C_1$ and $\C_2$ are satisfied.
The constraint $\FALSE$ is never satisfied, and the constraint $\TRUE$ is always satisfied. 

As in the work of Smith and Cartwright \cite{smith08}, on which we based our constraint
generation rules, we normalize all constraint formulas into disjunctive normal form
and simply away obvious contradictions and redundancies.

We define the negation $\neg \C$ of a constraint $\C$ using de Morgan's law.

Clearly any bounds environment $\Delta = \bds{X}{M}$ naturally defines a constraint $\textit{toConstraint}(\Delta)$. This conversion
has a partial inverse $\textit{toBound}(\C)$ that is defined whenever $\C$ can be written as a conjunction of constraints of the form `X <: M`. Both of these
operations will prove very convenient in Section \ref{sec:checking}.

\subsection{Subtype}
In \cite{smith08} Smith and Cartwright provide a sound and complete algorithm for generating constraints from the
Java subtyping relation. We essentially preserve the semantics of \cite{smith08} (see the appendix for details) but our system has two distinct differences.

First, we need to augment to the rule for tuple types to account for the fact
that any tuple with an argument that is equivalent to $\Bottom$ is itself
equivalent to $\Bottom$.
\TODO{Tuple Rule}
Second, we need to augment the rule for intersection types to account for exclusion. Note that this
makes the exclusion and subtyping rules mutually recursive.
\TODO{Intersection Rule}


\subsection{Exclusion}
\input{fig-exclusion}
Figure~\ref{fig:jexc} presents our exclusion rules, which formalize our original definition of exclusion in
Section~\ref{sec:excdec}. To make our rules algorithmic we needed to break the exclusion relation on constructed
types into four subrelations:
\begin{description}
\item[$\exce$] a 
\item[$\excc$] a
\item[$\exco$] a
\item[$\excp$] a
\end{description}


\subsection{Negation and Contrapositive}


\subsection{Constraint Solving}
Solving constraints
% We will also need to have the ability to solve constraints.
% $\Delta \vdash \textit{solve}(\C)$
% This
needs to be sound but not necessarily complete.\footnote{A 
failure in solving constraints may cause us to reject some overloadings that
were actually safe, 
but not to allow overloadings that are unsafe.}
Here is a simple algorithm which is sound but not complete. (We assume that all
constraints are kept in disjunctive normal form.)
\begin{enumerate}
\item Take $\C$ which is a union of intersection constraints and
try to solve each conjunct at a time (take the first one that succeeds).
\item Split the conjunct into positive and negative parts.
\item Deduce a set of equivalences from the positive part.
\item Solve the equivalences using unification (with subtyping) to get a substitution $\phi$.
\item Check whether applying $\phi$ to $\C$ reduces $\C$ to the trivial constraint 
$\TRUE$.
\item If so return $`Some`(\phi)$, otherwise return `None`.
\end{enumerate}
To get better completeness properties,
one can iterate constraint solving if $\phi(\C)$ is not false.
However, this might converge to a fixed point instead of terminating
because the constraints that are negative or that do not imply an equivalence
are never used to generate $\phi$.
