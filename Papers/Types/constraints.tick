We augment the subtyping judgments to include constraints
that we have inferred to hold:\\[-.2em]
\[
\jcsub{S}{T}{\C}
\]
\\
where the constraints are defined as follows:\\[-.2em]
\[
\begin{array}{llll}
\C &::=& S <: X &\mbox{primitive constraint}\\
&\mid& X <: S &\mbox{primitive constraint}\\
&\mid& \C \cap \C& \mbox{intersection constraint}\\
&\mid& \C \cup \C& \mbox{union constraint}\\
&\mid& \FALSE& \mbox{empty union}\\
&\mid& \TRUE& \mbox{empty intersection}\\
\end{array}
\]
\\
Our constraint generation is based on the work by Smith and Cartwright \cite{smith08}
where it has been shown that the constraint generation for `<:`
is complete and sound for a type system without exclusion.
Smith and Cartwright also defined a normalization algorithm for 
constraints (summation of products,
replacement of contradictions with \FALSE,
removal of redundancies, etc).
We assume that all the constraints are normalized.

We also add the following equivalence judgment:

\infrule
  {\jcsub{S}{T}{\C} \andalso \jcsub{T}{S}{\C'}}
  {\jgconstrtemplate{S}{\equiv}{T}{\C \cap \C'}}
The equivalence constraint generation is complete and sound if and only if
the constraint generation for `<:` is.

Because we added a new subtyping rule to deal with exclusion,
we need to adjust the constraint generation rule to deal with intersection types:
\infrule
  {\jgconstrtemplate{S}{\exc}{T}{\C} \\
   \jcsub{S}{U}{\C'} \andalso\jcsub{T}{U}{\C''}}
  {\jcsub{S \cap T}{U}{\C \cup \C' \cup \C''}}
where the exclusion judgment is defined formally in the next section.

To define the exclusion judgment, we need to know
the conditions when two types are not equivalent and
when one type is not a subtype of the other.
For this, We add the following constraints:\\[-.2em]
\[
S \not<: X, X \not<: S
\]
\\
which we call {\it negatives}.
We call the subtyping constraints {\it positives}.
Then, we can define a new judgment:\\[-.2em]
\[
\jgconstrtemplate{S}{\not <:}{T}{\C}
\]
\\
that is defined by using de morgan's law on $\jcsub{S}{T}{\C}$.
Similarly, we can define:\\[-.2em]
\[
\jgconstrtemplate{S}{\not \equiv}{T}{\C}
\]

\vspace*{1em}
Solving constraints
% We will also need to have the ability to solve constraints.
% $\Delta \vdash solve(\C)$
% This
needs to be sound but not necessarily complete.
The following steps work in most cases (always sound, definitely incomplete):
\begin{enumerate}
\item Take $\C$ which is a union of intersection constraints and
try to solve each conjunct at a time (take the first one that succeeds).
\item Split the conjunct into positive and negative parts.
\item Deduce a set of equivalences from the positive part.
\item Solve the equivalences using what is basically unification (with subtyping) to get a substitution $\phi$.
\item Check whether applying $\phi$ to $\C$ is $\TRUE$.
\item If so return $`Some`(\phi)$, otherwise return `None`.
\end{enumerate}
To get better completeness properties,
one can iterate constraint solving if $\phi(\C)$ is not false.
However, this might converge to a fixed point instead of terminating
because the constraints that are negative or that do not imply an equivalence
are never used to generate $\phi$.
