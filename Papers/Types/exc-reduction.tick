In the evaluation of valid overloadings from Section~\ref{sec:examples},
intensional type analysis was required in order to reason about certain
examples. Since this reasoning justified
the validity of these overloaded functions, we incorporate it into
the present formal system as well.

Whenever two different domain types should be
applicable to the same argument type $W$ (in order to validate the Meet Rule
or Return Type Rule), an existentially quantified intersection type
naturally arises as the necessary supertype of $W$.
Intersection types $S \cap T$ in our type system naturally fall into two
distinct cases: either $S \nexc T$, or $S \exc T$ in which case the 
intersection has the same extent as \Bottom.
In the second case, the intersection is trivial and $W$, as
a subtype of the intersection, must also be trivial.
Moreover, because the argument type $W$ to which both declarations must be applicable
is necessarily equivalent to \Bottom, then the Meet Rule and Return Type Rule
are both trivially satisfied by the presence of the implicit overloading on
\Bottom. In this manner case analysis on whether an existentially
quantified (intersection) type is \Bottom facilitates the checking of our
rules.

Na\"{i}vely one might expect this case analysis on $S \cap T$ to simply check
whether $S \exc T$. However, as is the case when checking generic
function declarations, the types $S$ and $T$ might have free type variables,
whose uncertainty often precludes a definitive statement about $S \exc T$.
(For example, `C[\X\]` $\exc$ `C[\Y\]` holds only if $X \not\equiv Y$.) Our solution is to reason backwards: Under the assumption that the intersection
is nontrivial (that the types do not exclude), gather the necessary
constraints on type parameters. (For example, `C[\X\] CAP C[\Y\]` $\not\equiv \Bottom$ yields the constraint $X \equiv Y$.) These constraints are then
reduced, resulting in an instantiation (and potentially tighter bounds
on type parameters) that necessarily follows from our assumption of nontriviality.%
\footnote{A similar sort of case analysis and constraint solving
arises for pattern matching with generalized algebraic data types (GADTs) \cite{simonet07}: GADTs resemble our existential types and pattern matching resembles our function application.}


We call the general pattern of simplifying an existentially quantified
(intersection) type \emph{existential reduction}, given by the judgment $\jtred{\delta_1}{\delta_2}$ in Figure~\ref{fig:existential}.

\noindent\TODO{Stuff after this needs to be incorporated into the above.}






% We now use the non-equivalence judgment to make rigorous our intuition about
% how polymorphic exclusion affects the mechanical verification of the overloading rules.
To show that the overloadings of functions such as `tail` and `foo` are valid,
we needed to modify the $\subtypeofinner$ relation on existentials and universals
to use exclusion information:\\[1em]


A reduction judgment on existential types $\vdash\delta\eqred\delta',\phi$
defined in Figure~\ref{fig:existential} reduces $\delta = \exttype{T}$ to
$\delta' = \exttype[\Delta']{T'}$ with the substitution $\phi$
under the assumption that $T$ is not equivalent to \Bottom; or,
if $T$ is equivalent to \Bottom, the reduced existential $\delta'$ is \Bottom.
When the substitution is unnecessary we omit it.

In fact, an existential type $\delta$ reduces to $\delta'$
such that $T \ni \delta$ if and only if $T \ni \delta'$; therefore,
we have $\delta' \le \delta$.
Reducing an existential type in this fashion involves the same kind of
type analysis required for type checking generalized algebraic data types
\cite{simonet07,jones09}.



As an example, consider the following reduction:\\[.8em]
\begin{tabular}{l}
$\vdash$ `EXISTS[\X <: Any, Y <: ZZ\](ArrayList[\X\] CAP List[\Y\])`\\[.3em]
\andalso~~~~~~$\eqred$ `EXISTS[\W <: ZZ\]ArrayList[\W\]`
\end{tabular}
\\[.8em]
with substitution $[W/X,\, W/Y]$. We first check under what constraints $\C$
the intersection `ArrayList[\X\] CAP List[\Y\]` is not equivalent to \Bottom:
with polymorphic exclusion (specifically, the absence of multiple instantiation inheritance)
we know that `ArrayList[\X\]` excludes `List[\Y\]`,
which makes their intersection equivalent
to \Bottom, unless $X \equiv Y$ is true. Solving the constraint $X
\equiv Y$ yields a type substitution like $\phi = [W/X,\, W/Y]$. The
judgment $\phi[\Delta] = \Delta'$ lets us construct reduced bounds
from $\phi$ and the original bounds $\Delta$. To do this, we first
partition $\phi(\bar{X})$ into a list of type variables $\bar{Y}$ and a
list of other types $\bar{T}$. In our example, $\phi(X, Y) = W$ gets
partitioned into $W$ and $\emptyset$. Then we need to construct a new
bound $\phi^{-1}[Y_i, \Delta]$ for each $Y_i$ in $\bar{Y}$ by
conjoining the bounds for every type variable in $\phi^{-1}(Y)$. In
our example, $X$ and $Y$ map to $W$, so the bounds for $W$ are `{Any, ZZ}`,
which we take as the new bounds environment $\Delta'$. We must
ensure that the substitution does not produce invalid bounds, so we
check $\bar{\Delta' \vdash \phi(X) <: \bar{\phi(M)}}$. In our example,
`W <: {ZZ, Any}` easily proves that `W <: ZZ` and `W <: Any`. With
$\Delta'$ the reduced existential type is simply
$\exists\ob{\Delta'}\phi(T)$, where $T$ is the constituent type of the
original existential. In our example, the final, reduced existential
type is `EXISTS[\W <: ZZ\]ArrayList[\W\]`.
%
Once we have augmented the subtyping relation with existential
reduction, we can finally check that the declarations $\D(`foo`)$ from
Section~\ref{sec:problems} satisfy the Meet Rule.


Similiarly, to check that the declarations $\D(`tail`)$ from Section~\ref{sec:problems}
satisfy the Return Type Rule, we need to show the following:\\[.8em]
\begin{tabular}{l}
$\vdash$
`FORALL[\X<:Any\]ArrayList[\X\] -> ArrayList[\X\]`\\
$\le$
`FORALL[\X<:Any,Y<:Any\](ArrayList[\X\] CAP List[\Y\])`\\
\hspace*{11.2em}
`-> List[\Y\]`
\end{tabular}
\\[.8em]
%EXISTS[\X <: Any, Y <: ZZ\](ArrayList[\X\] CAP List[\Y\])
%\andalso~~~$\eqred$ `EXISTS[\W <: ZZ\]ArrayList[\W\]`
By the adjusted subtype relation in this section and the rules in Figure~\ref{fig:existential},
we can show the following:\\[.8em]
\begin{tabular}{l}
$\vdash$
`EXISTS[\X<:Any, Y<:Any\]ArrayList[\X\] CAP List[\Y\]`\\[.3em]
\andalso~~~$\eqred$ `EXISTS[\W <: Any\]ArrayList[\W\]`
\end{tabular}
\\[.8em]
with substitution $[W/X, W/Y]$.  Because the substitution satisfies the following:\\[.8em]
\begin{tabular}{l}
$\vdash$
`FORALL[\X<:Any\]ArrayList[\X\] -> ArrayList[\X\]`\\
$\le$
`FORALL[\X<:Any\]ArrayList[\X\] -> List[\X\]`\\
\end{tabular}
\\[.8em]
we can verify that the declarations $\D(`tail`)$ satisfy the Return Type Rule.


% A similar analysis shows that if an instance of a universal arrow has
% the domain `Bottom`, then it is irrelevant for the purposes of
% guaranteeing Progress. Therefore we can use our reduction rule for
% existential types to aid in the verification of the Return Type Rule
% by augmenting the subtype rules for universal arrows:
% \\[-1.5em]
% \infrule
%   {\jtreds{\exttype[\Delta_1]{T}}{\delta'}{\phi} \andalso
%    \jqsub{S}{\unitype[{\phi[\Delta_1]}]{\left(\arrowtype{\phi(T)}{\phi(U)}\right)}}}
%   {\jqsub{S}{\unitype[\Delta_1]{\arrowtype{T}{U}}}}
%  % {\Delta \vdash S <: reduce(`FORALL[\X_bar <: M_bar\]S \to T`)}
%  % {\Delta \vdash S <: `FORALL[\X_bar <: M_bar\]S \to T`}
% It is easy to see from the previous existential reduction instance that this subtype judgment can be proven,
% thus allowing us to verify the Return Type Rule for the function $\D(tail)$ from Section~4.

%% Because this subtype judgment holds for the previous existential
%% reduction instance, we can verify the Return Type Rule for the
%% function $\D(tail)$ from Section~4.
%% %% It is easy to see from the previous existential reduction instance
%% %% that this subtype judgment holds, thus allowing us to verify
%% %% the Return Type Rule for the function $\D(tail)$ from Section~4. 
