We now use the non-equivalence judgment to make rigorous our intuition about how polymorphic exclusion affects the mechanical verification of the overloading rules. We define a reduction judgment on existential types in Figure~\ref{fig:exred} which reduces $\delta$ to $\delta'$ such that $T \ni \delta$ if and only if $T \ni \delta$. Furthermore we have that $\delta' \le \delta$. Then we will show how augmenting the $\le$ relation with the rule
\infrule
  {\jtred{\delta}{\delta'} \andalso \jqsub{\delta'}{T}}
  {\jqsub{\delta}{T}}
lets us prove that more sets of overloaded functions satisfy the overloading rules. Reducing an
existential type in this fashion involves the same 
kind of type analysis required in other languages 
for type checking generalized algebraic data 
types \cite{simonet07,jones09}.

The reduction judgment $\;\jtreds{\delta}{\delta'}{\phi}\;$ says that the existential type $\delta = \exttype{T}$ reduces to $\delta' = \exttype[\Delta']{T'}$ with the substitution $\phi$ (when the substitution is unnecessary we omit it) under the assumption that $T$ is not equivalent to \BottomType; or, if $T$ is equivalent to \BottomType, the reduced existential $\delta'$ is \BottomType. As an example, consider the following instance of reduction %
\[ `EXISTS[\X <: Any, Y <: ZZ\](ArrayList[\X\] CAP List[\Y\])` \]
\[ \eqred \]
\[ `EXISTS[\W <: ZZ\]ArrayList[\W\]` \] %
with substitution $[X/Y]$. We first check under what constraints $\C$ the intersection `ArrayList[\X\] CAP List[\Y\]` is not equivalent to \BottomType: with polymorphic exclusion (specifically, the absence of multiple instantiation inheritance) we know that `ArrayList[\X\]` excludes `List[\Y\]`, which would make their intersection equivalent to \BottomType, unless $X \equiv Y$ is true. Solving the constraint $X \equiv Y$ yields a type substitution like $\phi = [W/X,\, W/Y]$. The judgment $\phi(\Delta) = \Delta'$ lets us construct reduced bounds from $\phi$ and the original bounds $\Delta$. To do this we first partition $\phi[\Delta]$ into a list of type variables $\bar{Y}$ and a list of other types $\bar{U}$. In our example $\phi(X, Y) = W$ gets partitioned into $W$ and $\emptyset$. Then we need to construct a new bound $\phi^{-1}[Y_i, \Delta]$ for each $Y_i$ in $\bar{Y}$ by conjoining the bounds for every type variable in $\varphi^{-1}(Y)$. In our example $X$ and $Y$ map to $W$, so the bounds for $W$ are `{Any, ZZ}`, which we take as the new bounds environment $\Delta'$. We must ensure that the substitution does not produce invalid bounds, so we check $\Delta' \vdash \phi(\bar{X}) <: \phi(\bar{M})$. In our example `W <: {ZZ, Any}` easily proves that `W <: ZZ` and `W <: Any`. With $\Delta'$ the reduced existential type is simply $\exists\ob{\Delta}\phi(T)$, where $T$ is the constituent type of the original existential. In our example, the final, reduced existential type is `EXISTS[\W <: ZZ\]ArrayList[\W\]`.

Once we have augmented the subtyping relation with existential reduction, we can finally check that the declarations $\D(foo)$ from Section~4 satisfy the Meet Rule.


%%%%%%%%%%%%%%% BEGIN REDUCTION FIGURE %%%%%%%%%%%%%%%%
\begin{figure}

\newjudge{Existential reduction}{\jtreds{\delta}{\delta}{\phi}}
\infrule
  {\jcequiv{T}{\BottomType}{\TRUE}}
  {\jtreds{\exttype{T}}{\BottomType}{[]}}

% \infrule
%   {\jcnonequiv{T}{\BottomType}{\C} \\
%    \jcsolve{\C}{\NONE}}
%   {\jtred{\exttype{T}}{\exttype{T}}}
% 
% \infrule
%   {\jcnonequiv{T}{\BottomType}{\C} \\
%    \jcsolve{\C}{\phi} \andalso \phi[\Delta] = \NONE}
%   {\jtred{\exttype{T}}{\exttype{T}}}

\infrule
  {\jcnonequiv{T}{\BottomType}{\C} \\
   \jcsolve{\C}{\phi} \andalso \phi[\Delta] = \Delta'}
  {\jtreds{\exttype{T}}{\exttype[\Delta']{\phi(T)}}{\phi}}

\newjudge{Bounds substitution}{\phi[\Delta] = \Delta}
\infrule
  {\Delta = \bds{X}{M}
      \andalso \phi(\bar{X}) = \bar{Y} \sqcup \bar{T}
      \andalso \bar{N} = \phi^{-1}[\bar{Y},\Delta] \\
    \forall i. \quad \jcsub[\bds{Y}{N}]{\phi(X_i)}{\bd{\phi(M_i)}}{\C_i}
      \andalso \C_i = \TRUE}
  {\phi[\Delta] = \bds{Y}{N}}

% \infrule
%   {\Delta = \bds{X}{M}
%       \andalso \phi(\bar{X}) = \bar{Y} \sqcup \bar{T}
%       \andalso \bar{N} = \phi^{-1}[\bar{Y},\Delta] \\
%     \exists i. \quad \jcsub[\bds{Y}{N}]{\phi(X_i)}{\bd{\phi(M_i)}}{\C_i}
%       \andalso \C_i \neq \FALSE}
%   {\phi[\Delta] = \NONE}

\newjudge{Bounds transfer}{\phi^{-1}[X,\Delta] = \bar{T}}
\infrule
  {\bar{T} = \{\phi(\Delta(X)) \;:\; X \in \Delta \;\text{and}\; \phi(X) = Y\}}
  {\phi^{-1}[Y,\Delta] = conjuncts(\bigcap \bar{T})}

  \caption{Reduction of existential types}
  \label{fig:exred}
\end{figure}
%%%%%%%%%%%%%%% END REDUCTION FIGURE %%%%%%%%%%%%%%%%

A similar analysis shows that if an instance of a universal arrow has the domain `BottomType`, then it is irrelevant for the purposes of guaranteeing Progress. Therefore we can use our reduction rule for existential types to aid in the verification of the Return Type Rule by augmenting the subtype rules for universal arrows.
\infrule
  {\jtreds{\exttype[\Delta_1]{T}}{\delta'}{\phi} \\
   \jqsub{S}{\unitype[{\phi[\Delta_1]}]{\left(\arrowtype{\phi(T)}{\phi(U)}\right)}}}
  {\jqsub{S}{\unitype[\Delta_1]{\arrowtype{T}{U}}}}
 % {\Delta \vdash S <: reduce(`FORALL[\X_bar <: M_bar\]S \to T`)}
 % {\Delta \vdash S <: `FORALL[\X_bar <: M_bar\]S \to T`}
It is easy to see from the previous existential reduction instance that this subtype judgment can be proven, thus allowing us to verify the Return Type Rule for the function $\D(tail)$ from Section~4.
