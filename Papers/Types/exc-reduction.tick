In the evaluation of valid overloadings from Section~\ref{sec:examples},
intensional type analysis was required in order to reason about certain
examples. Since this reasoning justified
the validity of these overloaded functions, we incorporate it into
the present formal system as well.

Whenever two different domain types should be
applicable to the same argument type $W$ (in order to validate the Meet Rule
or Return Type Rule), an existentially quantified intersection type
naturally arises as the necessary supertype of $W$.
Intersection types $S \cap T$ in our type system naturally fall into two
distinct cases: either $S \nexc T$, or $S \exc T$ in which case the 
intersection has the same extent as \Bottom.
In the second case, the intersection is trivial and $W$, as
a subtype of the intersection, must also be trivial.
Moreover, because the argument type $W$ to which both declarations must be applicable
is necessarily equivalent to \Bottom, then the Meet Rule and Return Type Rule
are both trivially satisfied by the presence of the implicit overloading on
\Bottom. In this manner case analysis on whether an existentially
quantified (intersection) type is \Bottom facilitates the checking of our
rules.

Na\"{i}vely one might expect this case analysis on $S \cap T$ to simply check
whether $S \exc T$. However, as is the case when checking generic
function declarations, the types $S$ and $T$ might have free type variables,
whose uncertainty often precludes a definitive statement about $S \exc T$.
(For example, `C[\X\]` $\exc$ `C[\Y\]` holds only if $X \not\equiv Y$.) Our solution is to reason backwards: Under the assumption that the intersection
is nontrivial (that the types do not exclude), gather the necessary
constraints on type parameters. (For example, `C[\X\] CAP C[\Y\]` $\not\equiv \Bottom$ yields the constraint $X \equiv Y$.) These constraints are then
reduced, resulting in an instantiation (and potentially tighter bounds
on type parameters) that necessarily follows from our assumption of nontriviality.%
\footnote{A similar sort of case analysis and constraint solving
arises for pattern matching with generalized algebraic data types (GADTs) \cite{simonet07}: GADTs resemble our existential types and pattern matching resembles our function application.}


We call the general pattern of simplifying an existentially quantified
(intersection) type \emph{existential reduction}, given by the judgment $\jtred{\delta_1}{\delta_2}$ in Figure~\ref{fig:exred}. The first rule for existential reduction performs the constraint-based case analysis described above, while the second merely relates the existential to itself if the premises of the first rule do not hold. We thus explain the first rule in more detail.

The first premise determines the constraints $\C$ that must be true under
the hypothesis that $T \not\equiv \Bottom$ (i.e. that this type is
nontrivial). Note that the type variables from $\Delta$ are bound, while any
type variables from the existential itself, $\Delta'$, become inference type
variables mentioned in $\C$. The second premise binds $\C'$ to exactly
the inference type variables and bounds denoted by the existential's type parameters; these are the constraints that must hold for $T$ to still make
sense.
In the third premise, if \textit{unify} succeeds, it
produces a substitution $\phi$ for any inference type variables from $\Delta'$ constrained by equalities. Because $\phi$ is a most general unifier, it has the property that any other valid substitution $\psi$ of $\Delta'$'s variables with
$\psi(T) \not\equiv \Bottom$ must be equal to $\tau \circ \phi$, for some
other substitution $\tau$. Moreover, if \textit{unify} succeeds, it produces
a set of leftover constraints $\C''$ that are not unifiable equalities (but have still
been simplified).
If it is possible to express $\C''$ as some type environment $\Delta''$,
then we use this as the new type parameters over the simplified type
$\phi(T)$.

Similarly we call the general pattern of simplifying a universally quantified arrow type \emph{universal reduction} given by the judgment $\jtred{\sigma_1}{\sigma_2}$
The first premise reduces the domain type $\dom(\sigma) = \exttype[\Delta']{S}$, resulting in a new existential type $\delta = \exttype[\Delta'']{\phi(S)}$ and a substitution $\phi$ mapping type variables from $\Delta'$
to types with variables in $\Delta''$. We then construct a new arrow with domain $\delta$ and range $\phi(T)$.

%%%%%%%%%%%%%%%%%%%%% BEGIN EXRED FIG %%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t!]
\centering
\vspace*{.5em}

\newjudge{Existential Reduction}{\jtreds{\delta}{\delta}{\phi}}
\infrule
  {\jcnequiv{T}{\Bottom}{\C} \andalso \toConstraint{\Delta'}{\C'} \\
   \jsolve{\C \wedge \C'}{\phi}{\C''} \andalso \toBound{\C''}{\Delta''}}
  {\jtreds{\exttype[\Delta']{T}}{\exttype[\Delta'']{\phi(T)}}{\phi}}

\infrule
  {\text{otherwise}}
  {\jtreds{\exttype[\Delta']{T}}{\exttype[\Delta']{T}}{\subst{}{}}}

  \caption{Existential reduction judgment.}
  \label{fig:exred}
  
\newjudge{Universal Reduction}{\jtreds{\sigma}{\sigma}{\phi}}
\infrule
  {\jtreds{\exttype[\Delta']{S}}{\exttype[\Delta'']{\phi(S)}}{\phi}}
  {\jtreds{\unitype[\Delta']{\arrowtype{S}{T}}}{\unitype[\Delta'']{\arrowtype{\phi(S)}{\phi(T)}}}{\phi}}


\infrule
  {\text{otherwise}}
  {\jtreds{\unitype[\Delta']{\arrowtype{S}{T}}}{\unitype[\Delta']{\arrowtype{S}{T}}}{\subst{}{}}}

  
\end{figure}
%%%%%%%%%%%%%%%%%%%%% END EXRED FIG %%%%%%%%%%%%%%%%%%%%%%

As an example, in order to check that the first two declarations of $\D_{\mathit{bar}}$ from Section~$\ref{sec:examples}$ satisfy the Meet Rule,
we must reduce the existential \[
\text{`EXISTS[\X <: Any, Y <: ZZ\](ArrayList[\X\] CAP List[\Y\]).`}
\] Thus we must find the constraint $\C$ such that \[
\jcnequiv[]{\text{`ArrayList[\X\] CAP List[\Y\]`}}{\Bottom}{\C}
\] can be derived, noting that $X$ and $Y$ are actually (unbound) type inference variables here. In this instance $\C = X \equiv Y$ due to multiple
instantiation exclusion. Then we convert the bounds on the existential's type parameters into the constraint $\C'$ on $X$ and $Y$ as inference variables: $\toConstraint{\text{`X <: Any, Y <: ZZ`}}{\text{`X <: Any, Y <: ZZ`}}$.
Unifying the constraint \[
\C \wedge \C' = X \equiv Y \wedge X \subtypeof `Any` \wedge Y \subtypeof `ZZ`
\] yields the type substitution $\phi = [W/X, W/Y]$ (for some fresh variable $W$) and the simplified leftover constraint $\C'' =$ \text{`W <: ZZ`}. Since $\C''$ has the
form of a type environment, $\toBound{\C''}{\text{`W <: ZZ`}}$,
we finally reduce this existential to `EXISTS[\W <: ZZ\](ArrayList[\W\] CAP List[\W\])`. However, due to the class table declaration of `ArrayList[\W\]`
this existential type will be indistinguishable (by $\leinner$) from the simpler `EXISTS[\W<:ZZ\]ArrayList[\W\]`.


% % We now use the non-equivalence judgment to make rigorous our intuition about
% % how polymorphic exclusion affects the mechanical verification of the overloading rules.
% To show that the overloadings of functions such as `tail` and `foo` are valid,
% we needed to modify the $\subtypeofinner$ relation on existentials and universals
% to use exclusion information:\\[1em]
% 
% 
% A reduction judgment on existential types $\vdash\delta\eqred\delta',\phi$
% defined in Figure~\ref{fig:existential} reduces $\delta = \exttype{T}$ to
% $\delta' = \exttype[\Delta']{T'}$ with the substitution $\phi$
% under the assumption that $T$ is not equivalent to \Bottom; or,
% if $T$ is equivalent to \Bottom, the reduced existential $\delta'$ is \Bottom.
% When the substitution is unnecessary we omit it.
% 
% In fact, an existential type $\delta$ reduces to $\delta'$
% such that $T \ni \delta$ if and only if $T \ni \delta'$; therefore,
% we have $\delta' \le \delta$.
% Reducing an existential type in this fashion involves the same kind of
% type analysis required for type checking generalized algebraic data types
% \cite{simonet07,jones09}.
% 
% 
% 
% As an example, consider the following reduction:\\[.8em]
% \begin{tabular}{l}
% $\vdash$ `EXISTS[\X <: Any, Y <: ZZ\](ArrayList[\X\] CAP List[\Y\])`\\[.3em]
% \andalso~~~~~~$\eqred$ `EXISTS[\W <: ZZ\]ArrayList[\W\]`
% \end{tabular}
% \\[.8em]
% with substitution $[W/X,\, W/Y]$. We first check under what constraints $\C$
% the intersection `ArrayList[\X\] CAP List[\Y\]` is not equivalent to \Bottom:
% with polymorphic exclusion (specifically, the absence of multiple instantiation inheritance)
% we know that `ArrayList[\X\]` excludes `List[\Y\]`,
% which makes their intersection equivalent
% to \Bottom, unless $X \equiv Y$ is true. Solving the constraint $X
% \equiv Y$ yields a type substitution like $\phi = [W/X,\, W/Y]$. The
% judgment $\phi[\Delta] = \Delta'$ lets us construct reduced bounds
% from $\phi$ and the original bounds $\Delta$. To do this, we first
% partition $\phi(\bar{X})$ into a list of type variables $\bar{Y}$ and a
% list of other types $\bar{T}$. In our example, $\phi(X, Y) = W$ gets
% partitioned into $W$ and $\emptyset$. Then we need to construct a new
% bound $\phi^{-1}[Y_i, \Delta]$ for each $Y_i$ in $\bar{Y}$ by
% conjoining the bounds for every type variable in $\phi^{-1}(Y)$. In
% our example, $X$ and $Y$ map to $W$, so the bounds for $W$ are `{Any, ZZ}`,
% which we take as the new bounds environment $\Delta'$. We must
% ensure that the substitution does not produce invalid bounds, so we
% check $\bar{\Delta' \vdash \phi(X) <: \bar{\phi(M)}}$. In our example,
% `W <: {ZZ, Any}` easily proves that `W <: ZZ` and `W <: Any`. With
% $\Delta'$ the reduced existential type is simply
% $\exists\ob{\Delta'}\phi(T)$, where $T$ is the constituent type of the
% original existential. In our example, the final, reduced existential
% type is `EXISTS[\W <: ZZ\]ArrayList[\W\]`.
% %
% Once we have augmented the subtyping relation with existential
% reduction, we can finally check that the declarations $\D(`foo`)$ from
% Section~\ref{sec:problems} satisfy the Meet Rule.
% 
% 
% Similiarly, to check that the declarations $\D(`tail`)$ from Section~\ref{sec:problems}
% satisfy the Return Type Rule, we need to show the following:\\[.8em]
% \begin{tabular}{l}
% $\vdash$
% `FORALL[\X<:Any\]ArrayList[\X\] -> ArrayList[\X\]`\\
% $\le$
% `FORALL[\X<:Any,Y<:Any\](ArrayList[\X\] CAP List[\Y\])`\\
% \hspace*{11.2em}
% `-> List[\Y\]`
% \end{tabular}
% \\[.8em]
% %EXISTS[\X <: Any, Y <: ZZ\](ArrayList[\X\] CAP List[\Y\])
% %\andalso~~~$\eqred$ `EXISTS[\W <: ZZ\]ArrayList[\W\]`
% By the adjusted subtype relation in this section and the rules in Figure~\ref{fig:existential},
% we can show the following:\\[.8em]
% \begin{tabular}{l}
% $\vdash$
% `EXISTS[\X<:Any, Y<:Any\]ArrayList[\X\] CAP List[\Y\]`\\[.3em]
% \andalso~~~$\eqred$ `EXISTS[\W <: Any\]ArrayList[\W\]`
% \end{tabular}
% \\[.8em]
% with substitution $[W/X, W/Y]$.  Because the substitution satisfies the following:\\[.8em]
% \begin{tabular}{l}
% $\vdash$
% `FORALL[\X<:Any\]ArrayList[\X\] -> ArrayList[\X\]`\\
% $\le$
% `FORALL[\X<:Any\]ArrayList[\X\] -> List[\X\]`\\
% \end{tabular}
% \\[.8em]
% we can verify that the declarations $\D(`tail`)$ satisfy the Return Type Rule.
% 
% 
% % A similar analysis shows that if an instance of a universal arrow has
% % the domain `Bottom`, then it is irrelevant for the purposes of
% % guaranteeing Progress. Therefore we can use our reduction rule for
% % existential types to aid in the verification of the Return Type Rule
% % by augmenting the subtype rules for universal arrows:
% % \\[-1.5em]
% % \infrule
% %   {\jtreds{\exttype[\Delta_1]{T}}{\delta'}{\phi} \andalso
% %    \jqsub{S}{\unitype[{\phi[\Delta_1]}]{\left(\arrowtype{\phi(T)}{\phi(U)}\right)}}}
% %   {\jqsub{S}{\unitype[\Delta_1]{\arrowtype{T}{U}}}}
% %  % {\Delta \vdash S <: reduce(`FORALL[\X_bar <: M_bar\]S \to T`)}
% %  % {\Delta \vdash S <: `FORALL[\X_bar <: M_bar\]S \to T`}
% % It is easy to see from the previous existential reduction instance that this subtype judgment can be proven,
% % thus allowing us to verify the Return Type Rule for the function $\D(tail)$ from Section~4.
% 
% %% Because this subtype judgment holds for the previous existential
% %% reduction instance, we can verify the Return Type Rule for the
% %% function $\D(tail)$ from Section~4.
% %% %% It is easy to see from the previous existential reduction instance
% %% %% that this subtype judgment holds, thus allowing us to verify
% %% %% the Return Type Rule for the function $\D(tail)$ from Section~4. 
