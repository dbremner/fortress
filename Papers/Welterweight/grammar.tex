



\begin{figure*}

\begin{tabular*}{\textwidth}{@{}l@{\extracolsep{0pt plus 1fil}}|l@{}}
\begin{array}[t]{@{}l@{\;}c@{\;}l@{\hskip 1.5em}l@{\hskip 0em}l@{}}
p        & ::= &  \bar{\delta}, e                                                    & \multicolumn{2}{@{}l@{}}{\hbox{\rm program (declarations plus expression)\hskip0.9em}} \\[4pt]
\delta   & ::= &  \multicolumn{2}{@{}l@{\hskip 1.5em}}{ \kwd{trait} \; T\bigobb{V\;\beta}
                              \mathbin{\extends} \bigbd{t} \mathbin{\exc} \bigbd{t} \mathbin{\comprises} \bigbd{c} \; \bar{\mu} \; \kwd{end}              } & \hbox{\rm trait declaration} \\[1pt]
         &  |  &  \multicolumn{2}{@{}l@{\hskip 1.5em}}{ \kwd{object} \; O\bigobb{\beta} (\bar{z\COLON\tau}) \extends \bigbd{t} \; \bar{\mu } \; \kwd{end} } & \hbox{\rm object declaration} \\[1pt]
         &  |  &  \multicolumn{2}{@{}l@{\hskip 1.5em}}{ f\bigobb{\beta} (\bar{x\COLON\tau})\COLON\tau = e                                                 } & \hbox{\rm function declaration} \\[4pt]
V        & ::= &  \multicolumn{2}{@{}l@{\hskip 1.5em}}{ \kwd{covariant} \mid \kwd{contravariant} \mid \kwd{invariant}                                     } & \hbox{\rm variance} \\[4pt]
\mu      & ::= &  m\bigobb{\varphi} (\bar{x\COLON\tau})\COLON\tau = e                & \multicolumn{2}{@{}l@{}}{\hbox{\rm method declaration}} \\[4pt]
\beta    & ::= &  P \extends \bdb{\tau}                                              & \multicolumn{2}{@{}l@{}}{\hbox{\rm simple type parameter binding}} \\[4pt]
\varphi  & ::= &  \bdb{\tau} \extends P \extends \bdb{\tau}                          & \multicolumn{2}{@{}l@{}}{\hbox{\rm full type parameter binding}} \\[4pt]
e        & ::= &  x                                                                  & \multicolumn{2}{@{}l@{}}{\hbox{\rm variable reference}} \\
         &  |  &  \kwd{self}                                                         & \multicolumn{2}{@{}l@{}}{\hbox{\rm self reference}} \\
         &  |  &  (\bar{e})                                                          & \multicolumn{2}{@{}l@{}}{\hbox{\rm tuple creation}} \\
         &  |  &  \pi_i(e)                                                           & \multicolumn{2}{@{}l@{}}{\hbox{\rm tuple projection}} \\
         &  |  &  ((\bar{x\COLON\tau})\COLON\tau \Rightarrow e)                      & \multicolumn{2}{@{}l@{}}{\hbox{\rm function creation}} \\
         &  |  &  e(\bar{e})                                                         & \multicolumn{2}{@{}l@{}}{\hbox{\rm function application}} \\
         &  |  &  e.z                                                                & \multicolumn{2}{@{}l@{}}{\hbox{\rm field reference}} \\
         &  |  &  O\obb{\tau}(\bar{e})                                               & \multicolumn{2}{@{}l@{}}{\hbox{\rm object creation}} \\
         &  |  &  f\obb{\tau}(\bar{e})                                               & \multicolumn{2}{@{}l@{}}{\hbox{\rm function invocation}} \\
         &  |  &  e.m\obb{\tau}(\bar{e})                                             & \multicolumn{2}{@{}l@{}}{\hbox{\rm method invocation}} \\
         &  |  &  (e \; \kwd{match} \; x\COLON\tau \Rightarrow e \; \kwd{else}\; e)  & \multicolumn{2}{@{}l@{}}{\hbox{\rm match expression}}
\end{array}
&
\begin{array}[t]{@{}l@{\;}c@{\;}l@{\hskip 1.5em}l@{}}
\tau     & ::= &  P                                         & \hbox{\rm type parameter reference} \\
         &  |  &  c                                         & \hbox{\rm constructed type} \\
         &  |  &  (\bar{\tau})                              & \hbox{\rm tuple type} \\
         &  |  &  \arrowtype{\tau}{\tau}                    & \hbox{\rm arrow type} \\
         &  |  &  \TYP{Any}                                     & \hbox{\rm special \TYP{Any} type} \\
         &  |  &  \TYP{Object}                                  & \hbox{\rm special \TYP{Object} type} \\[4pt]
c        & ::= &  O\obb{\tau}                               & \hbox{\rm object type} \\
         &  |  &  t                                         & \hbox{\rm trait type} \\[4pt]
t        & ::= &  T\obb{\tau}                               & \hbox{\rm trait type} \\[4pt]
P        & ::= &  \hbox{\rm identifier}                     & \hbox{\rm type parameter name} \\[4pt]
T        & ::= &  \hbox{\rm identifier}                     & \hbox{\rm generic trait name} \\[4pt]
O        & ::= &  \hbox{\rm identifier}                     & \hbox{\rm generic object name} \\[4pt]
x        & ::= &  \hbox{\rm identifier}                     & \hbox{\rm variable name} \\[4pt]
z        & ::= &  \hbox{\rm identifier}                     & \hbox{\rm field name} \\[4pt]
f        & ::= &  \hbox{\rm identifier}                     & \hbox{\rm function name} \\[4pt]
m        & ::= &  \hbox{\rm identifier}                     & \hbox{\rm method name} \\[4pt]
i        & ::= &  \hbox{\rm integer}                        & \hbox{\rm fixed integer}
\end{array}
\end{tabular*}

\caption{Grammar for Welterweight Fortress}
\label{fig:grammar}
\end{figure*}


\begin{figure}

\begin{array}[t]{@{}l@{\;}c@{\;}l@{\hskip 2em}l@{}}
\alpha   & ::= &  P                                  & \hbox{\rm type parameter name} \\
         &  |  &  T\obb{\alpha}                      & \hbox{\rm trait type} \\
         &  |  &  O\obb{\alpha}                      & \hbox{\rm object type} \\
         &  |  &  (\bar{\alpha})                     & \hbox{\rm tuple type} \\
         &  |  &  \arrowtype{\alpha}{\alpha}         & \hbox{\rm arrow type} \\
         &  |  &  \TYP{Any}                              & \hbox{\rm special \TYP{Any} type} \\
         &  |  &  \TYP{Object}                           & \hbox{\rm special \TYP{Object} type} \\
         &  |  &  \TYP{Bottom}                           & \hbox{\rm special \TYP{Bottom} type} \\
         &  |  &  \uniontype{\alpha}{\alpha}         & \hbox{\rm union type} \\
         &  |  &  \intersectiontype{\alpha}{\alpha}  & \hbox{\rm intersection type} \\[4pt]
\kappa   & ::= &  \alpha                             & \hbox{\rm lattice type} \\
         &  |  &  \existstypeb{\varphi}{\alpha}      & \hbox{\rm existentially quantified type} \\[1pt]
         &  |  &  \foralltypeb{\varphi}{\alpha}      & \hbox{\rm universally quantified type} \\[4pt]
\xi      & ::= &  \delta                             & \hbox{\rm program declaration} \\
         &  |  &  \varphi                            & \hbox{\rm full type parameter binding} \\[4pt]
\Delta   & ::= &  \bar{\xi}                          & \hbox{\rm type-declaration environment} \\[4pt]
\Gamma   & ::= &  \bar{x:\alpha}                     & \hbox{\rm variable-type environment} \\[4pt]
\end{array}

\caption{Symbols Not Used in the Concrete Syntax}
\label{fig:internalsymbols}
\end{figure}


\begin{figure}

\begin{array}[t]{@{}l@{\;}c@{\;}l@{\hskip 2em}l@{}}
v        & ::= &  O\obb{\alpha}(\bar{v})                              & \hbox{\rm object instance} \\
         &  |  &  (\bar{v})                                           & \hbox{\rm tuple value} \\
         &  |  &  ((\bar{x\COLON\tau})\COLON\tau \Rightarrow e)     & \hbox{\rm function value} \\[4pt]
E        & ::= &  \Box                                                               & \hbox{\rm evaluation context} \\
         &  |  &  (\bar{e}\,E\,\bar{e})                                              \\
         &  |  &  \pi_i(E)                                                           \\
         &  |  &  E(\bar{e})                                                         \\
         &  |  &  e(\bar{e}\,E\,\bar{e})                                             \\
         &  |  &  E.z                                                                \\
         &  |  &  O\obb{\tau}(\bar{e}\,E\,\bar{e})                                   \\
         &  |  &  f\obb{\tau}(\bar{e}\,E\,\bar{e})                                   \\
         &  |  &  E.m\obb{\tau}(\bar{e})                                             \\
         &  |  &  e.m\obb{\tau}(\bar{e}\,E\,\bar{e})                                 \\
         &  |  &  (E \; \kwd{match} \; x\COLON\tau \Rightarrow e \; \kwd{else}\; e)  \\[4pt]
R        & ::= &  \pi_i(v)                                                           & \hbox{\rm redex} \\
         &  |  &  v(\bar{v})                                                         \\
         &  |  &  v.z                                                                \\
         &  |  &  f\obb{\tau}(\bar{v})                                               \\
         &  |  &  v.m\obb{\tau}(\bar{v})                                             \\
         &  |  &  (v \; \kwd{match} \; x\COLON\tau \Rightarrow e \; \kwd{else}\; e)
\end{array}

\bigskip
\newjudge{Ilk of a value}{\mathit{ilk}(v) = \alpha}
\medskip
\begin{array}[t]{@{}l@{}}
\mathit{ilk}(O\obb{\alpha}(\bar{v})) = O\obb{\alpha} \\[2pt]
\mathit{ilk}((\bar{v})) = (\bar{\mathit{ilk}(v)}) \\[2pt]
\mathit{ilk}(((\bar{x\COLON\tau})\COLON\tau' \Rightarrow e)) = \arrowtype{(\bar{\tau})}{\tau'}
\end{array}

\medskip
\caption{Values, Evaluation Contexts, Redexes, and Ilks}
\label{fig:values}
\end{figure}



\begin{figure}

\newjudge{Evaluation rules}{\jevalstep[\Delta]{E[R]}{E[e]}}

\bigskip

\infrule[R-Field]
  {  \kwd{object} \; O\ob{\dontcare} (\bar{z\COLON\dontcare}) \dontcare \; \kwd{end} \in \set{\Delta} \\
     1 \leq i \leq \countof(\bar{z})}
  { \jevalstep[\Delta]{E[O\obb{\alpha}(\bar{v}).z_i]}{E[v_i]} }

\infrule[R-Apply]
  { \jsub[\Delta]{(\bar{\mathit{ilk}(v)})}{(\bar{\tau})} }
  { \jevalstep[\Delta]{}{E\big[ [\bar{v/x}]e \big]} }


\medskip
\caption{Dynamic Semantics: Evaluation Rules}
\label{fig:evaluation}
\end{figure}


