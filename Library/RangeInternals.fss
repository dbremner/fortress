(*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component RangeInternals
import TypeProxy.{...}
export RangeInternals

private printLimit = 5

(************************************************************
* Bounds juggling and modular arithmetic
************************************************************)

(** Much of the complexity in ranges is getting the corner cases right
    for unbounded ranges, backwards ranges, and intersection thereof.
    There's hairy modular arithmetic involved in intersecting strided
    ranges, but that mostly involves working around the round-to-0
    behavior of machine arithmetic (which is exceedingly
    irritating). **)

(* Round to nearest multiple of stride towards 0. *)
roundToStride[\I extends Integral[\I\]\](amt:I, stride:I) =
    stride (amt DIV stride)

(* Perform necessary arithmetic on strides to find starting points of
   ranges.  The following start at the given starting point and go either
   up or down by stride, until the bound is reached as described.

   A positive stride is assumed! *)
atOrAboveGoingUp[\I extends Integral[\I\]\](start:I,bound:I,stride:I): I =
    start + roundToStride(bound-start+stride-1, stride)
atOrBelowGoingUp[\I extends Integral[\I\]\](start:I,bound:I,stride:I): I =
    start + roundToStride(bound-start, stride)
atOrBelowGoingDown[\I extends Integral[\I\]\](start:I,bound:I,stride:I): I =
    start - roundToStride(start-bound+stride-1, stride)
atOrAboveGoingDown[\I extends Integral[\I\]\](start:I,bound:I,stride:I): I =
    start - roundToStride(start-bound, stride)

(* These work as above, but do not assume a particular relationship0
   between starting point and bound---so they either count up or count
   down as appropriate.  This requires a test when rounding division
   to 0. *)
atOrBelow[\I extends Integral[\I\]\](start:I, bound:I, stride:I): I =
    if start <= bound then atOrBelowGoingUp(start,bound,stride)
    else atOrBelowGoingDown(start,bound,stride) end

atOrAbove[\I extends Integral[\I\]\](start:I, bound:I, stride:I): I =
    if start >= bound then atOrAboveGoingDown(start,bound,stride)
    else atOrAboveGoingUp(start,bound,stride) end

(* Find meeting point given the two bounds; tries to avoid overflow. *)
meetingPoint[\I extends Integral[\I\]\](init0:I, stride0:I, init1:I, stride1:I, stride:I): Maybe[\I\] =
    if init0 = init1 then Just[\I\](init0)
    else
        (i_min,s_min,i_max,s_max) : (I,I,I,I) :=
            if init0 < init1 then
                (init0,stride0,init1,stride1)
            else
                (init1,stride1,init0,stride0)
            end
        i_max := atOrAboveGoingDown(i_max,i_min,s_max)
        endPoint = i_min + stride
        while i_max =/= i_min AND i_max < endPoint do
            i_next = atOrAboveGoingUp(i_min,i_max,s_min)
            (i_min,s_min,i_max,s_max) := (i_max,s_max,i_next,s_min)
        end
        if i_max = i_min then
            Just[\I\](i_max)
        else
            Nothing[\I\]
        end
    end

(************************************************************
* Help for comparisons
************************************************************)

(** Stride comparison *)
opr SCMP[\I extends Integral[\I\]\](a:I, b:I): Comparison =
    if a = b then EqualTo
    elif (a < 0 AND b > 0) OR (a > 0 AND b < 0) then
        Unordered
    elif a DIVIDES b then
        GreaterThan
    elif b DIVIDES a then
        LessThan
    else
        Unordered
    end

opr SCMP[\I extends Integral[\I\], J extends Integral[\J\]\](a:(I,J), b:(I,J)): Comparison = do
    (ai,aj) = a; (bi,bj) = b
    (ai SCMP bi) SYMMETRIC_PARTIAL (aj SCMP bj)
  end

opr SCMP[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\]\]
        (a:(I,J,K), b:(I,J,K)): Comparison = do
    (ai,aj,ak) = a; (bi,bj,bk) = b
    (ai SCMP bi) SYMMETRIC_PARTIAL: ((aj SCMP bj) SYMMETRIC_PARTIAL: (ak SCMP bk))
  end


(** Point comparison *)
opr PCMP[\I extends Integral[\I\]\](a:I, b:I): Comparison = a CMP b

opr PCMP[\I extends Integral[\I\], J extends Integral[\J\]\](a:(I,J), b:(I,J)): Comparison = do
    (ai,aj) = a; (bi,bj) = b
    (ai PCMP bi) SYMMETRIC_PARTIAL (aj PCMP bj)
  end

opr PCMP[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\]\]
        (a:(I,J,K), b:(I,J,K)): Comparison = do
    (ai,aj,ak) = a; (bi,bj,bk) = b
    (ai PCMP bi) SYMMETRIC_PARTIAL: ((aj PCMP bj) SYMMETRIC_PARTIAL: (ak PCMP bk))
  end


(** Bounds checks for narrowToRange *)
checkSelection[\R extends Range[\I\], I\]
              (this:Range[\I\], other: Range[\I\], r:R): R = do
    tf = this.forward()
    otf = other.forward()
    for tfl <- tf.left, ofl <- otf.left, tfl > ofl, NOT tf.isEmpty, NOT otf.isEmpty do
        println(other " left outside bounds " this)
        throw IndexOutOfBounds[\I\](this,ofl)
    end
    for tfr <- tf.right, ofr <- otf.right, tfr < ofr, NOT tf.isEmpty, NOT otf.isEmpty do
        println(other " right outside bounds " this)
        throw IndexOutOfBounds[\I\](this,ofr)
    end
    r
  end

(************************************************************
* Concrete Range Traits
************************************************************)

trait ScalarRange[\I extends Integral[\I\]\] extends { Range[\I\] }
    truncL(l:I): ScalarRangeWithLeft[\I\] = do
        dir = if self.stride > 0 then 1 else -1 end
        self INTERSECTION leftScalarRange[\I\](l,dir)
      end
    opr INTERSECTION(self, other: Range[\I\]): Range[\I\] =
        fail("ScalarRange INTERSECTION Range!  Shouldn't happen.")
    intersectWithExtent(e:ExtentScalarRange[\I\]): ScalarRangeWithExtent[\I\]
    check(): ScalarRange[\I\] = do
        str = self.stride
        if str = 0 then fail(dump() ": Zero stride") end
        for l <- self.left, r <- self.right do
            if (l-r) MOD str =/= 0 AND NOT self.isEmpty then
                fail(dump() ": Bounds don't match stride.")
            end
        end
        self
      end
end

combine2D[\I extends Integral[\I\], J extends Integral[\J\]\]
         (i:ScalarRange[\I\], j:ScalarRange[\J\]): Range2D[\I,J\] =
    fail("shouldn't happen: combine2D of non-uniform ranges " i " and " j)

trait Range2D[\I extends Integral[\I\], J extends Integral[\J\]\] extends Range[\(I,J)\]
    getter range1(): ScalarRange[\I\]
    getter range2(): ScalarRange[\J\]
    getter stride(): (I,J) = (self.range1.stride, self.range2.stride)
    getter isEmpty(): Boolean = self.range1.isEmpty OR self.range2.isEmpty
    getter toString(): String = "(" self.range1 " BY " self.range2 ")"
    every(s_i:I, s_j:J): Range2D[\I,J\]
    atMost(n_i:I, n_j:J): Range2D[\I,J\] =
        combine2D(self.range1.atMost(n_i), self.range2.atMost(n_j))
    truncL(l_i:I, l_j:J): RangeWithLeft[\(I,J)\] =
        combine2D(self.range1.truncL(l_i),self.range2.truncL(l_j))
    truncR(r_i:I, r_j:J): RangeWithRight[\(I,J)\] =
        combine2D(self.range1.truncR(r_i),self.range2.truncR(r_j))
    opr INTERSECTION(self, other: Range[\(I,J)\]): Range[\(I,J)\] =
        fail("other is Range[\\(I,J)\\] but not Range2D")
    opr INTERSECTION(self, other: Range2D[\I,J\]): Range[\(I,J)\] =
        combine2D(self.range1 INTERSECTION other.range1,
                  self.range2 INTERSECTION other.range2)
    opr IN(n:(I,J), self): Boolean = do
        (n_i,n_j) = n
        n_i IN self.range1 AND: n_j IN self.range2
      end
    opr =(self, other:Range2D[\I,J\]): Boolean =
        self.range1 = other.range1 AND: self.range2 = other.range2
    check():Range2D[\I,J\] = do
        _ = self.range1.check()
        _ = self.range2.check()
        self
      end
end

trait ActualRange2D[\I extends Integral[\I\], J extends Integral[\J\],
                    Self extends ActualRange2D[\I,J,Self,Scalar1,Scalar2\],
                    Scalar1 extends ScalarRange[\I\],
                    Scalar2 extends ScalarRange[\J\]\] extends Range2D[\I,J\]
    getter range1(): Scalar1
    getter range2(): Scalar2
    every(s_i:I, s_j:J): Self =
        self.recombine(self.range1.every(s_i), self.range2.every(s_j))
    recombine(a:Scalar1, b:Scalar2): Self
end

combine3D[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\]\]
         (i:ScalarRange[\I\], j:ScalarRange[\J\], k:ScalarRange[\K\]): Range3D[\I,J,K\] =
    fail("shouldn't happen: combine3D of non-uniform ranges " i " and " j)

trait Range3D[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\]\] extends Range[\(I,J,K)\]
    getter range1(): ScalarRange[\I\]
    getter range2(): ScalarRange[\J\]
    getter range3(): ScalarRange[\K\]
    getter stride(): (I,J,K) =
        (self.range1.stride, self.range2.stride, self.range3.stride)
    getter isEmpty(): Boolean =
        self.range1.isEmpty OR self.range2.isEmpty OR self.range3.isEmpty
    getter toString(): String = "(" self.range1 " BY " self.range2 " BY " self.range3 ")"
    every(s_i:I, s_j:J, s_k:K): Range3D[\I,J,K\]
    atMost(n_i:I, n_j:J, n_k:K): Range3D[\I,J,K\] =
        combine3D(self.range1.atMost(n_i), self.range2.atMost(n_j), self.range3.atMost(n_k))
    truncL(l_i:I, l_j:J, l_k:K): RangeWithLeft[\(I,J,K)\] =
        combine3D(self.range1.truncL(l_i), self.range2.truncL(l_j),self.range3.truncL(l_k))
    truncR(r_i:I, r_j:J, r_k:K): RangeWithRight[\(I,J,K)\] =
        combine3D(self.range1.truncR(r_i), self.range2.truncR(r_j),self.range3.truncR(r_k))
    opr INTERSECTION(self, other: Range[\(I,J,K)\]): Range[\(I,J,K)\] =
        fail("other is Range[\\(I,J,K)\\] but not Range3D")
    opr INTERSECTION(self, other: Range3D[\I,J,K\]): Range[\(I,J,K)\] =
        combine3D(self.range1 INTERSECTION other.range1,
                  self.range2 INTERSECTION other.range2,
                  self.range3 INTERSECTION other.range3)
    opr IN(n:(I,J,K), self): Boolean = do
        (n_i,n_j,n_k) = n
        n_i IN self.range1 AND: n_j IN self.range2
      end
    opr =(self, other:Range3D[\I,J,K\]): Boolean =
        self.range1 = other.range1 AND: self.range2 = other.range2 AND: self.range3 = other.range3
    check():Range3D[\I,J,K\] = do
        _ = self.range1.check()
        _ = self.range2.check()
        _ = self.range3.check()
        self
      end
end

trait ActualRange3D[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\],
                    Self extends ActualRange3D[\I,J,K,Self,Scalar1,Scalar2,Scalar3\],
                    Scalar1 extends ScalarRange[\I\],
                    Scalar2 extends ScalarRange[\J\],
                    Scalar3 extends ScalarRange[\K\]\] extends Range3D[\I,J,K\]
    getter range1(): Scalar1
    getter range2(): Scalar2
    getter range3(): Scalar3
    every(s_i:I, s_j:J, s_k:K): Self =
        self.recombine(self.range1.every(s_i), self.range2.every(s_j), self.range3.every(s_k))
    recombine(a:Scalar1, b:Scalar2, c:Scalar3): Self
end

trait PartialScalarRange[\I extends Integral[\I\]\]
    extends { ScalarRange[\I\], PartialRange[\I\] }
end

object OpenScalarRange[\I extends Integral[\I\]\](str: I)
        extends { PartialScalarRange[\I\], OpenRange[\I\] }
    getter stride(): I = str
    getter toString(): String =
        if str > 0 then
            "...o,o+" str "..."
        else
            "...o,o" str "..."
        end
    truncL(l:I): LeftScalarRange[\I\] = leftScalarRange[\I\](l,str)
    flip(): OpenScalarRange[\I\] = OpenScalarRange[\I\](-str)
    forward(): OpenScalarRange[\I\] = OpenScalarRange[\I\](|str|)
    every(s:I): ScalarRange[\I\] =
        if s<0 AND str<0 then OpenScalarRange[\I\](-s str) else OpenScalarRange[\I\](s str) end
    atMost(n:I): ScalarRangeWithExtent[\I\] = extentScalarRange[\I\](n,str)
    opr INTERSECTION(self, other: ScalarRange[\I\]): ScalarRange[\I\] = other.every(openEveryParam(other))
    intersectWithExtent(e:ExtentScalarRange[\I\]): ScalarRangeWithExtent[\I\] =
        e.every(openEveryParam(e))
    openEveryParam(r:ScalarRange[\I\]): I = do
        gcd = str GCD r.stride
        str DIV gcd
      end
    dump(): String = "OpenScalarRange(" str ")"
end

combine2D[\I extends Integral[\I\], J extends Integral[\J\]\]
         (i:OpenScalarRange[\I\], j:OpenScalarRange[\J\]): OpenRange2D[\I,J\] =
    OpenRange2D[\I,J\](i.stride, j.stride)

object OpenRange2D[\I extends Integral[\I\], J extends Integral[\J\]\](str_i:I, str_j:J)
        extends { OpenRange[\(I,J)\],
                  ActualRange2D[\I,J,OpenRange2D[\I,J\],OpenScalarRange[\I\],OpenScalarRange[\J\]\] }
    getter stride(): (I,J) = (str_i,str_j)
    getter range1(): OpenScalarRange[\I\] = OpenScalarRange[\I\](str_i)
    getter range2(): OpenScalarRange[\J\] = OpenScalarRange[\J\](str_j)
    flip(): OpenRange2D[\I,J\] = OpenRange2D[\ZZ32,ZZ32\](-str_i,-str_j)
    forward(): OpenRange2D[\I,J\] = OpenRange2D[\ZZ32,ZZ32\](|str_i|,|str_j|)
    recombine(i:OpenScalarRange[\I\], j:OpenScalarRange[\J\]): OpenRange2D[\I,J\] =
        combine2D[\I,J\](i, j)
    dump(): String = "OpenRange2D(" str_i "," str_j ")"
end

combine3D[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\]\]
         (i:OpenScalarRange[\I\], j:OpenScalarRange[\J\], k:OpenScalarRange[\K\]): OpenRange3D[\I,J,K\] =
    OpenRange3D[\I,J,K\](i.stride, j.stride, k.stride)

object OpenRange3D[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\]\](str_i:I, str_j:J, str_k:K)
        extends { OpenRange[\(I,J,K)\],
                  ActualRange3D[\I,J,K,OpenRange3D[\I,J,K\],
                                OpenScalarRange[\I\],OpenScalarRange[\J\],OpenScalarRange[\K\]\] }
    getter stride(): (I,J,K) = (str_i,str_j,str_k)
    getter range1(): OpenScalarRange[\I\] = OpenScalarRange[\I\](str_i)
    getter range2(): OpenScalarRange[\J\] = OpenScalarRange[\J\](str_j)
    getter range3(): OpenScalarRange[\K\] = OpenScalarRange[\K\](str_k)
    flip(): OpenRange3D[\I,J,K\] = OpenRange3D[\ZZ32,ZZ32\](-str_i,-str_j,-str_k)
    forward(): OpenRange3D[\I,J,K\] = OpenRange3D[\ZZ32,ZZ32\](|str_i|,|str_j|,|str_k|)
    recombine(i:OpenScalarRange[\I\], j:OpenScalarRange[\J\], k:OpenScalarRange[\K\]): OpenRange3D[\I,J,K\] =
        combine3D[\I,J,K\](i, j, k)
    dump(): String = "OpenRange3D(" str_i "," str_j "," str_k ")"
end

open[\I extends Integral[\I\]\]() = OpenScalarRange[\I\](1)

trait ScalarRangeWithExtent[\I extends Integral[\I\]\]
        extends { ScalarRange[\I\], RangeWithExtent[\I\] }
end

(* Invariant: ex > 0.  Means take every every |str|^th element, up to
   |ex| elements.  Work from left if ex is positive, from right if ex is
   negative.  Reverse afterwards if str is negative. *)
object ExtentScalarRange[\I extends Integral[\I\]\](ex:I, str:I)
        extends { ScalarRangeWithExtent[\I\], PartialScalarRange[\I\], ExtentRange[\I\] }
    getter stride(): I = str
    getter extent(): Just[\I\] = Just[\I\]( |ex| )
    getter fromLeft(): Boolean = ex > 0
    getter toString(): String =
        case ex of
            1 => "l"
            -1 => "r"
            2 => if str > 0 then "l,l+" str else "l,l" str end
            -2 => if str > 0 then "r-" str ",r" else "r+" (-str) ",r" end
            else =>
                if ex > 0 then
                    f = (ex-1) str
                    if str > 0
                    then "l,l+" str ",...l+" f
                    else "l,l" str ",...l" f end
                else
                    f = (-ex-1) str
                    if str > 0
                    then "r-" f "...,r-" str ",r"
                    else "r+" (-f) "...,r+" (-str) ",r" end
                end
        end
    truncL(s:I): FullScalarRange[\I\] =
        if ex > 0 then
            fullScalarRange[\I\](s, s + (ex-1) str, str)
        else
            fullScalarRange[\I\](s, s - (ex+1) str, str)
        end
    flip(): ExtentScalarRange[\I\] = ExtentScalarRange[\I\](-ex, -str)
    forward(): ExtentScalarRange[\I\] =
        if str < 0 then flip() else self end
    every(s:I): ExtentScalarRange[\I\] =
        if s < 0 then
            every(-s).flip()
        else
            exr = if ex > 0 then ex+s-1 else ex-s+1 end
            ExtentScalarRange[\I\](exr DIV s, s str)
        end
    atMost(n:I): ScalarRange[\I\] =
        (* If either n or ex is negative, yield negative ex in result (for idempotence) *)
        if n = 0 then
            emptyScalarRange[\I\]()
        elif n < 0 then
            ExtentScalarRange[\I\](-|ex| MAX n, str)
        elif ex < 0 then
            ExtentScalarRange[\I\](ex MAX -n, str)
        else
            ExtentScalarRange[\I\](ex MIN n, str)
        end
    opr INTERSECTION(self, other: Range[\I\]): ScalarRangeWithExtent[\I\] =
        other.intersectWithExtent(self)
    intersectWithExtent(e:ExtentScalarRange[\I\]): ScalarRangeWithExtent[\I\] = do
        x = self.extent.get MIN e.extent.get
        resultStride = str LCM e.stride
        s = if (str < 0 OR e.stride < 0) AND resultStride > 0
            then -resultStride
            else resultStride end
        if self.fromLeft AND e.fromLeft then
            extentScalarRange[\I\](x,s)
        else
            extentScalarRange[\I\](-x,s)
        end
      end
    opr =(self, b:ExtentScalarRange[\I\]): Boolean = ex = b.ex AND (str = b.str OR ex=1 OR ex=-1)
    dump(): String = "ExtentScalarRange(" ex "," str ")"
end

extentScalarRange[\I extends Integral[\I\]\](ex:I, str:I): ScalarRangeWithExtent[\I\] =
    if ex = 0 then emptyScalarRange[\I\]() else ExtentScalarRange[\I\](ex,str).check() end

combine2D[\I extends Integral[\I\], J extends Integral[\J\]\]
         (i:ExtentScalarRange[\I\], j:ExtentScalarRange[\J\]): ExtentRange2D[\I,J\] =
    ExtentRange2D[\I,J\](i.ex, j.ex, i.stride, j.stride)

object ExtentRange2D[\I extends Integral[\I\], J extends Integral[\J\]\]
                    (ex_i:I, ex_j:J, str_i:I, str_j:J)
        extends { ExtentRange[\(I,J)\],
                  ActualRange2D[\I,J,ExtentRange2D[\I,J\],
                                ExtentScalarRange[\I\],ExtentScalarRange[\J\]\] }
    getter stride(): (I,J) = (str_i,str_j)
    getter extent(): Just[\(I,J)\] = Just[\(I,J)\]( |ex_i|, |ex_j| )
    getter range1(): ExtentScalarRange[\I\] = ExtentScalarRange[\I\](ex_i,str_i)
    getter range2(): ExtentScalarRange[\J\] = ExtentScalarRange[\J\](ex_j,str_j)
    flip(): ExtentRange2D[\I,J\] = ExtentRange2D[\ZZ32,ZZ32\](-ex_i,-ex_j,-str_i,-str_j)
    forward(): ExtentRange2D[\I,J\] =
        self.recombine(self.range1.forward(), self.range2.forward())
    recombine(i:ExtentScalarRange[\I\], j:ExtentScalarRange[\J\]): ExtentRange2D[\I,J\] =
        combine2D[\I,J\](i, j)
    dump(): String = "ExtentRange2D(" ex_i "," ex_j ", " str_i "," str_j ")"
end

combine3D[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\]\]
         (i:ExtentScalarRange[\I\], j:ExtentScalarRange[\J\], k:ExtentScalarRange[\K\]): ExtentRange3D[\I,J,K\] =
    ExtentRange3D[\I,J,K\](i.ex, j.ex, k.ex, i.stride, j.stride, k.stride)

object ExtentRange3D[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\]\]
                    (ex_i:I, ex_j:J, ex_k:K, str_i:I, str_j:J, str_k:K)
        extends { ExtentRange[\(I,J,K)\],
                  ActualRange3D[\I,J,K,ExtentRange3D[\I,J,K\],
                                ExtentScalarRange[\I\],ExtentScalarRange[\J\], ExtentScalarRange[\K\]\] }
    getter stride(): (I,J,K) = (str_i,str_j,str_k)
    getter extent(): Just[\(I,J,K)\] = Just[\(I,J,K)\]( |ex_i|, |ex_j| , |ex_k| )
    getter range1(): ExtentScalarRange[\I\] = ExtentScalarRange[\I\](ex_i,str_i)
    getter range2(): ExtentScalarRange[\J\] = ExtentScalarRange[\J\](ex_j,str_j)
    getter range3(): ExtentScalarRange[\K\] = ExtentScalarRange[\K\](ex_k,str_k)
    flip(): ExtentRange3D[\I,J,K\] = ExtentRange3D[\ZZ32,ZZ32\](-ex_i,-ex_j,-ex_k,-str_i,-str_j,-str_k)
    forward(): ExtentRange3D[\I,J,K\] =
        self.recombine(self.range1.forward(), self.range2.forward(), self.range3.forward())
    recombine(i:ExtentScalarRange[\I\], j:ExtentScalarRange[\J\], k:ExtentScalarRange[\K\]): ExtentRange3D[\I,J,K\] =
        combine3D[\I,J,K\](i, j, k)
    dump(): String = "ExtentRange3D(" ex_i "," ex_j "," ex_k ", " str_i "," str_j "," str_k ")"
end

trait BoundedScalarRange[\I extends Integral[\I\]\]
        extends { ScalarRange[\I\], BoundedRange[\I\] }
    opr INTERSECTION(self, other: ScalarRange[\I\]): BoundedScalarRange[\I\] =
        typecase other of
            BoundedScalarRange[\I\] =>
                if self.stride < 0 OR other.stride < 0 then
                    s = if self.stride < 0 then self.flip() else self end
                    o = if other.stride < 0 then other.flip() else other end
                    s.forwardIntersection(o).flip()
                else
                    self.forwardIntersection(other)
                end
            ExtentScalarRange[\I\] => self.intersectWithExtent(other)
            OpenScalarRange[\I\] => self.every(other.openEveryParam(self))
        end
    intersectWithExtent(e:ExtentScalarRange[\I\]): FullScalarRange[\I\] =
        if e.fromLeft then
            resultGCD = self.stride GCD e.stride
            str' = e.stride DIV resultGCD
            init = self
            adj = if str' < 0 then init.flip() else init end
            res = adj.every(str').atMost(e.extent.get) (*'*)
            if e.stride < 0 then res.flip() else res end
        else
            self.flip().intersectWithExtent(e.flip())
        end
    forwardIntersection(other: BoundedScalarRange[\I\]): BoundedScalarRange[\I\] =
        typecase other of
            FullScalarRange[\I\] => other.forwardIntersection(self)
            else =>
                resultStride = self.stride LCM other.stride
                self.nonemptyUpwardIntersection(other, resultStride)
        end
    (* nonemptyUpwardIntersection does the bulk of the work of opr INTERSECTION. *)
    nonemptyUpwardIntersection(other:BoundedScalarRange[\I\], resultStride:I):BoundedScalarRange[\I\] =
        if p <- meetingPoint(self.leftOrRight,  self.stride,
                             other.leftOrRight, other.stride, resultStride) then
            other.nonemptyUpwardIntersectionWithPoint(self, resultStride, p)
        else
            emptyScalarRange[\I\]()
        end
    nonemptyUpwardIntersectionWithPoint(other: BoundedScalarRange[\I\], resultStride:I, p:I): BoundedScalarRange[\I\]
end

trait ScalarRangeWithLeft[\I extends Integral[\I\]\]
        extends { BoundedScalarRange[\I\], RangeWithLeft[\I\] }
    maxLeft(other:ScalarRange[\I\]): I =
        if ol <- other.left then
            ol MAX self.left.get
        else
            self.left.get
        end
end

object LeftScalarRange[\I extends Integral[\I\]\](l:I, str:I)
        extends { ScalarRangeWithLeft[\I\], PartialScalarRange[\I\], LeftRange[\I\] }
    getter stride(): I = str
    getter left(): Just[\I\] = Just[\I\](l)
    getter toString(): String = do
        t : I := l
        v : String := "["
        n : I := 1
        s = self.stride
        while n < printLimit do
            v ||= t ","
            t += s
            n += 1
        end
        v || t "..."
      end
    flip(): RightScalarRange[\I\] = rightScalarRange[\I\](l, -str)
    forward(): BoundedScalarRange[\I\] =
        if str < 0 then self.flip() else self end
    every(s:I): ScalarRange[\I\] =
        if s > 0 then
            leftScalarRange[\I\](l, s str)
        else
            flip().every(-s)
        end
    atMost(n:I): ScalarRange[\I\] =
        fullScalarRange[\I\](l, l + ( |n| - 1 ) str, str)
    dump(): String = "leftScalarRange(" l "," str ")"
    opr =(self, b:LeftScalarRange[\I\]): Boolean = l = b.l AND str = b.str
    opr IN(n:I, self): Boolean =
        (if self.stride > 0 then l <= n else n <= l) AND: (self.stride DIVIDES (n-l))
    nonemptyUpwardIntersectionWithPoint(other: BoundedScalarRange[\I\], resultStride:I, p:I): ScalarRangeWithLeft[\I\] =
        if r <- other.right then
            fullScalarRangeInter(l,r,resultStride,p)
        else
            leftScalarRangeInter(self.maxLeft(other),resultStride,p)
        end
end

leftScalarRange[\I extends Integral[\I\]\](l:I, str:I): LeftScalarRange[\I\] = LeftScalarRange[\I\](l,str).check()

leftScalarRangeInter[\I extends Integral[\I\]\](l:I, str:I, p:I): LeftScalarRange[\I\] =
    leftScalarRange[\I\](atOrAbove(p,l,str),str)

combine2D[\I extends Integral[\I\], J extends Integral[\J\]\]
         (i:LeftScalarRange[\I\], j:LeftScalarRange[\J\]): LeftRange2D[\I,J\] =
    LeftRange2D[\I,J\](i.left.get, j.left.get, i.stride, j.stride)

object LeftRange2D[\I extends Integral[\I\], J extends Integral[\J\]\]
                    (l_i:I, l_j:J, str_i:I, str_j:J)
        extends { LeftRange[\(I,J)\],
                  ActualRange2D[\I,J,LeftRange2D[\I,J\],
                                LeftScalarRange[\I\],LeftScalarRange[\J\]\] }
    getter stride(): (I,J) = (str_i,str_j)
    getter left(): Just[\(I,J)\] = Just[\(I,J)\]( l_i, l_j )
    getter range1(): LeftScalarRange[\I\] = LeftScalarRange[\I\](l_i,str_i)
    getter range2(): LeftScalarRange[\J\] = LeftScalarRange[\J\](l_j,str_j)
    flip(): RightRange2D[\I,J\] = RightRange2D[\ZZ32,ZZ32\](l_i,l_j,-str_i,-str_j)
    forward(): BoundedRange[\(I,J)\] =
        self.recombine(self.range1.forward(), self.range2.forward())
    recombine(i:LeftScalarRange[\I\], j:LeftScalarRange[\J\]): LeftRange2D[\I,J\] =
        combine2D[\I,J\](i, j)
    dump(): String = "LeftRange2D(" l_i "," l_j ", " str_i "," str_j ")"
end

combine3D[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\]\]
         (i:LeftScalarRange[\I\], j:LeftScalarRange[\J\], k:LeftScalarRange[\K\]): LeftRange3D[\I,J,K\] =
    LeftRange3D[\I,J,K\](i.left.get, j.left.get, k.left.get, i.stride, j.stride, k.stride)

object LeftRange3D[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\]\]
                    (l_i:I, l_j:J, l_k:K, str_i:I, str_j:J, str_k:K)
        extends { LeftRange[\(I,J,K)\],
                  ActualRange3D[\I,J,K,LeftRange3D[\I,J,K\],
                                LeftScalarRange[\I\],LeftScalarRange[\J\],LeftScalarRange[\K\]\] }
    getter stride(): (I,J,K) = (str_i,str_j,str_k)
    getter left(): Just[\(I,J,K)\] = Just[\(I,J,K)\]( l_i, l_j , l_k )
    getter range1(): LeftScalarRange[\I\] = LeftScalarRange[\I\](l_i,str_i)
    getter range2(): LeftScalarRange[\J\] = LeftScalarRange[\J\](l_j,str_j)
    getter range3(): LeftScalarRange[\K\] = LeftScalarRange[\K\](l_k,str_k)
    flip(): RightRange3D[\I,J,K\] = RightRange3D[\ZZ32,ZZ32\](l_i,l_j,l_k,-str_i,-str_j,-str_k)
    forward(): BoundedRange[\(I,J,K)\] =
        self.recombine(self.range1.forward(), self.range2.forward(), self.range3.forward())
    recombine(i:LeftScalarRange[\I\], j:LeftScalarRange[\J\], k:LeftScalarRange[\K\]): LeftRange3D[\I,J,K\] =
        combine3D[\I,J,K\](i, j, k)
    dump(): String = "LeftRange3D(" l_i "," l_j "," l_k ", " str_i "," str_j "," str_k ")"
end

trait ScalarRangeWithRight[\I extends Integral[\I\]\]
        extends { BoundedScalarRange[\I\], RangeWithRight[\I\] }
    minRight(other:ScalarRange[\I\]): I =
        if ol <- other.right then
            ol MIN self.right.get
        else
            self.right.get
        end
end

object RightScalarRange[\I\](r:I, str:I)
        extends { ScalarRangeWithRight[\I\], PartialScalarRange[\I\], RightRange[\I\] }
    getter stride(): I = str
    getter right(): Just[\I\] = Just[\I\](r)
    getter toString(): String = do
        t : I := r
        v : String := "]"
        n : I := 1
        s = self.stride
        while n < printLimit do
            v := "," t || v
            t -= s
            n += 1
        end
        "..." t || v
      end
    flip(): LeftScalarRange[\I\] = leftScalarRange[\I\](r, -str)
    forward(): BoundedScalarRange[\I\] =
        if str < 0 then self.flip() else self end
    every(s:I): RightScalarRange[\I\] =
        if s < 0 then
            flip().every(-s)
        else
            rightScalarRange[\I\](r, s str)
        end
    atMost(n:I): ScalarRange[\I\] =
        fullScalarRange[\I\](r - ( |n| - 1 ) str, r, str)
    dump(): String = "rightScalarRange(" r "," str ")"
    opr =(self, b:RightScalarRange[\I\]): Boolean = r = b.r AND str = b.str
    opr IN(n:I, self): Boolean =
        (if self.stride > 0 then n <= r else r <= n) AND: (self.stride DIVIDES (r-n))
    nonemptyUpwardIntersectionWithPoint(other: BoundedScalarRange[\I\], resultStride:I, p:I):
            ScalarRangeWithRight[\I\] =
        if l <- other.left then
            fullScalarRangeInter(l,r,resultStride,p)
        else
            rightScalarRangeInter(self.minRight(other),resultStride,p)
        end
end

rightScalarRange[\I extends Integral[\I\]\](r:I, str:I): RightScalarRange[\I\] = RightScalarRange[\I\](r,str).check()

rightScalarRangeInter[\I extends Integral[\I\]\](r:I, str:I, p:I): RightScalarRange[\I\] =
    rightScalarRange[\I\](atOrBelow(p,r,str),str)

combine2D[\I extends Integral[\I\], J extends Integral[\J\]\]
         (i:RightScalarRange[\I\], j:RightScalarRange[\J\]): RightRange2D[\I,J\] =
    RightRange2D[\I,J\](i.right.get, j.right.get, i.stride, j.stride)

object RightRange2D[\I extends Integral[\I\], J extends Integral[\J\]\]
                    (r_i:I, r_j:J, str_i:I, str_j:J)
        extends { RightRange[\(I,J)\],
                  ActualRange2D[\I,J,RightRange2D[\I,J\],
                                RightScalarRange[\I\],RightScalarRange[\J\]\] }
    getter stride(): (I,J) = (str_i,str_j)
    getter right(): Just[\(I,J)\] = Just[\(I,J)\]( r_i, r_j )
    getter range1(): RightScalarRange[\I\] = RightScalarRange[\I\](r_i,str_i)
    getter range2(): RightScalarRange[\J\] = RightScalarRange[\J\](r_j,str_j)
    flip(): LeftRange2D[\I,J\] = LeftRange2D[\ZZ32,ZZ32\](r_i,r_j,-str_i,-str_j)
    forward(): BoundedRange[\(I,J)\] =
        self.recombine(self.range1.forward(), self.range2.forward())
    recombine(i:RightScalarRange[\I\], j:RightScalarRange[\J\]): RightRange2D[\I,J\] =
        combine2D[\I,J\](i, j)
    dump(): String = "RightRange2D(" r_i "," r_j ", " str_i "," str_j ")"
end

combine3D[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\]\]
         (i:RightScalarRange[\I\], j:RightScalarRange[\J\], k:RightScalarRange[\K\]): RightRange3D[\I,J,K\] =
    RightRange3D[\I,J,K\](i.right.get, j.right.get, k.right.get, i.stride, j.stride, k.stride)

object RightRange3D[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\]\]
                    (r_i:I, r_j:J, r_k:K, str_i:I, str_j:J, str_k:K)
        extends { RightRange[\(I,J,K)\],
                  ActualRange3D[\I,J,K,RightRange3D[\I,J,K\],
                                RightScalarRange[\I\],RightScalarRange[\J\],RightScalarRange[\K\]\] }
    getter stride(): (I,J,K) = (str_i,str_j,str_k)
    getter right(): Just[\(I,J,K)\] = Just[\(I,J,K)\]( r_i, r_j , r_k )
    getter range1(): RightScalarRange[\I\] = RightScalarRange[\I\](r_i,str_i)
    getter range2(): RightScalarRange[\J\] = RightScalarRange[\J\](r_j,str_j)
    getter range3(): RightScalarRange[\K\] = RightScalarRange[\K\](r_k,str_k)
    flip(): LeftRange3D[\I,J,K\] = LeftRange3D[\ZZ32,ZZ32\](r_i,r_j,r_k,-str_i,-str_j,-str_k)
    forward(): BoundedRange[\(I,J,K)\] =
        self.recombine(self.range1.forward(), self.range2.forward(), self.range3.forward())
    recombine(i:RightScalarRange[\I\], j:RightScalarRange[\J\], k:RightScalarRange[\K\]): RightRange3D[\I,J,K\] =
        combine3D[\I,J,K\](i, j, k)
    dump(): String = "RightRange3D(" r_i "," r_j "," r_k ", " str_i "," str_j "," str_k ")"
end

trait FullScalarRange[\I extends Integral[\I\]\]
        extends { ScalarRangeWithLeft[\I\], ScalarRangeWithRight[\I\],
                  ScalarRangeWithExtent[\I\], FullRange[\I\] }
    getter bounds(): CompactFullScalarRange[\I\] = CompactFullParScalarRange[\I\](0,size()-1)
    getter toString(): String =
        if self.isEmpty then
            "[]"
        else
            r = self.right.get
            t : I := self.left.get
            v : String := "["
            n : I := 1
            s = self.stride
            if s > 0 then
                while t < r AND n < printLimit do
                    v ||= t ","
                    t += s
                    n += 1
                end
            else
                while t > r AND n < printLimit do
                    v ||= t ","
                    t += s
                    n += 1
                end
            end
            if t=r then
                v || t "]"
            else
                v || "... " r "]"
            end
        end
    flip(): FullScalarRange[\I\] = fullScalarRange[\I\](self.right.get,self.left.get,-self.stride)
    every(s:I): FullScalarRange[\I\] =
        if s < 0 then
            flip().every(-s)
        elif self.isEmpty then self
        elif s > 0 then
            r = self.right.get
            l = self.left.get
            str' = s self.stride
            steps = (r-l) DIV str' (* Doesn't work for empty b/c DIV rounds to 0! *)
            fullScalarRange[\I\](l, l + steps str', str')
        else
            fail(dump() ".every(" s "); zero stride.")
        end
    atMost(n:I): FullScalarRange[\I\] =
        if n >= 0 then
            l = self.left.get
            str = self.stride
            r' = l + (n-1) str (* ' *)
            r = self.right.get
            if (str > 0 AND r' > r) OR (str < 0 AND r' < r) then
                self
            else
                fullScalarRange[\I\](l, r', str)
            end
        else (* n < 0 *)
            r = self.right.get
            str = self.stride
            l' = r + (n+1) str (* ' *)
            l = self.left.get
            if (str > 0 AND l' < l) OR (str < 0 AND l' > l) then (* ' *)
                self
            else
                fullScalarRange[\I\](l', r, str) (* ' *)
            end
        end
    opr =(self, b:FullScalarRange[\I\]): Boolean =
        (self.isEmpty AND b.isEmpty) OR
        (self.left = b.left AND self.right = b.right AND
            (self.stride = b.stride OR self.left=self.right))
    forwardIntersection(other: BoundedScalarRange[\I\]): FullScalarRange[\I\] =
        if self.isEmpty then self
        elif other.isEmpty then other
        else
            resultStride = self.stride LCM other.stride
            self.nonemptyUpwardIntersection(other, resultStride)
        end
    (* nonemptyUpwardIntersection does the bulk of the work of opr INTERSECTION. *)
    nonemptyUpwardIntersection(other: BoundedScalarRange[\I\], resultStride:I): FullScalarRange[\I\] =
        if p <- meetingPoint(self.leftOrRight, self.stride,
                             other.leftOrRight, other.stride, resultStride) then
            nonemptyUpwardIntersectionWithPoint(other, resultStride, p)
        else
            emptyScalarRange[\I\]()
        end
    nonemptyUpwardIntersectionWithPoint(other: BoundedScalarRange[\I\], resultStride:I, p:I): FullScalarRange[\I\] =
        fullScalarRangeInter(self.maxLeft(other),self.minRight(other),resultStride,p)
    opr[r:Range[\I\]]: FullScalarRange[\I\] = do
        f = self.bounds.narrowToRange(r)
        l = self.left.get
        s = self.stride
        fullScalarRange[\I\](l + f.left.get s, l + f.right.get s, f.stride s)
      end
end

trait FullRange2D[\I extends Integral[\I\], J extends Integral[\J\]\]
        extends { FullRange[\(I,J)\], Range2D[\I,J\], DelegatedIndexed[\(I,J),(I,J)\] }
    getter extent(): Just[\(I,J)\] = Just[\(I,J)\]( self.range1.extent.get, self.range2.extent.get )
    getter generator(): Generator[\(I,J)\] = self.range1.cross[\J\](self.range2)
    getter indices(): Generator[\(I,J)\] = self.range1.indices.cross[\J\](self.range2.indices)
    opr |self|: ZZ32 = |self.range1| |self.range2|
    flip(): FullRange2D[\I,J\] = do
        (l_i,l_j) = self.left.get
        (r_i,r_j) = self.right.get
        (str_i,str_j) = self.stride.get
        fullRange2D[\ZZ32,ZZ32\](r_i,r_j,l_i,l_j,-str_i,-str_j)
      end
    opr[ij:(I,J)]: (I,J) = do (i,j) = ij; (self.range1[i],self.range2[j]) end
    opr[r:Range[\(I,J)\]]: FullRange2D[\I,J\] = do
        f = self.bounds.narrowToRange(r)
        (l1,l2) = self.left.get
        (s1,s2) = self.stride
        (fl1,fl2) = f.left.get
        (fr1,fr2) = f.right.get
        (fs1,fs2) = f.stride
        fullRange2D[\I,J\](l1 + fl1 s1, l2 + fl2 s2, fs1 s1, fs2 s2)
      end
end

tupleFlatten[\I,J,K\](t:(I,J),k:K):(I,J,K) = do (i,j)=t; (i,j,k) end


trait FullRange3D[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\] \]
        extends { FullRange[\(I,J,K)\], Range3D[\I,J,K\], DelegatedIndexed[\(I,J,K),(I,J,K)\] }
    getter extent(): Just[\(I,J,K)\] =
        Just[\(I,J,K)\]( self.range1.extent.get, self.range2.extent.get, self.range3.extent.get )
    getter generator(): Generator[\(I,J,K)\] =
        self.range1.cross[\J\](self.range2).cross[\K\](self.range3).map[\(I,J,K)\](
            tupleFlatten[\I,J,K\])
    getter indices(): Generator[\(I,J)\] =
        self.range1.indices.cross[\J\](self.range2.indices).cross[\K\](self.range3.indices).map[\(I,J,K)\](
            tupleFlatten[\I,J,K\])
    opr |self|: ZZ32 = |self.range1| |self.range2| |self.range3|
    flip(): FullRange3D[\I,J,K\] = do
        (l_i,l_j,l_k) = self.left.get
        (r_i,r_j,r_k) = self.right.get
        (str_i,str_j,str_k) = self.stride.get
        fullRange3D[\ZZ32,ZZ32\](r_i,r_j,r_k,l_i,l_j,l_k,-str_i,-str_j,-str_k)
      end
    opr[ij:(I,J,K)]: (I,J,K) =
        do (i,j,k) = ij; (self.range1[i],self.range2[j],self.range3[k]) end
    opr[r:Range[\(I,J,K)\]]: FullRange3D[\I,J,K\] = do
        f = self.bounds.narrowToRange(r)
        (l1,l2,l3) = self.left.get
        (s1,s2,s3) = self.stride
        (fl1,fl2,fl3) = f.left.get
        (fr1,fr2,fr3) = f.right.get
        (fs1,fs2,fs3) = f.stride
        fullRange3D[\I,J,K\](l1 + fl1 s1, l2 + fl2 s2, l3 + fl3 s3, fs1 s1, fs2 s2, fs3 s3)
      end
end

trait CompactFullScalarRange[\I extends Integral[\I\]\] extends { FullScalarRange[\I\], CompactFullRange[\I\] }
    getter stride(): I = 1
    getter extent(): Just[\I\] = Just[\I\]( self.size )
    getter size(): ZZ32 = do
        l = self.lower
        r = self.upper
        res = narrow(r-l+1)
        if res <= 1 AND: r>l then 0 else res end
      end
    getter isEmpty(): Boolean = self.lower > self.upper
    getter indexValuePairs(): Indexed[\(I,I),I\] = do
        l = self.lower
        self.map[\(I,I)\](fn (i:I):(I,I) => (i-l,i))
      end
    getter indices(): Indexed[\I,I\] = do
        l = self.lower
        self.map[\I\](fn (i:I):(I,I) => (i-l))
      end
    opr[i:I]: I =
        if i NOTIN self.bounds then throw IndexOutOfBounds(self.bounds,i)
        else i+self.lower end
    opr IN(n:I, self): Boolean = self.lower <= n <= self.upper
end

object CompactFullParScalarRange[\I extends Integral[\I\]\](l:I, r:I)
        extends { CompactFullScalarRange[\I\] }
    getter lower(): I = l
    getter upper(): I = r
    getter left(): Just[\I\] = Just[\I\](l)
    getter right(): Just[\I\] = Just[\I\](r)
    seq(self): CompactFullSeqScalarRange[\I\] = CompactFullSeqScalarRange[\I\](l,r)
    dump(): String = "CompactFullParScalarRange(" l "," r ")"
    generate[\T\](red:Reduction[\T\], body: I->T): T =
        if r < l then
            red.empty()
        else
            loop'(lo:I,hi:I): T =
                if lo=hi then
                    body(lo)
                else
                    (* Identify power-of-2 boundary in region, split there *)
                    split = partitionL((lo BITXOR hi)+1)
                    mid   = hi BITAND (BITNOT (split-1))
                    red.join(loop'(lo,mid-1),loop'(mid,hi))
                end
            loop'(l,r)
        end
    loop(body: I->()): () =
        if r < l then
            ()
        else
            lop(lo:I,hi:I): () =
                if lo=hi then
                    body(lo)
                else
                    (* Identify power-of-2 boundary in region, split there *)
                    split = partitionL((lo BITXOR hi)+1)
                    mid   = hi BITAND (BITNOT (split-1))
                    do
                        lop(lo,mid-1)
                    also do
                        lop(mid,hi)
                    end
                end
            lop(l,r)
        end
end

object CompactFullSeqScalarRange[\I extends Integral[\I\]\](l:I, r:I)
        extends { CompactFullScalarRange[\I\], SequentialGenerator[\I\] }
    getter lower(): I = l
    getter upper(): I = r
    getter left(): Just[\I\] = Just[\I\](l)
    getter right(): Just[\I\] = Just[\I\](r)
    dump(): String = "CompactFullSeqScalarRange(" l "," r ")"
    generate[\T\](red:Reduction[\T\], body: I->T): T = do
        result : T := red.empty()
        i : I := l
        while i <= r do
            b = body(i)
            result := red.join(result, b)
            i += 1
        end
        result
      end
    loop(body: I->()): () = do
        i : I := l
        while i <= r do
            body(i)
            i += 1
        end
      end
end

combine2D[\I extends Integral[\I\], J extends Integral[\J\]\]
         (i:CompactFullScalarRange[\I\], j:CompactFullScalarRange[\J\]): CompactFullRange2D[\I,J\] =
    CompactFullRange2D[\I,J\](i.left.get, j.left.get, i.right.get, j.right.get)

object CompactFullRange2D[\I extends Integral[\I\], J extends Integral[\J\]\]
                         (l_i:I, l_j:J, r_i:I, r_j:J)
        extends { CompactFullRange[\(I,J)\], FullRange2D[\I,J\],
                  ActualRange2D[\I,J,CompactFullRange2D[\I,J\],
                                CompactFullScalarRange[\I\],CompactFullScalarRange[\J\]\] }
    getter lower(): (I,J) = (l_i,l_j)
    getter upper(): (I,J) = (r_i,r_j)
    getter bounds(): CompactFullRange2D[\I,J\] =
        CompactFullRange2D[\I,J\](0,0,r_i-l_i,r_j-l_j)
    getter indices(): Generator[\(I,J)\] =
        self.generator.map[\(I,J)\](fn (i,j) => (i-l_i, j-l_j))
    getter indexValuePairs(): Generator[\((I,J),(I,J))\] =
        self.generator.map[\(I,J)\](fn (i,j) => ((i-l_i, j-l_j),(i,j)))
    getter stride(): (I,J) = (1,1)
    getter left(): Just[\(I,J)\] = Just[\(I,J)\]( l_i, l_j )
    getter right(): Just[\(I,J)\] = Just[\(I,J)\]( r_i, r_j )
    getter range1(): CompactFullScalarRange[\I\] = CompactFullParScalarRange[\I\](l_i,r_i)
    getter range2(): CompactFullScalarRange[\J\] = CompactFullParScalarRange[\J\](l_j,r_j)
    recombine(i:CompactFullScalarRange[\I\], j:CompactFullScalarRange[\J\]):
            CompactFullRange2D[\I,J\] = combine2D[\I,J\](i, j)
    dump(): String = "CompactFullRange2D(" l_i "," l_j ", " r_i "," r_j ")"
end

combine3D[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\]\]
         (i:CompactFullScalarRange[\I\], j:CompactFullScalarRange[\J\], k:CompactFullScalarRange[\K\]): CompactFullRange3D[\I,J,K\] =
    CompactFullRange3D[\I,J,K\](i.left.get, j.left.get, k.left.get, i.right.get, j.right.get, k.right.get)

object CompactFullRange3D[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\]\]
                         (l_i:I, l_j:J, l_k:K, r_i:I, r_j:J, r_k:K)
        extends { CompactFullRange[\(I,J,K)\], FullRange3D[\I,J,K\],
                  ActualRange3D[\I,J,K,CompactFullRange3D[\I,J,K\],
                                CompactFullScalarRange[\I\],CompactFullScalarRange[\J\],
                                CompactFullScalarRange[\K\]\] }
    getter lower(): (I,J,K) = (l_i,l_j,l_k)
    getter upper(): (I,J,K) = (r_i,r_j,r_k)
    getter bounds(): CompactFullRange3D[\I,J,K\] =
        CompactFullRange3D[\I,J,K\](0,0,r_i-l_i,r_j-l_j)
    getter indices(): Generator[\(I,J,K)\] =
        self.generator.map[\(I,J,K)\](fn (i,j,k) => (i-l_i, j-l_j))
    getter indexValuePairs(): Generator[\((I,J,K),(I,J,K))\] =
        self.generator.map[\(I,J,K)\](fn (i,j,k) => ((i-l_i, j-l_j),(i,j,k)))
    getter stride(): (I,J,K) = (1,1)
    getter left(): Just[\(I,J,K)\] = Just[\(I,J,K)\]( l_i, l_j , l_k )
    getter right(): Just[\(I,J,K)\] = Just[\(I,J,K)\]( r_i, r_j , r_k )
    getter range1(): CompactFullScalarRange[\I\] = CompactFullParScalarRange[\I\](l_i,r_i)
    getter range2(): CompactFullScalarRange[\J\] = CompactFullParScalarRange[\J\](l_j,r_j)
    getter range3(): CompactFullScalarRange[\K\] = CompactFullParScalarRange[\K\](l_k,r_k)
    recombine(i:CompactFullScalarRange[\I\], j:CompactFullScalarRange[\J\], k:CompactFullScalarRange[\K\]):
            CompactFullRange3D[\I,J,K\] = combine3D[\I,J,K\](i, j, k)
    dump(): String = "CompactFullRange3D(" l_i "," l_j "," l_k ", " r_i "," r_j "," r_k ")"
end

trait StridedFullScalarRange[\I extends Integral[\I\]\]
        extends { FullScalarRange[\I\], StridedFullRange[\I\] }
    getter size(): ZZ32 = do
        res = narrow((self.right.get-self.left.get) DIV self.stride + 1)
        if res <= 1 AND: self.isEmpty then 0
        else res end
      end
    getter isEmpty(): Boolean =
        if self.stride > 0 then (self.left.get>self.right.get)
                           else (self.left.get<self.right.get) end
    getter indexValuePairs(): Indexed[\(I,I),I\] =
        self.map[\(I,I)\](fn (i:I):(I,I) => ((i-self.left.get) DIV self.stride,i))
    getter indices(): Indexed[\I,I\] =
        self.map[\I\](fn (i:I):(I,I) => (i-self.left.get) DIV self.stride)
    opr[i:I]: I =
        if i NOTIN self.bounds then throw IndexOutOfBounds[\I\](self.bounds,i)
        else i self.stride + self.left.get end
    dump(): String = "StridedFullScalarRange(" self.left.get "," self.right.get "," self.stride ")"
    opr IN(n:I, self): Boolean = do
        l = self.left.get
        r = self.right.get
        (if self.stride > 0 then l <= n <= r else r <= n <= l) AND: (self.stride DIVIDES (n-l))
      end
    forward(): FullScalarRange[\I\] =
        if self.stride < 0 then self.flip() else self end
end

object StridedFullParScalarRange[\I extends Integral[\I\]\](l:I, r:I, str:I) extends StridedFullScalarRange[\I\]
    getter stride(): I = str
    getter left(): Just[\I\] = Just[\I\](l)
    getter right(): Just[\I\] = Just[\I\](r)
    seq(self): StridedFullSeqScalarRange[\I\] = StridedFullSeqScalarRange[\I\](l,r,str)
    dump(): String = "StridedFullParScalarRange(" l "," r "," str ")"
    generate[\T\](red:Reduction[\T\], body: I->T): T =
        if str > 0 then
            if r < l then
                red.empty()
            else
                loop'(lo:I,hi:I): T =
                    if lo=hi then
                        body(lo)
                    else
                        (* Identify power-of-2 boundary *)
                        split = partitionL((lo BITXOR hi)+1)
                        midAmt = (hi BITAND (BITNOT (split-1))) - lo - 1
                        (* Round power-of-2 boundary down to stride size
                           WARNING?  Problem with negative lo here?  *)
                        midL = lo + str (midAmt DIV str)
                        midR = midL + str
                        red.join(loop'(lo,midL),loop'(midR,hi))
                    end
                loop'(l,r)
            end
        else (* str > 0 *)
            if l < r then
                red.empty()
            else
                str' = -str
                loop'(lo:I,hi:I): T =
                    if lo=hi then
                        body(lo)
                    else
                        (* Identify power-of-2 boundary *)
                        split = partitionL((lo BITXOR hi)+1)
                        midAmt = (hi BITAND (BITNOT (split-1))) - lo - 1
                        (* Round power-of-2 boundary down to stride size
                           WARNING?  Problem with negative lo here?  *)
                        midL = lo + str' (midAmt DIV str')
                        midR = midL + str'
                        red.join(loop'(midR,hi),loop'(lo,midL))
                    end
                loop'(r,l)
            end
        end
    loop(body: I->()): () =
        if str > 0 then
            if r < l then
                ()
            else
                lop(lo:I,hi:I): () =
                    if lo=hi then
                        body(lo)
                    else
                        (* Identify power-of-2 boundary *)
                        split = partitionL((lo BITXOR hi)+1)
                        midAmt = (hi BITAND (BITNOT (split-1))) - lo - 1
                        (* Round power-of-2 boundary down to stride size
                           WARNING?  Problem with negative lo here?  *)
                        midL = lo + str (midAmt DIV str)
                        midR = midL + str
                        do
                            lop(lo,midL)
                        also do
                            lop(midR,hi)
                        end
                    end
                lop(l,r)
            end
        else (* str > 0 *)
            if l < r then
                ()
            else
                str' = -str
                lop(lo:I,hi:I): () =
                    if lo=hi then
                        body(lo)
                    else
                        (* Identify power-of-2 boundary *)
                        split = partitionL((lo BITXOR hi)+1)
                        midAmt = (hi BITAND (BITNOT (split-1))) - lo - 1
                        (* Round power-of-2 boundary down to stride size
                           WARNING?  Problem with negative lo here?  *)
                        midL = lo + str' (midAmt DIV str')
                        midR = midL + str'
                        do
                            lop(midR,hi)
                        also do
                            lop(lo,midL)
                        end
                    end
                lop(r,l)
            end
        end
end

object StridedFullSeqScalarRange[\I extends Integral[\I\]\](l:I, r:I, str:I)
        extends { StridedFullScalarRange[\I\], SequentialGenerator[\I\] }
    getter stride(): I = str
    getter left(): Just[\I\] = Just[\I\](l)
    getter right(): Just[\I\] = Just[\I\](r)
    seq(self): StridedFullSeqScalarRange[\I\] = StridedFullSeqScalarRange[\I\](l,r)
    dump(): String = "StridedFullSeqScalarRange(" l "," r "," str ")"
    generate[\T\](red:Reduction[\T\], body: I->T): T = do
        result : T := red.empty()
        i : I := l
        if str > 0 then
            while i <= r do
                b = body(i)
                result := red.join(result,b)
                i += str
            end
        else (* str < 0 *)
            while i >= r do
                b = body(i)
                result := red.join(result,b)
                i += str
            end
        end
        result
      end
    loop(body: I->()): () =
        if str > 0 then
            i : I := l
            while i <= r do
                body(i)
                i += str
            end
        else (* str < 0 *)
            i : I := l
            while i >= r do
                body(i)
                i += str
            end
        end
end


combine2D[\I extends Integral[\I\], J extends Integral[\J\]\]
         (i:FullScalarRange[\I\], j:FullScalarRange[\J\]): FullRange2D[\I,J\] =
    StridedFullRange2D[\I,J\](i.left.get, j.left.get, i.right.get, j.right.get,
                            i.stride, j.stride)

object StridedFullRange2D[\I extends Integral[\I\], J extends Integral[\J\]\]
                         (l_i:I, l_j:J, r_i:I, r_j:J, str_i:I, str_j:J)
        extends { StridedFullRange[\(I,J)\], FullRange2D[\I,J\],
                  ActualRange2D[\I,J,StridedFullRange2D[\I,J\],
                                FullScalarRange[\I\],FullScalarRange[\J\]\] }
    getter bounds(): StridedFullRange2D[\I,J\] =
        CompactFullRange2D[\I,J\](0,0,(r_i-l_i) DIV str_i,(r_j-l_j) DIV str_j)
    getter indices(): Generator[\(I,J)\] =
        self.generator.map[\(I,J)\](fn (i,j) => ((i-l_i) DIV str_i, (j-l_j) DIV str_j))
    getter indexValuePairs(): Generator[\((I,J),(I,J))\] =
        self.generator.map[\(I,J)\](fn (i,j) => (((i-l_i) DIV str_i, (j-l_j) DIV str_j),(i,j)))
    getter stride(): (I,J) = (str_i,str_j)
    getter left(): Just[\(I,J)\] = Just[\(I,J)\]( l_i, l_j )
    getter right(): Just[\(I,J)\] = Just[\(I,J)\]( r_i, r_j )
    getter range1(): FullScalarRange[\I\] = StridedFullParScalarRange[\I\](l_i,r_i,str_i)
    getter range2(): FullScalarRange[\J\] = StridedFullParScalarRange[\J\](l_j,r_j,str_j)
    forward(): FullRange2D[\I,J\] =
        self.recombine(self.range1.forward(), self.range2.forward())
    recombine(i:FullScalarRange[\I\], j:FullScalarRange[\J\]):
            StridedFullRange2D[\I,J\] = combine2D[\I,J\](i, j)
    dump(): String = ("StridedFullRange2D(" l_i "," l_j ", " r_i "," r_j ", "
                                          str_i "," str_j ")" )
end

combine3D[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\]\]
         (i:FullScalarRange[\I\], j:FullScalarRange[\J\], k:FullScalarRange[\K\]): FullRange3D[\I,J,K\] =
    StridedFullRange3D[\I,J,K\](i.left.get, j.left.get, k.left.get, i.right.get, j.right.get, k.right.get,
                            i.stride, j.stride, k.stride)

object StridedFullRange3D[\I extends Integral[\I\], J extends Integral[\J\], K extends Integral[\K\]\]
                         (l_i:I, l_j:J, l_k:K, r_i:I, r_j:J, r_k:K, str_i:I, str_j:J, str_k:K)
        extends { StridedFullRange[\(I,J,K)\], FullRange3D[\I,J,K\],
                  ActualRange3D[\I,J,K,StridedFullRange3D[\I,J,K\],
                                FullScalarRange[\I\],FullScalarRange[\J\],FullScalarRange[\K\]\] }
    getter bounds(): StridedFullRange3D[\I,J,K\] =
        CompactFullRange3D[\I,J,K\](0,0,(r_i-l_i) DIV str_i,(r_j-l_j) DIV str_j, (r_k-l_k) DIV str_k)
    getter indices(): Generator[\(I,J,K)\] =
        self.generator.map[\(I,J,K)\](fn (i,j,k) => ((i-l_i) DIV str_i, (j-l_j) DIV str_j, (k-l_k) DIV str_k))
    getter indexValuePairs(): Generator[\((I,J,K),(I,J,K))\] =
        self.generator.map[\(I,J,K)\](fn (i,j,k) => (((i-l_i) DIV str_i, (j-l_j) DIV str_j, (k-l_k) DIV str_k),(i,j,k)))
    getter stride(): (I,J,K) = (str_i,str_j,str_k)
    getter left(): Just[\(I,J,K)\] = Just[\(I,J,K)\]( l_i, l_j , l_k )
    getter right(): Just[\(I,J,K)\] = Just[\(I,J,K)\]( r_i, r_j , r_k )
    getter range1(): FullScalarRange[\I\] = StridedFullParScalarRange[\I\](l_i,r_i,str_i)
    getter range2(): FullScalarRange[\J\] = StridedFullParScalarRange[\J\](l_j,r_j,str_j)
    getter range3(): FullScalarRange[\K\] = StridedFullParScalarRange[\K\](l_k,r_k,str_k)
    forward(): FullRange3D[\I,J,K\] =
        self.recombine(self.range1.forward(), self.range2.forward(), self.range3.forward())
    recombine(i:FullScalarRange[\I\], j:FullScalarRange[\J\], k:FullScalarRange[\K\]):
            StridedFullRange3D[\I,J,K\] = combine3D[\I,J,K\](i, j, k)
    dump(): String = ("StridedFullRange3D(" l_i "," l_j "," l_k ", " r_i "," r_j "," r_k ", "
                                          str_i "," str_j "," str_k ")" )
end


fullScalarRange[\I extends Integral[\I\]\](l:I, r:I, str:I): FullScalarRange[\I\] =
    if str=1 then CompactFullParScalarRange[\I\](l,r).check()
    else StridedFullParScalarRange[\I\](l,r,str).check() end

fullScalarRangeInter[\I extends Integral[\I\]\](l:I, r:I, str:I, p:I): FullScalarRange[\I\] =
    fullScalarRange[\I\](atOrAbove(p,l,str), atOrBelow(p,r,str), str)

fullRange2D[\I extends Integral[\I\], J extends Integral[\J\]\]
           (l_i:I, l_j:J, r_i:I, r_j:J, str_i:I, str_j:J): FullRange2D[\I,J\] =
    if str_i=1 AND str_j=1 then
        CompactFullRange2D[\I,J\](l_i,l_j,r_i,r_j).check()
    else
        StridedFullRange2D[\I,J\](l_i,l_j,r_i,r_j,str_i,str_j).check()
    end

emptyScalarRange[\I\]() : FullScalarRange[\I\] = CompactFullParScalarRange[\I\](0,-1)

(** Helpers for # to get the type instantiation "right".  We pass in bogus ZZ32's to
    ensure that the result type is at least ZZ32. **)
sized1Range[\I extends AnyIntegral\](_:I,lo:I,ex:I): CompactFullParScalarRange[\I\] =
    CompactFullParScalarRange[\I\](lo,lo+ex-1)
sized2Range[\I extends AnyIntegral, J extends AnyIntegral\]
           (_:I,_:J,l1:I,l2:J,ex1:I,ex2:J): CompactFullRange2D[\I,J\] =
    CompactFullRange2D[\I,J\](l1,l2,l1+ex1-1,l2+ex2-1)
sized3Range[\I extends AnyIntegral, J extends AnyIntegral, K extends AnyIntegral\]
     (_:I,_:J,_:K,l1:I,l2:J,l3:K,ex1:I,ex2:J,ex3:K): CompactFullRange3D[\I,J,K\] =
    CompactFullRange3D[\I,J,K\](l1,l2,l3,l1+ex1-1,l2+ex2-1,l3+ex3-1)

(** Helpers for : to get the type instantiation "right".  We pass in bogus ZZ32's to
    ensure that the result type is at least ZZ32.  **)
bounded1Range[\I extends AnyIntegral\](_:I,lo:I,hi:I): CompactFullParScalarRange[\I\] = CompactFullParScalarRange[\I\](lo,hi)
bounded2Range[\I extends AnyIntegral, J extends AnyIntegral\]
           (_:I,_:J,l1:I,l2:J,hi1:I,hi2:J): CompactFullRange2D[\I,J\] =
    CompactFullRange2D[\I,J\](l1,l2,hi1,hi2)
bounded3Range[\I extends AnyIntegral, J extends AnyIntegral, K extends AnyIntegral\]
     (_:I,_:J,_:K,l1:I,l2:J,l3:K,hi1:I,hi2:J,hi3:K): CompactFullRange3D[\I,J,K\] =
    CompactFullRange3D[\I,J,K\](l1,l2,l3,hi1,hi2,hi3)

left1Range[\I extends AnyIntegral\](_:I,x:I):LeftRange[\I\] = LeftScalarRange[\I\](x,1)
left2Range[\I extends AnyIntegral, J extends AnyIntegral\](_:I,_:J,x:I,y:J):
    LeftRange[\(I,J)\] = LeftRange2D[\I,J\](x,y,1,1)
left3Range[\I extends AnyIntegral, J extends AnyIntegral, K extends AnyIntegral\]
           (_:I,_:J,_:K,x:I,y:J,z:K): LeftRange[\(I,J,K)\] =
    LeftRange3D[\I,J,K\](x,y,z,1,1,1)

extent1Range[\I extends AnyIntegral\](_:I,x:I):ExtentRange[\I\] =
    if x=0 then
        xx = x-x
        CompactFullParScalarRange[\I\](xx,xx-1)
    else
        ExtentScalarRange[\I\](x,1)
    end
extent2Range[\I extends AnyIntegral, J extends AnyIntegral\](_:I,_:J,x:I,y:J):
        ExtentRange[\(I,J)\] =
    if x=0 OR y=0 then
        xx = x-x
        yy = y-y
        CompactFullRange2D[\I,J\](xx,xx-1,yy,yy-1)
    else
        ExtentRange2D[\I,J\](x,y,1,1)
    end
extent3Range[\I extends AnyIntegral, J extends AnyIntegral, K extends AnyIntegral\]
            (_:I,_:J,_:K,x:I,y:J,z:K): ExtentRange[\(I,J,K)\] =
    if x=0 OR y=0 OR z=0 then
        xx = x-x
        yy = y-y
        zz = z-z
        CompactFullRange3D[\I,J,K\](xx,xx-1,yy,yy-1,zz,zz-1)
    else
        ExtentRange3D[\I,J,K\](x,y,z,1,1,1)
    end

right1Range[\I extends AnyIntegral\](_:I,x:I):RightRange[\I\] = RightScalarRange[\I\](x,1)
right2Range[\I extends AnyIntegral, J extends AnyIntegral\](_:I,_:J,x:I,y:J):
    RightRange[\(I,J)\] = RightRange2D[\I,J\](x,y,1,1)
right3Range[\I extends AnyIntegral, J extends AnyIntegral, K extends AnyIntegral\]
           (_:I,_:J,_:K,x:I,y:J,z:K): RightRange[\(I,J,K)\] =
    RightRange3D[\I,J,K\](x,y,z,1,1,1)

openRangeHelper[\I extends AnyIntegral\](_ : __Proxy[\I\]):
    OpenScalarRange[\I\] = OpenScalarRange[\I\](1)
openRangeHelper[\I extends AnyIntegral, J extends AnyIntegral\](_ : __Proxy[\(I,J)\]):
    OpenRange2D[\I,J\] = OpenRange2D[\I\](1,1)
openRangeHelper[\I extends AnyIntegral, J extends AnyIntegral, K extends AnyIntegral\]
               (_ : __Proxy[\(I,J,K)\]): OpenRange3D[\I,J,K\] = OpenRange3D[\I,J,K\](1,1,1)

end
