(*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component SkipTree
import List.{...}


export SkipTree

trait SkipTree[\Key,Value\]

    (** Takes a querykey as input and returns either a Just[\Value\]
      * object if the (key,value) pair lives in this map, or
      * returns Nothing[\Value\] otherwise.
      *)
    find(querykey : Key) : Maybe[\Value\]

    (** Takes a newkey and newvalue as input and returns a 
      * new skip tree with the (key, value) pair inserted.
      * Currently, if newkey already exists in the tree,
      * then this operation does not insert (key, newvalue)
      * into the tree.
      *)
    insert(newkey : Key, newvalue : Value) : SkipTree[\Key,Value\]

    (**
     *  Return a random level >= 1 with a negative binomial distribution.
     *)
    randomLevel():ZZ32 = do
        level:ZZ32 := 1
        while random(1.0) < 0.5 do
            level += 1
        end
        level
    end
    
    (**
     * The verify method will throw an error
     * if this structure does not satisfy the properties
     * of a Skip Tree.
     **)    
    verify():()    

end (* trait SkipTree[\Key,Value\] *)


object NonEmptySkipTree[\Key,Value\](root : Node[\Key,Value\]) extends { SkipTree[\Key,Value\] }

    find(querykey : Key) : Maybe[\Value\] = root.find(querykey)

    insert(newkey : Key, newvalue : Value) : SkipTree[\Key,Value\] = do
        newheight = randomLevel()
        typecase exists = root.find(newkey) of
            Just[\Value\] => self
            else =>
                root' = root.insert(newkey,newvalue,newheight)
                NonEmptySkipTree[\Key,Value\](root')
        end
    end
    
    verify():() = root.verify()
   
end

object EmptySkipTree[\Key,Value\] extends { SkipTree[\Key,Value\] }

    find(querykey : Key) : Maybe[\Value\] = Nothing[\Value\]
    
    insert(newkey : Key, newvalue : Value) : SkipTree[\Key,Value\] = do
        newheight = randomLevel()
        root = LeafNode[\Key,Value\](newkey, newvalue, newheight)     
        NonEmptySkipTree[\Key,Value\](root')        
    end
    
    verify():() = ()

end


object Filter[\Key\](pivot : Key, lessThanOrEquals : Boolean)

    filter(query : Key) : Boolean = do
        if lessThanOrEquals then
            query <= pivot
        else
            query > pivot
        end
    end
    
end

object Node[\Key,Value\](keys     : List[\Key\],
                         values   : List[\Value\],
                         children : List[\Maybe[\Node[\Key,Value\]\]\],
                         height   : ZZ32)

    getter toString() : String = keys "" values "" children " h" height

    (** Takes a querykey as input and returns either a Just[\Value\]
      * object if the (key,value) pair lives in this map, or
      * returns Nothing[\Value\] otherwise.
      *)    
    find(querykey : Key) : Maybe[\Value\] = do
        parentIndex = binarySearch[\Key\](keys, querykey)
        if parentIndex >= 0 then
            Just[\Value\](values[parentIndex])
        else
            childIndex = insertionPoint(parentIndex)
            typecase child = children[childIndex] of
                Just[\Value\] => child.get().find(querykey)
                else => Nothing[\Value\]
            end
        end
    end


    (** Takes a newkey and newvalue as input and returns a 
      * new node with the (key, value) pair inserted.
      * Currently, if newkey already exists in the tree,
      * then this operation does not insert (key, newvalue)
      * into the tree.      
      *)
    insert(newkey:Key, newvalue:Value, newheight:ZZ32) : Node[\Key,Value\] = do
        if newheight < height then
            insertBelowHeight(newkey,newvalue,newheight)
        elif newheight = height then
            insertEqualHeight(newkey,newvalue)
        else
            insertAboveHeight(newkey,newvalue,newheight)
        end    
    end

    (* perform the insert operation when self.height > newheight *)
    private insertBelowHeight(newkey:Key, newvalue:Value, newheight:ZZ32) : Node[\Key,Value\] = do
        i = insertionPoint(binarySearch[\Key\](keys,newkey))
        newchild = typecase child = children[i] of    
            Just[\Node[\Key,Value\]\] => child.get().insert(newkey,newvalue,newheight)
            else => LeafNode[\Key,Value\](newkey,newvalue,newheight)
        end
        newchildren = children[0 # i].addRight(Just[\Node[\Key,Value\]\](newchild)) || children[(i + 1):]
        Node[\Key,Value\](keys,values,newchildren,height)
    end

    (* perform the insert operation when self.height = newheight *)
    private insertEqualHeight(newkey:Key, newvalue:Value) : Node[\Key,Value\] = do
        i = insertionPoint(binarySearch[\Key\](keys,newkey))
        newkeys = keys[0#i] || singleton[\Key\](newkey) || keys[i:]
        newvalues = values[0#i] || singleton[\Value\](newvalue) || values[i:]
        (newleft, newright) = 
                (filterChild(newkey, children[i], true),
                 filterChild(newkey, children[i], false))
        leftchildren = children[0#i].addRight(newleft)
        rightchildren = children[(i + 1):].addLeft(newright)
        newchildren =  leftchildren || rightchildren
        Node[\Key,Value\](newkeys,newvalues,newchildren,height)
    end

    (* perform the insert operation when self.height < newheight *)
    private insertAboveHeight(newkey:Key,newvalue:Value,newheight:ZZ32) : Node[\Key,Value\] = do
        newkeys     = singleton[\Key\](newkey)
        newvalues   = singleton[\Value\](newvalue)
        (newleft,newright) = (filterChild(newkey, Just[\Node[\Key,Value\]\](self), true),
                         filterChild(newkey, Just[\Node[\Key,Value\]\](self), false))
        newchildren = emptyList[\Maybe[\Node[\Key,Value\]\]\]().addRight(newleft).addRight(newright)
        Node[\Key,Value\](newkeys,newvalues,newchildren,newheight)
    end

    private filterChild(newkey : Key, 
                        target : Maybe[\Node[\Key,Value\]\],
                        lessThanOrEquals : Boolean)
                       : Maybe[\Node[\Key,Value\]\] = do
        typecase target of
            Just[\Node[\Key,Value\]\] =>
                filter = Filter[\Key\](newkey, lessThanOrEquals) 
                target.get().applyFilter(filter)
            else =>
                Nothing[\Node[\Key,Value\]\]
        end    
    end

    private applyFilter(filter : Filter[\Key\]) : Maybe[\Node[\Key,Value\]\] = do
        parentIndex = binarySearch[\Key\](keys, filter.pivot)
        childIndex = if (parentIndex >= 0 AND filter.lessThanOrEquals = false) then
            insertionPoint(parentIndex) + 1
        else
            insertionPoint(parentIndex)
        end
        filteredChild = typecase child = children[childIndex] of    
            Just[\Node[\Key,Value\]\] => child.get().applyFilter(filter)
            else => child
        end
        if filter.lessThanOrEquals then
            filterLessThanOrEquals(childIndex, filteredChild)
        else
            filterGreaterThan(childIndex, filteredChild)
        end     
    end

    private filterLessThanOrEquals(insertIndex   : ZZ32, 
                           filteredChild : Maybe[\Node[\Key,Value\]\]) 
                          : Maybe[\Node[\Key,Value\]\] = do
        if insertIndex = 0 then
            filteredChild
        else
            newkeys = keys[0 # insertIndex]
            newvalues = values[0 # insertIndex]
            newchildren = children[0 # insertIndex].addRight(filteredChild) 
            Just[\Node[\Key,Value\]\](Node[\Key,Value\](newkeys,newvalues,newchildren,height))
        end
    end
    
    private filterGreaterThan(insertIndex   : ZZ32, 
                      filteredChild : Maybe[\Node[\Key,Value\]\]) 
                     : Maybe[\Node[\Key,Value\]\] = do
        if insertIndex = keys.size() then
            filteredChild
        else
            newkeys = keys[insertIndex:]
            newvalues = values[insertIndex:]
            newchildren = children[(insertIndex + 1):].addLeft(filteredChild) 
            Just[\Node[\Key,Value\]\](Node[\Key,Value\](newkeys,newvalues,newchildren,height))
        end
    end    
    
    (* transform the index from binarySearch(list, key)
     * into an insertion point.
     *)
    private insertionPoint(index : ZZ32) : ZZ32 = do
        if index >= 0 then index
        else |index| - 1 end
    end

    smallestKey():Key = do
        typecase child = children[0] of    
            Just[\Node[\Key,Value\]\] => child.get().smallestKey()
            else => keys[0]
        end
    end
    
    largestKey():Key = do
        typecase child = children[children.size() - 1] of    
            Just[\Node[\Key,Value\]\] => child.get().largestKey()
            else => keys[keys.size() - 1]
        end
    end

    (**
     * The verify method will throw an error
     * if this structure does not satisfy the properties
     * of a Skip Tree.
     **)        
    verify():() = do
        if height <= 0 then
            fail(toString() " : All nodes must have a height that is a positive integer")
        end
        if |keys| =/= |values| then
            fail(toString() " : Size of keys is not equal to size of values")
        end
        if |keys| + 1 =/= |children| then
            fail(toString() " : Size of children is not equal to size of keys plus one")
        end
        for i <- 0 # (keys.size() - 1) do
            if keys[i] >= keys[i + 1] then
                fail(toString() " : Keys " keys[i] " and " keys[i + 1] " are not in sorted order")
            end
        end
        for i <- 0 # keys.size() do        
            typecase child = children[i] of    
                Just[\Node[\Key,Value\]\] => do
                    if child.get().largestKey() > keys[i] then
                        fail(toString() " : " child.get().largestKey() " > " keys[i])
                    end
                end
                else => ()
            end
            typecase child = children[i + 1] of    
                Just[\Node[\Key,Value\]\] => do
                    if child.get().smallestKey() < keys[i] then
                        fail(toString() " : " child.get().smallestKey() " < " keys[i])
                    end
                end
                else => ()
            end            
        end
        (* recusively check non-empty children *)
        for i <- 0 # children.size() do
            typecase child = children[i] of    
                Just[\Node[\Key,Value\]\] => child.get().verify()
                else => ()
            end        
        end
    end
    
end (** object Node[\Key,Value\] **)

LeafNode[\Key,Value\](key : Key, val : Value, height : ZZ32) = do
    keys = singleton[\Key\](key)
    values = singleton[\Value\](val)
    child = singleton[\Maybe[\Node[\Key,Value\]\]\](Nothing[\Node[\Key,Value\]\])
    children = child.append(child)
    Node[\Key,Value\](keys,values,children,height) 
end (** LeafNode[\Key,Value\](key : Key, val : Value, height : ZZ32) **)


(**
  *  Implementation of java.util.Collections.binarySearch
  *  JavaDoc from http://java.sun.com/javase/6/docs/api/java/util/Collections.html
  *
  *  Searches the specified list for the specified object using
  *  the binary search algorithm. The list must be sorted into
  *  ascending order according to the natural ordering of its 
  *  elements prior to making this call. If it is not sorted, the
  *  results are undefined. If the list contains multiple elements
  *  equal to the specified object, there is no guarantee which one will be found.
  *
  *  Parameters:
  *      list - the list to be searched.
  *      key - the key to be searched for. 
  *  Returns:
  *      the index of the search key, if it is contained in the list;
  *      otherwise, (-(insertion point) - 1). The insertion point is defined
  *      as the point at which the key would be inserted into the list: 
  *      the index of the first element greater than the key, or list.size()
  *      if all elements in the list are less than the specified key. 
  *      Note that this guarantees that the return value will be >= 0
  *      if and only if the key is found. 
  **)
binarySearch[\T\](list : List[\T\], key : T) : ZZ32 = do
    if list.size() <= 8 then (* base case *)
        index:ZZ32 := - list.size() - 1
        label loop
            for i <- seq(0 # list.size()) do
                if list[i] = key then
                    index := i
                    exit loop
                elif list[i] > key then
                    index := -i - 1
                    exit loop                    
                end
           end
        end loop
        index
    else (* recursive step *)
        split = list.size() DIV 2
        if (key < list[split]) then
            binarySearch[\T\](list[0 # split], key)
        else
            right = binarySearch[\T\](list[split:], key)
            if right >= 0 then right + split
            else right - split end
        end
    end
end 


end (* component SkipTree *)