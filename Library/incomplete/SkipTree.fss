component SkipTree
import List.{...}
export Executable


object SkipTree[\Key,Value\](root : Maybe[\Node[\Key,Value\]\])

    (** Takes a queryKey as input and returns either a Just[\Value\]
      * object if the (key,value) pair lives in this map, or
      * returns Nothing[\Value\] otherwise.
      *)
    find(queryKey : Key) : Maybe[\Value\] = do
        typecase root of    
            Just[\Node[\Key,Value\]\] => root.getVal().find(queryKey)
            else => Nothing[\Value\]
        end
    end

    (** Takes a newKey and newValue as input and returns a 
      * new skip tree with the (key, value) pair inserted.
      * Currently, if newKey already exists in the tree,
      * then this operation does not insert (key, newValue)
      * into the tree.
      *)
    insert(newKey : Key, newValue : Value) : SkipTree[\Key,Value\] = do
        newHeight = randomLevel()
        typecase root of
            Just[\Node[\Key,Value\]\] =>
                typecase exists = root.getVal().find(newKey) of
                    Just[\Value\] => self
                    else =>
                        root' = root.getVal().insert(newKey,newValue,newHeight)
                        SkipTree[\Key,Value\](Just[\Node[\Key,Value\]\](root'))
                end
            else =>                
                root' = LeafNode[\Key,Value\](newKey,newValue,newHeight)
                SkipTree[\Key,Value\](Just[\Node[\Key,Value\]\](root'))
        end
    end


    (**
     *  Return a random level >= 1 with a negative binomial distribution.
     *)
    randomLevel():ZZ32 = do
        level:ZZ32 := 1
        while random(1.0) < 0.5 do
            level += 1
        end
        level
    end
    
end

object Filter[\Key\](pivot : Key, lessThanOrEquals : Boolean)

    filter(query : Key) : Boolean = do
        if lessThanOrEquals then
            query <= pivot
        else
            query > pivot
        end
    end
    
end

object Node[\Key,Value\](keys     : List[\Key\],
                         values   : List[\Value\],
                         children : List[\Maybe[\Node[\Key,Value\]\]\],
                         height   : ZZ32)

    getter toString() : String = keys "" values "" children " h" height

    (** Takes a queryKey as input and returns either a Just[\Value\]
      * object if the (key,value) pair lives in this map, or
      * returns Nothing[\Value\] otherwise.
      *)    
    find(queryKey : Key) : Maybe[\Value\] = do
        parentIndex = binarySearch[\Key\](keys, queryKey)
        if parentIndex >= 0 then
            Just[\Value\](values[parentIndex])
        else
            childIndex = insertionPoint(parentIndex)
            typecase child = children[childIndex] of
                Just[\Value\] => child.getVal().find(queryKey)
                else => Nothing[\Value\]
            end
        end
    end


    (** Takes a newKey and newValue as input and returns a 
      * new node with the (key, value) pair inserted.
      *)
    insert(newKey:Key, newValue:Value, newHeight:ZZ32) : Node[\Key,Value\] = do
        if newHeight < height then
            insertBelowHeight(newKey,newValue,newHeight)
        elif newHeight = height then
            insertEqualHeight(newKey,newValue)
        else
            insertAboveHeight(newKey,newValue,newHeight)
        end    
    end

    (* perform the insert operation when self.height > newHeight *)
    private insertBelowHeight(newKey:Key, newValue:Value, newHeight:ZZ32) : Node[\Key,Value\] = do
        i = insertionPoint(binarySearch[\Key\](keys,newKey))
        newchild = typecase child = children[i] of    
            Just[\Node[\Key,Value\]\] => child.getVal().insert(newKey,newValue,newHeight)
            else => LeafNode[\Key,Value\](newKey,newValue,newHeight)
        end
        newchildren = children[0 # i].addRight(Just[\Node[\Key,Value\]\](newchild)) || children[(i + 1):]
        Node[\Key,Value\](keys,values,newchildren,height)
    end

    (* perform the insert operation when self.height = newHeight *)
    private insertEqualHeight(newKey:Key, newValue:Value) : Node[\Key,Value\] = do
        i = insertionPoint(binarySearch[\Key\](keys,newKey))
        newkeys = keys[0#i] || singleton[\Key\](newKey) || keys[i:]
        newvalues = values[0#i] || singleton[\Value\](newValue) || values[i:]
        (newleft, newright) = (filterChild(newKey, children[i], true), filterChild(newKey, children[i], false))
        leftchildren = children[0#i].addRight(newleft)
        rightchildren = children[(i + 1):].addLeft(newright)
        newchildren =  leftchildren || rightchildren
        Node[\Key,Value\](newkeys,newvalues,newchildren,height)
    end

    private filterChild(newKey : Key, 
                        target : Maybe[\Node[\Key,Value\]\],
                        lessThanOrEquals : Boolean)
                       : Maybe[\Node[\Key,Value\]\] = do
        typecase target of
            Just[\Value\] =>
                filter = Filter[\Key\](newKey, lessThanOrEquals) 
                child.getVal().applyFilter(filter)
            else =>
                Nothing[\Node[\Key,Value\]\]
        end    
    end

    applyFilter(filter : Filter[\Key\]) : Maybe[\Node[\Key,Value\]\] = do
        parentIndex = binarySearch(keys, filter.pivot)
        childIndex = if (parentIndex >= 0 AND filter.lessThanOrEquals = false) then
            insertionPoint(parentIndex) + 1
        else
            insertionPoint(parentIndex)
        end
        filteredChild = typecase child = children[childIndex] of    
            Just[\Node[\Key,Value\]\] => child.getVal().applyFilter(filter)
            else => child
        end
        if filter.lessThanOrEquals then
            filterLessThanOrEquals(childIndex, filteredChild)
        else
            filterGreaterThan(childIndex, filteredChild)
        end     
    end

    filterLessThanOrEquals(insertIndex   : ZZ32, 
                           filteredChild : Maybe[\Node[\Key,Value\]\]) 
                          : Maybe[\Node[\Key,Value\]\] = do
        if insertIndex = 0 then
            filteredChild
        else
            newkeys = keys[0 # insertIndex]
            newvalues = values[0 # insertIndex]
            newchildren = children[0 # insertIndex].addRight(filteredChild) 
            Just[\Node[\Key,Value\]\](Node[\Key,Value\](newkeys,newvalues,newchildren,height))
        end
    end
    
    filterGreaterThan(insertIndex   : ZZ32, 
                      filteredChild : Maybe[\Node[\Key,Value\]\]) 
                     : Maybe[\Node[\Key,Value\]\] = do
        if insertIndex = keys.size() then
            filteredChild
        else
            newkeys = keys[insertIndex:]
            newvalues = values[insertIndex:]
            newchildren = children[(insertIndex + 1):].addLeft(filteredChild) 
            Just[\Node[\Key,Value\]\](Node[\Key,Value\](newkeys,newvalues,newchildren,height))
        end
    end    
    
    (* transform the index from binarySearch(list, key)
     * into an insertion point.
     *)
    insertionPoint(index : ZZ32) : ZZ32 = do
        if index >= 0 then index
        else |index| - 1 end
    end
    
end (** object Node[\Key,Value\] **)

LeafNode[\Key,Value\](key : Key, val : Value, height : ZZ32) = do
    keys = singleton[\Key\](key)
    values = singleton[\Value\](val)
    child = singleton[\Maybe[\Node[\Key,Value\]\]\](Nothing[\Node[\Key,Value\]\])
    children = child.append(child)
    Node[\Key,Value\](keys,values,children,height) 
end (** LeafNode[\Key,Value\](key : Key, val : Value, height : ZZ32) **)


(**
  *  Implementation of java.util.Collections.binarySearch
  *  JavaDoc from http://java.sun.com/javase/6/docs/api/java/util/Collections.html
  *
  *  Searches the specified list for the specified object using
  *  the binary search algorithm. The list must be sorted into
  *  ascending order according to the natural ordering of its 
  *  elements prior to making this call. If it is not sorted, the
  *  results are undefined. If the list contains multiple elements
  *  equal to the specified object, there is no guarantee which one will be found.
  *
  *  Parameters:
  *      list - the list to be searched.
  *      key - the key to be searched for. 
  *  Returns:
  *      the index of the search key, if it is contained in the list;
  *      otherwise, (-(insertion point) - 1). The insertion point is defined
  *      as the point at which the key would be inserted into the list: 
  *      the index of the first element greater than the key, or list.size()
  *      if all elements in the list are less than the specified key. 
  *      Note that this guarantees that the return value will be >= 0
  *      if and only if the key is found. 
  **)
binarySearch[\T\](list : List[\T\], key) : ZZ32 = do
    if list.size() = 1 then (* base case *)
        if key < list[0] then -1
        elif key = list[0] then 0
        else -2 end
    else (* recursive step *)
        split = list.size() DIV 2
        if (key < list[split]) then
            binarySearch[\T\](list[0 # split], key)
        else
            right = binarySearch[\T\](list[split:], key)
            if right >= 0 then right + split
            else right - split end
        end
    end
end 


run(args:String...):() = do
    leaf = LeafNode[\ZZ32,ZZ32\](7,1,3)
    println leaf.toString()
    println leaf.find(3)
    println leaf.find(7)    
    testList = emptyList[\ZZ32\]().addRight(5).addRight(10).addRight(15).addRight(20)
    assert(binarySearch[\ZZ32\](testList, 2), -1)
    assert(binarySearch[\ZZ32\](testList, 5), 0)
    assert(binarySearch[\ZZ32\](testList, 7), -2)
    assert(binarySearch[\ZZ32\](testList, 10), 1)
    assert(binarySearch[\ZZ32\](testList, 13), -3)
    assert(binarySearch[\ZZ32\](testList, 15), 2)
    assert(binarySearch[\ZZ32\](testList, 17), -4)
    assert(binarySearch[\ZZ32\](testList, 20), 3)
    assert(binarySearch[\ZZ32\](testList, 23), -5)

    println leaf.insert(5,2,2).toString()    
    (** tree = SkipTree[\ZZ32,ZZ32\](Just[\Node[\ZZ32,ZZ32\]\](leaf)) *)
    
    
        
    
end (* run(args:String...):() *)


end