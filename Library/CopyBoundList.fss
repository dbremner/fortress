(*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component CopyBoundList
import OneShotFlag.{...}
import NativeArray.{...}

export CopyBoundList

(** A CopyBoundList is an ArrayList when it gets large enough, but
    otherwise works by simply copying data using a flat array.
 **)

(* Tests can be found in
   tests/CopyBoundListQuick.fss
   demos/CopyBoundListLong.fss [not yet]
*)

copyBound : ZZ32 = 8

private scale(x : ZZ32): ZZ32 = 2 x

private expansion(curr: ZZ32, new: ZZ32) =
    if new > curr then
        (* Common case? *)
        (1 + scale curr) MAX new
    elif scale new <= curr then
        new
    else
        curr
    end

(** Lists of some item type.  Used to collect elements of unknown type
    into a list whose element type is as specific as possible. **)
trait SomeList excludes { Number, HasRank, String }
        (* comprises List[\E\] where [\E\] *)
    opr ||(self, f:SomeList): SomeList = app(self,f)
    addLeft(e:Any): SomeList = addL(e,self)
    addRight(e:Any): SomeList = addR(self,e)
end

private app[\T,E extends T,F extends T\](a:List[\E\], b:List[\F\]): List[\T\] =
    typecase (a,b) of
        (List[\T\],List[\T\]) => a || b
        (List[\T\],List[\F\]) => a.appendRC[\F\](b)
        (List[\E\],List[\T\]) => b.appendLC[\E\](a)
        else =>
            emptyList[\T\](scale(|a| + |b|)).appendR[\E\](a).appendR[\F\](b)
    end

private addL[\T,E extends T,F extends T\](x:E, xs:List[\F\]): List[\T\] =
    emptyList[\T\](scale(|xs|)).addRight(x).appendR[\F\](xs)

private addR[\T,E extends T,F extends T\](xs:List[\F\],x:E): List[\T\] =
    emptyList[\T\](scale(|xs|)).appendR[\F\](xs).addRight(x)

(** %List%.  We return a %Generator% for non-list-specific operations
    for which reuse of the %Generator% will not increase asymptotic
    complexity, but return a %List% in cases (such as %map% and
    %filter%) where it will.  *)
trait List[\E\] extends { SomeList, LexicographicOrder[\List[\E\],E\] }
        excludes { Number, HasRank }
    (** %left% and %extractLeft% return the leftmost element in the list
        (and in the latter case, the remainder of the list without its
        leftmost element).  They return %Nothing% if the list is empty.
        %right% and %extractRight% do the same with the rightmost
        element. *)
    getter left():Maybe[\E\] = self.extractLeft.map[\E\](fn (v:E,_):E => v)
    getter right():Maybe[\E\] = self.extractRight.map[\E\](fn (_,v:E):E => v)
    getter extractLeft(): Maybe[\(E,List[\E\])\]
    getter extractRight(): Maybe[\(List[\E\],E)\]
    getter toString():String =
      "<|" (if (h,t) <- self.extractLeft then
                h (BIG ||[e<-t] ", " e)
            else " " end) "|>"
    (** the operator %||% returns a list containing the elements of %self% followed
        by the elements of %f% *)
    opr ||(self, other:List[\E\]): List[\E\]
    (** Helper methods for %append% *)
    private appendRC[\T\](other:List[\T\]): List[\E\]
    private appendLC[\T\](other:List[\T\]): List[\E\]
    private appendR[\T\](other:List[\T\]): List[\E\]
    private appendL[\T\](other:List[\T\]): List[\E\]
    (** %addLeft% and %addRight% add an element to the left or right of
        the list, respectively *)
    addLeft(e:E):List[\E\]
    addRight(e:E):List[\E\]
    (** %take% returns the leftmost %n% elements of the list; if the
        list is shorter than this, the entire list is returned. *)
    take(n:ZZ32): List[\E\]
    (** %drop% drops the leftmost %n% elements of the list; if the list
        is shorter than this, an empty list is returned. *)
    drop(n:ZZ32): List[\E\]
    opr [n:ZZ32]: E
    opr [n:Range[\ZZ32\]]: List[\E\] = do
        r = (0 # |self|).narrowToRange(n)
        if r.stride = 1 then
            drop(r.left.get).take(|r|)
        else
            <| self[i] | i <- r |>
        end
      end
    (** %l.split(n)% is equivalent to %(l.take(n),l.drop(n))%.  Note in
        particular that appending its results yields the original
        list. *)
    split(n:ZZ32): (List[\E\], List[\E\])
    (** %split% splits the list into two smaller lists.  If %|l| > 1%
        both lists will be non-empty. *)
    split(): (List[\E\], List[\E\])
    reverse(): List[\E\] =
        generate[\List[\E\]\](RevConcat[\E\],singleton[\E\])
    filter(p: E -> Boolean): List[\E\] =
        concatMap[\E\](fn (x:E):List[\E\] => if p(x) then singleton[\E\](x)
                                             else emptyList[\E\]() end)
    (** %concatMap% is an in-place version of the %nest% method from
        %Generator%; it flattens the result into an actual list, rather than
        returning an abstract %Generator%. *)
    concatMap[\G\](f: E->List[\G\]): List[\G\] =
        generate[\List[\G\]\](Concat[\G\],f)
    map[\G\](f: E->G): List[\G\] =
        concatMap[\G\](fn (e:E):List[\G\] => singleton[\G\](f(e)))
    ivmap[\G\](f: (ZZ32,E)->G): List[\G\] =
        self.indexValuePairs.generate[\List[\G\]\](Concat[\G\],
                  fn (t:(ZZ32,E)):List[\G\] => singleton[\G\](f(t)))
end

(** Vararg factory for lists; provides aggregate list constants **)
opr <|[\E\] xs: E... |>: List[\E\] = list(xs)
opr BIG <|[\T\]|>: Comprehension[\T,List[\T\],SomeList,SomeList\] =
    covariantComprehension[\T,List[\T\]\](fn (x) => x)

covariantComprehension[\T,R\](unwrap:SomeList->R): Comprehension[\T,R,SomeList,SomeList\] =
    Comprehension[\T,R,SomeList,SomeList\](
        fn xs => unwrap(xs || emptyList[\T\]()), CVConcat[\T\], cvSingleton)

(** Convert generator into list; can be used to desugar list
    comprehensions *)
list[\E\](g:Generator[\E\]):List[\E\] =
    g.generate[\List[\E\]\](Concat[\E\], singleton[\E\])
list[\E\](g:Indexed[\E,ZZ32\]):List[\E\] = do
    a = primitiveImmutableArray[\E\](|g|)
    for (i,v) <- g[#].indexValuePairs do
        a.init0(i,v)
    end
    fromImmutableArray[\E\](a)
  end
list[\E\](f: ImmutableArray[\E,ZZ32\]): List[\E\] =
    if f.bounds.lower = 0 then
        fromImmutableArray[\E\](f)
    else
        fromImmutableArray[\E\](f[#].copy())
    end
list[\E\](r: List[\E\]): List[\E\] = r

(** Flatten an int-indexed collection of lists **)
concat[\E\](lists:Indexed[\List[\E\],ZZ32\]):CBList[\E\] = do
    (* The following just sets positions to the prefix sum of the lengths
       of the lists.  sz is the total length.  When we have prefixes we
       ought to do this step in parallel. *)
    listsLower = lists.bounds.lower
    positions = primitiveImmutableArray[\ZZ32\](|lists|)
    sz : ZZ32 := 0
    for (i,l) <- sequential(lists.indexValuePairs) do
         positions.init0(i-listsLower,sz)
         sz += |l|
    end
    (* The prefix is complete.  Allocate the final list and put elements
       into place in parallel. *)
    under = primitiveImmutableArray[\E\](sz)
    for (i,l) <- lists.indexValuePairs do
        ofs = positions.get(i-listsLower)
        for (j,v) <- l.indexValuePairs do
            under.init0(ofs+j,v)
        end
    end
    fromImmutableArray[\E\](under)
  end

(** A reduction object for concatenating lists. *)
private object Concat[\E\] extends MonoidReduction[\ List[\E\] \]
  getter toString():String = "List concatenation"
  empty(): List[\E\] = emptyList[\E\]()
  join(a:List[\E\], b:List[\E\]): List[\E\] = a || b
end

(** A reduction object for concatenating lists covariantly. *)
private object CVConcat[\T\] extends MonoidReduction[\SomeList\]
  getter toString():String = "Covariant list concatenation"
  empty(): SomeList = emptyList[\T\]()
  join(a:SomeList, b:SomeList): SomeList = a || b
end

(** The same for reverse concatenation *)
private object RevConcat[\E\] extends MonoidReduction[\ List[\E\] \]
  getter toString():String = "List reversal concatenation"
  empty(): List[\E\] = emptyList[\E\]()
  join(a:List[\E\], b:List[\E\]): List[\E\] = b || a
end

trait CBList[\E\] extends { List[\E\], DelegatedIndexed[\E,ZZ32\] }
        comprises { Empty[\E\], Small[\E\], Large[\E\] }
    getter leftSpace(): ZZ32 = 0
    getter rightSpace(): ZZ32 = 0
    fill[\T\](start: ZZ32, under: ImmutableArray[\T,ZZ32\]): ()
end

object Empty[\E\] extends { CBList[\E\] }
    getter size(): ZZ32 = 0
    getter isEmpty(): Boolean = true
    getter left(): Maybe[\E\] = Nothing[\E\]
    getter right():Maybe[\E\] = Nothing[\E\]
    getter extractLeft(): Maybe[\(E,CBList[\E\])\] =
        Nothing[\(E,CBList[\E\])\]
    getter extractRight(): Maybe[\(CBList[\E\],E)\] =
        Nothing[\(CBList[\E\],E)\]
    getter indices(): Generator[\ZZ32\] = Nothing[\ZZ32\]
    getter indexValuePairs(): Generator[\(ZZ32,E)\] = Nothing[\(ZZ32,E)\]
    getter generator(): Generator[\E\] = Nothing[\E\]
    opr |self| : ZZ32 = 0

    get(i:ZZ32): E = fail("get Empty")

    fill[\T\](start: ZZ32, under: ImmutableArray[\T,ZZ32\]): () = ()

    addLeft(e:E): List[\E\] = singleton[\E\](e)
    addRight(e:E): List[\E\] = singleton[\E\](e)

    opr ||(self, other:List[\E\]): List[\E\] = other
    appendR[\T\](other:List[\T\]): List[\E\] = do
        under = primitiveImmutableArray[\E\](|other|)
        under.fill(fn i => other.get(i))
        Small[\E\](under)
      end
    appendRC[\T\](other:List[\T\]): List[\E\] = appendR[\T\](other)
    appendL[\T\](left1:List[\T\]): List[\E\] = appendR[\T\](left1)
    appendLC[\T\](left1:List[\T\]): List[\E\] = appendR[\T\](left1)

    take(n:ZZ32): CBList[\E\] = self
    drop(n:ZZ32): CBList[\E\] = self
    split(n:ZZ32): (CBList[\E\],CBList[\E\]) = (self,self)
    split(): (CBList[\E\],CBList[\E\]) = (self,self)
    opr [n:ZZ32]: E = fail("CBList[" n "] index outside 0#0")
    reverse(): CBList[\E\] = self
    map[\G\](f:E->G): CBList[\G\] = Empty[\G\]
    ivmap[\G\](f:(ZZ32,E)->G): CBList[\G\] = Empty[\G\]
    concatMap[\G\](f: E->List[\G\]): List[\G\] = Empty[\G\]
end


object Small[\E\]( underlying : ImmutableArray[\E,ZZ32\] )
        extends { CBList[\E\] }
    getter size(): ZZ32 = |underlying|
    getter isEmpty(): Boolean = false
    getter left(): Maybe[\E\] = Just[\E\](underlying.get(0))
    getter right():Maybe[\E\] = Just[\E\](underlying.get(|underlying| - 1))
    getter extractLeft(): Maybe[\(E,CBList[\E\])\] =
        Just[\(E,CBList[\E\])\](underlying.get(0),
                           if |underlying| <= 1 then
                               Empty[\E\]
                           else
                               Small[\E\](underlying[1:].copy())
                           end)
    getter extractRight(): Maybe[\(CBList[\E\],E)\] = do
        lastIndex = |underlying| - 1
        Just[\(CBList[\E\],E)\](if lastIndex < 1 then
                               Empty[\E\]
                           else
                               Small[\E\](underlying[#lastIndex].copy())
                           end,
                           underlying.get(lastIndex))
      end
    getter indices(): Generator[\ZZ32\] = underlying.indices()
    getter indexValuePairs(): Generator[\(ZZ32,E)\] =
        underlying.indexValuePairs()
    getter generator(): Generator[\E\] = underlying
    getter large(): Large[\E\] = Large[\E\](underlying,0,noShot,|underlying|,noShot)
    opr |self| : ZZ32 = |underlying|

    get(i:ZZ32): E = underlying.get(i)

    fill[\T\](start: ZZ32, under: ImmutableArray[\T,ZZ32\]): () = do
        under.init0(i+start, cast[\T\](v)), (i,v) <- underlying.indexValuePairs()
      end

    addLeft(e:E): List[\E\] = do
        sz = |underlying|
        if sz < copyBound then
            newUnder = primitiveImmutableArray[\E\](sz+1)
            newUnder.init(0,e)
            newUnder.init(i+1, v), (i,v) <- underlying.indexValuePairs()
            Small[\E\](newUnder)
        else
            large().addLeft(e)
        end
      end
    addRight(e:E): List[\E\] = do
        sz = |underlying|
        if sz < copyBound then
            newUnder = primitiveImmutableArray[\E\](sz+1)
            newUnder.init(sz,e)
            newUnder.init(i, v), (i,v) <- underlying.indexValuePairs()
            Small[\E\](newUnder)
        else
            large().addRight(e)
        end
      end

    opr ||(self, other:List[\E\]): List[\E\] =
        if |underlying| + |other| <= copyBound then
            appendR[\E\](other)
        else
            large() || other
        end
    appendR[\T\](other:List[\T\]): List[\E\] =
        if other.isEmpty() then self
        else
            szs = |self|
            newUnder = primitiveImmutableArray[\E\](szs+|other|)
            do
                newUnder.init(i, v), (i,v) <- underlying.indexValuePairs()
            also do
                newUnder.init(i+szs, v), (i,v) <- other.indexValuePairs()
            end
            Small[\E\](newUnder)
        end
    appendRC[\T\](other:List[\T\]): List[\E\] =
        if |other| + |underlying| <= copyBound then
            appendR[\T\](other)
        else
            large().appendRC[\T\](other)
        end
    appendL[\T\](left1:List[\T\]): List[\E\] =
        if left1.isEmpty() then self
        else
            szl = |left1|
            newUnder = primitiveImmutableArray[\E\](szl+|self|)
            do
                newUnder.init(i, v), (i,v) <- left1.indexValuePairs()
            also do
                newUnder.init(i+szl, v), (i,v) <- self.indexValuePairs()
            end
            Small[\E\](newUnder)
        end
    appendLC[\T\](left1:List[\T\]): List[\E\] =
        if |left1| + |underlying| <= copyBound then
            appendL[\T\](left1)
        else
            large().appendLC[\T\](left1)
        end

    (** Return first n elements of this list.  take(n) never fails: If n is
        negative or 0, an empty list is returned; if n is larger than |self|,
        the whole list is returned. **)
    take(n:ZZ32): CBList[\E\] =
        if n <= 0 then Empty[\E\]
        elif n < |underlying| then
            Small[\E\](underlying[#n].copy())
        else
            self
        end
    (** Drop the first n elements from this list and return the rest.  drop(n)
        never fails: If n is larger than |self|, an empty list is returned; if
        n <= 0 the original list is returned. **)
    drop(n:ZZ32): CBList[\E\] =
        if n <= 0 then
            self
        elif n < |underlying| then
            Small[\E\](underlying[n:].copy())
        else
            Empty[\E\]
        end
    split(n:ZZ32): (CBList[\E\],CBList[\E\]) =
        if n <= 0 then
            (Empty[\E\], self)
        elif n < |underlying| then
            (Small[\E\](underlying[#n].copy()),
             Small[\E\](underlying[n:].copy()))
        else
            (self, Empty[\E\])
        end
    split(): (CBList[\E\],CBList[\E\]) = do
        sz = |underlying|
        if sz <= 1 then
            (self,Empty[\E\])
        else
            split(partitionL(sz))
        end
      end
    opr [n:ZZ32]: E = underlying[n]
    reverse(): CBList[\E\] = do
        sz = |underlying|
        under = primitiveImmutableArray[\E\](sz)
        sz1 = sz - 1
        under.init(sz1-i,v), (i,v) <- underlying.indexValuePairs()
        Small[\E\](under)
      end
    mapArr[\G\](f:E->G):ImmutableArray[\G,ZZ32\] =
        primitiveImmutableArray[\G\](|self|).fill(fn (i:ZZ32):G => f(underlying.get(i)))
    map[\G\](f:E->G): CBList[\G\] = Small[\G\](mapArr[\G\](f))
    ivmapArr[\G\](f:(ZZ32,E)->G):ImmutableArray[\G,ZZ32\] =
        primitiveImmutableArray[\G\](|self|).fill(fn (i:ZZ32):G => f(i,underlying.get(i)))
    ivmap[\G\](f:(ZZ32,E)->G): CBList[\G\] =
        Small[\G\](ivmapArr[\G\](f))
    (* We implement concatMap data-parallel fashion to avoid repeated copying.
       Cost: we must allocate 2*|self| auxiliary arrays. *)
    concatMap[\G\](f: E->List[\G\]): List[\G\] = do
        lists = mapArr[\List[\G\]\](f)
        concat[\G\](lists)
      end
end

object Large[\E\]( underlying : ImmutableArray[\E,ZZ32\],
                 firstUsed : ZZ32, canExtendLeft : OneShot,
                 firstUnused : ZZ32, canExtendRight : OneShot )
        extends { CBList[\E\] }
    getter size(): ZZ32 = |self|
    getter isEmpty(): Boolean = firstUnused <= firstUsed
    getter left(): Maybe[\E\] =
        if self.isEmpty then Nothing[\E\]
        else Just[\E\](underlying.get(firstUsed)) end
    getter right():Maybe[\E\] =
        if self.isEmpty then Nothing[\E\]
        else Just[\E\](underlying.get(firstUnused-1)) end
    getter extractLeft(): Maybe[\(E,CBList[\E\])\] =
        if self.isEmpty then Nothing[\(E,CBList[\E\])\]
        else Just[\(E,CBList[\E\])\](underlying.get(firstUsed),
                       Large(underlying, firstUsed+1, noShot,
                                 firstUnused, canExtendRight))
        end
    getter extractRight(): Maybe[\(CBList[\E\],E)\] =
        if self.isEmpty then Nothing[\(CBList[\E\],E)\]
        else Just[\(CBList[\E\],E)\](
                       Large(underlying, firstUsed, canExtendLeft,
                                      firstUnused-1, noShot),
                       underlying.get(firstUnused-1))
        end
    getter indices(): ZeroIndexed[\ZZ32\] = 0 # |self|
    getter indexValuePairs(): Generator[\(ZZ32,E)\] =
        self.indices.map[\(ZZ32,E)\](fn (i:ZZ32):(ZZ32,E) =>
                                        (i,underlying.get(firstUsed+i)))
    getter generator(): Generator[\E\] =
        (firstUsed # |self|).map[\E\](fn (i:ZZ32):E => underlying.get(i))

    getter leftSpace(): ZZ32 =
        if canExtendLeft.canTry then
            if firstUsed=0 then canExtendLeft.tryOnce() end
            firstUsed
        else
            0
        end
    getter rightSpace(): ZZ32 =
        if canExtendRight.canTry then
            res = |underlying| - firstUnused
            if res = 0 then canExtendRight.tryOnce() end
            res
        else
            0
        end

    opr |self| : ZZ32 = firstUnused - firstUsed

    get(i:ZZ32): E = underlying.get(firstUsed+i)

    fill[\T\](start: ZZ32, under: ImmutableArray[\T,ZZ32\]): () = do
        shift = start - firstUsed
        under.init0(i+shift, cast[\T\](underlying.get(i))), i <- firstUsed # |self|
      end

    (** Return new %CBList% enlarged on the left by at least %i%
        elements.  It claims %canExtendLeft% on the new list.  **)
    enlargeLeft[\T\](i:ZZ32): CBList[\T\] = do
        sz0 = |underlying|
        sz = (sz0 + i) MAX scale(sz0)
        fstUsed = sz - sz0
        under = primitiveImmutableArray[\E\](sz)
        fill[\T\](fstUsed,under)
        fstUnused = fstUsed + |self|
        Large(under,fstUsed,noShot,fstUnused,oneShot())
      end

    (** Return new %CBList% enlarged on the right by at least %i%
        elements.  It claims %canExtendRight% on the new list.  **)
    enlargeRight[\T\](i:ZZ32): CBList[\T\] = do
        sz0 = |underlying|
        sz = (sz0 + i) MAX scale(sz0)
        under = primitiveImmutableArray[\E\](sz)
        fill[\T\](firstUsed,under)
        Large(under,firstUsed,oneShot(),firstUnused,noShot)
      end

    addLeft(e:E): List[\E\] = do
        c = if canExtendLeft.tryOnce() AND firstUsed > 0 then
                self
            else
                enlargeLeft[\E\](1)
            end
        cFirstUsed1 = c.firstUsed-1
        cUnder = c.underlying
        cUnder.init0(cFirstUsed1,e)
        Large( cUnder, cFirstUsed1,   oneShot(),
                                c.firstUnused, c.canExtendRight )
      end
    addRight(e:E): List[\E\] = do
        c = if canExtendRight.tryOnce() AND firstUnused < |underlying| then
                self
            else
                enlargeRight[\E\](1)
            end
        cFirstUnused = c.firstUnused
        cUnder = c.underlying
        cUnder.init0(cFirstUnused,e)
        Large( cUnder, c.firstUsed,    c.canExtendLeft,
                                cFirstUnused+1, oneShot() )
      end

    (** %||% cab either append %other% to the right of %self%
        or %self% to the left of %other%.  Choose based on available
        space, preferring right append and if necessary right extension. **)
    opr ||(self, other:List[\E\]): List[\E\] =
        if self.rightSpace >= |other| AND: canExtendRight.tryOnce() then
            appendR[\E\](other)
        elif other.leftSpace >= |self| AND: other.canExtendLeft.tryOnce() then
            other.appendL[\E\](self)
        else
            (* Enlarge on the right.  Note missed opportunity for parallelism in
               the name of maintainability: we could do the two copy operations
               in enlargeRight and appendR in parallel. *)
            otherSize = |other|
            fresh = enlargeRight[\E\](otherSize)
            fresh.appendR[\E\](other)
        end
    appendR[\T\](other:List[\T\]): List[\E\] = do
        other.fill[\E\](firstUnused,underlying)
        Large(underlying,firstUsed,canExtendLeft,
                            firstUnused + |other|, oneShot())
      end
    appendRC[\T\](other:List[\T\]): List[\E\] =
        if self.rightSpace >= |other| AND: canExtendRight.tryOnce() then
            appendR[\T\](other)
        else
            fresh = enlargeRight[\E\](|other|)
            fresh.appendR[\T\](other)
        end
    appendL[\T\](left1:List[\T\]): List[\E\] = do
        lsz = |left1|
        fstUsed = firstUsed - lsz
        left1.fill[\E\](fstUsed,underlying)
        Large(underlying,fstUsed,oneShot(),firstUnused,canExtendRight)
      end
    appendLC[\T\](left1:List[\T\]): List[\E\] =
        if self.leftSpace >= |left1| AND: canExtendLeft.tryOnce() then
            appendL[\T\](left1)
        else
            fresh = enlargeLeft[\E\](|left1|)
            fresh.appendL[\T\](left1)
        end

    (** Return first n elements of this list.  take(n) never fails: If n is
        negative or 0, an empty list is returned; if n is larger than |self|,
        the whole list is returned. **)
    take(n:ZZ32): CBList[\E\] =
        if n <= 0 then
            Large(underlying,firstUsed,canExtendLeft,
                                      firstUsed,noShot)
        elif n < |self| then
            Large(underlying, firstUsed,canExtendLeft,
                                       firstUsed+n, noShot)
        else
            self
        end
    (** Drop the first n elements from this list and return the rest.  drop(n)
        never fails: If n is larger than |self|, an empty list is returned; if
        n <= 0 the original list is returned. **)
    drop(n:ZZ32): CBList[\E\] =
        if n <= 0 then
            self
        elif n < |self| then
            Large(underlying, firstUsed+n, noShot,
                                       firstUnused, canExtendRight)
        else
            Large(underlying, firstUnused, noShot,
                                       firstUnused, canExtendRight)
        end
    split(n:ZZ32): (CBList[\E\],CBList[\E\]) =
        if n <= 0 then
            (Large(underlying, firstUsed,canExtendLeft,
                                        firstUsed,noShot),
             self)
        elif n < |self| then
            (Large(underlying, firstUsed,canExtendLeft,
                                        firstUsed+n, noShot),
             Large(underlying, firstUsed+n, noShot,
                                        firstUnused, canExtendRight))
        else
            (self,
             Large(underlying, firstUnused, noShot,
                                        firstUnused, canExtendRight))
        end
    split(): (CBList[\E\],CBList[\E\]) = do
        sz = |self|
        if sz <= 1 then
            split(sz)
        else
            split(partitionL(sz))
        end
      end
    opr [n:ZZ32]: E = do
        ui = firstUsed + n
        if 0 <= n AND ui < firstUnused then
            underlying.get(ui)
        else
            fail("CBList[" n "] index outside 0#" |self|)
        end
      end
    reverse(): CBList[\E\] = do
        firstUnused1 = firstUnused-1
        sz = |self|
        under = primitiveImmutableArray[\E\](sz)
        under.init0(i,underlying.get(firstUnused1-i)), i <- 0#sz
        fromImmutableArray[\E\](under)
      end
    mapArr[\G\](f:E->G):ImmutableArray[\G,ZZ32\] =
        primitiveImmutableArray[\G\](|self|).fill(
            fn (i:ZZ32):G => f(underlying.get(i+firstUsed)))
    map[\G\](f:E->G): CBList[\G\] =
        fromImmutableArray[\G\](mapArr[\G\](f))
    ivmapArr[\G\](f:(ZZ32,E)->G):ImmutableArray[\G,ZZ32\] =
        primitiveImmutableArray[\G\](|self|).fill(
            fn (i:ZZ32):G => f(i,underlying.get(i+firstUsed)))
    ivmap[\G\](f:(ZZ32,E)->G): CBList[\G\] =
        fromImmutableArray[\G\](ivmapArr[\G\](f))
    (* We implement concatMap data-parallel fashion to avoid repeated copying.
       Cost: we must allocate 2*|self| auxiliary arrays. *)
    concatMap[\G\](f: E->List[\G\]): List[\G\] = do
        lists = mapArr[\List[\G\]\](f)
        concat[\G\](lists)
      end
end

private fromImmutableArray[\E\](under: ImmutableArray[\E,ZZ32\]) =
    if |under| = 0 then
        Empty[\E\]
    else
        Small[\E\](under)
    end

emptyList[\E\](): List[\E\] = Empty[\E\]

(** emptyList[\E\](n) allocates an empty list that can accept n
    addRight operations without reallocating the underlying storage. **)
emptyList[\E\](n:ZZ32): List[\E\] =
    if n > copyBound then
        Large(primitiveImmutableArray[\E\](n),0,noShot,0,oneShot())
    else
        Empty[\E\]
    end

private cvSingleton(e:Any): SomeList = singleton(e)

singleton[\E\](e:E): List[\E\] = do
    u = PrimImmutableArray[\E,1\]()
    u.init0(0,e)
    Small[\E\](u)
  end

end
