(*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component FortressLibrary
import NativeArray.{...}
import NatReflect.{...}

export Executable

(** The following function is actually recognized as a special piece
    of built-in magic by the Fortress interpreter.  The javaClass
    argument names a Java Class which is a subclass of
    com.sun.fortress.interpreter.glue.NativeApp, which provides code
    for the closure which is used in place of the call to
    builtinPrimitive.  Meanwhile all the necessary type information,
    argument names, etc. must be declared here in Fortress-land.  For
    examples see the end of this file.

    In practice if you're extending the interpreter you will probably
    want to extend com.sun.fortress.interpreter.glue.NativeFn0,1,2,3,4
    or one of their subclasses defined in
    com.sun.fortress.interpreter.glue.primitive.  These types are
    generally easier to work with, and the boilerplate packing and
    unpacking of values is done for you.
*)

builtinPrimitive[\T\](javaClass:String):T =
  fail ("Implementation should not invoke builtinPrimitive " javaClass)

(** Builtin types from evaluator.Primitives.java:

Here "object" really implies non-extensibility.

trait  Number        extends { Any }         excludes { String, Boolean }
trait  Integral      extends { Number }      excludes { String, Boolean, RR64, FloatLiteral }
object ZZ32          extends { Integral }    excludes { String, Boolean, RR64, FloatLiteral }
object ZZ64          extends { Integral }    excludes { String, Boolean, RR64, FloatLiteral }
object RR64          extends { Number }      excludes { String, Boolean }
object String        extends { Any }         excludes { IntLiteral, FloatLiteral, Boolean }
object IntLiteral    extends { ZZ32, ZZ64, RR64 }
object FloatLiteral  extends { RR64 }

trait  Any           extends {}
  Note that everything is considered to extend the type Any.

Note also that there isn't (yet) a trait Object!  Eventually
user-written trait and object declarations will extend Object by
default; right now they instead extend Any by default.

Note also that most of these types should not form a hierarchy, but
instead a flat type space with coercions between constituents.  Due to
the absence of coercion we have the rather unfortunate situation you
see here.

*)

(************************************************************
* Simple Combinators
************************************************************)

(** Casting *)

cast[\T extends Any\](x:Any):T =
  typecase x of
    T => x
    else => throw CastError
  end

instanceOf[\T extends Any\](x:Any):Boolean =
  typecase x of
    T => true
    else => false
  end

(** Useful functions *)

ignore(_:Any):() = ()

identity[\T extends Any\](x:T):T = x

(* Should we depracate tuple and use identity instead?  Decision: no. *)
tuple[\T\](x:T):T = x

(* Function composition *)
opr COMPOSE[\A,B,C\](f: B->C, g: A->B): A->C = fn (a:A): C => f(g(a))

(** Reflection of static type parameters for overloading purposes.
    Works around shortcomings in the story on parametric overloading
    (all overloadings must have the same parameters with the same
    bounds).  Allows us to overload a function based on the parametric
    type of an output. *)

object __Proxy[\T extends (* U *) Any\]
    (* extends { __Proxy[\U\], Object } where { U extends Any } *)
  getter toString() = "__Proxy object, should not be user-visible."
end

fail(s:String) = do
   println("FAIL: " s)
   printTaskTrace()
   throwError(s)
   throw FailCalled(s)
end

(************************************************************
* Control over locality and location
************************************************************)

(* At the moment all Fortress objects are immediately shared by default. *)

shared[\T extends Any\](x:T): T = x

isShared(x:Any): Boolean = true

localize[\T extends Any\](x:T): T = x

(* copy is presently unimplemented.
copy[\T extends Any\](x:T): T =
*)

trait Region extends Equality[\Region\]
    getter toString(): String
    isLocalTo(r: Region): Boolean = false
    opr =(self, other:Region): Boolean = self SEQUIV other
end

object Global extends Region
    getter toString(): String = "Global"
    isLocalTo(_: Region): Boolean = true
end

region(a:Any): Region = Global

here(): Region = Global

(************************************************************
* Equality and ordering
************************************************************)

opr =(a:Any, b:Any):Boolean = a SEQV b

opr =/=(a:Any, b:Any):Boolean = NOT (a=b)

trait Equality[\Self extends Equality[\Self\]\]
        excludes { Number } (** Until Number is an actual type. **)
    opr =(self, other:Self): Boolean
end

(** Total ordering *)

object LexicographicPartialReduction extends Reduction[\Comparison\]
    empty(): Comparison = EqualTo
    join(a:Comparison, b:Comparison):Comparison = a LEXICO b
end

object LexicographicReduction extends Reduction[\TotalComparison\]
    empty(): TotalComparison = EqualTo
    join(a:TotalComparison, b:TotalComparison):TotalComparison = a LEXICO b
end

trait Comparison
        extends { StandardPartialOrder[\Comparison\] }
        comprises { Unordered, TotalComparison }
    getter toString(): String
    opr =(self, other:Comparison): Boolean = false
    opr LEXICO(self, other:Comparison): Comparison = Unordered
    opr INVERSE(self): Comparison
end

(** Unordered is the outcome of a CMP b when a and b are partially
    ordered and no ordering relationship exists between them. **)
object Unordered extends Comparison
    getter toString(): String = "Unordered"
    opr =(self, other:Unordered): Boolean = true
    opr <(self, other:Comparison): Boolean = false
    opr INVERSE(self): Comparison = Unordered
end

trait TotalComparison
        extends { Comparison, StandardTotalOrder[\TotalComparison\] }
        comprises { LessThan, EqualTo, GreaterThan }
    (* We're both a partial order (including Unordered) and a total
       order (TotalComparison alone).  Avoid ambiguity between the
       default definitions of CMP and >=. *)
    opr =(self, other:TotalComparison): Boolean = false
    opr =(self, other:Unordered): Boolean = false
    opr CMP(self, other:Unordered): Boolean = Unordered
    opr <(self, other:Unordered): Boolean = false
    opr >=(self, other:Unordered): Boolean = false
    opr >=(self, other:Comparison): Boolean = NOT (other < self)
    opr LEXICO(self, other:TotalComparison): TotalComparison = self
    opr LEXICO(self, other:()->TotalComparison): TotalComparison = self
    opr INVERSE(self): TotalComparison
end

object LessThan extends TotalComparison
    getter toString(): String = "LessThan"
    opr =(self, other:LessThan): Boolean = true
    opr CMP(self, other:LessThan): Comparison = EqualTo
    opr CMP(self, other:TotalComparison): TotalComparison = GreaterThan
    opr <(self, other:LessThan): Boolean = false
    opr <(self, other:TotalComparison): Boolean = true
    opr INVERSE(self): TotalComparison = GreaterThan
end

object GreaterThan extends TotalComparison
    getter toString(): String = "GreaterThan"
    opr =(self, other:GreaterThan): Boolean = true
    opr CMP(self, other:GreaterThan): Comparison = EqualTo
    opr CMP(self, other:TotalComparison): TotalComparison = LessThan
    opr <(self, other:TotalComparison): Boolean = false
    opr INVERSE(self): TotalComparison = LessThan
end

object EqualTo extends TotalComparison
    getter toString(): String = "EqualTo"
    opr =(self, other:EqualTo): Boolean = true
    opr CMP(self, other:TotalComparison): TotalComparison = INVERSE other
    opr <(self, other:GreaterThan): Boolean = true
    opr <(self, other:TotalComparison): Boolean = false
    opr LEXICO(self, other:TotalComparison): TotalComparison = other
    opr LEXICO(self, other:()->TotalComparison): TotalComparison = other()
    opr INVERSE(self): TotalComparison = EqualTo
end

(** StandardPartialOrder is partial ordering using <,>,<=,>=,=, and CMP.
    This is primarily for floating-point values.  Minimal complete
    definition: CMP or { <, = }. **)
trait StandardPartialOrder[\Self extends StandardPartialOrder[\Self\]\]
        excludes { Number } (** Until Number is an actual type. **)
    opr CMP(self, other:Self): Comparison =
        if self < other then LessThan
        elif other > self then GreaterThan
        elif self = other then EqualTo
        else Unordered
        end
    opr <(self, other:Self): Boolean = LessThan = (self CMP other)
    opr >(self, other:Self): Boolean = other < self
    opr =(self, other:Self): Boolean = EqualTo = (self CMP other)
    opr <=(self, other:Self): Boolean = other >= self
    opr >=(self, other:Self): Boolean = (self = other OR: self > other)
end

(** StandardTotalOrder is the usual total order using <,>,<=,>=,=, and CMP.
    Most values that define a comparison should do so using this.
    Minimal complete definition: either CMP or < (it's advisable to
    define = in the latter case). **)
trait StandardTotalOrder[\Self extends StandardTotalOrder[\Self\]\]
        extends StandardPartialOrder[\Self\]
        excludes { Number } (** Until Number is an actual type. **)
    opr CMP(self, other:Self): Comparison =
        if self < other then LessThan
        elif other < self then GreaterThan
        else EqualTo
        end
    opr >=(self, other:Self): Boolean = NOT (self < other)
end

(** Assertion *)
assert(flag:Boolean): () =
    if NOT flag then
        fail("Assertion failed!")
    end

assert(flag: Boolean, failMsg: String): () =
    if NOT flag then
        fail(failMsg)
    end

assert(x:Any, y:Any, failMsg: Any...): () =
    if x =/= y then
        msg = x " =/= " y "; " (BIG STRING failMsg)
        fail(msg)
    end

(************************************************************
* Generator support
************************************************************)

(** Generator
 *
 * We say an object which extends Generator[\T\] "generates objects of
 * type T."
 *
 * Generators are used to express iteration in Fortress.  Every
 * generated expression in Fortress (eg for loop, comprehension) is
 * desugared into calls to methods of Generator, chiefly the generate
 * method.
 *
 * Every generator has a notion of a "natural order" (which by default is
 * unspecified), which describes the ordering of reduction operations,
 * and also describes the order in which elements are produced by the
 * sequential version of the same generator (given by the seq(self)
 * method).  The default implementation of seq(self) guarantees that these
 * orders will match.
 *
 * Note in particular that the natural order of a Generator must be
 * consistent; that is, if a SEQV b then a and b must yield SEQV
 * elements in the same natural order.  However, note that unless a type
 * specifically documents otherwise, no particular element ordering is
 * guaranteed, nor is it necessary to guarantee that a=b have the same
 * natural order when equality is defined.
 *
 * Note that more complex derived generators are specified further
 * down in the definition of Generator.  These have the same notions
 * of natural order and by default are defined in terms of the
 * generate() method.
 *
 * Minimal complete definition of a Generator is the generate(...) method.
 *)
trait Generator[\E\]
    excludes { Number }
    (** generate is the core of Generator.  It generates elements of
        type E and passes them to the body function.  This generation
        can occur using any mixture of serial and parallel execution
        desired by the author of the generator; by default uses of a
        generator must assume every call to the body occurs in
        parallel.

        The results of generation are combined using the reduction
        object R, which specifies a monoidal operation (associative
        and with an identity).  Body results must be combined together
        following the natural order of the generator.  The author of
        the generator is free to use the identity element anywhere
        desired in this computation, and to group reductions in any
        way desired; if no elements are generated the identity must be
        returned. *)
    generate[\R\](r: Reduction[\R\], body: E->R): R

    (** Transforming generators into new generators *)
    (** map applies a function f to each element generated and yields
        the result.  The resulting generator must have the same
        ordering and cross product properties as the generator from
        which it is derived. *)
    map[\G\](f: E->G): Generator[\G\] = SimpleMappedGenerator[\E,G\](self,f)
    (** seq produces a sequential version of the same generator, in
        which elements are produced in the generator's natural order. *)
    seq(self): SequentialGenerator[\E\] = NaiveSeqGenerator[\E\](self)

    (** Nesting of two generators; the innermost is data-dependent
        upon the outer one.  This is specifically designed to be
        overloaded so that the combined generators have properties
        appropriate to the pairing.  Because of the data dependency
        the natural order of the nesting is the natural order of the
        inner generators, in the natural order the outer nesting
        produces them.  So for example, if we write:
          (0#3).nest[\ZZ32\](\(n:ZZ32):Generator[\ZZ32\] => (n*100#4))
        then the natural order is 0,1,2,3,100,101,102,103,200,201,202,203
     **)
    nest[\G\](f: E -> Generator[\G\]): Generator[\G\] =
        SimpleNestedGenerator[\E,G\](self,f)

    (** Cross product of two generators.  This is specifically
        designed to be overloaded, such that pairs of independent
        generators can be combined to produce a generator which
        possibly interleaves the iteration spaces of the two
        generators.  For example, we might combine (0#16).cross(0#32)
        such that it first splits the second range in half, then the
        first range in half, then the second, and so forth.

        Consider a grid for which the rows are labeled from top to
        bottom with the elements of a in natural order, and the
        columns are labeled from left to right with the elements of g
        in natural order.  Each point in the grid corresponds to a
        pair (a,b) that must be generated by self.cross(g).  In the
        natural order of the cross product, an element must occur
        after those that lie above and to the left of it in the grid.
        By default the natural order of the cross product is
        left-to-right, top to bottom.  Programmers must not rely on
        the default order, except that cross products involving one or
        more sequential generators are always performed in the default
        order.  Note that this means that the following have the same
        natural order:
           seq(a).cross(b)
           a.cross(seq(b))
           seq(a).cross(seq(b))
        But seq(a.cross(b)) may have a different natural order. *)
    cross[\G\](g: Generator[\G\]): Generator[\(E,G)\] =
        SimplePairGenerator[\E,G\](self, g)

    (** Derived generation operations *)
    (** mapReduce is equivalent to generate, but takes an explicit join
        and zero which can have any type.  It still assumes join is
        associative and that zero is the identity of join. **)
    mapReduce[\R\](body: E->R, join:(R,R)->R, zero:R): R =
        generate[\R\](MapReduceReduction[\R\](join,zero), body)
    (** reduce works much like generate or mapReduce,
        but has no body expression **)
    reduce(j:(E,E)->E, z:E):E = mapReduce[\E\](fn (e:E)=>e, j, z)
    reduce(r: Reduction[\E\]):E = generate[\E\](r, fn(e:E)=>e)
    (** loop is a version of generate which discards the void results
        of the body computation.  It is used to translated
        reduction-variable-free for loops. **)
    loop(f:E->()): () = generate[\()\](VoidReduction, f)
    (** Is x generated by this generator? **)
    opr IN(x:E, self) = BIG OR [y <- self] x=y
end

(** The following top-level functions are used as glue in the
    desugaring of generated expressions (comprehensions, BIG
    operators, and loops).  They exist at the top level in part to
    work around shortcomings in the ablity of the Fortress interpreter
    to check types dynamically for anything except top-level
    non-overloaded function calls. **)
__generate[\E,R\](g:Generator[\E\], r: Reduction[\R\], b:E->R): R =
    g.generate[\R\](r,b)

__nest[\E1,E2\](g:Generator[\E1\], f:E1->Generator[\E2\]):Generator[\E2\] =
    g.nest[\E2\](f)

__singleton[\E\](body:E): Generator[\E\] = Just[\E\](body)

__loop[\E,R\](g:Generator[\E\], body:E->R): () = g.loop(body)

__cond[\E,R\](c:Condition[\E\], t:E->R, e:()->R): R = c.cond[\R\](t,e)
__cond[\E\](c:Condition[\E\], t:E->()): () = c.cond[\()\](t, fn () => ())

(** Unlike the user-visible dotted map method, this method is used for
    the internals of comprehension desugaring.  As a result we know
    that its result will immediately be consumed, and we should *not*
    create an intermediate collection if we're passed a
    collection. **)
__map[\E,R\](g:Generator[\E\], f:E->R): Generator[\R\] =
    typecase g of
        SequentialGenerator[\E\] => SimpleMappedSeqGenerator[\E,R\](g,f)
        else => SimpleMappedGenerator[\E,R\](g,f)
    end

trait SequentialGenerator[\E\] extends { Generator[\E\] }
    seq(self) = self
    map[\G\](f: E->G): SequentialGenerator[\G\] =
        SimpleMappedSeqGenerator[\E,G\](self,f)
    (* TODO: make overloaded *)
    nest[\G\](f: E -> Generator[\G\]): Generator[\G\] =
        typecase f of
            E -> SequentialGenerator[\G\] =>
                SimpleNestedSeqGenerator[\E,G\](self,f)
            else => SimpleNestedGenerator[\E,G\](self,f)
        end
    (* TODO: make overloaded *)
    cross[\F\](g:Generator[\F\]): Generator[\(E,F)\] =
        typecase g of
            SequentialGenerator[\F\] =>
                    SimplePairSeqGenerator[\E,F\](self,g)
            else => SimplePairGenerator[\E,F\](self,g)
        end
end

(** A Condition is a Generator that generates 0 or 1 element.
    Conditions can be used as nullary comprehension generators or
    as predicates in an if expression. **)
trait Condition[\E\] extends { ZeroIndexed[\E\], SequentialGenerator[\E\] }
    getter isEmpty(): Boolean = NOT holds()
    getter holds(): Boolean = cond[\Boolean\](fn (_:E):Boolean => true, fn () => false)
    getter size(): ZZ32 = if self then 1 else 0 end
    getter get(): ZZ32 throws NotFound = cond[\E\](identity[\E\], fn () => throw NotFound)
    getter bounds(): FullRange[\ZZ32\] = 0 # |self|
    getter indices(): FullRange[\ZZ32\] = bounds()
    getter indexValuePairs(): Condition[\(ZZ32,E)\] =
        cond[\E\](fn (e:E) => Just[\(ZZ32,E)\](0,e), fn () => Nothing[\(ZZ32,E)\])
    opr |self|: ZZ32 = if self then 1 else 0 end
    opr [i:ZZ32]:E throws NotFound = if i=0 then get() else throw NotFound end
    opr [r:Range[\ZZ32\]]: Condition[\E\] =
        cond[\E\](fn (e:E): Condition[\E\] => do
                    r1 = (0#1)[r]
                    if r1.isEmpty() then Nothing[\E\] else self end
                  end,
                fn (): Condition[\E\] => do r1 = (0#0)[r]; self end)
    getDefault(e:E): E = cond[\E\](identity[\E\], fn () => e)
    cond[\G\](t: E -> G, e: () -> G): G
    generate[\G\](r:Reduction[\G\], body: E -> G): G = cond[\G\](t,fn () => r.empty())

    (** For a Condition, these methods run eagerly. **)
    map[\G\](f: E->G): Condition[\G\] =
        cond[\G\](fn (e:E) => Just[\G\](f(e)), fn () => Nothing[\G\])
    ivmap[\G\](f: (ZZ32,E)->G): Condition[\G\] =
        cond[\G\](fn (e:E) => Just[\G\](f(0,e)), fn () => Nothing[\G\])
    nest[\G\](f: E -> Generator[\G\]): Generator[\G\] =
        cond[\G\](f, fn () => Nothing[\G\])
    cross[\G\](g: Generator[\G\]): Generator[\(E,G)\] =
        cond[\G\](fn (e:E):Generator[\(E,G)\] => g.map[\(E,G)\](fn (g:G):(E,G) => (e,g)),
               fn () => Nothing[\(E,G)\])
    mapReduce[\R\](body: E->R, _:(R,R)->R, zero:R): R =
        cond[\G\](body, fn () => zero)
    reduce(_:(E,E)->E, z:E):E = cond[\E\](identity[\E\], fn ():E => z)
    reduce(r: Reduction[\E\]):E = cond[\E\](identity[\E\], fn ():E => r.empty())
    loop(f:E->()): () = cond[\G\](f,fn ():() => ())
    opr IN(x:E, self):Boolean = cond[\Boolean\](fn (e:E):Boolean => x=e, fn () => false)
end

(** Operations which use generation internally.  Should be functional
    methods of Generator, but that didn't work when last tested. **)

(** IN returns true if any element generated by its second argument is
    = to its first argument.  x NOTIN g is simply NOT (x IN g).
    Unless documented otherwise, this is O(n) for an n-element
    Generator (it simply performs naive matching).  **)
opr NOTIN[\E\](x: E, this: Generator[\E\]): Boolean = NOT (x IN this)

(* seq[\T\](g:Generator[\T\]):SequentialGenerator[\T\] = g.seq() *)
sequential[\T\](g:Generator[\T\]):SequentialGenerator[\T\] = seq(g)


(************************************************************
* The Maybe type, used instead of null
************************************************************)

(* This makes excludes work without where clauses, and allows opr =()
   to remain non-parametric. *)
value trait MaybeType extends Equality[\MaybeType\] excludes Number
        (** \vspace{-4ex} NOT YET: %comprises Maybe[\T\] where [\T\]% *)
    getter holds() : Boolean
    opr =(self, other:MaybeType): Boolean = false
end

(** %Maybe% represents either %Nothing% or a single element of type
    %T% (%Just[\T\]%), which may be retrieved by calling %get%.  An
    object of type %Maybe[\T\]% can be used as a generator; it is either
    empty (%Nothing%) or generates the single element yielded by
    %get%, so there is no issue of canonical order or parallelism.

    Thus, %Just[\T\]% can be used as a single-element generator, and
    %Nothing% can be used as an empty generator. *)
value trait Maybe[\T\]
        extends { MaybeType, Condition[\T\] }
        comprises { Nothing[\T\], Just[\T\] }
end

value object Just[\T\](x:T) extends Maybe[\T\]
    getter size()=1
    getter toString():String = "Just(" x ")"
    getter holds() = true
    getter get() = x
    opr |self| : ZZ32 = 1
    getDefault(_:T): T = x
    cond[\R\](t:T->R, _:()->R): R = t(x)
    generate[\R\](_:Reduction[\R\],m:T->R): R = m(x)
    opr[i:ZZ32]:T = if i=0 then x else fail("Maybe[" i "] nonzero index") end

    map[\G\](f: T->G): Just[\G\] = Just[\G\](f(x))
    cross[\G\](g: Generator[\G\]): Generator[\(T,G)\] =
        g.map[\(T,G)\](fn (e:G):(T,G) => (x,e))

    mapReduce[\R\](m: T->R, _:(R,R)->R, _:R): R = m(x)
    reduce(_:(T,T)->T, _:T):T = x
    reduce(_: Reduction[\T\]):T = x
    loop(f:T->()): () = f(x)
    opr IN(y:T, self): Boolean = x=y
    opr =(self,o:Just[\T\]): Boolean = x=o.get()
end

(* Obviously ought to be a non-parametric singleton when we get where
   clauses working. *)
value object Nothing[\T\] extends Maybe[\T\]
    getter size()=0
    getter holds() = false
    getter get() = throw NotFound
    getter toString():String = "Nothing"
    opr |self| : ZZ32 = 0
    getDefault(t:T):T = t
    cond[\R\](_:T->R, e:()->R): R = e()
    generate[\R\](r:Reduction[\R\],_:T->R): R = r.empty()
    opr[_:ZZ32]: T = fail("Cannot index Nothing")

    map[\G\](f: T->G): Nothing[\G\] = Nothing[\G\]
    cross[\G\](g: Generator[\G\]): Generator[\(T,G)\] = Nothing[\(T,G)\]

    mapReduce[\R\](_: T->R, _:(R,R)->R, z:R): R = z
    reduce(_:(T,T)->T, z:T):T = z
    reduce(r: Reduction[\T\]):T = r.empty()
    loop(f:T->()): () = ()
    opr IN(x:T, self): Boolean = false
    opr =(self,_:Nothing[\T\]) = true
end

(************************************************************
* Exception hierarchy
************************************************************)

trait Exception comprises { UncheckedException, CheckedException }
end

(* Exceptions which are not checked *)

trait UncheckedException extends Exception excludes CheckedException
end

object FailCalled(s:String) extends UncheckedException
  toString(): String = "FAIL: " s
end

object DivisionByZero extends UncheckedException
end

object UnpastingError extends UncheckedException
end

object CallerViolation extends UncheckedException
end

object CalleeViolation extends UncheckedException
end

object TestFailure extends UncheckedException
end

object ContractHierarchyViolation extends UncheckedException
end

object NoEqualityOnFunctions extends UncheckedException
end

object InvalidRange extends UncheckedException
end

object ForbiddenException(chain : Exception) extends UncheckedException
end

(* Should this be called "IndexNotFound" instead? *)
object NotFound extends UncheckedException
end

object IndexOutOfBounds extends UncheckedException
end

object NegativeLength extends UncheckedException
end

object IntegerOverflow extends UncheckedException
end

object RationalComparisonError extends UncheckedException
end

object FloatingComparisonError extends UncheckedException
end

(* Checked Exceptions *)

trait CheckedException extends Exception excludes UncheckedException
end

object CastError extends CheckedException
end

object IOFailure extends CheckedException
end

object MatchFailure extends CheckedException
end

(* SetsNotDisjoint? *)
object DisjointUnionError extends CheckedException
end

object APIMissing extends CheckedException
end

object APINameCollision extends CheckedException
end

object ExportedAPIMissing extends CheckedException
end

object HiddenAPIMissing extends CheckedException
end

object TryAtomicFailure extends CheckedException
end

(* Should take a spawned thread as an argument *)
object AtomicSpawnSynchronization extends {UncheckedException}
end

(************************************************************
* Array support
************************************************************)

oops(s:ZZ32, l:ZZ32, sz:ZZ32, got:ZZ32):() = do
   fail("Index of dimension " s " out of bounds; got " got " which is not in " l "#" sz);
end

trait HasRank extends Equality[\HasRank\] excludes { Number, MaybeType }
  (** \vspace{-4ex} NOT YET: %comprises Array[\T,E,I\] where [\T,E,I\]{ T extends Array[\T,E,I\] }% *)
  rank():ZZ32
  opr =(self, other:HasRank): Boolean = false
end

(* Declared Rank-n-ness *)
trait Rank[\ nat n \] extends HasRank
  rank():ZZ32 = n
end

(* Potemkin exclusion traits.  Really we just want to say that
 * Rank[\n\] excludes Rank[\m\] where { m =/= n }, but we can't yet. *)

trait Rank1 extends { Rank[\1\]} excludes { Rank2, Rank3, Number, String }
end

trait Rank2 extends { Rank[\2\]} excludes { Rank3, Number, String }
end

trait Rank3 extends { Rank[\3\]} excludes { Number, String }
end

(* The trait Indexed_i[\n\] indicates that something has an i^th
 * dimension of size n.  In general anything which extends Indexed_i
 * must also extend Indexed_j for j < i. *)

trait Indexed1[\ nat n \] extends HasRank end

trait Indexed2[\ nat n \] extends HasRank end

trait Indexed3[\ nat n \] extends HasRank end

(** The indexed trait indicates that an object of type T can be
indexed using type I to obtain elements with type E.

An object i that's an instance of Indexed defines three basic things:
  The indexing operator opr [], which must be defined for every instance of
    the type.

  A suite of generators: i.indices generates the index space of the
    array.  i itself generates the values contained at those indices.
    i.indexValuePairs yields pairs of (index,value).  All of these
    share the same natural order.  It is necessary to define one of
    indices() and indexValuePairs(), in addition to generate() (but
    the latter requirement can be dispensed by instead extending
    DelegatedIndexed).

  A set of utility functions, assign, fill, and copy.  Only fill and
    copy need to be defined.
**)
trait Indexed[\E, I\] extends Generator[\E\]
    (** isEmpty indicates whether there are any valid indices.  It is
        defined as size=0 *)
    getter isEmpty(): Boolean = |self| = 0
    (** %size()% is depracated; use %|self|%. *)
    getter size(): ZZ32
    (** bounds() yields a range of indices that are valid for the
        indexed generator. *)
    getter bounds(): FullRange[\I\]
    (** indexValuePairs() generates the elements of the indexed object
        (exactly those elements that are generated by the object itself),
        but each element is paired with its index.  When we obtain
        (i,v) from indexValuePairs we know that:
           self[i] = v
           the i are distinct and i IN bounds()
           stripping away the i yields exactly the results of v <- self
        This generator attempts to follow the structure of the
        underlying object as closely as possible.  *)
    getter indexValuePairs(): Indexed[\(I,E),I\] =
        indices().map[\(I,E)\](fn (i:I): (I,E) => (i,self[i]))
    (** indices() yields the indices corresponding to the elements of
        the indexed object---it corresponds to the index component of
        indexValuePairs().  This may in general be a subset of all the
        valid indices represented by bounds().  This generator
        attempts to follow the structure of the underlying object as
        closely as possible. *)
    getter indices(): Indexed[\I,I\] =
        indexValuePairs().map[\I\](fn (i:I, e:E): I => i)

    (** %|self|% indicates the number of distinct valid indices that may
        be passed to indexing operations. *)
    opr |self| : ZZ32

    (** Indexing.  i IN bounds() must hold. *)
    opr[i:I] : E

    (** Locality of a particular index (NOT of its contents!). *)
    region(i:I): Region = Global

    (** Indexing by ranges.  The results are 0-based when the
        underlying index type has a notion of 0.  This ensures
        consistency of behavior between types such as vectors that
        *only* support 0 indexing and types such as arrays that permit
        other choices of lower bounds.  The easiest way to write the
        index by ranges operation for an instance of Indexed is to
        take advantage of indexing on the ranges themselves by writing
        (bounds())[r] in order to narrow and bounds check the range r
        and obtain a closed range of indices on the underlying
        data. **)
    opr[r:Range[\I\]] : Indexed[\E,I\]
    opr[_:OpenRange[\Any\]] : Indexed[\E,I\] = self[OpenRange[\I\]]

    (** Roughly speaking, ivmap(f) is equivalent to
        indexValuePairs.map(f).  However ivmap function isn't merely a
        convenient shortcut.  It's actually intended to create a copy
        of the underlying indexed structure when that is appropriate.

        The usual map function in Generator should do the same (and
        does for the instances in this library).  Copying can be bad
        for space, but is complexity-preserving if the mapped
        generator is used more than once. **)
    ivmap[\R\](f:(I,E)->R): Indexed[\R, I\] = indexValuePairs().map[\R\](f)
    map[\R\](f:E->R): Indexed[\R, I\] = SimpleMappedIndexed[\E,R,I\](self,f)
end

trait ZeroIndexed[\E\] extends Indexed[\E,ZZ32\]
    bounds(): FullRange[\ZZ32\] = 0 # |self|
    zip[\F\](g:ZeroIndexed[\F\]):ZeroIndexed[\(E,F)\] =
        DefaultZip[\E,F\](self,g)
    (** indexOf(e) returns an index at which e can be found,
        or an index NOTIN bounds() if no such index exists. **)
    indexOf(e:E): ZZ32 =
        label found
            for (i,v) <- indexValuePairs() do
                if v = e then exit found with i end
            end
            -1
        end found
end

object DefaultZip[\E,F\](e:ZeroIndexed[\E\],f:ZeroIndexed[\F\])
        extends { ZeroIndexed[\(E,F)\], DelegatedIndexed[\(E,F),ZZ32\] }
    getter size(): ZZ32 = |self|
    getter indices(): Generator[\ZZ32\] =
        if |e| <= |f| then e.indices() else f.indices() end
    opr |self| : ZZ32 = |e| MIN |f|
    opr[i:ZZ32]:(E,F) = (e[i],f[i])
    opr[r:Range[\ZZ32\]] : ZeroIndexed[\(E,F)\] =
        DefaultZip[\E,F\](e[r],f[r])
end

trait LexicographicOrder[\T extends LexicographicOrder[\T,E\],E\]
        extends { StandardTotalOrder[\T\], ZeroIndexed[\E\] }
    opr CMP(self, other:T): TotalComparison =
        self.zip[\E\](other).generate[\TotalComparison\](
            LexicographicReduction,
            fn(a:E,b:E): TotalComparison => a CMP b) LEXICO
        (|self| CMP |other|)
    (** We give a specialized version of = because it can fail faster
        than CMP by checking sizes early. **)
    opr =(self,other:T): Boolean =
        (|self| = |other|) AND:
          (BIG AND [(a,b)<-self.zip[\E\](other)] a=b)
end

toArray[\E\](g:Indexed[\E,ZZ32\]): Array[\E,ZZ32\] = do
    bnds = g.bounds()
    r = array[\E\](|bnds|).shift(bnds.lower())
    for (i,v) <- g.indexValuePairs() do
        r.init(i,v)
    end
    r
  end

(** DelegatedIndexed is an Indexed generator that has recourse to
    another Indexed generator() internally.  By default this in turn
    is defined in terms of indexValuePairs().  Thus it's only
    necessary to define either indexValuePairs() or indices().

    This class is designed for convenience; it shouldn't be used as a
    type in runing code, but only as a supertype in lieu of Indexed.
**)
trait DelegatedIndexed[\E,I\] extends Indexed[\E,I\]
    getter generator(): Generator[\E\] =
        indexValuePairs().map[\E\](fn (i:I, e:E): E => e)
    getter size(): ZZ32 = |generator()|
    opr |self| : ZZ32 = |generator()|
    generate[\R\](r: Reduction[\R\], body: E->R): R =
        generator().generate[\R\](r,body)
    seq(self): SequentialGenerator[\E\] = seq(generator())
    cross[\G\](g: Generator[\G\]): Generator[\(E,G)\] =
        generator().cross[\G\](g)
    mapReduce[\R\](body: E->R, join:(R,R)->R, zero:R): R =
        generator().mapReduce[\R\](body,join,zero)
    reduce(j:(E,E)->E, z:E):E = generator().reduce(j,z)
    reduce(r: Reduction[\E\]):E = generator().reduce(r)
    loop(f:E->()): () = generator().loop(f)
end

(** The MutableIndexed trait is an indexed trait whose elements can be
    mutated using indexed assignment.  Right now we're using this type
    in a somewhat dangerous way, since eg Array1[\E,b0,s0\] extends
    both Indexed[\Array1[\E,b0,s0\],E,ZZ32\] and
    Indexed[\Array[\E,ZZ32\],E,ZZ32\].  We will need to find a
    solution to this at some point.
**)
trait MutableIndexed[\E, I\]
        extends { Indexed[\E,I\] }
    opr[i:I]:=(v:E) : ()

    (** For Ranged assignment, the extents of r and v.bounds() must
        match, but the lower bounds need not. **)
    opr[r:Range[\I\]]:=(v:Indexed[\E,I\]) : ()
    opr[_:OpenRange[\Any\]]:=(v:Indexed[\E,I\]) : () =
        do self[bounds()] := v end
end

(* Array whose bounds are implicit rather than static, and which may
   be either mutable or immutable. *)
trait ReadableArray[\E,I\]
        extends { HasRank, Indexed[\E,I\] }
        comprises { Array[\E,I\], ImmutableArray[\E,I\] }

    (** Indexed functionality with more specific type information **)
    opr[r:Range[\I\]] : ReadableArray[\E,I\]
    opr[_:OpenRange[\Any\]] : ReadableArray[\E,I\]
    ivmap[\R\](f:(I,E)->R): ReadableArray[\R, I\]
    map[\R\](f:E->R): ReadableArray[\R, I\]

    (** Shift the origin of an array.  This should yield a new view of
        the same array; ie initialization and/or update to either will
        be reflected in the other. **)
    shift(newOrigin:I):ReadableArray[\E,I\]

    (** Initialize element at index i with value v.  This should occur
        once, before any other access or assignment occurs to element
        i.  An error will be signaled if an uninitialized element is
        read or an initialized element is re-initialized. **)
    init(i:I, v:E): ()

    (** Bulk initialization of an array using a given function or value **)
    fill(f:I->E):ReadableArray[\E,I\]
    fill(v:E):ReadableArray[\E,I\]

    copy():ReadableArray[\E,I\]

    (** Create a fresh array structurally identical to the present
        one, but holding elements of type U. **)
    replica[\U\]():ReadableArray[\U,I\]

    opr =(self, other:HasRank): Boolean =
        typecase other of
            ReadableArray[\E,I\] => indices().generate[\Boolean\](AndReduction,
                                           fn (i:I):Boolean => self[i]=other[i])
            else => false
        end

end

trait ImmutableArray[\E,I\] extends { ReadableArray[\E,I\] }
        excludes { Array[\E,I\] }
    opr[r:Range[\I\]] : ImmutableArray[\E,I\]
    opr[_:OpenRange[\Any\]] : ImmutableArray[\E,I\]
    ivmap[\R\](f:(I,E)->R): ImmutableArray[\R, I\]
    map[\R\](f:E->R): ImmutableArray[\R, I\]
    shift(newOrigin:I):ImmutableArray[\E,I\]
    init(i:I, v:E): ()
    fill(f:I->E):ImmutableArray[\E,I\]
    fill(v:E):ImmutableArray[\E,I\]
    copy():ImmutableArray[\E,I\]
    replica[\U\]():ImmutableArray[\U,I\]

    (** Thaw array (return mutable copy) **)
    thaw():Array[\E,I\]
end

trait Array[\E,I\] extends { ReadableArray[\E,I\], MutableIndexed[\E,I\] }
    opr[r:Range[\I\]] : Array[\E,I\]
    opr[_:OpenRange[\Any\]] : Array[\E,I\]
    ivmap[\R\](f:(I,E)->R): Array[\R, I\]
    map[\R\](f:E->R): Array[\R, I\]
    shift(newOrigin:I):Array[\E,I\]
    init(i:I, v:E): ()
    fill(f:I->E):Array[\E,I\]
    fill(v:E):Array[\E,I\]
    assign(f:I->E):Array[\E,I\]
    copy():Array[\E,I\]
    replica[\U\]():Array[\U,I\]

    (** Freeze array (return mutable copy) **)
    freeze(): ImmutableArray[\E,I\]
end

(** Factory for arrays that returns an empty 0-indexed array of a given
    run-time-determined size. **)
array[\E\](x:ZZ32):Array[\E,ZZ32\] = __arr1(__Proxy[\E\],reflect(x))
array[\E\](x:ZZ32,y:ZZ32):Array[\E,(ZZ32,ZZ32)\] =
    __arr2(__Proxy[\E\],reflect(x), reflect(y))
array[\E\](x:ZZ32,y:ZZ32,z:ZZ32):Array[\E,(ZZ32,ZZ32,ZZ32)\] =
    __arr3(__Proxy[\E\],reflect(x), reflect(y), reflect(z))

(* This should be local to array, but we don't support local
   parametric methods in the language spec at all at the moment. *)
__arr1[\E, nat n\](w:__Proxy[\E\],x:N[\n\]):Array1[\E,0,n\] =
    array1[\E,n\]()
__arr2[\E, nat n, nat m\](w:__Proxy[\E\],x:N[\n\],y:N[\m\]):
    Array2[\E,0,n,0,m\] = array2[\E,n,m\]()
__arr3[\E, nat n, nat m, nat p\](w:__Proxy[\E\],x:N[\n\],y:N[\m\],z:N[\p\]):
    Array3[\E,0,n,0,m,0,p\] = array3[\E,n,m,p\]()

(** Factory for immutable arrays that returns an empty 0-indexed array
    of a given run-time-determined size. **)
immutableArray[\E\](x:ZZ32):ImmutableArray[\E,ZZ32\] =
    __imm1(__Proxy[\E\],reflect(x))
immutableArray[\E\](x:ZZ32,y:ZZ32):ImmutableArray[\E,(ZZ32,ZZ32)\] =
    __imm2(__Proxy[\E\],reflect(x), reflect(y))
immutableArray[\E\](x:ZZ32,y:ZZ32,z:ZZ32):ImmutableArray[\E,(ZZ32,ZZ32,ZZ32)\] =
    __imm3(__Proxy[\E\],reflect(x), reflect(y), reflect(z))

(* This should be local to immutableArray, but we don't support local
   parametric methods in the language spec at all at the moment. *)
__imm1[\E, nat n\](w:__Proxy[\E\],x:N[\n\]):ImmutableArray1[\E,0,n\] =
   immutableArray1[\E,n\]()
(*
__imm2[\E, nat n, nat m\](w:__Proxy[\E\],x:N[\n\],y:N[\m\]):
    ImmutableArray2[\E,0,n,0,m\] = immutableArray2[\E,n,m\]()
__imm3[\E, nat n, nat m, nat p\](w:__Proxy[\E\],x:N[\n\],y:N[\m\],z:N[\p\]):
    ImmutableArray3[\E,0,n,0,m,0,p\] = immutableArray3[\E,n,m,p\]()
*)

primitiveArray[\E\](x:ZZ32):Array[\E,ZZ32\] = __parr(__Proxy[\E\],reflect(x))
__parr[\E, nat n\](w:__Proxy[\E\],x:N[\n\]):PrimitiveArray[\E,n\] =
    PrimitiveArray[\E,n\]()

primitiveImmutableArray[\E\](x:ZZ32):ImmutableArray[\E,ZZ32\] =
    __piarr(__Proxy[\E\],reflect(x))
__piarr[\E, nat n\](w:__Proxy[\E\],x:N[\n\]):PrimImmutableArray[\E,n\] =
    PrimImmutableArray[\E,n\]()

(** Array type supporting un-bounds-checked 0-based indexing.
    Useful for the internals of all the array functionality. **)
trait ArrayTypeWith0[\E,I\]
      extends { ReadableArray[\E,I\], DelegatedIndexed[\E,I\] }
    (** 0-based non-bounds-checked indexing **)
    get(i:I): E
    init0(i:I, e:E): ()
    zeroIndices(): FullRange[\I\]
    (** Convert from base()-based indexing to 0-based indexing,
        performing bounds checking. **)
    offset(i:I): I
    (** Convert from 0-based indexing to base()-based indexing **)
    toIndex(i:I): I
end

(** NOTE: StandardImmutableArrayType is a parent of
    StandardMutableArrayType.  It therefore doesn't extend
    ImmutableArrayType as you might expect.  Other types that extend
    it should also extend ImmutableArrayType explicitly. **)
trait StandardImmutableArrayType[\T extends StandardImmutableArrayType[\T,E,I\],E,I\]
        extends { ArrayTypeWith0[\E,I\] }
    (** CONCRETE GETTERS
        Default implementations of getters based on abstract methods
        in StandardArrayType. **)
    getter indices(): Indexed[\I,I\] = bounds()
(* puppy 4
    getter indexValuePairs(): Indexed[\(I,E),I\] =
        zeroIndices().map[\(I,E)\](fn (i:I):(I,E) => (toIndex(i),get(i)))
*)
    getter generator(): Indexed[\E,I\] =
        zeroIndices().map[\E\](fn (i:I):E => get(i))

    (** CONCRETE METHODS
        Default implementations of most array stuff based on the above.
        The things we can't provide are anything involving replica. **)
    opr[i:I]:E = get(offset(i))
    init(i:I, v:E) = init0(offset(i),v)

    generate[\R\](r: Reduction[\R\], body: E->R): R =
        generator().generate[\R\](r,body)
    seq(self): SequentialGenerator[\E\] = seq(generator())

    fill(f:I->E):T = do
        for i <- zeroIndices() do init0(i,f(toIndex(i))) end
        self
      end
    fill(v:E):T = do
        for i <- zeroIndices() do init0(i,v) end
        self
      end

    copy():T
end


trait StandardMutableArrayType[\T extends StandardMutableArrayType[\T,E,I\],E,I\]
    extends { StandardImmutableArrayType[\T,E,I\], Array[\E,I\] }
    (** 0-based non-bounds-checked indexing **)
    put(i:I, e:E): ()
    opr[i:I]:=(v:E):() = put(offset(i),v)

    opr[r:Range[\I\]]:=(a:Indexed[\E,I\]):() = do
        a0 = a[a.bounds()]      (* Make a have 0 origin *)
        s0 = self[r]            (* Make self have 0 origin *)
        if a0.bounds() = s0.bounds() then
            for (i,v) <- a.indexValuePairs() do
                s0.put(i,v)
            end
        else
            fail("Can't assign indexed with bounds " a.bounds()
                 "\n to differently-sized subarray " self.bounds())
        end
      end

    assign(v:T):T = do
        for i <- zeroIndices() do put(i,v.get(i)) end
        self
      end
    assign(f:I->E):T = do
        for i <- zeroIndices() do put(i,f(toIndex(i))) end
        self
      end
end

(* Canonical partitioning of a positive number x into two pieces.  If
     (a,b) = partition(n)
   and n > 0 then 0 < a <= b,  n = a + b.
   As it turns out we choose a to be the largest power of 2 < n.
*)
partition(x:ZZ32):(ZZ32,ZZ32) = do
    m = partitionL(x)
    (m,x-m)
  end

(** A ReadableArray1[\T,b0,s0\] is an arbitrary 1-dimensional array
    whose s0 elements are of type T, and whose lowest index is b0.

    The natural order of all generators is from b0 to b0+s0-1. **)
trait ReadableArray1[\T, nat b0, nat s0\]
        extends { Indexed1[\s0\], Rank1, ArrayTypeWith0[\T,ZZ32\] }
        comprises { ImmutableArray1[\T,b0,s0\], Array1[\T,b0,s0\] }
    getter size():ZZ32 = s0
    getter bounds():ScalarRange[\ZZ32\] = b0#s0
    getter mutability():String
    getter toString() = do
        r = "[" b0 "#" s0 "]" mutability() " = ["
        if s0=0 then
            r "]"
        else
            f(i:ZZ32,t:T):String = " " t
            j(a:String,b:String):String = a b
            r indexValuePairs().mapReduce[\String\](f,j,"") " ]"
        end
      end

    opr |self| : ZZ32 = s0

    subarray[\nat b, nat s, nat o\]():ReadableArray1[\T, b, s\]

    (* Offset converts from b0 indexing to 0 indexing,
       bounds checking en route *)
    offset(i:ZZ32):ZZ32 = do
        r = i - b0
        if NOT (0 <= r < s0) then oops(1, b0, s0, i) end
        r
    end
    toIndex(i:ZZ32):ZZ32 = i + b0

    zeroIndices(): ScalarRange[\ZZ32\] = 0#s0
end

trait ImmutableArray1[\T, nat b0, nat s0\]
    extends { StandardImmutableArrayType[\ImmutableArray1[\T,b0,s0\],T,ZZ32\],
              ImmutableArray[\T,ZZ32\], ReadableArray1[\T,b0,s0\] }
    getter mutability():String = "(immutable)"
    shift(o:ZZ32): ImmutableArray[\T,ZZ32\] =
        if o=0 then
            self
        else
            __subarrayI(self,reflect(o),N[\s0\],N[\b0\])
        end

    opr[r: Range[\ZZ32\]] : ImmutableArray[\T,ZZ32\] = do
        r' = (bounds())[r]
        z = N[\0\]
        s = reflect( |r'| )
        l = reflect(r'.lower())
        __subarrayI(self,z,s,l)
      end
    opr[_:OpenRange[\ZZ32\]] : ImmutableArray1[\T,0,s0\] =
        subarray[\0,s0,0\]()
    opr[_:OpenRange[\Any\]] : ImmutableArray1[\T,0,s0\] =
        subarray[\0,s0,0\]()

    (** subarray selects a subarray of this array based on static parameters.
        b#s are the new bounds of the array; o is
        the index of the subarray within the current array. **)
    subarray[\nat b, nat s, nat o\]():ImmutableArray1[\T, b, s\] = do
        boundsCheck = (bounds())[o#s]
        __ImmutableSubArray1[\T,b,s,b0,s0\](self,o-b0,1)
    end

    (* the replica method returns a replica of the array (similar layout
       etc.) but with a different element type. *)
    replica[\U\]():ImmutableArray1[\U,b0,s0\] = __immutableFactory1[\U,b0,s0\]()

    copy():ImmutableArray1[\T,b0,s0\] =
        replica[\T\]().fill(fn (i:ZZ32):T => get(i-b0))

    thaw():Array1[\T,b0,s0\] =
        __builtinFactory1[\T,b0,s0\]().fill(fn (i:ZZ32):T => get(i-b0))

    map[\R\](f:T->R): ImmutableArray1[\R,b0,s0\] =
        replica[\R\]().fill(fn (i:ZZ32):R => f(get(i-b0)))
    ivmap[\R\](f:(ZZ32,T)->R): ImmutableArray1[\R,b0,s0\] =
        replica[\R\]().fill(fn (i:ZZ32):R => f(i,get(i-b0)))
end

(** Array1[\T,b0,s0\] is a 1-dimension array whose s0 elements are of
    type T, and whose lowest index is b0. **)
trait Array1[\T, nat b0, nat s0\]
    extends { ReadableArray1[\T,b0,s0\],
              StandardMutableArrayType[\Array1[\T,b0,s0\],T,ZZ32\] }
    excludes {Number, String}

    getter mutability():String = ""

    shift(o:ZZ32): Array[\T,ZZ32\] =
        if o=0 then
            self
        else
            __subarray(self,reflect(o),N[\s0\],N[\b0\])
        end

    opr[r: Range[\ZZ32\]] : Array[\T,ZZ32\] = do
        r' = (bounds())[r]
        z = N[\0\]
        s = reflect( |r'| )
        l = reflect(r'.lower())
        __subarray(self,z,s,l)
      end
    opr[_:OpenRange[\ZZ32\]] : Array1[\T,0,s0\] =
        subarray[\0,s0,0\]()
    opr[_:OpenRange[\Any\]] : Array1[\T,0,s0\] =
        subarray[\0,s0,0\]()

    (** subarray selects a subarray of this array based on static parameters.
        b#s are the new bounds of the array; o is
        the index of the subarray within the current array. **)
    subarray[\nat b, nat s, nat o\]():Array1[\T, b, s\] = do
      boundsCheck = (bounds())[o#s]
      __SimpleSubArray1[\T,b,s,b0,s0\](self,o-b0,1)
    end

    (* the replica method returns a replica of the array (similar layout
       etc.) but with a different element type. *)
    replica[\U\]():Array1[\U,b0,s0\] = __builtinFactory1[\U,b0,s0\]()

    copy():Array1[\T,b0,s0\] =
        replica[\T\]().fill(fn (i:ZZ32):T => get(i-b0))

    freeze():ImmutableArray1[\T,b0,s0\] =
        __immutableFactory1[\T,b0,s0\]().fill(fn (i:ZZ32):T => get(i-b0))

    map[\R\](f:T->R): Array1[\R,b0,s0\] =
        replica[\R\]().fill(fn (i:ZZ32):R => f(get(i-b0)))
    ivmap[\R\](f:(ZZ32,T)->R): Array1[\R,b0,s0\] =
        replica[\R\]().fill(fn (i:ZZ32):R => f(i,get(i-b0)))
end

(* WORK AROUND absence of type inference in method calls. *)
__subarray[\T, nat b0, nat s0, nat b, nat s, nat o\]
          (it:Array1[\T,b0,s0\],
           _:N[\b\],_:N[\s\],_:N[\o\]):Array1[\T,b,s\] =
    it.subarray[\b,s,o\]()

__subarrayI[\T, nat b0, nat s0, nat b, nat s, nat o\]
          (it:ImmutableArray1[\T,b0,s0\],
           _:N[\b\],_:N[\s\],_:N[\o\]):ImmutableArray1[\T,b,s\] =
    it.subarray[\b,s,o\]()


(** A 1-D subarray of an Array1.
    b_a#s_a is the underlying array's bounds; b0#s0 is the
    result bounds.  o0 is the starting offset in the underlying array,
    defined in 0-indexed space.  m0 the stride within that array.
    Invariant: (s0-1) m0 + o0 - b_a) < s_a *)
object __SimpleSubArray1[\T, nat b0, nat s0, nat b_a, nat s_a\]
       (arr:Array1[\T,b_a,s_a\], o0:ZZ32, m0:ZZ32)
       extends Array1[\T, b0, s0\]
    index(i:ZZ32):T = i m0 + o0
    get(i:ZZ32):T = arr.get(index(i))
    put(i:ZZ32,v:T): () = arr.put(index(i),v)
    init0(i:ZZ32,v:T): () = arr.init0(index(i),v)
    subarray[\nat b, nat s, nat o\]():Array1[\T, b, s\] = do
        boundsCheck = (bounds())[o#s]
        o_n : ZZ32 = o - b0
        __SimpleSubArray1[\T, b, s, b_a, s_a\](arr, index(o_n), m0)
      end
end

(** The same as above, but immutable. **)
object __ImmutableSubArray1[\T, nat b0, nat s0, nat b_a, nat s_a\]
       (arr:ImmutableArray1[\T,b_a,s_a\], o0:ZZ32, m0:ZZ32)
       extends ImmutableArray1[\T, b0, s0\]
    index(i:ZZ32):T = i m0 + o0
    get(i:ZZ32):T = arr.get(index(i))
    put(i:ZZ32,v:T): () = arr.put(index(i),v)
    init0(i:ZZ32,v:T): () = arr.init0(index(i),v)
    subarray[\nat b, nat s, nat o\]():ImmutableArray1[\T, b, s\] = do
        boundsCheck = (bounds())[o#s]
        o_n : ZZ32 = o - b0
        __ImmutableSubArray1[\T, b, s, b_a, s_a\](arr, index(o_n), m0)
      end
end

trait Vector[\T extends Number, nat s0\] extends Array1[\T,0,s0\]
    add(v:Vector[\T,s0\]): Vector[\T,s0\] =
        ivmap[\T\](fn (i:ZZ32, e: T):T => e + v.get(i))
    subtract(v:Vector[\T,s0\]): Vector[\T,s0\] =
        ivmap[\T\](fn (i:ZZ32, e: T):T => e - v.get(i))
    negate(): Vector[\T,s0\] = map[\T\](fn (e: T):T => - e)
    scale(t: T): Vector[\T,s0\] = map[\T\](fn (v) => t v)
    pmul(v: Vector[\T,s0\]): Vector[\T,s0\] =
        ivmap[\T\](fn (i:ZZ32, e: T):T => e v.get(i))
    dot(v: Vector[\T,s0\]): T =
        SUM [(i,me_i)<-indexValuePairs()] me_i v.get(i)
end

object __DefaultVector[\T, nat s0\]() extends Vector[\T,s0\]
  mem: PrimitiveArray[\T,s0\] = PrimitiveArray[\T,s0\]()
  get(i:ZZ32):T = mem.get(i)
  put(i:ZZ32, v:T) = mem.put(i,v)
  init0(i:ZZ32, v:T) = mem.init0(i,v)
  replica[\U\]() = array1[\T,s0\]()
end

(* builtinFactory1 must be a non-overloaded 0-parameter factory for
   1-D arrays.  The type parameters are enshrined in LHSEvaluator.java
   and NonPrimitive.java; the factory name is enshrined in
   WellKnownNames.java.  There must be some factory, named in this
   file, with this type signature.  A similar thing is true for
   K-dimensional array types. *)
__builtinFactory1[\T, nat b0, nat s0\]():Array1[\T,b0,s0\] = do
    r = array1[\T,s0\]()
    typecase _ = N[\b0\] of
        N[\0\] => r
        else => r.subarray[\b0,s0,0\]()
    end
  end

(* immutableFactory1 is a non-overloaded 0-parameter factory for
   0-indexed 1-D arrays.  It is also mentioned in WellKnownNames as it
   is used to allocate storage for varargs. *)
__immutableFactory1[\T, nat b0, nat s0\]():Array1[\T,b0,s0\] = do
    r = immutableArray1[\T,s0\]()
    typecase _ = N[\b0\] of
        N[\0\] => r
        else => r.subarray[\b0,s0,0\]()
    end
  end

(* TODO: fix when Number is covariant. *)
array1[\T, nat s0\]():Array1[\T,0,s0\] =
    typecase _ = __Proxy[\T\] of
        __Proxy[\ZZ32\] => vector[\T,s0\]()
        __Proxy[\ZZ64\] => vector[\T,s0\]()
        __Proxy[\Integral\] => vector[\T,s0\]()
        __Proxy[\RR64\] => vector[\T,s0\]()
        __Proxy[\Number\] => vector[\T,s0\]()
        else => PrimitiveArray[\T,s0\]()
    end
array1[\T, nat s0\](v:T):Array1[\T,0,s0\] = array1[\T,s0\]().fill(v)
array1[\T, nat s0\](f:ZZ32->T):Array1[\T,0,s0\] = array1[\T,s0\]().fill(f)

immutableArray1[\T, nat s0\](): ImmutableArray1[\T,0,s0\] =
    PrimImmutableArray[\T,s0\]()

(* vector is the same as array1, but specialized to numeric type arguments *)
vector[\T extends Number, nat s0\]():Vector[\T,s0\] = __DefaultVector[\T,s0\]()
vector[\T extends Number, nat s0\](v:T):Vector[\T,s0\] =
    vector[\T,s0\]().fill(v)
vector[\T extends Number, nat s0\](f:ZZ32->T):Vector[\T,s0\] =
    vector[\T,s0\]().fill(f)


opr +[\ T extends Number, nat n, nat m \]
     (me : Vector[\T,n\], other : Vector[\T,n\]):Vector[\T,n\] = me.add(other)

opr -[\ T extends Number, nat n, nat m \]
     (me : Vector[\T,n\], other : Vector[\T,n\]):Vector[\T,n\] =
    me.subtract(other)

opr -[\ T extends Number, nat n, nat m \]
     (me : Vector[\T,n\]):Vector[\T,n\] = me.negate()

pmul[\ T extends Number, nat k \]
    (a : Vector[\T,k\], b : Vector[\T,k\]):Vector[\T,k\] = a.pmul(b)

opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (me : Vector[\T,n\], other : Vector[\T,n\]):T = me.dot(other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (me : Vector[\T,n\], other : Vector[\T,n\]):T = me.dot(other)

opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (me : Vector[\T,n\], other : T) : Vector[\T,n\] = me.scale(other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (me : Vector[\T,n\], other : T) : Vector[\T,n\] = me.scale(other)

opr DOT[\ T extends Number, nat n, nat m, nat p \]
        (other : T, me : Vector[\T,n\]) : Vector[\T,n\] = me.scale(other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (other : T, me : Vector[\T,n\]) : Vector[\T,n\] = me.scale(other)

squaredNorm[\T extends Number, nat s0\](a:Vector[\T,s0\]):T = a.dot(a)

opr ||[\ T extends Number, nat k \]me : Vector[\T,k\]|| : RR64 = SQRT squaredNorm(me)

(** Array2[\T,b0,s0,b1,s1\] is the type of 2-dimensional arrays of
    element type T, with size s0 in the first dimension and s1 in the
    second dimension and lowest index (b0,b1).  Natural order for all
    generators in each dimension is from b to b+s-1; the overall order
    of elements need only be consistent with the cross product of
    these orderings (see Generator.cross()). **)
trait Array2[\T, nat b0, nat s0, nat b1, nat s1\]
    extends { Indexed1[\s0\], Indexed2[\s1\], Rank2,
              StandardMutableArrayType[\Array2[\T,b0,s0,b1,s1\],T,(ZZ32,ZZ32)\] }
    excludes { Number, String }
  getter size():ZZ32 = s0 s1
  getter bounds():Tuple2Range[\ZZ32,ZZ32\] = (b0,b1)#(s0,s1)
  getter toString() = do
    r : String := "[" b0 "#" s0 "," b1 "#" s1 "] ="
    row(i) =
      for j <- seq(0#s1) do
         r := r " " get(i,j)
      end
    if s0 = 0 then
      r " []"
    else
      r := r "\n["
      row(0)
      for i <- seq(1#(s0-1)) do
        r := r "\n "
        row(i)
      end
      r " ]"
    end
  end
  opr |self| : ZZ32 = s0 s1
  (* Translate from b0,b1-indexing to 0-indexing, checking bounds. *)
  offset(t:(ZZ32,ZZ32)):(ZZ32,ZZ32) = do
    (a0,a1) = t
    c0 = a0 - b0
    c1 = a1 - b1
    if NOT (0 <= c0 < s0) then
        oops(1,b0,s0,a0)
    elif NOT (0 <= c1 < s1) then
        oops(2,b1,s1,a1)
    else
        (c0,c1)
    end
  end
  toIndex(t:(ZZ32,ZZ32)):(ZZ32,ZZ32) = do (a0,a1)=t; (a0+b0,a1+b1) end
  opr[x:ZZ32,y:ZZ32]:=(v:T):() = do self[ (x,y) ] := v end
  opr[r:Range[\(ZZ32,ZZ32)\]]: Array[\T,(ZZ32,ZZ32)\] = do
      r' = (bounds())[r]
      (z0,z1) = r'.extent()
      (l0,l1) = r'.lower()
      __subarray(N[\0\],reflect(z0), N[\0\],reflect(z1),
                 reflect(l0),reflect(l1))
    end
  opr[_:OpenRange[\ZZ32\]] : Array2[\T,0,s0,0,s1\] =
      subarray[\0,s0,0,s1,0,0\]()
  opr[_:OpenRange[\Any\]] : Array2[\T,0,s0,0,s1\] =
      subarray[\0,s0,0,s1,0,0\]()
  shift(t:(ZZ32,ZZ32)): Array[\T,(ZZ32,ZZ32)\] = do
      (o0,o1)=t
      if o0=0 AND o1=0 then
          self
      else
          __subarray(reflect(o0),N[\s0\], reflect(o1),N[\s1\], N[\b0\],N[\b1\])
      end
    end

  (** 2-D subarray given static subarray parameters.
      (bo1,bo2)#(so1,so2) are output bounds.
      The result is the subarray starting at (o0,o1) in the original array.
   **)
  subarray[\nat bo0, nat so0, nat bo1, nat so1, nat o0, nat o1\]
          (): Array2[\T,bo0,so0,bo1,so1\] = do
      boundsCheck = (bounds())[ (o0,o1)#(so0,so1) ]
      SubArray2[\T,bo0,so0,bo1,so1,b0,s0,b1,s1\](self,1,o0,1,o1)
    end

  __subarray[\nat bo0, nat so0, nat bo1, nat so1, nat o0, nat o1\]
          (_:N[\bo0\],_:N[\so0\],_:N[\bo1\],_:N[\so1\],
           _:N[\o0\],_:N[\o1\]): Array2[\T,bo0,so0,bo1,so1\] =
      subarray[\bo0,so0,bo1,so1,o0,o1\]()

  zeroIndices():Tuple2Range[\ZZ32,ZZ32\] = (0,0)#(s0,s1)

  replica[\U\]():Array2[\U,b0,s0,b1,s1\] =
      __builtinFactory2[\U,b0,s0,b1,s1\]()
  copy():Array2[\T,b0,s0,b1,s1\] =
      self.replica[\T\]().fill(fn (i:ZZ32,j:ZZ32):T => get(i-b0,j-b1))
  put(t:(ZZ32, ZZ32), v:T) : ()
  get(t:(ZZ32, ZZ32)):T
  t():Array2[\T,b1,s1,b0,s0\] = TransposedArray2[\T,b1,s1,b0,s0\](self)
  (* Copied here for better return type information. *)
  map[\R\](f:T->R): Array2[\R,b0,s0,b1,s1\] =
      replica[\R\]().fill(fn (i:ZZ32,j:ZZ32):R => f(get(i-b0,j-b1)))
  ivmap[\R\](f:((ZZ32,ZZ32),T)->R): Array2[\R,b0,s0,b1,s1\] =
      replica[\R\]().fill(fn (i:ZZ32,j:ZZ32):R => f((i,j),get(i-b0,j-b1)))

  freeze():ImmutableArray[\T,(ZZ32,ZZ32)\] = fail("Freeze not defined yet!")
end

(** Default array is column-major, but we could switch it. **)
object __DefaultArray2[\T, nat b0, nat s0, nat b1, nat s1\]()
        extends Array2[\T, b0, s0, b1, s1\]
    mem:PrimitiveArray[\T, (s0 s1) \] = PrimitiveArray[\T, (s0 s1) \]()
    init0(t:(ZZ32,ZZ32), v:T) : () = do (i,j)=t; mem.init0(i s1 + j, v) end
    put(t:(ZZ32,ZZ32), v:T) : () = do (i,j)=t; mem.put(i s1 + j, v) end
    get(t:(ZZ32,ZZ32)):T = do (i,j)=t; mem.get(i s1 + j) end
end

(** Transposes the index of the underlying array mem, and transposes
    its natural order as well. **)
object TransposedArray2[\T, nat b0, nat s0, nat b1, nat s1\]
                       (mem:Array2[\T,b1,s1,b0,s0\])
    extends Array2[\T, b0, s0, b1, s1\]
  replica[\U\]():Array2[\U,b0,s0,b1,s1\] = mem.replica[\U\]().t()

  init0(t:(ZZ32,ZZ32), v:T) : () = do (i,j)=t; mem.init0((j,i),v) end
  put(t:(ZZ32,ZZ32), v:T) : () = do (i,j)=t; mem.put((j,i),v) end
  get(t:(ZZ32,ZZ32)):T = do (i,j)=t; mem.get(j,i) end
  t() = mem
end

(** Simple 2-D subarray, used when we have no other knowledge of the
    underlying structure.  If we're on top of a PrimitiveArray we can
    really do much better than this.
    (b0,b1)#(s0,s1) are the bounds of the subarray.
    (bu0,bu1)#(su0,su1) are the bounds of the underlying array.
    m_i, o_i are multiplier and offset (0-based) of dimension i.
**)
object SubArray2[\T, nat b0, nat s0, nat b1, nat s1,
                     nat bu0, nat su0, nat bu1, nat su1\]
                (mem: Array2[\T,bu0,su0,bu1,su1\],
                 m0:ZZ32, o0:ZZ32, m1:ZZ32, o1:ZZ32)
        extends Array2[\T,b0,s0,b1,s1\]
    index(a0:ZZ32, a1:ZZ32): (ZZ32,ZZ32) = (m0 a0 + o0, m1 a1 + o1)
    init0(t:(ZZ32,ZZ32), v:T): () = mem.init0(index(t),v)
    put(t:(ZZ32,ZZ32), v:T): () = mem.put(index(t),v)
    get(t:(ZZ32,ZZ32)): T = mem.get(index(t))
end

trait Matrix[\T extends Number, nat s0, nat s1\] extends Array2[\T, 0, s0, 0, s1\]
    add(v:Matrix[\T,s0,s1\]): Matrix[\T,s0,s1\] =
        ivmap[\T\](fn (i:(ZZ32,ZZ32),e:T):T => e + v.get(i))
    subtract(v:Matrix[\T,s0,s1\]): Matrix[\T,s0,s1\] =
        ivmap[\T\](fn (i:(ZZ32,ZZ32),e:T):T => e - v.get(i))
    negate(): Matrix[\T,s0,s1\] = map[\T\](fn (e:T):T => - e)
    scale(t: T): Matrix[\T,s0,s1\] = map[\T\](fn (e:T):T => t e)
    mul[\ nat s2 \](other: Matrix[\T,s1,s2\]): Matrix[\T,s0,s2\] = do
        res = matrix[\T,s0,s2\]()
        mma(a:ZZ32,i:ZZ32,b:ZZ32,j:ZZ32,c:ZZ32,k:ZZ32):() =
            if k>=i AND k>=j then
              if k=1 then
                pr : T = get(a,b) other.get(b,c)
                (* If this were atomic, we could parallelize j-partition. *)
                res.put((a,c), res.get(a,c) + pr)
              else
                (k0,k1) = partition(k)
                (mma(a,i,b,j,c,k0),mma(a,i,b,j,c+k0,k1))
              end
            elif j>=i then
                (j0,j1) = partition(j)
                mma(a,i,b,j0,c,k)
                mma(a,i,b+j0,j1,c,k)
            else
                (i0,i1) = partition(i)
                (mma(a,i0,b,j,c,k),mma(a+i0,i1,b,j,c,k))
            end
        mm(a:ZZ32,i:ZZ32,b:ZZ32,j:ZZ32,c:ZZ32,k:ZZ32):() =
            if k>=i AND k>=j then
              if k=1 then
                res.put((a,c), get(a,b) other.get(b,c))
              else
                (k0,k1) = partition(k)
                (mm(a,i,b,j,c,k0),mm(a,i,b,j,c+k0,k1))
              end
            elif j>=i then
                (j0,j1) = partition(j)
                mm(a,i,b,j0,c,k)
                mma(a,i,b+j0,j1,c,k)
            else
                (i0,i1) = partition(i)
                (mm(a,i0,b,j,c,k),mm(a+i0,i1,b,j,c,k))
            end
        if s0=0 OR s1=0 OR s2=0 then
          res
        else
          mm(0,s0,0,s1,0,s2)
          res
        end
      end
    rmul(v: Vector[\T,s1\]): Vector[\T,s0\] = do
        row(i:ZZ32):T =
            SUM[(j,v_j)<-v.indexValuePairs()] get(i,j) v_j
        vector[\T,s0\]().fill(row)
      end
    lmul(v: Vector[\T,s0\]): Vector[\T,s1\] = do
        col(i:ZZ32):T =
            SUM[(j,v_j)<-v.indexValuePairs()] v_j get(j,i)
        vector[\T,s1\]().fill(col)
      end
    t(): Matrix[\T,s1,s0\] = TransposedMatrix[\T,s1,s0\](self)
end

(* Default matrix should match default array in column vs row-major. *)
object __DefaultMatrix[\T, nat s0, nat s1\]()
    extends Matrix[\T, s0, s1\]
  mem:PrimitiveArray[\T, (s0 s1) \] = PrimitiveArray[\T, (s0 s1) \]()
  init0(t:(ZZ32,ZZ32), v:T) : () = do (i,j)=t; mem.init0(i s1 + j, v) end
  put(t:(ZZ32,ZZ32), v:T) : () = do (i,j)=t; mem.put(i s1 + j, v) end
  get(t:(ZZ32,ZZ32)):T = do (i,j)=t; mem.get(i s1 + j) end
end

object TransposedMatrix[\T, nat s0, nat s1\](mem:Matrix[\T,s1,s0\])
        extends Matrix[\T, s0, s1\]
    replica[\U\]():Array2[\U,0,s0,0,s1\] = mem.replica[\U\]().t()

    init0(t:(ZZ32,ZZ32), v:T) : () = do (i,j)=t; mem.init0((j,i),v) end
    put(t:(ZZ32,ZZ32), v:T) : () = do (i,j)=t; mem.put((j,i),v) end
    get(t:(ZZ32,ZZ32)):T = do (i,j)=t; mem.get(j,i) end
    t(): Matrix[\T,s1,s0\] = mem
    add(v:TransposedMatrix[\T,s0,s1\]): Matrix[\T,s0,s1\] = mem.add(v.t()).t()
    subtract(v:Matrix[\T,s0,s1\]): Matrix[\T,s0,s1\] = mem.subtract(v.t()).t()
    negate(): Matrix[\T,s0,s1\] = mem.negate().t()
    scale(f: T): Matrix[\T,s0,s1\] = mem.scale(f).t()
    rmul(v: Vector[\T,s1\]): Vector[\T,s0\] = mem.lmul(v)
    lmul(v: Vector[\T,s0\]): Vector[\T,s1\] = mem.rmul(v)
(*  Can't overload generic methods yet, but this is preferable.
    mul[\nat s2\](v:TransposedMatrix[\T,s1,s2\]): Matrix[\T,s0,s2\] =
        v.t().mul(mem).t()
*)
end

__builtinFactory2[\T,nat b0,nat s0,nat b1,nat s1\]():Array2[\T,b0,s0,b1,s1\] =
    if b0=0 AND b1=0 then
        array2[\T,s0,s1\]()
    else
        __DefaultArray2[\T,b0,s0,b1,s1\]()
    end

(* array2 is a factory for 0-based 2-D arrays. *)
(* TODO: fix when Number is covariant. *)
array2[\T, nat s0, nat s1\]():Array2[\T,0,s0,0,s1\] =
    typecase _ = __Proxy[\T\] of
        __Proxy[\ZZ32\] => matrix[\T,s0,s1\]()
        __Proxy[\ZZ64\] => matrix[\T,s0,s1\]()
        __Proxy[\Integral\] => matrix[\T,s0,s1\]()
        __Proxy[\RR64\] => matrix[\T,s0,s1\]()
        __Proxy[\Number\] => matrix[\T,s0,s1\]()
        else => __DefaultArray2[\T,0,s0,0,s1\]()
    end
array2[\T, nat s0, nat s1\](v:T):Array2[\T,0,s0,0,s1\] =
  array2[\T,s0,s1\]().fill(v)
array2[\T, nat s0, nat s1\](f:(ZZ32,ZZ32)->T):Array2[\T,0,s0,0,s1\] =
  array2[\T,s0,s1\]().fill(f)

(* matrix is the same as array1, but specialized to numeric type
   arguments, except that the default value (if given) is used to
   construct a multiple of the identity matrix. *)
matrix[\T extends Number, nat s0, nat s1\]():Matrix[\T,s0,s1\] =
  __DefaultMatrix[\T,s0,s1\]()
matrix[\T extends Number, nat s0, nat s1\](v:T):Matrix[\T,s0,s1\] =
  array2[\T,s0,s1\]().fill(fn (x:ZZ32,y:ZZ32):T => if x=y then v else 0 end)

opr +[\ T extends Number, nat n, nat m \]
     (me:Matrix[\T,n,m\], other:Matrix[\T,n,m\]): Matrix[\T,n,m\] =
        me.add(other)

opr -[\ T extends Number, nat n, nat m \]
     (me:Matrix[\T,n,m\], other:Matrix[\T,n,m\]) : Matrix[\T,n,m\] =
        me.subtract(other)

opr -[\ T extends Number, nat n, nat m \]
     (me:Matrix[\T,n,m\]): Matrix[\T,n,m\] =
        me.negate()

(* Matrix multiplication; used to use a cache-oblivious algorithm, but
   we ran into trouble due to lack of support for atomic increment of
   matrix elements. *)
opr DOT[\ T extends Number, nat n, nat m, nat p\]
       (me:Matrix[\T,n,m\], other:Matrix[\T,m,p\]): Matrix[\T,n,p\] =
        me.mul[\p\](other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p\]
     (me:Matrix[\T,n,m\], other:Matrix[\T,m,p\]): Matrix[\T,n,p\] =
        me.mul[\p\](other)


(* matrix-vector multiplication *)
opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (me:Matrix[\T,n,m\], v:Vector[\T,m\]):Vector[\T,n\] = me.rmul(v)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (me:Matrix[\T,n,m\], v:Vector[\T,m\]):Vector[\T,n\] = me.rmul(v)

(* vector-matrix multiplication *)
opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (v:Vector[\T,n\], me:Matrix[\T,n,m\]):Vector[\T,m\] = me.lmul(v)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (v:Vector[\T,n\], me:Matrix[\T,n,m\]):Vector[\T,m\] = me.lmul(v)

opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (me : Matrix[\T,n,m\], other : T) : Matrix[\T,n,m\] = me.scale(other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (me : Matrix[\T,n,m\], other : T) : Matrix[\T,n,m\] = me.scale(other)

opr DOT[\ T extends Number, nat n, nat m, nat p \]
       (other : T, me : Matrix[\T,n,m\]) : Matrix[\T,n,m\] = me.scale(other)

opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (other : T, me : Matrix[\T,n,m\]) : Matrix[\T,n,m\] = me.scale(other)

(** Array3[\T,b0,s0,b1,s1,b2,s2\] is the type of 3-dimensional arrays
    of element type T, with size s_i in the i^th dimension and lowest
    index (b0,b1,b2).  Natural order for all generators in each
    dimension is from b to b+s-1; the overall order of elements need
    only be consistent with the cross product of these orderings (see
    Generator.cross()). **)
trait Array3[\T, nat b0, nat s0, nat b1, nat s1, nat b2, nat s2\]
    extends { Indexed1[\s0\], Indexed2[\s1\], Indexed3[\s2\], Rank3,
              StandardMutableArrayType[\Array3[\T,b0,s0,b1,s1,b2,s2\],T,
                                        (ZZ32,ZZ32,ZZ32)\] }
    excludes { Number, String }

    getter size():ZZ32 = s0 s1 s2
    getter bounds():Tuple3Range[\ZZ32,ZZ32,ZZ32\] = (b0,b1,b2)#(s0,s1,s2)

    getter toString():String = do
      r : String := "[" b0 "#" s0 "," b1 "#" s1 "," b2 "#" s2 "] ="
      row(i,k) =
          for j <- seq(0#s1) do
            r := r " " self[b0+i,b1+j,b2+k]
          end
      plane(k) =
        if s1 > 0 then
          row(0,k)
          for i <- seq(1#(s0-1)) do
            r := r "\n "
            row(i,k)
          end
        end
      if s0=0 then
        r " []"
      else
        r := r "\n["
        plane(0)
        for k <- seq(1#(s2-1)) do
          r := r " ;;\n "
          plane(k)
        end
        r " ]"
      end
    end

    opr |self| : ZZ32 = s0 s1 s2

    (* Again, offset performs bounds checking and shifts to 0 indexing. *)
    offset(t:(ZZ32,ZZ32,ZZ32)):(ZZ32,ZZ32,ZZ32) = do
      (a0,a1,a2)=t
      c0 = a0 - b0; c1 = a1 - b1; c2 = a2 - b2
      if NOT (0 <= c0 < s0) then oops(1, b0, s0, a0); end
      if NOT (0 <= c1 < s1) then oops(2, b1, s1, a1); end
      if NOT (0 <= c2 < s2) then oops(3, b2, s2, a2); end
      (c0,c1,c2)
    end
    toIndex(t:(ZZ32,ZZ32,ZZ32)):(ZZ32,ZZ32,ZZ32) =
        do (a0,a1,a2) = t; (a0+b0,a1+b1,a2+b2) end

    (* And get and put are 0-indexed without bounds checks. *)
    put(t:(ZZ32,ZZ32,ZZ32), v:T) : ()
    get(t:(ZZ32,ZZ32,ZZ32)):T

    opr[i:ZZ32, j:ZZ32, k:ZZ32] := (v:T) = do self[ (i,j,k) ] := v end
    opr[r:Range[\(ZZ32,ZZ32,ZZ32)\]]: Array[\T,(ZZ32,ZZ32,ZZ32)\] = do
        r' = (bounds())[r]
        (z0,z1,z2) = r'.extent()
        (l0,l1,l2) = r'.lower()
        __subarray(N[\0\],reflect(z0), N[\0\],reflect(z1),
                   N[\0\],reflect(z2), reflect(l0),reflect(l1), reflect(l2))
      end
    opr[_:OpenRange[\ZZ32\]] : Array3[\T,0,s0,0,s1,0,s2\] =
        subarray[\0,s0,0,s1,0,s2,0,0,0\]()
    opr[_:OpenRange[\Any\]] : Array3[\T,0,s0,0,s1,0,s2\] =
        subarray[\0,s0,0,s1,0,s2,0,0,0\]()
    shift(t:(ZZ32,ZZ32,ZZ32)): Array[\T,(ZZ32,ZZ32)\] = do
        (o0,o1,o2)=t
        if o0=0 AND o1=0 AND o2=0 then
            self
        else
            __subarray(reflect(o0),N[\s0\], reflect(o1),N[\s1\],
                       reflect(o2),N[\s2\], N[\b0\],N[\b1\],N[\b2\])
        end
      end

    (** 2-D subarray given static subarray parameters.
        (bo1,bo2)#(so1,so2) are output bounds.
        The result is the subarray starting at (o0,o1) in the original array.
     **)
    subarray[\nat bo0, nat so0, nat bo1, nat so1, nat bo2, nat so2,
              nat o0, nat o1, nat o2\]
            (): Array3[\T,bo0,so0,bo1,so1,bo2,so2\] = do
        boundsCheck = (bounds())[ (o0,o1,o2)#(so0,so1,so2) ]
        SubArray3[\T,bo0,so0,bo1,so1,bo2,so2,b0,s0,b1,s1,b2,s2\]
                 (self,1,o0,1,o1,1,o2)
      end

    __subarray[\nat bo0, nat so0, nat bo1, nat so1, nat bo2, nat so2,
                nat o0, nat o1, nat o2\]
          (_:N[\bo0\],_:N[\so0\],_:N[\bo1\],_:N[\so1\],_:N[\bo2\],_:N[\so2\],
           _:N[\o0\],_:N[\o1\],_:N[\o2\]): Array3[\T,bo0,so0,bo1,so1,bo2,so2\] =
        subarray[\bo0,so0,bo1,so1,bo2,so2,o0,o1,o2\]()

    zeroIndices():Tuple3Range[\ZZ32,ZZ32,ZZ32\] = (0,0,0)#(s0,s1,s2)

    replica[\U\]():Array3[\U,b0,s0,b1,s1,b2,s2\] =
        __DefaultArray3[\T,b0,s0,b1,s1,b2,s2\]()
    copy():Array3[\T,b0,s0,b1,s1,b2,s2\] =
        self.replica[\T\]().fill(fn (i:ZZ32,j:ZZ32,k:ZZ32):T =>
                                     get(i-b0,j-b1,k-b2))
    map[\R\](f:T->R): Array3[\R,b0,s0,b1,s1,b2,s2\] =
        replica[\R\]().fill(fn (i:ZZ32,j:ZZ32,k:ZZ32):R =>
                                f(get(i-b0,j-b1,k-b2)))
    ivmap[\R\](f:((ZZ32,ZZ32,ZZ32),T)->R): Array3[\R,b0,s0,b1,s1,b2,s2\] =
        replica[\R\]().fill(fn (i:ZZ32,j:ZZ32,k:ZZ32):R =>
                                f((i,j,k),get(i-b0,j-b1,k-b2)))

    freeze():ImmutableArray[\T,(ZZ32,ZZ32,ZZ32)\] =
        fail("Freeze not defined yet!")
end

object __DefaultArray3[\T, nat b0, nat s0, nat b1, nat s1, nat b2, nat s2\]() extends
                                        Array3[\T, b0, s0, b1, s1, b2, s2\]
  mem:PrimitiveArray[\T,(s0 (s1 s2))\] = PrimitiveArray[\T,(s0 (s1 s2))\]()

  ofs(i:ZZ32,j:ZZ32,k:ZZ32):ZZ32 = (i s1 + j) s2 + k

  init0(t:(ZZ32,ZZ32,ZZ32), v:T) : () = mem.init0(ofs(t),v)
  put(t:(ZZ32,ZZ32,ZZ32), v:T) : () = mem.put(ofs(t),v)
  get(t:(ZZ32,ZZ32,ZZ32)) : T = mem.get(ofs(t))
end

(** Simple 3-D subarray, used when we have no other knowledge of the
    underlying structure.  If we're on top of a PrimitiveArray we can
    really do much better than this.
    (b0,b1,b2)#(s0,s1,s2) are the bounds of the subarray.
    (bu0,bu1,bu2)#(su0,su1,su2) are the bounds of the underlying array.
    m_i, o_i are multiplier and offset (0-based) of dimension i.
**)
object SubArray3[\T, nat b0, nat s0, nat b1, nat s1, nat b2, nat s2,
                     nat bu0, nat su0, nat bu1, nat su1, nat bu2, nat su2\]
                (mem: Array3[\T,bu0,su0,bu1,su1,bu2,su2\],
                 m0:ZZ32,o0:ZZ32, m1:ZZ32,o1:ZZ32, m2:ZZ32, o2:ZZ32)
        extends Array3[\T,b0,s0,b1,s1,b2,s2\]
    index(a0:ZZ32, a1:ZZ32, a2:ZZ32): (ZZ32,ZZ32,ZZ32) =
        (m0 a0 + o0, m1 a1 + o1, m2 a2 + o2)
    init0(t:(ZZ32,ZZ32,ZZ32), v:T): () = mem.init0(index(t),v)
    put(t:(ZZ32,ZZ32,ZZ32), v:T): () = mem.put(index(t),v)
    get(t:(ZZ32,ZZ32,ZZ32)): T = mem.get(index(t))
end

__builtinFactory3[\T, nat b0, nat s0, nat b1, nat s1, nat b2, nat s2\]():
        Array3[\T,b0,s0,b1,s1,b2,s2\] =
  __DefaultArray3[\T,b0,s0,b1,s1,b2,s2\]()

array3[\T,nat s0, nat s1, nat s2\]():Array3[\T,0,s0,0,s1,0,s2\] =
  __DefaultArray3[\T,0,s0,0,s1,0,s2\]()

(*************

trait Monoid[\ T, opr OPLUS \]
  where { T extends Monoid[\ T, OPLUS \] }
    zero() : T
    opr OPLUS(self, other:T):T
end

*************)

(************************************************************
* Reductions
************************************************************)

trait Reduction[\ R \]
    getter toString() = "A Reduction without a toString() of its own"
    empty(): R
    join(a: R, b: R): R
end

object VoidReduction extends Reduction[\()\]
    getter toString() = "VoidReduction"
    empty(): () = ()
    join(a: (), b: ()): () = ()
end

(* Hack to permit any Number to work non-parametrically. *)
object SumReduction extends Reduction[\Number\]
    getter toString() = "SumReduction"
    empty(): Number = 0
    join(a: Number, b: Number): Number = a+b
end

opr SUM[\T\](g:(Reduction[\Number\],T->Number)->Number): Number =
    g(SumReduction,cast[\Number\])

object ProdReduction extends Reduction[\Number\]
    getter toString() = "ProdReduction"
    empty(): Number = 1
    join(a:Number, b:Number): Number = a b
end

opr PROD[\T\](g:(Reduction[\Number\],T->Number)->Number): Number =
    g(ProdReduction,cast[\Number\])

object NoMin extends UncheckedException end

(* Hack to permit both Numbers and TotalOrders to work. *)
object MinReduction extends Reduction[\Any\]
    getter toString() = "MinReduction"
    empty(): Any = NoMin
    join(a: Any, b: Any): Any =
        typecase _ = (a,b) of
            (NoMin,Any) => b
            (Any,NoMin) => a
            else => a MIN b
        end
end

(* Again, type information is notoriously non-specific to permit
   either TotalOrder or Number types. *)
opr BIG MIN[\T\](g:(Reduction[\Any\],T->Any)->Any): Any =
    typecase x = g(MinReduction,identity[\Any\]) of
        NoMin => throw x
        else => x
    end

object NoMax extends UncheckedException end

object MaxReduction extends Reduction[\Any\]
    getter toString() = "MaxReduction"
    empty(): Any = NoMax
    join(a: Any, b: Any): Any =
        typecase _ = (a,b) of
            (NoMax,Any) => b
            (Any,NoMax) => a
            else => a MAX b
        end
end

opr BIG MAX[\T\](g:(Reduction[\Any\],T->Any)->Any): Any =
    typecase x = g(MaxReduction,identity[\Any\]) of
        NoMax => throw x
        else => x
    end

(** AndReduction and OrReduction take advantage of natural zeroes for early exit. **)
object AndReduction extends Reduction[\Boolean\]
    getter toString() = "AndReduction"
    empty(): Boolean = true
    join(a: Boolean, b: Boolean): Boolean = a AND b
end

opr BIG AND[\T\](g:(Reduction[\Boolean\],T->Boolean)->Boolean):Boolean =
    label MustBe
        f(x): Boolean =
            typecase x of
                Boolean => if x then true else exit MustBe with false end
                else => fail("BIG AND of non-boolean")
            end
        g(AndReduction, f)
    end MustBe

object OrReduction extends Reduction[\Boolean\]
    getter toString() = "OrReduction"
    empty(): Boolean = false
    join(a: Boolean, b: Boolean): Boolean = a OR b
end

opr BIG OR[\T\](g:(Reduction[\Boolean\],T->Boolean)->Boolean):Boolean =
    label MustBe
        f(x): Boolean =
            typecase x of
                Boolean => if x then exit MustBe with true else false end
                else => fail("BIG OR of non-boolean")
            end
        g(OrReduction, f)
    end MustBe

object StringReduction extends Reduction[\String\]
    getter toString() = "StringReduction"
    empty(): Boolean = ""
    join(a:String, b:String): String = a b
end

opr BIG STRING(g:(Reduction[\String\],Any->String)->String): String =
    g(StringReduction, fn (x:Any)=> "" x)

object MapReduceReduction[\R\](j:(R,R)->R, z:R) extends Reduction[\R\]
    getter toString()="mapReduce.Reduction"
    empty() = z
    join(a:R, b:R): R = (j)(a,b)
end

(** Helpers for maps and cross products of generators.  These can be
    quite a bit more sophisticated (for example, we can hoist maps
    outwards if we think that'd be useful), but let's get this much
    working first. *)

trait MappedGenerator[\E,F\] extends Generator[\F\]
    getter g(): Generator[\E\]
    getter f(): E -> F
    getter toString(): String = g() ".map(f)"
    generate[\R\](r: Reduction[\R\], m: F->R): R =
        g().generate[\R\](r, m COMPOSE f())
    reduce(r: Reduction[\F\]): F =
        g().generate[\F\](r, f())
    map[\G\](f': F->G): SimpleMappedGenerator[\E,G\] =
        SimpleMappedGenerator[\E,G\](g(), f' COMPOSE f())
    seq(self) = SimpleMappedSeqGenerator[\E,F\](seq(g()),f())
end

object SimpleMappedGenerator[\E,F\](g0: Generator[\E\], f0: E->F)
        extends MappedGenerator[\E,F\]
    getter g() = g0
    getter f() = f0
end

object SimpleMappedIndexed[\E,F,I\](g0: Indexed[\E,I\], f0: E->F)
        extends { MappedGenerator[\E,F\], Indexed[\F,I\] }
    getter size(): ZZ32 = |g()|
    getter g() = g0
    getter f() = f0
    getter bounds(): Range[\I\] = g().bounds()
    getter indexValuePairs(): Indexed[\(I,F),I\] =
        g().indexValuePairs().map[\(I,F)\](fn (i:I, e:E): F => (i,(f())(e)))
    getter indices(): Indexed[\I,I\] = g().indices()
    opr |self| : ZZ32 = |g()|
    opr[i:I] : F = (f())(g()[i])
    opr[r:Range[\I\]] : Indexed[\F,I\] =
        SimpleMappedIndexed[\E,F,I\](g()[r],f())

    ivmap[\R\](ff:(I,F)->R): Indexed[\R,I\] =
        g0().ivmap[\R\](fn (i:I, e:E) => ff(i, (f())(e)))
    map[\G\](f': F->G): SimpleMappedIndexed[\E,G,I\] =
        SimpleMappedIndexed[\E,G,I\](g(), f' COMPOSE f())
end

object SimpleMappedSeqGenerator[\E,F\](g0: SequentialGenerator[\E\], f0: E->F)
        extends { MappedGenerator[\E,F\], SequentialGenerator[\F\] }
    getter g() = g0
    getter f() = f0
    getter toString() = "seq(" g0 ".map(f))"
    seq(self): SimpleMappedSeqGenerator[\E,F\] = self
end

trait NestedGenerator[\E,F\] extends Generator[\F\]
    getter g(): Generator[\E\]
    getter f(): E -> Generator[\F\]
    getter toString(): String
    generate[\R\](r: Reduction[\R\], m: F->R): R =
        g().generate[\R\](r,fn (e:E):R => (f())(e).generate[\R\](r,m))
    mapReduce[\R\](body: F->R, join:(R,R)->R, zero:R): R =
        g().mapReduce[\R\](
            fn (e:E): R => (f())(e).mapReduce[\R\](body,join,zero),
            join, zero)
    reduce(r: Reduction[\F\]): F =
        g().generate[\F\](r,fn (e:E):F => (f())(e).reduce(r))
    reduce(j:(F,F)->F, z:F):F =
        g().mapReduce[\F\](fn (e:E): F => (f())(e).reduce(j,z), j, z)
    loop(body:F->()): () =
        g().loop(fn (e:E) => (f())(e).loop(body))
    map[\G\](h:F->G): Generator[\G\] =
        g().nest[\G\](fn (e:E): Generator[\G\] => (f())(e).map[\G\](h))
    nest[\G\](h:F->Generator[\G\]): Generator[\G\] =
        g().nest[\G\](fn (e:E):Generator[\G\] => (f())(e).nest[\G\](h))
end

object SimpleNestedGenerator[\E,F\](g0: Generator[\E\], f0: E->Generator[\F\])
        extends { NestedGenerator[\E,F\] }
    getter g() = g0
    getter f() = f0
    getter toString() = g() ".nest(f)"
    seq(self) =
        typecase ff = f() of
            (E -> SequentialGenerator[\F\]) =>
                SimpleNestedSeqGenerator[\E,F\](seq(g()),ff)
            else =>
                SimpleNestedSeqGenerator[\E,F\](seq(g()),
                     fn (e:E): SequentialGenerator[\F\] => seq(self.f()(e)))
        end
end

object SimpleNestedSeqGenerator[\E,F\]
        (g0: SequentialGenerator[\E\], f0: E->SequentialGenerator[\F\])
        extends { NestedGenerator[\E,F\], SequentialGenerator[\F\] }
    getter g() = g0
    getter f() = f0
    getter toString() = "seq(" g() ".nest(f))"
end

trait PairGenerator[\E,F\] extends Generator[\(E,F)\]
  comprises { SimplePairGenerator[\E,F\], SimplePairSeqGenerator[\E,F\] }
    getter e(): Generator[\E\]
    getter f(): Generator[\F\]
    getter toString(): String
    getter size():ZZ32 = |self|
    opr |self| : ZZ32 = |e()| |f()|
    generate[\R\](r: Reduction[\R\], m:(E,F)->R): R =
        e().generate[\R\](r, fn (a: E): R =>
                              f().generate[\R\](r, fn (b: F): R => m(a,b)))
end

object SimplePairGenerator[\E,F\](e0: Generator[\E\], f0: Generator[\F\])
        extends PairGenerator[\E,F\]
    getter e() = e0
    getter f() = f0
    getter toString()=(e0 ".cross(" f0 ")" )
    seq(self) = SimplePairSeqGenerator[\E,F\](seq(e0),seq(f0))
end

object SimplePairSeqGenerator[\E,F\](e0: Generator[\E\], f0: Generator[\F\])
        extends { PairGenerator[\E,F\], SequentialGenerator[\(E,F)\] }
    getter e() = e0
    getter f() = f0
    getter toString()=("seq(" e ".cross(" f "))" )
end

(** Helper for serializing generators naively.  This code should make
 *  obvious that naive seq is *VERY INEFFICIENT*.  It
 *  constructs a function closure whose size is proportional to
 *  %|g|%, and then executes that closure.  This trick is old hat
 *  to lambda-calculus wonks, but pretty unfamiliar to the common man.
 *
 *  Basically each element takes in the accumulated value a from the element
 *  to its left.  This is joined with the result of mapping on the
 *  current element value, and that result is returned.  Join simply
 *  reverse-composes the functions for its subtrees, so the output of the left
 *  subtree is fed to the right subtree.
 *
 *  Note that a similar trick can be used to reverse and sequentialize
 *  a generator (use forward function composition rather than reverse
 *  composition, and flipping around the join at the leaves). *)
object NaiveSeqGenerator[\E\](g: Generator[\E\])
        extends SequentialGenerator[\E\]
    getter size() = |g|
    getter toString():String = "naive seq(" g.toString() ")"
    opr |self| : ZZ32 = |g|
    generate[\R\](r: Reduction[\R\], m:E->R): R = do
      rcompose(f:R->R, g:R->R): R->R = fn (x:R):R => g(f(x))
      id(x:R):R = x
      mp(x:E):R->R = fn (a:R):R => r.join(a,m(x))
      f : R -> R = g.mapReduce[\R->R\](mp,rcompose,id)
      mt : R = r.empty()
      f mt
    end
end

(************************************************************
* Ranges
************************************************************)

(** Ranges in general represent uses of the # and : operators.
    It's mostly subtypes of Range that are interesting.

    The partial order on ranges describes containment:
      a < b iff all points in a are strictly contained in b.
 **)
trait Range[\T\]
    extends StandardPartialOrder[\Range[\T\]\]
    comprises { RangeWithLower[\T\], RangeWithUpper[\T\],
                RangeWithExtent[\T\], PartialRange[\T\] }
    excludes { Number }
    opr[r:Range[\T\]]: Range[\T\] = fail("Unrecognized Range " r)
    opr[_:OpenRange[\Any\]] : Range[\T\] = self
    opr[other:LowerRange[\T\]] : Range[\T\]
    opr[other:UpperRange[\T\]] : Range[\T\]
    opr[other:ExtentRange[\T\]] : Range[\T\]
    opr[other:FullRange[\T\]] : FullRange[\T\]
    opr =(self,_:Range[\T\]): Boolean = false
end

trait PartialRange[\T\] extends Range[\T\]
    comprises { OpenRange[\T\],
                LowerRange[\T\], UpperRange[\T\], ExtentRange[\T\] }
    excludes { FullRange[\T\] }
end

object OpenRange[\T\] extends { Range[\T\], PartialRange[\T\] }
    toString():String = "#"
    opr[_:OpenRange[\T\]] : OpenRange[\T\] = self

    opr[other:LowerRange[\T\]] : LowerRange[\T\] = other
    opr[other:UpperRange[\T\]] : UpperRange[\T\] = other
    opr[other:ExtentRange[\T\]] : ExtentRange[\T\] = other
    opr[other:FullRange[\T\]] : FullRange[\T\] = other
    opr =(self,_:OpenRange[\T\]): Boolean = true
    opr CMP(self,other:Range[\T\]): Comparison =
        typecase other of
            OpenRange[\T\] => EqualTo
            else => GreaterThan
        end
end

opr PARTIAL_LEXICO(a:Comparison, b:Comparison) =
    typecase a of
        Unordered => Unordered
        EqualTo => b
        else =>
            typecase b of
                Unordered => Unordered
                else => a
            end
    end

opr PARTIAL_LEXICO(a:Comparison, b:()->Comparison) =
    typecase a of
        Unordered => Unordered
        EqualTo => b()
        else =>
            typecase _ = b() of
                Unordered => Unordered
                else => a
            end
    end

(** Non-traditional partial ordering on tuples, CMP ordering elsewhere. **)
opr PCMP[\A,B\](t1:(A,B), t2:(A,B)): Comparison = do
    (a1,b1)=t1
    (a2,b2)=t2
    (a1 CMP a2) PARTIAL_LEXICO: (b1 CMP b2)
  end

opr PCMP[\A,B,C\](t1:(A,B,C), t2:(A,B,C)): Comparison = do
    (a1,b1,c1)=t1
    (a2,b2,c2)=t2
    (a1 CMP a2) PARTIAL_LEXICO: (b1 CMP b2) PARTIAL_LEXICO (c1 CMP c2)
  end

opr PCMP(a:Integral, b:Integral): TotalComparison = a CMP b

(** Non-traditional subtraction of bounds, elementwise on tuples **)
opr SUBTR[\A,B\](t1:(A,B), t2:(A,B)): (A,B) = do
    (a1,b1) = t1
    (a2,b2) = t2
    (a1 SUBTR a2, b1 SUBTR b2)
  end

opr SUBTR[\A,B,C\](t1:(A,B,C), t2:(A,B,C)): (A,B,C) = do
    (a1,b1,c1) = t1
    (a2,b2,c2) = t2
    (a1 SUBTR a2, b1 SUBTR b2, c1 SUBTR c2)
  end

opr SUBTR[\T extends Integral\](a:T, b:T):T = 1 + a - b

(** join upper and lower bounds comparisons (total or partial) to
    yield partial containment. **)

trait RangeWithLower[\T\] extends Range[\T\]
        comprises { LowerRange[\T\], FullRange[\T\] }
    getter lower():T
end

rangeBoundError[\T\](r1:Range[\T\], r2: Range[\T\]): Range[\T\] =
    fail(r1 "[" r2 "] does not contain bound of indexing range")

object LowerRange[\T\](lo:T) extends { RangeWithLower[\T\], PartialRange[\T\] }
    getter lower():T = lo
    toString():String = lower() "#"
    opr[_:OpenRange[\T\]] : LowerRange[\T\] = self
    opr[other:LowerRange[\T\]] : LowerRange[\T\] =
        if other.lower() >= lower() then
            other
        else
            rangeBoundError[\T\](self,other)
        end
    opr[other:ExtentRange[\T\]] : FullRange[\T\] = lower() # other.extent()
    opr[other:UpperRange[\T\]] : FullRange[\T\] =
        if other.upper() >= lower() then
            lower() : other.upper()
        else
            rangeBoundError[\T\](self,other)
        end
    opr[other:FullRange[\T\]] : FullRange[\T\] =
        if other.lower() >= lower() then
            other
        else
            rangeBoundError[\T\](self,other)
        end
    opr =(self, x:LowerRange[\T\]): Boolean = lower() = x.lower()
    opr CMP(self, other:Range[\T\]): Comparison =
        typecase other of
            OpenRange[\T\] => LessThan
            LowerRange[\T\] => other.lower() PCMP lower()
            FullRange[\T\] =>
                typecase c = other.lower() PCMP lower() of
                    EqualTo => GreaterThan
                    LessThan => Unordered
                    else => c
                end
            else => Unordered
        end
end

trait RangeWithUpper[\T\] extends Range[\T\]
        comprises { UpperRange[\T\], FullRange[\T\] }
    getter upper():T
end

object UpperRange[\T\](up:T) extends { RangeWithUpper[\T\], PartialRange[\T\] }
    getter upper():T = up
    toString():String = ":" upper()
    opr[_:OpenRange[\T\]] : UpperRange[\T\] = self
    opr[other:LowerRange[\T\]] : FullRange[\T\] = other.lower():upper()
    opr[other:UpperRange[\T\]] : UpperRange[\T\] =
        if other.upper() <= upper() then
            other
        else
            rangeBoundError[\T\](self,other)
        end
    opr[other:ExtentRange[\T\]] : FullRange[\T\] =
        (upper() SUBTR other.extent()) # other.extent()
    opr[other:FullRange[\T\]] : FullRange[\T\] =
        if other.upper() <= upper() then
            other
        else
            rangeBoundError[\T\](self,other)
        end
    opr =(self,x:UpperRange[\T\]): Boolean = upper() = x.upper()
    opr CMP(self, other:Range[\T\]): Comparison =
        typecase other of
            OpenRange[\T\]  => LessThan
            UpperRange[\T\] => upper() PCMP other.upper()
            FullRange[\T\]  =>
                typecase c = upper() PCMP other.upper() of
                    EqualTo => GreaterThan
                    LessThan => Unordered
                    else => c
                end
            else => Unordered
        end
end

trait RangeWithExtent[\T\] extends Range[\T\]
        comprises { ExtentRange[\T\], FullRange[\T\] }
    getter extent():T
    toString():String = "#" extent()
end

object ExtentRange[\T\](ex:T) extends { RangeWithExtent[\T\], PartialRange[\T\] }
    getter extent():T = ex
    opr[_:OpenRange[\T\]] : ExtentRange[\T\] = self
    opr[other:LowerRange[\T\]] : FullRange[\T\] = other.lower() # extent()
    opr[other:UpperRange[\T\]] : FullRange[\T\] =
        (other.upper() SUBTR extent()) # extent()
    opr[other:ExtentRange[\T\]] : ExtentRange[\T\] =
        if other.extent() <= extent() then
            other
        else
            rangeBoundError[\T\](self,other)
        end
    opr[other:FullRange[\T\]] : FullRange[\T\] =
        if other.extent() <= extent() then
            other
        else
            rangeBoundError[\T\](self,other)
        end
    opr =(self,x:ExtentRange[\T\]): Boolean = extent() = x.extent()
    opr CMP(self, other:Range[\T\]): Comparison =
        typecase other of
            OpenRange[\T\]   => LessThan
            ExtentRange[\T\] => extent() PCMP other.extent()
            else => Unordered
        end
end

trait FullRange[\T\]
        extends { RangeWithLower[\T\], RangeWithUpper[\T\],
                  RangeWithExtent[\T\], Indexed[\T,T\] }
        comprises { ScalarRange[\T\], TupleRange[\T\] }
    getter indices(): FullRange[\T\] = bounds()

    opr[r:Range[\T\]]: FullRange[\T\] = fail("Unrecognized Range " r)
    opr[_:OpenRange[\T\]]: FullRange[\T\] = self
    (** Square-bracket indexing on a FullRange restricts that range to
         the range provided.  Restriction should behave as follows:
            - Restriction to an OpenRange is the identity.
            - An UpperRange or ExtentRange restrict the upper bound and
              extent of the range.
            - A LowerRange restricts the lower bound and extent of the range.
        Note that this makes it compatible with the square-bracket
        indexing of the Indexed trait. **)
    opr[r:LowerRange[\T\]]: FullRange[\T\] =
        if r.lower() = lower() then
            (* Important, also handles empty range case. *)
            self
        elif r.lower() IN self then
            r.lower():upper()
        else
            rangeBoundError[\T\](self,r)
        end
    opr[r:UpperRange[\T\]]: FullRange[\T\] =
        if r.upper() = upper() then
            (* Important, also handles empty range case. *)
            self
        elif r.upper() IN self then
            lower():r.upper()
        else
            rangeBoundError[\T\](self,r)
        end
    opr[r:ExtentRange[\T\]]: FullRange[\T\] =
        if r.extent() <= extent() then
            lower()#r.extent()
        else
            fail(self "[" r "] is not sufficiently large in some dimension")
        end
    opr[r:FullRange[\T\]]: FullRange[\T\] =
        if r.lower() < lower() then
            rangeBoundError[\T\](self,r)
        elif r.upper() > upper() then
            rangeBoundError[\T\](self,r)
        else
            r
        end

    toString():String = lower() "#" extent()

    opr =(self, other:FullRange[\T\]): Boolean =
        lower()=other.lower() AND |self| = |other|
    opr CMP(self, other:Range[\T\]): Comparison =
        typecase other of
            FullRange[\T\] =>
                a = lower() PCMP other.lower()
                b = upper() PCMP other.upper()
                typecase _ = (a,b) of
                    (Unordered,Comparison) => Unordered
                    (Comparison,Unordered) => Unordered
                    (LessThan,LessThan) => Unordered
                    (GreaterThan,GreaterThan) => Unordered
                    (EqualTo,Comparison) => b
                    (GreaterThan,Comparison) => LessThan
                    else (* LessThan,Comparison *) => GreaterThan
                end
            else => INVERSE (other CMP self)
        end
end

rangeIndexFailure[\T\](r:FullRange[\T\],i:T): () =
    fail(r "[" i "] out of range.")

(** ParRanges and SeqRanges, the simplest and most basic of all
generators.  They generate |self| numbers, incrementing by 1, starting
with lower() (that's the canonical ordering). *)
trait ScalarRange[\N extends Integral\]
        extends { FullRange[\N\] }
    getter bounds():FullRange[\N\] = 0#extent()
    getter upper():N = lower() + extent() - 1
    getter size():ZZ32 = |self|
    opr |self| : ZZ32 = narrow(|\extent()/|)
    opr[i:N]: N =
        if 0 <= i < extent() then
            i + lower()
        else
            rangeIndexFailure[\N\](self,i)
        end
    opr IN(a:N, self): Boolean = do
        t = a - lower()
        0 <= t < |self|
      end
end

value object ParRange[\N extends Integral\](lo:N, ex:N)
        extends ScalarRange[\N\]
    getter extent() = ex
    getter lower() = lo
    getter indexValuePairs() =
        ParRange[\N\](0,ex).map[\(N,N)\](fn (n:N):(N,N) => (n,n+lo))

    seq(self) = SeqRange[\N\](lo,ex)
    generate[\R\](r: Reduction[\R\], m: N->R): R =
        if |self| < 1 then
            r.empty()
        else
            gen(l,s) = if s>=2 then
                           (s1,s2) = partition(s)
                           r.join(gen(l,s1),gen(l+s1,s2))
                       else
                           m(l)
                       end
            gen(lo,|self|)
        end
    mapReduce[\R\](m: N->R, j:(R,R)->R, z:R): R =
        if |self| < 1 then
            z
        else
            gen(l,s) = if s>=2 then
                           (s1,s2) = partition(s)
                           j(gen(l,s1),gen(l+s1,s2))
                       else
                           m(l)
                       end
            gen(lo,|self|)
        end
    reduce(j:(N,N)->N, z:N):N =
        if |self| < 1 then
            z
        else
            gen(l,s) = if s>=2 then
                           (s1,s2) = partition(s)
                           j(gen(l,s1),gen(l+s1,s2))
                       else
                           l
                       end
            gen(lo,|self|)
        end
    reduce(r: Reduction[\N\]):N =
        if |self| < 1 then
            r.empty()
        else
            gen(l,s) = if s>=2 then
                           (s1,s2) = partition(s)
                           r.join(gen(l,s1),gen(l+s1,s2))
                       else
                           l
                       end
            gen(lo,|self|)
        end
    loop(f:N->()): () =
        if |self| < 1 then
            ()
        else
            gen(l,s) = if s>=2 then
                           (s1,s2) = partition(s)
                           (gen(l,s1),gen(l+s1,s2))
                           ()
                       else
                           f(l)
                       end
            gen(lo,|self|)
        end
end
value object SeqRange[\N extends Integral\](lo:N, ex:N)
        extends { ScalarRange[\N\], SequentialGenerator[\N\] }
    getter extent() = ex
    getter lower() = lo
    getter toString() = "seq(" lo "#" ex ")"
    getter indexValuePairs() =
        SeqRange[\N\](0,ex).map[\(N,N)\](fn (n:N):(N,N) => (n,n+lo))
    generate[\R\](r: Reduction[\R\], m: N->R): R = do
        h = lo + ex
        l : N := lo
        acc : R = r.empty()
        (* DO NOT DEFINE THIS USING RECURSION!!! *)
        while l < h do
            b = m(l)
            acc := r.join(acc, b)
            l += 1
        end
        acc
      end
    loop(f: N->()): () = do
        h = lo + ex
        l : N := lo
        (* DO NOT DEFINE THIS USING RECURSION!!! *)
        while l < h do
            f(l)
            l += 1
        end
      end
end

trait TupleRange[\T\] extends FullRange[\T\]
end

object Tuple2Range[\N extends Integral, M extends Integral\]
                  (l1:N,l2:M,x1:N,x2:M)
        extends { TupleRange[\(N,M)\], DelegatedIndexed[\(N,M),(N,M)\] }
    getter bounds():Tuple2Range[\N,M\] = (0,0)#(x1,x2)
    getter extent():(N,M) = (x1,x2)
    getter lower():(N,M) = (l1,l2)
    getter upper():(N,M) = ((l1#x1).upper(), (l2#x2).upper())
    getter size():(N,M) = |self|
    getter generator():Generator[\(N,M)\] = (l1#x1).cross[\M\](l2#x2)
    getter toString(): String = "(" l1 "," l2 ")#(" x1 "," x2 ")"
    getter indexValuePairs() =
        Tuple2Range[\N\](0,0,x1,x2).map[\((N,M),(N,M))\](
            fn (n:N,m:M):((N,M),(N,M)) => ((n,m),(n+l1,m+l2)))
    opr |self| : ZZ32 = |l1#x1| |l2#x2|
    opr[i:(N,M)]: (N,M) = do
        (i1,i2) = i
        if 0 <= i1 < x1 AND 0 <= i2 < x2 then
            (i1+l1,i2+l2)
        else
            rangeIndexFailure[\(N,M)\](self,i)
        end
      end
    opr IN(t:(N,M), self): Boolean = do
        (v1,v2) = t
        0 <= v1-l1 < x1 AND 0 <= v2-l2 < x2
      end
    opr =(self,r:Tuple2Range[\N,M\]): Boolean =
        l1=r.l1 AND l2=r.l2 AND x1=r.x1 AND x2=r.x2
end

object Tuple3Range[\N1 extends Integral, N2 extends Integral, N3 extends Integral\]
                  (l1:N1,l2:N2,l3:N3,x1:N1,x2:N2,x3:N3)
        extends { TupleRange[\(N1,N2,N3)\],
                  DelegatedIndexed[\(N1,N2,N3),(N1,N2,N3)\] }
    getter bounds():Tuple3Range[\N1,N2,N3\] = (0,0,0)#(x1,x2,x3)
    getter extent():(N1,N2,N3) = (x1,x2,x3)
    getter lower():(N1,N2,N3) = (l1,l2,l3)
    getter upper():(N1,N2,N3) =
        ((l1#x1).upper(), (l2#x2).upper(), (l3#x3).upper())
    getter size():(N1,N2,N3) = |self|
    getter generator():Generator[\(N1,N2,N3)\] =
        (l1#x1).cross[\N2\](l2#x2).cross[\N3\](l3#x3).map[\(N1,N2,N3)\](
            fn (t:(N1,N2),n3:N3):(N1,N2,N3) => do (n1,n2)=t; (n1,n2,n3) end)
    getter toString(): String = "(" l1 "," l2 "," l3 ")#(" x1 "," x2 "," x3 ")"
    getter indexValuePairs() =
        (0#x1).cross(0#x2).cross(0#x3).map[\((N1,N2,N3),(N1,N2,N3))\](
            fn (t:(N1,N2),n3:N3):((N1,N2,N3),(N1,N2,N3)) =>
                do (n1,n2)=t; ((n1,n2,n3),(n1+l1,n2+l2,n3+l3)) end)
    opr |self| : (N1,N2,N3) = |l1#x1| |l2#x2| |l3#x3|
    opr[i:(N1,N2,N3)]: (N1,N2,N3) = do
        (i1,i2,i3) = i
        if 0 <= i1 < x1 AND 0 <= i2 < x2 AND 0 <= i3 < x3 then
            (i1+l1,i2+l2, i3+l3)
        else
            rangeIndexFailure[\(N1,N2,N3)\](self,i)
        end
      end
    opr IN(t:(N1,N2,N3), self): Boolean = do
        (v1,v2,v3) = t
        0 <= v1-l1 < x1 AND 0 <= v2-l2 < x2 AND 0 <= v3-l3 < x3
      end
    opr =(self,r:Tuple3Range[\N1,N2,N3\]): Boolean =
        l1=r.l1 AND l2=r.l2 AND x1=r.x1 AND x2=r.x2 AND l3=r.l3 AND x3=r.x3
end

(** The # and : operators serve as factories for parallel ranges. **)
opr #[\I extends Integral\](lo:I, ex:I): ParRange[\I\] = ParRange[\I\](lo,ex)
opr #(lo:IntLiteral, ex:IntLiteral): ParRange[\ZZ32\] = ParRange[\ZZ32\](lo,ex)
opr #[\I extends Integral, J extends Integral\]
     (lo:(I,J), ex:(I,J)): Tuple2Range[\I,J\] =
    do (l1,l2)=lo; (x1,x2)=ex; Tuple2Range[\I,J\](l1,l2,x1,x2) end
opr #[\I extends Integral, J extends Integral, K extends Integral\]
     (lo:(I,J,K), ex:(I,J,K)): Tuple3Range[\I,J,K\] =
    do (l1,l2,l3)=lo; (x1,x2,x3)=ex; Tuple3Range[\I,J,K\](l1,l2,l3,x1,x2,x3) end

opr :[\I extends Integral\](lo:I, hi:I): ParRange[\I\] =
        ParRange[\I\](lo,hi-lo+1)
opr :(lo:IntLiteral, ex:IntLiteral): ParRange[\ZZ32\] =
        ParRange[\ZZ32\](lo,hi-lo+1)
opr :[\I extends Integral, J extends Integral\]
     (lo:(I,J), hi:(I,J)): Tuple2Range[\I,J\] =
    do (l1,l2)=lo; (h1,h2)=hi; Tuple2Range[\I,J\](l1,l2,h1-l1+1,h2-l2+1) end
opr :[\I extends Integral, J extends Integral, K extends Integral\]
     (lo:(I,J,K), hi:(I,J,K)): Tuple3Range[\I,J,K\] = do
    (l1,l2,l3)=lo; (h1,h2,h3)=hi
    Tuple3Range[\I,J,K\](l1,l2,l3,h1-l1+1,h2-l2+1,h3-l3+1)
  end

(** Factories for incomplete ranges **)
opr (x:T)#[\T\] : LowerRange[\T\] = LowerRange[\T\](x)
opr (x:T):[\T\] : LowerRange[\T\] = LowerRange[\T\](x)
opr #[\T\](x:T) : ExtentRange[\T\] = ExtentRange[\T\](x)
opr :[\T\](x:T) : UpperRange[\T\] = UpperRange[\T\](x)

opr #() : OpenRange[\Any\] = OpenRange[\Any\]
opr :() : OpenRange[\Any\] = OpenRange[\Any\]

(***********************************************************
* Numeric primitives
************************************************************)

opr |x:ZZ32| : ZZ32 = if x>=0 then x else -x end
opr |x:ZZ64| : ZZ64 = if x>=0 then x else -x end
opr |x:IntLiteral| : IntLiteral = if x>=0 then x else -x end

opr -(a:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Negate")
opr +(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Add")
opr -(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Sub")
opr DOT(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Mul")
opr juxtaposition
     (a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Mul")
opr DIV(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Div")
opr REM(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Rem")
opr MOD(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Mod")
opr GCD(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Gcd")
opr LCM(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Lcm")
opr CHOOSE(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Choose")
opr BITAND(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$BitAnd")
opr BITOR(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$BitOr")
opr BITXOR(a:ZZ32,b:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$BitXor")
opr LSHIFT(a:ZZ32,b:Integral):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$LShift")
opr RSHIFT(a:ZZ32,b:Integral):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$RShift")
opr BITNOT(a:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$BitNot")
opr =(a:ZZ32, b:ZZ32):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Eq")
opr <=(a:ZZ32, b:ZZ32):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$LessEq")
opr ^(a:ZZ32, b:Integral):Number = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Pow")
widen(a:ZZ32):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$ToLong")
partitionL(a:ZZ32):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$Partition")

nanoTime():ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$NanoTime")
printTaskTrace():() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$PrintTaskTrace")

__globalTimeInformation: ZZ64 := 0
recordTime(dummy: Any): () = do __globalTimeInformation := nanoTime() end
printTime(dummy: Any): () = do
    r = nanoTime()
    e = r - __globalTimeInformation
    __globalTimeInformation := r
    secs: ZZ64 = (e+500000) DIV 1000000
    println("Operation took " secs "ms")
  end

opr -(a: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Negate")
opr +(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Add")
opr -(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Sub")
opr DOT(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Mul")
opr juxtaposition
     (a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Mul")
opr DIV(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Div")
opr REM(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Rem")
opr MOD(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Mod")
opr GCD(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Gcd")
opr LCM(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Lcm")
opr CHOOSE(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Choose")
opr BITAND(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$BitAnd")
opr BITOR(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$BitOr")
opr BITXOR(a: IntLiteral,b: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$BitXor")
opr LSHIFT(a: IntLiteral,b:Integral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$LShift")
opr RSHIFT(a: IntLiteral,b:Integral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$RShift")
opr BITNOT(a: IntLiteral): IntLiteral = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$BitNot")
opr =(a: IntLiteral, b: IntLiteral):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Eq")
opr <=(a: IntLiteral, b: IntLiteral):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$LessEq")
opr ^(a: IntLiteral, b:Integral):Number = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.IntLiteral$Pow")

opr -[\ T extends Number, nat n, nat m \]
     (a:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Negate")
opr +[\ T extends Number, nat n, nat m \]
     (a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Add")
opr -[\ T extends Number, nat n, nat m \]
     (a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Sub")
opr DOT[\ T extends Number, nat n, nat m, nat p \]
     (a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Mul")
opr juxtaposition[\ T extends Number, nat n, nat m, nat p \]
     (a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Mul")
opr DIV(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Div")
opr REM(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Rem")
opr MOD(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Mod")
opr GCD(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Gcd")
opr LCM(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Lcm")
opr CHOOSE(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Choose")
opr BITAND(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$BitAnd")
opr BITOR(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$BitOr")
opr BITXOR(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$BitXor")
opr LSHIFT(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$LShift")
opr RSHIFT(a:Integral,b:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$RShift")
opr BITNOT(a:Integral):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$BitNot")
opr =(a:Integral, b:Integral):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Eq")
opr <=(a:Integral, b:Integral):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$LessEq")
opr ^(a:ZZ64, b:Integral):Number = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Long$Pow")
narrow(a:ZZ64):ZZ32 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Int$FromLong")

opr   <(a:Integral, b:Integral):Boolean = NOT (b <= a)
opr   >(a:Integral, b:Integral):Boolean = NOT (a <= b)
opr  >=(a:Integral, b:Integral):Boolean = b <= a
opr CMP(a:Integral, b:Integral):TotalComparison =
    if a<b then LessThan elif a>b then GreaterThan else EqualTo end
opr MIN[\I extends Integral\](a:I, b:I):I = if a <= b then a else b end
opr MAX[\I extends Integral\](a:I, b:I):I = if b <= a then a else b end

opr -(a:RR64):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Negate")
opr +(a:Number,b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Add")
opr -(a:Number,b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Sub")
opr DOT(a:Number,b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Mul")
opr juxtaposition
     (a:Number,b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Mul")
opr /(a:Number,b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Div")
opr =(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Eq")
opr =/=(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$NEq")
opr <(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Less")
opr <=(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$LessEq")
opr >(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Greater")
opr >=(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$GreaterEq")
opr CMP(a:Number, b:Number):Comparison =
    if a<b then LessThan
    elif a>b then GreaterThan
    elif a=b then EqualTo
    else Unordered
    end
opr MIN(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Min")
opr MAX(a:Number, b:Number):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Max")
opr |a:RR64| : RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Abs")
opr ^(a:Number, b:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Pow")
opr SQRT(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Sqrt")
sin(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Sin")
cos(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Cos")
tan(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Tan")
asin(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$ASin")
acos(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$ACos")
atan(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$ATan")
atan2(y:Number,x:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$ATan2")
log(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Log")
exp(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Exp")
floor(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Floor")
opr |\a:Number/| : ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$IFloor")
ceiling(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Ceiling")
opr |/a:Number\| : ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$ICeiling")
truncate(a:Number):ZZ64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Truncate")
random(a:Number):RR64 = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Float$Random")

opr =(a:Char, b:Char):Boolean = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.Char$Eq")

opr DOT(a:String, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:String, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(a:Number, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:Number, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(a:String, b:Number):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:String, b:Number):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(a:Boolean, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:Boolean, b:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(a:String, b:Boolean):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:String, b:Boolean):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(a:String, c:Char):String =builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (a:String, c:Char):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(c:Char, a:String):String =builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr juxtaposition
     (c:Char, a:String):String = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$App")
opr DOT(a:String, b:()):String = a "()"
opr juxtaposition(a:String, b:()):String = a "()"
opr DOT(a:String, b:(Any,Any)):String = do (i,j) = b; a "(" i "," j ")" end
opr juxtaposition(a:String, b:(Any,Any)):String =
    do (i,j) = b; a "(" i "," j ")" end
opr juxtaposition(a:String, b:(Any,Any,Any)):String =
    do (i,j,k) = b; a "(" i "," j "," k ")" end
opr DOT(a:(), b:String):String = "()" b
opr juxtaposition(a:(), b:String):String = "()" b
opr DOT(a:Any, b:String):String = ("" a) b
opr juxtaposition(a:Any, b:String):String = ("" a) b
opr DOT(a:String, b:Any):String = a b.toString()
opr juxtaposition(a:String, b:Any):String = a b.toString()

print(a:String):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Print")
println(a:String):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Println")
print(a:Number):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Print")
println(a:Number):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Println")
print(a:Boolean):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Print")
println(a:Boolean):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Println")
println(a:Char):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$Println")
print(a:Any):() = print("" a)
println(a:Any):() = println("" a)
(* 0-argument versions handle passing of () to single-argument versions. *)
print():() = print("()")
println():() = println("")

(* These are useful temporary hacks for debugging multi-threaded programs *)
printThreadInfo(a:String):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$PrintThreadInfo")
printThreadInfo(a:Number):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$PrintThreadInfo")
throwError(a:String):() = builtinPrimitive("com.sun.fortress.interpreter.glue.prim.StringPrim$ThrowError")

opr SEQV(a:Any, b:Any):Boolean =
    builtinPrimitive("com.sun.fortress.interpreter.glue.prim.AnyPrim$SEquiv")

opr  OR(a:Boolean, b:Boolean):Boolean = if a then true else b end
opr AND(a:Boolean, b:Boolean):Boolean = if a then b else false end
opr  OR(a:Boolean, b:()->Boolean):Boolean = if a then true else b() end
opr AND(a:Boolean, b:()->Boolean):Boolean = if a then b() else false end
opr NOT(a:Boolean):Boolean = if a then false else true end
opr ->(a: Boolean, b:Boolean):Boolean = if a then b else true end
opr ->(a: Boolean, b:()->Boolean):Boolean = if a then b() else true end
opr <->(a: Boolean, b:Boolean):Boolean = a=b

true : Boolean = () SEQV ()
false : Boolean = true SEQV ()

opr +[\T extends Number\](x:T):T = x

opr =[\A,B\](t1:(A,B), t2:(A,B)): Boolean = do
    (a1,b1) = t1
    (a2,b2) = t2
    (a1=a2) AND: (b1=b2)
  end

opr <[\A,B\](t1:(A,B), t2:(A,B)): Boolean = do
    (a1,b1) = t1
    (a2,b2) = t2
    typecase _ = a1 CMP a2 of
        LessThan => true
        EqualTo => b1 < b2
        GreaterThan => false
    end
  end

opr <=[\A,B\](t1:(A,B), t2:(A,B)): Boolean = do
    (a1,b1) = t1
    (a2,b2) = t2
    typecase _ = a1 CMP a2 of
        LessThan => true
        EqualTo => b1 <= b2
        GreaterThan => false
    end
  end

opr >[\A,B\](t1:(A,B), t2:(A,B)): Boolean = do
    (a1,b1) = t1
    (a2,b2) = t2
    typecase _ = a1 CMP a2 of
        LessThan => false
        EqualTo => b1 > b2
        GreaterThan => true
    end
  end

opr >=[\A,B\](t1:(A,B), t2:(A,B)): Boolean = do
    (a1,b1) = t1
    (a2,b2) = t2
    typecase _ = a1 CMP a2 of
        LessThan => false
        EqualTo => b1 >= b2
        GreaterThan => true
    end
  end

opr CMP[\A,B\](t1:(A,B), t2:(A,B)): Boolean = do
    (a1,b1) = t1
    (a2,b2) = t2
    (a1 CMP a2) LEXICO: (b1 CMP b2)
  end

opr =[\A,B,C\](t1:(A,B,C), t2:(A,B,C)): Boolean = do
    (a1,b1,c1) = t1
    (a2,b2,c2) = t2
    (a1=a2) AND: (b1=b2) AND: (c1=c2)
  end

opr <[\A,B,C\](t1:(A,B,C), t2:(A,B,C)): Boolean = do
    (a1,b1,c1) = t1
    (a2,b2,c2) = t2
    typecase _ = (a1 CMP a2) LEXICO: (b1 CMP b2) of
        LessThan => true
        EqualTo => c1 < c2
        GreaterThan => false
    end
  end

opr <=[\A,B,C\](t1:(A,B,C), t2:(A,B,C)): Boolean = do
    (a1,b1,c1) = t1
    (a2,b2,c2) = t2
    typecase _ = (a1 CMP a2) LEXICO: (b1 CMP b2) of
        LessThan => true
        EqualTo => c1 <= c2
        GreaterThan => false
    end
  end

opr >[\A,B,C\](t1:(A,B,C), t2:(A,B,C)): Boolean = do
    (a1,b1,c1) = t1
    (a2,b2,c2) = t2
    typecase _ = (a1 CMP a2) LEXICO: (b1 CMP b2) of
        LessThan => false
        EqualTo => c1 > c2
        GreaterThan => true
    end
  end

opr >=[\A,B,C\](t1:(A,B,C), t2:(A,B,C)): Boolean = do
    (a1,b1,c1) = t1
    (a2,b2,c2) = t2
    typecase _ = (a1 CMP a2) LEXICO: (b1 CMP b2) of
        LessThan => false
        EqualTo => c1 >= c2
        GreaterThan => true
    end
  end

opr CMP[\A,B,C\](t1:(A,B,C), t2:(A,B,C)): Boolean = do
    (a1,b1,c1) = t1
    (a2,b2,c2) = t2
    (a1 CMP a2) LEXICO: (b1 CMP b2) LEXICO: (c1 CMP c2)
  end

end
