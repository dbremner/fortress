(*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component String
import List.{...}
import JavaString.{...}
export String

(* fib is an array of Fibonacci numbers.   We start with 
    fib[0] = 0 so that the empty string does not have to be a special case. *)
  fib = do
    maxFib = 46         (* fib(47) > maximum ZZ32 *)
    a: Array1⟦ZZ32, 0, 47⟧ = array1⟦ZZ32, 47⟧()
    a[0] := 0
    a[1] := 1
    a[n] := a[n-2] + a[n-1], n ← seq(2:maxFib)
    a
  end

(*
==== Shared Traits ====
*)

  trait Concatenable extends String
    opr || (self, other:String): String =
        if |other| = 0 then self else concatAndBalanceIfNecessary(self, other) end
    opr || (self, _:EmptyString): String = self
    opr || (self, other:Char) = concatAndBalanceIfNecessary(self, other.asString)
    
  end Concatenable

  trait Balanceable extends String
    getter isBalanced() = self.depth ≤ 46 AND: |self| ≥ fib[self.depth]
    getter isAlmostBalanced() = self.depth ≤ 48 AND: |self| ≥ fib[self.depth-2]
    getter isExtremelyUnbalanced() = self.depth > 45
  end Balanceable
  
  trait StringDebug extends String
    getter asDebugString(): String = asDebugStringIndented(0)
    abstract asDebugStringIndented(indent: ZZ32): String
  end

(*
==== CatString ====
*)

(* Factory *)

    concatAndBalanceIfNecessary(s1: String, s2: String) = do
        result = CatString(s1, s2)
        if result.isExtremelyUnbalanced 
            then result.balanced()
            else result
        end
      end

(* Object *)
        
  object CatString(left: String, right:String)  extends {Concatenable, Balanceable, StringDebug}
    size = left.size + right.size
    depthField = 1 + (left.depth MAX right.depth)
    getter depth() = depthField
    getter bounds() = 0#size
    getter generator() = ConcatGenerator(left.generator, right.generator)
    getter asJavaString() = javaAppend(left.asJavaString, right.asJavaString)
    getter asExprString() = left.asExprString.allButLast() || right.asExprString.allButFirst 

    opr ∈ (c:Char, self): Boolean = (c IN left) OR (c IN right)

    opr CMP(self, other: String) 
    (*) ensures {outcome = (self.asJavaString CMP other.asJavaString)} 
    = do
      result =
        if |left| ≥ |other|
        then
            (left CMP other) LEXICO: (|self| CMP |other|)
        else
            (left CMP other[0#|left|]) LEXICO: (right CMP other[(|left|):]) LEXICO: (|self| CMP |other|)
        end
      if result ≠ (self.asJavaString CMP other.asJavaString) then
        println "Callee Failure, self = " self.asDebugString ", CMP other = " other.asDebugString
        println "result = " result
      end
      result
    end

    opr CASE_INSENSITIVE_CMP(self, other:String): TotalComparison 
    (*) ensures {outcome = (self.asJavaString CASE_INSENSITIVE_CMP other.asJavaString)} 
    =
        if |left| ≥ |other|
        then
            left CASE_INSENSITIVE_CMP other
        else
            (left CASE_INSENSITIVE_CMP other[0#|left|]) LEXICO: (right CASE_INSENSITIVE_CMP other[(|left|):])
        end

    (* get is, and should be, without bounds checks.  [ ] does the bounds checks,
        and then delegates to get *)
    get(i): Char =
        if i ∈ left.indices then left[i] else right[i - |left|] end

    verify() = do
        assert(self.depth, (left.depth MAX right.depth) + 1, self)
        assert(self.size(), |left| + |right|, self)
    end


    asDebugStringIndented(indent: ZZ32): String = 
        (spaces(indent) || self.balanceIndicator() || "C" || self.size "/" self.depth || ":")  //
        left.asDebugStringIndented(indent+8) //
        right.asDebugStringIndented(indent+8)

    balanceIndicator() = if self.isBalanced then "B" elif self.isAlmostBalanced then "b" else "u" end

    uncheckedSubstring(r0: Range⟦ZZ32⟧) = label method
        (* printlnWithThread ("CatString.uncheckedSubstring " self "[" r0 "]").asJavaString *)
        if r0.isEmpty then exit method with EmptyString end
        if r0 = self.bounds then exit method with self end
        leftBounds' = r0 ∩ left.bounds
        rightBounds' = (r0 ≪ left.size) ∩ right.bounds
        if leftBounds'.isEmpty then
            exit method with right.uncheckedSubstring(rightBounds')
        end
        if rightBounds'.isEmpty then
            exit method with left.uncheckedSubstring(leftBounds')
        end
        SubString(self, r0)
    end method

    writeOn(stream): () = do
        stream.write(left)
        stream.write(right)
    end

    splitWithOffsets(): Generator⟦(ZZ32, String)⟧ = ⟨⟦(ZZ32, String)⟧ (0, left), (|left|, right) ⟩
    split(): Generator⟦String⟧ =  ⟨⟦String⟧ piece | (_, piece) ← self.splitWithOffsets() ⟩
    
    balanced() 
    (*) ensures {outcome = self ∧ outcome.isAlmostBalanced} 
    =
      label method
        if self.isBalanced then exit method with self end
        forest = BalancingForest()
        forest.add(self.left)
        forest.add(self.right)
        forest.contents
      end method
  end CatString

  object BalancingForest()
    balanceDebug = false
    var cumulativeSize: ZZ32 := 0
    var sequence: Array1⟦String, 0, 47⟧ := array1⟦String, 47⟧(EmptyString)
    (* invariant { BIG ∧ [ i ← sequence.indices ]
        |sequence[i]| = 0 ∨  fib[i] ≤ |sequence[i]| < fib[i+1]  } *)

    getter contents() 
    (*) ensures { |outcome| = cumulativeSize } 
    = do
        (* We could do this all with a BIG || of a sequential generator.
            That would preclude the possibility of a short-circuit evaluation.
            We could also use a concurrent generator, which would usually balance,
            depending on the whim of the scheduler ...
            Which is best? *)
        var  i: ZZ32 = 1
        var result: String = EmptyString
        while result.size < cumulativeSize do
            result := sequence[i] || result
            i := i + 1
        end
        result
    end

    showSequence() = if balanceDebug then
        for i ← seq(sequence.indices.flip) do
            if sequence[i].nonEmpty then
                println "sequence[" i "] ="  sequence[i].asDebugString
            end
        end
      end

    addWholeSubtree(s: String) =
      do
        (* adds s to this BalancingForest, maintaining the invariant that the concatenation
        of the elements of sequence is equal to the concatenation of all of the Strings s
        added to self *)
        cumulativeSize := cumulativeSize + |s|
        var i: ZZ32 = 0
        var sum: String = EmptyString
        while  |s| > fib[i] do
            if sequence[i] ≠ EmptyString then
                sum := sequence[i] || sum
                sequence[i] := EmptyString
            end
            i := i + 1
        end
        sum := sum || s
        while |sum| ≥ fib[i] do
            if sequence[i] ≠ EmptyString then
                sum := sequence[i] || sum
                sequence[i] := EmptyString
            end
            i := i + 1
        end
        sequence[i-1] := sum
      end

    add(s: JavaString) =
      do
        self.addWholeSubtree(s)
        if balanceDebug then
            print "added J\"" s "\", "
            self.showSequence()
        end
      end

    add(s: CatString)  =
      do
        if s.isBalanced then
            self.addWholeSubtree(s)
        else
            self.add(s.left)
            self.add(s.right)
        end
        if balanceDebug then
            print "added C\"" s "\", "
            self.showSequence()
        end
      end

    add(s: EmptyString) =
      do end

    add(s: SubString) =
        self.addWholeSubtree(s.balanced)

  end BalancingForest

  object ConcatGenerator⟦T⟧(first:Generator⟦T⟧, second:Generator⟦T⟧)
        extends Generator⟦T⟧
    generate⟦R⟧(r: Reduction⟦R⟧, body:T→R):R =
        r.join(first.generate⟦R⟧(r, body), second.generate⟦R⟧(r, body))
  end ConcatGenerator

(*
==== EmptyString ====
*)

  value object EmptyString extends {String, Concatenable, StringDebug}
    getter size() = 0
    getter bounds() = 0#0
    getter depth() = 0
    getter isEmpty() = true
    getter generator() = Nothing⟦Char⟧
    getter asJavaString() = ""
    getter asExprString() = "\"\""
    
    asDebugStringIndented(indent: ZZ32) = spaces(indent) "E" |self| "/" self.depth

    opr ∈ (c:Char, self): Boolean = false
    rangeContains(r: Range⟦ZZ32⟧, c: Char) = false

    opr CMP(self, other: String): TotalComparison =
        |self| CMP |other|
    opr CASE_INSENSITIVE_CMP(self, other:String): TotalComparison =
        |self| CMP |other|

    get(i): Char =
        throw IndexOutOfBounds("Can't get characters from an empty string")

    opr[r: Range⟦ZZ32⟧]: String = do
        rr = self.bounds[r]     (* to raise a bounds error *)
        EmptyString
    end

    verify() = do
        assert(self.depth, 0, self)
        assert(self.size, 0, self)
    end

    uncheckedSubstring(r0: Range⟦ZZ32⟧) 
    (*) requires { r0.isEmpty }
    =
        (* This method should execute only after a bounds check has
        passed, so we know that r0 must be empty! *)
        self

    opr || (self, other:String): String = other
    opr || (self, other:Char) = other.asString

    print(self): () = do end
    println(self): () = println("")
    writeOn(stream): () = do end

    splitWithOffsets() = Nothing⟦Generator⟦(ZZ32, String)⟧⟧

  end EmptyString
  
test stringifyChars() = do
    f:Char = 'f'
    println f.asString
    assert(f.asString, "f")
    println f.asExprString
    assert(f.asExprString, "'f'")
    println '\"'.asExprString
    assert('\"'.asExprString, "'\\\"'")
    println f.asDebugString
    assert(f.asDebugString, "a Char: f")
end

(*
==== SubString ====
*)

  object SubString(baseString: String, range: Range⟦ZZ32⟧) extends  {Concatenable, StringDebug}
    getter size() = range.size
    getter depth() = baseString.depth    (* We pretend that substring nodes don't add depth *)
    getter isEmpty() = false    (* Because we take care never to construct an empty SubString *)
    getter asJavaString() = baseString.asJavaString.uncheckedSubstring(range)
    getter asExprString() = self.asJavaString.asExprString
    getter isBalanced() = baseString.isBalanced

    balanced() =
        if self.isBalanced then self
        else baseString.balanced.uncheckedSubstring(range)
        end

    opr CMP(self, other: String) 
    (*) ensures { outcome = (self.asJavaString CMP other.asJavaString) } 
    = do
        pieces = baseString.splitWithOffsets()
        (if pieces.nonEmpty  then
            BIG LEXICO [(start, str) ← pieces] (do
                    baseSubrange = (start#|str|) ∩ range
                    baseString.uncheckedSubstring(baseSubrange) CMP 
                        other.uncheckedSubstring((baseSubrange≪range.lower) ∩ other.indices)
            end)
        else
            otherPieces = other.splitWithOffsets()
            if otherPieces.nonEmpty then
                (*) println "doing backwards comparison ... "
                BIG LEXICO [(start, str) ← otherPieces] (do
                        baseSubrange = ((start#|str|) ∩ self.indices) ≫ range.lower
                        baseString.uncheckedSubstring(baseSubrange) CMP str
                end)
            else
                  (self asif String) CMP (other asif String)
            end
        end) LEXICO (|self| CMP |other|)
    end

    opr CASE_INSENSITIVE_CMP(self, other: String) 
    (*) ensures { outcome = (self.asJavaString CASE_INSENSITIVE_CMP other.asJavaString) } 
    = do
        pieces = baseString.splitWithOffsets()
        (if pieces.nonEmpty  then
            BIG LEXICO [(start, str) ← pieces] (do
                    baseSubrange = (start#|str|) ∩ range
                    baseString.uncheckedSubstring(baseSubrange) CASE_INSENSITIVE_CMP
                        other.uncheckedSubstring((baseSubrange≪range.lower) ∩ other.indices)
            end)
        else
            otherPieces = other.splitWithOffsets()
            if otherPieces.nonEmpty then
                (*) println "doing backwards comparison ... "
                BIG LEXICO [(start, str) ← otherPieces] (do
                        baseSubrange = ((start#|str|) ∩ self.indices) ≫ range.lower
                        baseString.uncheckedSubstring(baseSubrange) CASE_INSENSITIVE_CMP str
                end)
            else
                (self asif String) CASE_INSENSITIVE_CMP (other asif String)
            end
        end) LEXICO (|self| CMP |other|)
    end

    opr ∈ (c: Char, self): Boolean =  label inOpr
        pieces = baseString.splitWithOffsets()
        if pieces.nonEmpty  then
            BIG ∨ [(start, str) ← pieces] (do
                    baseSubrange = (start#|str|) ∩ range
                    baseSubrange.nonEmpty AND: str.rangeContains(baseSubrange ≪ start, c)
                end)
        else
            baseString.rangeContains(range, c)
        end
    end inOpr

    rangeContains(r: Range⟦ZZ32⟧, c: Char) =
        baseString.rangeContains((r ≫ range.lower) ∩ range, c)

    verify() = label methodVerify
        baseString.verify()
        deny(baseString.isEmpty)
        deny(range.isEmpty, "SubString (" range ") has empty range")
        deny(range = baseString.bounds, true, "SubString ", baseString, range, " has range equal to that of baseString ", baseString.bounds)
        assert(range < baseString.bounds, true,
                "SubString ", baseString,  range, " has range greater than that of baseString ", baseString.bounds )
        typecase s = baseString of
            CatString ⇒ do 
                            deny((s.left.indices ∩ range).isEmpty, 
                                        "SubString of CatString not pushed right")
                            deny(((s.right.indices ≫ s.left.size) ∩ range).isEmpty, 
                                        "SubString of CatString not pushed left")
                end
            EmptyString ⇒ fail "SubString of EmptyString"
            SubString ⇒ fail "SubString of SubString"
        end
    end methodVerify

    asDebugStringIndented(indent: ZZ32) : String = 
        (spaces(indent) ||  "S" |self| "= [" range.asExprString "]") //
        baseString.asDebugStringIndented(indent + 8)

    splitWithOffsets(): Generator⟦(ZZ32, String)⟧ = do
    (* The pairs (start, str) that are generated are such that start[0] = 0 and start[i] = (str[0] || ... || str[i-1]).size
      and str[0] || str [1] || ... || str[n] = self
    *)
        pieces = baseString.splitWithOffsets()
        offset = range.lower
        if  pieces.nonEmpty then
            ⟨⟦(ZZ32, String)⟧ if (start#piece.size) ≤ range then
                    (start-offset, piece) asif (ZZ32, String)
                else
                    range' = range ∩ (start#piece.size)
                    (range'.lower-offset, SubString(piece, range'≪start)) asif (ZZ32, String)
                end | (start, piece) ← pieces,   (range ∩ (start#piece.size)).nonEmpty ⟩
        else
            Nothing⟦Generator⟦(ZZ32,String)⟧⟧
        end
    end

    get(i:ZZ32) = do
        (*) assert(i < range.size, "getting char " i " from a substring of size " |range|)
        baseString.get(range.lower+i)
    end

    uncheckedSubstring(r0: Range⟦ZZ32⟧) = do
        assert((r0≫range.lower) ≤ range, true, "asking for substring [",  r0, "] of S", self.size, " = ", self.asJavaString)
        if r0.isEmpty then EmptyString
        elif r0 = self.bounds then self
        else baseString.uncheckedSubstring(r0≫range.lower)
        end
    end

    writeOn(stream) = do
        pieces = baseString.splitWithOffsets()
        if pieces.nonEmpty  then
            for (start, str) ← pieces do
                    baseSubrange = (start#|str|) ∩ range
                    baseString.uncheckedSubstring(baseSubrange).writeOn(stream)
            end
        else
            for i ← range do
                        stream.write baseString.get(i)
            end
        end
    end

  end SubString

  object StringStats()
            var minFlat: ZZ32 := 1000000
            var maxFlat: ZZ32 := 0
            var numFlat: ZZ32 := 0

        collectStatsFor(s: CatString) = do
            self.collectStatsFor(s.left)
            self.collectStatsFor(s.right)
        end

        collectStatsFor(s: JavaString) = do
            minFlat := |s| MIN minFlat
            maxFlat := |s| MAX maxFlat
            numFlat := numFlat + 1
        end

        collectStatsFor(s: SubString) = do
            self.collectStatsFor(s.baseString)
        end

  end StringStats

  printStats(s: String): () = label methodPrintStats
        stats = StringStats()
        stats.collectStatsFor(s)
        print  "size = " |s| "; depth = " s.depth "; maxFlat = " stats.maxFlat
        print  "; minFlat = " stats.minFlat "; avFlat = " (|s| / (stats.numFlat asif Number))
        println  "; numFlat = " stats.numFlat
  end methodPrintStats

  spaces(indent: ZZ32): String 
  (*) ensures { |outcome| = indent} 
  = do
      spaceString = "                    "
      var result: String := EmptyString
      remainder: ZZ32  := indent
      while remainder > 0 do
        if remainder ≤ |spaceString| then
            result := result || spaceString[#remainder]
            remainder := 0
        else
            result := result || spaceString
            remainder := remainder - |spaceString| 
        end
      end (* do *)
      result
  end

end
