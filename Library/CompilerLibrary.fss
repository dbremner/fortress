(*******************************************************************************
    Copyright 2009 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************)

component CompilerLibrary
import CompilerBuiltin.{...}
(*) import java com.sun.fortress.nativeHelpers.equality.SEQV => jSEQV
export CompilerLibrary


(************************************************************
 * Value bindings
 ************************************************************)

(************************************************************
 * Simple Combinators
 ************************************************************)

(** Useful functions *)

ignore(_:Any):() = ()

(************************************************************
 * Control over locality and location
 ************************************************************)

(*) isShared(x:Any): Boolean = true

(************************************************************
 * Equality and ordering
 ************************************************************)

(*) opr =(a:Any, b:Any):Boolean = a SEQV b

(*) opr =/=(a:Any, b:Any):Boolean = NOT (a=b)

(*
(** Assertion *)
assert(flag:Boolean): () =
    if NOT flag then
        fail("Assertion failed!")
    end

assert(flag: Boolean, failMsg: String): () =
    if NOT flag then
        fail(failMsg)
    end


assert(x:Any, y:Any, failMsg: Any...): () =
    if x =/= y then
        msg = x.asDebugString " =/= " y.asDebugString "; " (BIG || failMsg)  (* use || here instead of loose juxt *)
        fail(msg)
    end
*)

(*
deny(flag:Boolean): () = assert(NOT flag)

deny(flag: Boolean, failMsg: String): () = assert(NOT flag, failMsg)


deny(x:Any, y:Any, failMsg: Any...): () =
    if x = y then
        msg = x.asDebugString " = " y.asDebugString "; " (BIG || failMsg)
        fail(msg)
    end
*)

(************************************************************
* Exception hierarchy
************************************************************)
trait Exception comprises { UncheckedException, CheckedException }
end

(* Exceptions which are not checked *)

trait UncheckedException extends Exception excludes CheckedException
end

(*
object FailCalled(s:String) extends UncheckedException
    getter asString(): String = "FAIL: " s
end

object DivisionByZero extends UncheckedException
    getter asString(): String = "Division by zero"
end

object UnpastingError extends UncheckedException
    getter asString(): String = "Unpasting error"
end

object CallerViolation extends UncheckedException
    getter asString(): String = "Caller violation"
end

object CalleeViolation extends UncheckedException
    getter asString(): String = "Callee violation"
end

object LabelException extends UncheckedException
    getter asString(): String = "Exiting without an enclosing label block"
end

object TestFailure extends UncheckedException
    getter asString(): String = "Test failure"
end

object ContractHierarchyViolation extends UncheckedException
    getter asString(): String = "Contract hierarchy violation"
end

object NoEqualityOnFunctions extends UncheckedException
    getter asString(): String = "No equality on functions"
end

object InvalidRange extends UncheckedException
    getter asString(): String = "Invalid range"
end

object ForbiddenException(chain : Exception) extends UncheckedException
    getter asString(): String = "Forbidden exception"
end

(* Should this be called "IndexNotFound" instead? *)
object NotFound extends UncheckedException
    getter asString(): String = "Not found"
end

object IndexOutOfBounds[\I\](range:Range[\I\],index:I) extends UncheckedException
    getter asString(): String = index " is outside the range " range
end

object EmptyReduction extends UncheckedException
    getter asString(): String = "EmptyReduction: no identity, no elements"
end

object NegativeLength extends UncheckedException
    getter asString(): String = "Negative length"
end

object IntegerOverflow extends UncheckedException
    getter asString(): String = "Integer Overflow"
end

object RationalComparisonError extends UncheckedException
    getter asString(): String = "Rational comparison error"
end

object FloatingComparisonError extends UncheckedException
    getter asString(): String = "Floating comparison error"
end
*)

(* Checked Exceptions *)

trait CheckedException extends Exception excludes UncheckedException
end

(*
object CastError extends CheckedException
    getter asString(): String = "Cast error"
end

object IOFailure extends CheckedException
    getter asString(): String = "I/O error"
end

object MatchFailure extends CheckedException
    getter asString(): String = "Match failure"
end

(* SetsNotDisjoint? *)
object DisjointUnionError extends CheckedException
    getter asString(): String = "Disjoint union error"
end

object APIMissing extends CheckedException
    getter asString(): String = "Api is missing"
end

object APINameCollision extends CheckedException
    getter asString(): String = "Api name collides with another"
end

object ExportedAPIMissing extends CheckedException
    getter asString(): String = "Exported api is missing"
end

object HiddenAPIMissing extends CheckedException
    getter asString(): String = "Hidden api is missing"
end

object TryAtomicFailure extends CheckedException
    getter asString(): String = "Try/atomic failure"
end

(* Should take a spawned thread as an argument *)
object AtomicSpawnSynchronization extends {UncheckedException}
    getter asString(): String = "Atomic spawn synchronization"
end
*)

(*
opr SEQV(a:Any, b:Any) = jSEQV(a,b)
*)

opr OR(a:Boolean, b:Boolean):Boolean = if a then a else b end
opr AND(a:Boolean, b:Boolean):Boolean = if a then b else a end
opr OR(a:Boolean, b:()->Boolean):Boolean = if a then a else b() end
opr AND(a:Boolean, b:()->Boolean):Boolean = if a then b() else a end
opr NOT(a:Boolean):Boolean = if a then false else true end
opr ->(a: Boolean, b:Boolean):Boolean = if a then b else true end
opr ->(a: Boolean, b:()->Boolean):Boolean = if a then b() else true end
opr XOR(a:Boolean, b:Boolean):Boolean = if a then NOT b else b end
opr <->(a: Boolean, b:Boolean):Boolean = if a then b else NOT b end

(************************************************************
 * Simple Range support
 ************************************************************)

trait GeneratorZZ32 excludes { Boolean }
    getter asString(): String
    seq(self): SeqGeneratorZZ32 = SeqGenZZ32(self)
    loop(body:ZZ32->()): ()
    generate(r: ReductionString, body: ZZ32->String): String
    seqloop(body:ZZ32->()): ()
    seqgenerate(r: ReductionString, body: ZZ32->String): String
    filter(f: ZZ32 -> Boolean): GeneratorZZ32
    opr IN(x:ZZ32, self): Boolean = false
end

opr =(left:GeneratorZZ32, right:GeneratorZZ32): Boolean = false

trait SeqGeneratorZZ32 extends GeneratorZZ32
    getter asString(): String
    seq(self): SeqGeneratorZZ32 = self
    loop(body:ZZ32->()): () = seqloop(body)
    generate(r: ReductionString, body: ZZ32->String): String = seqgenerate(r, body)
    seqloop(body:ZZ32->()): () = loop(body)
    seqgenerate(r: ReductionString, body: ZZ32->String): String = generate(r,body)
    filter(f: ZZ32 -> Boolean): SeqGeneratorZZ32
end

__loop(g: GeneratorZZ32, body: ZZ32->()): () = g.loop(body)

__bigOperator(o:ReductionString,
              desugaredClauses:(ReductionString, String->String)->String): String =
    desugaredClauses(o,fn (s:String):String => s)

__generate(g: GeneratorZZ32, r: ReductionString, f:ZZ32->String): String =
    g.generate(r,f)
__generate(p: Boolean, r: ReductionString, f:()->String): String =
    if p then f() else r.empty() end


object SeqGenZZ32(g: GeneratorZZ32) extends SeqGeneratorZZ32
    getter asString(): String = "seq(" g.asString ")"
    seq(self): SeqGeneratorZZ32 = self
    loop(body:ZZ32->()): () = g.seqloop(body)
    generate(r: ReductionString, body: ZZ32->String): String = g.seqgenerate(r, body)
    seqloop(body:ZZ32->()): () = g.seqloop(body)
    seqgenerate(r: ReductionString, body: ZZ32->String): String =
        g.seqgenerate(r,body)
    filter(f: ZZ32 -> Boolean): SeqGeneratorZZ32 = seq(g.filter(f))
end

opr PAR(a:(), b:()): () = ()

parloop(lo:ZZ32, hi:ZZ32, p:ZZ32->Boolean, body:ZZ32->()): () =
    if lo=hi then
        if p(lo) then body(lo) end
    else
        mid = (lo+hi) DIV 2
        parloop(lo, mid, p, body) PAR parloop(mid+1, hi, p, body)
    end

countedseqloop(lo:ZZ32, hi:ZZ32, p:ZZ32->Boolean, body:ZZ32->()): () =
    if lo=hi then
        if p(lo) then body(lo) end
    else
        mid = (lo+hi) DIV 2
        countedseqloop(lo, mid, p, body)
        countedseqloop(mid+1, hi, p, body)
    end

gen(lo:ZZ32, hi:ZZ32, p: ZZ32->Boolean, r:ReductionString, body: ZZ32->String): String =
    if lo=hi then
        if p(lo) then body(lo) else r.empty() end
    else
        mid = (lo+hi) DIV 2
        r.join(gen(lo, mid, p, r, body), gen(mid+1, hi, p, r, body))
    end

seqgen(lo:ZZ32, hi:ZZ32, p: ZZ32->Boolean, r:ReductionString, body: ZZ32->String): String =
    if lo=hi then
        if p(lo) then body(lo) else r.empty() end
    else
        mid = (lo+hi) DIV 2
        left = seqgen(lo, mid, p, r, body)
        right = seqgen(mid+1, hi, p, r, body)
        r.join(left, right)
    end

object FilteredRange(lo: ZZ32, hi:ZZ32, p: ZZ32 -> Boolean) extends GeneratorZZ32
    getter asString(): String = "filtered(" lo.asString ":" hi.asString ")"
    seq(self): SeqGeneratorZZ32 = SeqGenZZ32(self)
    loop(body:ZZ32->()): () = if lo > hi then () else parloop(lo,hi,p,body) end
    seqloop(body:ZZ32->()): () = if lo > hi then () else countedseqloop(lo,hi,p,body) end
    generate(r: ReductionString, body: ZZ32->String): String =
        if lo > hi then r.empty() else gen(lo,hi,p,r,body) end
    seqgenerate(r: ReductionString, body: ZZ32->String): String =
        if lo > hi then r.empty() else seqgen(lo,hi,p,r,body) end
    filter(q: ZZ32 -> Boolean): FilteredRange =
        FilteredRange(lo, hi, fn n => p(n) AND: q(n))
end

opr :(lo:ZZ32, hi:ZZ32): GeneratorZZ32 = FilteredRange(lo, hi, fn (n) => true)
opr #(lo:ZZ32, sz:ZZ32): GeneratorZZ32 = lo : (lo+sz-1)

trait ReductionString
    empty(): String
    join(a: String, b: String): String
end

object StringConcatenation extends ReductionString
    empty(): String = ""
    join(a: String, b: String): String = a || b
end

(*
opr BIG ||(): StringConcatenation = StringConcatenation
*)

end
