(*******************************************************************************
    Copyright 2008,2011, Oracle and/or its affiliates.
    All rights reserved.


    Use is subject to license terms.

    This distribution may include materials developed by third parties.

 ******************************************************************************)

component CompilerLibrary
(*
import java com.sun.fortress.nativeHelpers.{LocalRandom.localRandomDouble => jRandomDouble,
                                            LocalRandom.localRandomInt => jRandomInt }
*)
import CompilerBuiltin.{...}
import CompilerAlgebra.{...}
import java com.sun.fortress.nativeHelpers.{equality.sEquiv => jSEQUIV}
export CompilerLibrary


(************************************************************
 * Value bindings
 ************************************************************)

(************************************************************
 * Simple Combinators
 ************************************************************)

(** Useful functions *)

ignore(_: Any): () = ()

identity[\T extends Any\](x: T): T = x

(************************************************************
 * Control over locality and location
 ************************************************************)

(*) isShared(x:Any): Boolean = true

(************************************************************
 * Equality and ordering
 ************************************************************)

(* This is incomplete *)
opr ===(a:Any, b:Any):Boolean = jSEQUIV(a,b)
opr ===(a:ZZ64, b:ZZ64):Boolean = a=b
opr ===(a:ZZ32, b:ZZ32):Boolean = a=b
opr ===(a:RR64, b:RR64):Boolean = a=b
opr ===(a:RR32, b:RR32):Boolean = a=b
opr ===(a:String, b:String):Boolean = a=b
opr ===(a:Boolean, b:Boolean):Boolean = a<->b

opr NEQV(a:Any, b:Any):Boolean = NOT (a === b)

fail(s: String): None = do
    errorPrintln("FAIL: " s)
    throw FailCalled(s)
end


(** Assertion *)
assert(flag: Boolean): () =
    if NOT flag then
        fail("Assertion failed!")
    end

assert(flag: Boolean, failMsg: String): () =
    if NOT flag then
        fail(failMsg)
    end

(*
assert(x: Any, y: Any, failMsg: Any...): () =
    if x =/= y then
        msg = x.asDebugString " =/= " y.asDebugString "; " (BIG || failMsg)  (* use || here instead of loose juxt *)
        fail(msg)
    end
*)


deny(flag: Boolean): () = assert(NOT flag)

deny(flag: Boolean, failMsg: String): () = assert(NOT flag, failMsg)

(*
deny(x: Any, y: Any, failMsg: Any...): () =
    if x = y then
        msg = x.asDebugString " = " y.asDebugString "; " (BIG || failMsg)
        fail(msg)
    end
*)

(************************************************************
* Exception hierarchy
************************************************************)

(*) The upper parts of the exception hierarchy are in CompilerBuiltin:
(*)  Exception
(*)    UncheckedException
(*)    CheckedException
(*)      IOException
(*)        IOFailure
(*)        FileNotFoundException

object FailCalled(s:String) extends UncheckedException
    getter asString(): String = "FAIL: " s
end

object DivisionByZero extends UncheckedException
    getter asString(): String = "Division by zero"
end

object UnpastingError extends UncheckedException
    getter asString(): String = "Unpasting error"
end

object CallerViolation extends UncheckedException
    getter asString(): String = "Caller violation"
end

object CalleeViolation extends UncheckedException
    getter asString(): String = "Callee violation"
end

object LabelException extends UncheckedException
    getter asString(): String = "Exiting without an enclosing label block"
end

object TestFailure extends UncheckedException
    getter asString(): String = "Test failure"
end

object ContractHierarchyViolation extends UncheckedException
    getter asString(): String = "Contract hierarchy violation"
end

object NoEqualityOnFunctions extends UncheckedException
    getter asString(): String = "No equality on functions"
end

object InvalidRange extends UncheckedException
    getter asString(): String = "Invalid range"
end

object ForbiddenException(chain : Exception) extends UncheckedException
    getter asString(): String = "Forbidden exception"
end

(* Should this be called "IndexNotFound" instead? *)
object NotFound extends UncheckedException
    getter asString(): String = "Not found"
end

(*
object IndexOutOfBounds[\I\](range:Range[\I\],index:I) extends UncheckedException
    getter asString(): String = index " is outside the range " range
end
*)

object EmptyReduction extends UncheckedException
    getter asString(): String = "EmptyReduction: no identity, no elements"
end

object RationalComparisonError extends UncheckedException
    getter asString(): String = "Rational comparison error"
end

object FloatingComparisonError extends UncheckedException
    getter asString(): String = "Floating comparison error"
end


(* Checked Exceptions *)

(*
object CastError extends CheckedException
    getter asString(): String = "Cast error"
end

object MatchFailure extends CheckedException
    getter asString(): String = "Match failure"
end

(* SetsNotDisjoint? *)
object DisjointUnionError extends CheckedException
    getter asString(): String = "Disjoint union error"
end

object APIMissing extends CheckedException
    getter asString(): String = "Api is missing"
end

object APINameCollision extends CheckedException
    getter asString(): String = "Api name collides with another"
end

object ExportedAPIMissing extends CheckedException
    getter asString(): String = "Exported api is missing"
end

object HiddenAPIMissing extends CheckedException
    getter asString(): String = "Hidden api is missing"
end

object TryAtomicFailure extends CheckedException
    getter asString(): String = "Try/atomic failure"
end

(* Should take a spawned thread as an argument *)
object AtomicSpawnSynchronization extends {UncheckedException}
    getter asString(): String = "Atomic spawn synchronization"
end
*)

(*
opr SEQV(a:Any, b:Any) = jSEQV(a,b)
*)

(************************************************************
 * Simple Range support
 ************************************************************)

trait GeneratorZZ32 excludes { Boolean }
    getter asString(): String
    seq(self): SeqGeneratorZZ32 = SeqGenZZ32(self)
    loop(body:ZZ32->()): ()
    generate(r: ReductionString, body: ZZ32->String): String
    seqloop(body:ZZ32->()): ()
    seqgenerate(r: ReductionString, body: ZZ32->String): String
    filter(f: ZZ32 -> Boolean): GeneratorZZ32
    opr IN(x:ZZ32, self): Boolean = false
end

opr =(left:GeneratorZZ32, right:GeneratorZZ32): Boolean = false

trait SeqGeneratorZZ32 extends GeneratorZZ32
    getter asString(): String
    seq(self): SeqGeneratorZZ32 = self
    loop(body:ZZ32->()): () = seqloop(body)
    generate(r: ReductionString, body: ZZ32->String): String = seqgenerate(r, body)
    seqloop(body:ZZ32->()): () = loop(body)
    seqgenerate(r: ReductionString, body: ZZ32->String): String = generate(r,body)
    filter(f: ZZ32 -> Boolean): SeqGeneratorZZ32
end

__loop(g: GeneratorZZ32, body: ZZ32->()): () = g.loop(body)

__bigOperator(o:ReductionString,
              desugaredClauses:(ReductionString, String->String)->String): String =
    desugaredClauses(o,fn (s:String):String => s)

__generate(g: GeneratorZZ32, r: ReductionString, f:ZZ32->String): String =
    g.generate(r,f)
__generate(p: Boolean, r: ReductionString, f:()->String): String =
    if p then f() else r.empty() end


object SeqGenZZ32(g: GeneratorZZ32) extends SeqGeneratorZZ32
    getter asString(): String = "seq(" g.asString ")"
    loop(body:ZZ32->()): () = g.seqloop(body)
    generate(r: ReductionString, body: ZZ32->String): String = g.seqgenerate(r, body)
    seqloop(body:ZZ32->()): () = g.seqloop(body)
    seqgenerate(r: ReductionString, body: ZZ32->String): String =
        g.seqgenerate(r,body)
    filter(f: ZZ32 -> Boolean): SeqGeneratorZZ32 = seq(g.filter(f))
end

parloop(lo:ZZ32, hi:ZZ32, p:ZZ32->Boolean, body:ZZ32->()): () =
    if lo=hi then
        if p(lo) then body(lo) end
    else
        mid = (lo+hi) DIV 2
        do
           parloop(lo, mid, p, body)  
        also do
           parloop(mid+1, hi, p, body)
        end
    end

countedseqloop(lo:ZZ32, hi:ZZ32, p:ZZ32->Boolean, body:ZZ32->()): () =
    if lo=hi then
        if p(lo) then body(lo) end
    else
        mid = (lo+hi) DIV 2
        countedseqloop(lo, mid, p, body)
        countedseqloop(mid+1, hi, p, body)
    end

gen(lo:ZZ32, hi:ZZ32, p: ZZ32->Boolean, r:ReductionString, body: ZZ32->String): String =
    if lo=hi then
        if p(lo) then body(lo) else r.empty() end
    else
        mid = (lo+hi) DIV 2
        r.join(gen(lo, mid, p, r, body), gen(mid+1, hi, p, r, body))
    end

seqgen(lo:ZZ32, hi:ZZ32, p: ZZ32->Boolean, r:ReductionString, body: ZZ32->String): String =
    if lo=hi then
        if p(lo) then body(lo) else r.empty() end
    else
        mid = (lo+hi) DIV 2
        left = seqgen(lo, mid, p, r, body)
        right = seqgen(mid+1, hi, p, r, body)
        r.join(left, right)
    end

object FilteredRange(lo: ZZ32, hi:ZZ32, p: ZZ32 -> Boolean) extends GeneratorZZ32
    getter asString(): String = "filtered(" lo.asString ":" hi.asString ")"
    seq(self): SeqGeneratorZZ32 = SeqGenZZ32(self)
    loop(body:ZZ32->()): () = if lo > hi then () else parloop(lo,hi,p,body) end
    seqloop(body:ZZ32->()): () = if lo > hi then () else countedseqloop(lo,hi,p,body) end
    generate(r: ReductionString, body: ZZ32->String): String =
        if lo > hi then r.empty() else gen(lo,hi,p,r,body) end
    seqgenerate(r: ReductionString, body: ZZ32->String): String =
        if lo > hi then r.empty() else seqgen(lo,hi,p,r,body) end
    filter(q: ZZ32 -> Boolean): FilteredRange =
        FilteredRange(lo, hi, fn n => p(n) AND: q(n))
end

opr :(lo:ZZ32, hi:ZZ32): GeneratorZZ32 = FilteredRange(lo, hi, fn (n) => true)
opr #(lo:ZZ32, sz:ZZ32): GeneratorZZ32 = lo : (lo+sz-1)

trait ReductionString
    empty(): String
    join(a: String, b: String): String
end

object StringConcatenation extends ReductionString
    empty(): String = ""
    join(a: String, b: String): String = a || b
end

(*
opr BIG ||(): StringConcatenation = StringConcatenation
*)






(************************************************************
* Random numbers
************************************************************)

(*
random(i:RR64): RR64 = jRandomDouble(i)
randomZZ32(x:ZZ32): ZZ32 = jRandomInt(0,x)
*)

(************************************************************
* Matrices (stub)
************************************************************)
trait Matrix[\T, nat s0, nat s1\] extends Object end

(************************************************************
* Character properties
************************************************************)

characterMinSupplementaryCodePoint: ZZ32 = 65536
characterMinRadix: ZZ32 = 2
characterMaxRadix: ZZ32 = 36

(*) Character categories
characterUnassigned: ZZ32 = 0
characterUppercaseLetter: ZZ32 = 1
characterLowercaseLetter: ZZ32 = 2
characterTitlecaseLetter: ZZ32 = 3
characterModifierLetter: ZZ32 = 4
characterOtherLetter: ZZ32 = 5
characterNonSpacingMark: ZZ32 = 6
characterEnclosingMark: ZZ32 = 7
characterCombiningSpacingMark: ZZ32 = 8
characterDecimalDigitNumber: ZZ32 = 9
characterLetterNumber: ZZ32 = 10
characterOtherNumber: ZZ32 = 11
characterSpaceSeparator: ZZ32 = 12
characterLineSeparator: ZZ32 = 13
characterParagraphSeparator: ZZ32 = 14
characterControl: ZZ32 = 15
characterFormat: ZZ32 = 16
(*) There is no category 17
characterPrivateUse: ZZ32 = 18
characterSurrogate: ZZ32 = 19
characterDashPunctuation: ZZ32 = 20
characterStartPunctuation: ZZ32 = 21
characterEndPunctuation: ZZ32 = 22
characterConnectorPunctuation: ZZ32 = 23
characterOtherPunctuation: ZZ32 = 24
characterMathSymbol: ZZ32 = 25
characterCurrencySymbol: ZZ32 = 26
characterModifierSymbol: ZZ32 = 27
characterOtherSymbol: ZZ32 = 28
characterInitialQuotePunctuation: ZZ32 = 29
characterFinalQuotePunctuation: ZZ32 = 30

(*) Character directionality
characterDirectionalityUndefined: ZZ32 = -1
characterDirectionalityLeftToRight: ZZ32 = 0
characterDirectionalityRightToLeft: ZZ32 = 1
characterDirectionalityRightToLeftArabic: ZZ32 = 2
characterDirectionalityEuropeanNumber: ZZ32 = 3
characterDirectionalityEuropeanNumberSeparator: ZZ32 = 4
characterDirectionalityEuropeanNumberTerminator: ZZ32 = 5
characterDirectionalityArabicNumber: ZZ32 = 6
characterDirectionalityCommonNumberSeparator: ZZ32 = 7
characterDirectionalityNonspacingMark: ZZ32 = 8
characterDirectionalityBoundaryNeutral: ZZ32 = 9
characterDirectionalityParagraphSeparator: ZZ32 = 10
characterDirectionalitySegmentSeparator: ZZ32 = 11
characterDirectionalityWhitespace: ZZ32 = 12
characterDirectionalityOtherNeutrals: ZZ32 = 13
characterDirectionalityLeftToRightEmbedding: ZZ32 = 14
characterDirectionalityLeftToRightOverride: ZZ32 = 15
characterDirectionalityRightToLeftEmbedding: ZZ32 = 16
characterDirectionalityRightToLeftOverride: ZZ32 = 17
characterDirectionalityPopDirectionalFormat: ZZ32 = 18


end
